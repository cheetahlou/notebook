

# 运维篇

# 项目部署⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301270953045.png" alt="image-20230127095341891" style="zoom:60%;" />

## win打包 & 启动

### 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271001612.png" alt="image-20230127100119546" style="zoom:67%;" />

> jar支持命令行启动需要依赖maven插件支持，请确认打包时是否具有SpringBoot对应的maven插件

```xml
<build>
   <!-- 可以在此指定打包好的jar包名称 -->
   <finalName>Oss_test</finalName> 
   <plugins>
        <!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 -->
         <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
         </plugin>
    </plugins>
</build>
```

### 打包

> 首先，为了避免执行test命令，要先点击test，然后再点击蓝色圆圈里带闪电箭头的按钮，这样test指令就会出现一条线划掉，这样打包就不会执行这个test指令了
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220320095534000.png" alt="image-20220320095534000" style="zoom:67%;" />

打包，双击package指令

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211007180839095.png" alt="image-20211007180839095" style="zoom: 67%;" />

命令行里可以看到打包成功，并且从Building jar这个指令可以看到打包好的jar包

![image-20211007180939781](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211007180939781.png)

### 运行jar包

进入jar包所在目录

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211007181136917.png" alt="image-20211007181136917" style="zoom:67%;" />

部署运行，进入CMD，执行如下指令

```sh
java -jar 包名
java -jar springboot_test1-0.0.1-SNAPSHOT.jar
```

运行成功

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211007181233879.png" alt="image-20211007181233879" style="zoom:67%;" />

### win端口被占用 ⭐

```apl
# 查询指定端口
netstat -ano |findstr "端口号"
netstat -ano |findstr 8080
# 根据PID杀死任务
taskkill /F /PID "进程PID号"
taskkill /F /PID 26924
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251709750.png" alt="image-20220725170915686" style="zoom: 67%;" />

### maven插件作用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271004366.png" alt="image-20230127100405272" style="zoom:67%;" />

### 可执行jar包目录结构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271005472.png" alt="image-20230127100524373" style="zoom:67%;" />

## Linux运行(重点)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271009986.png" alt="image-20230127100926868" style="zoom:50%;" />

> 在IDEA中开发SpringBoot项目并打成jar包
>
> 将jar包上传到Linux服务器

```apl
mkdir /usr/local/app		# 创建目录，将项目jar包放到此目录
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251004950.png" alt="image-20220725100405738" style="zoom:67%;" />

### 前台启动

> 启动SpringBoot程序,前台启动(不推荐)
>

```sh
java -jar springboot_test1-0.0.1-SNAPSHOT.jar
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251004326.png" alt="image-20220725100453050" style="zoom:67%;" />

### 后台启动

后台启动(推荐)：改为后台运行SpringBoot程序，并将日志输出到日志文件

> - 线上程序不会采用控制台霸屏的形式运行程序，而是将程序在后台运行
> - 线上程序不会将日志输出到控制台，而是输出到日志文件，方便运维查阅信息

#### nohup 命令

> nohup 命令：英文全称 no hang up（不挂起），用于不挂断地运行指定命令，退出终端不会影响程序的运行
> 语法格式： nohup Command [ Arg … ] [&]
>
> - Command：要执行的命令
> - Arg：一些参数，可以指定输出文件
> - &：让命令在后台运行

```sh
# 后台运行java -jar命令，并将日志输出到hello.log文件
nohup java -jar HelloWorld.jar &> hello.log 2>&1 &		
```

**2>&1** 解释：将标准错误 2 重定向到标准输出 &1 ，标准输出 &1 再被重定向输入到 hello.log 文件中。

> - 0 – stdin (standard input，标准输入)
> - 1 – stdout (standard output，标准输出)
> - 2 – stderr (standard error，标准错误输出)

#### 后台启动

```sh
# 后台运行java -jar命令，并将日志输出到hello.log文件
nohup java -jar HelloWorld.jar &> hello.log 2>&1 &		
```

> ④：检查防火墙，确保8080端口对外开放，访问SpringBoot项目
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251005906.png" alt="image-20220725100529785" style="zoom: 50%;" />

> ⑥：停止SpringBoot程序
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251008367.png" alt="image-20220725100829222" style="zoom:80%;" />



## Docker运行

将文件从win10传到linux

创建文件夹，将Dockerfile和demo-1.0jar都放在一个文件夹里

```sh
mkdir /dockerfileTest
mv demo-1.0.jar /dockerfileTest
cd /dockerfileTest
vim Dockerfile
```

Dockerfile实现步骤

```dockerfile
FROM java:8
MAINTAINER  itheima <itheima@itcast.cn>
ADD springboot-hello-0.0.1-SNAPSHOT.jar  app.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","app.jar"]
```

通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本

构建和运行

```sh
docker build -t myspro:1.0 .
docker run -d -p 9001:8080 myspro:1.0
```

注意：执行完之后，要用docker ps -a，查看有没有端口映射成功。看PORTS

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211005203300921.png" alt="image-20211005203300921" style="zoom:80%;" />



# 配置文件高级

## 临时属性配置⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271021965.png" alt="image-20230127102151905" style="zoom:67%;" />

> 目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了。**如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口**，这个时候就尴尬了。**难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。**
>

```sh
java –jar springboot.jar –-server.port=8083
```

> 在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。这里格式不是yaml格式，当属性存在多级名称时，中间使用点分隔，**和properties文件中的属性格式完全相同。**如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔
>

```sh
java –jar springboot.jar –-server.port=80 --logging.level.root=debug
```



## 属性加载优先级

现在我们的程序配置受两个地方控制了，`第一配置文件，第二临时属性`。并且我们发现**临时属性的加载优先级要高于配置文件**的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：[https://docs.spring](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220320143343754.png" alt="image-20220320143343754" style="zoom:67%;" />

我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。

> 比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。
>

**总结**

1. 使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性
2. 临时属性添加方式：java –jar 工程名.jar –-属性名=值
3. 多个临时属性之间使用空格分隔
4. 临时属性必须是当前boot工程支持的属性，否则设置无效

## IDEA使用临时属性⭐

> 临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220320145034710.png" alt="image-20220320145034710" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271027294.png" alt="image-20230127102738220" style="zoom:60%;" />

> **通过这个args就可以获取到参数**。或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组。**当然，这种做法并没有什么实际开发意义**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271030584.png" alt="image-20230127103020508" style="zoom:67%;" />

不携带参数启动SpringBoot程序

![image-20230127102845358](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271028428.png)



## 配置文件4级分类⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251732646.png" alt="image-20220725173233573" style="zoom:67%;" />

### 配置文件级别

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271045269.png" alt="image-20230127104505195" style="zoom:60%;" />

> 好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271046465.png" alt="image-20230127104644398" style="zoom:67%;" />

### 应用场景

那为什么设计这种多种呢？说一个最典型的应用吧。

> - 场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。
> - 场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。
> - 场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？

> 解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？
>

> 级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271041397.png" alt="image-20230127104121324" style="zoom:67%;" />

### 配置演示

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251727125.png" alt="image-20220725172757061" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251728320.png" alt="image-20220725172824268" style="zoom:67%;" />



## 自定义配置文件

之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。

> 也就是配置文件名不叫application开头了，自己来定义名字

### 仅名称

**方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名**

然后将application.yml修改成ebank.yml，进行测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271049578.png" alt="image-20230127104956500" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271050304.png" alt="image-20230127105022242" style="zoom:67%;" />

### 全路径名

**方式二：使用临时属性设置配置文件路径，这个是全路径名**

然后将application.yml修改成ebank.properties，进行测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211206105716450.png" alt="image-20211206105716450" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271050547.png" alt="image-20230127105059483" style="zoom:67%;" />

### 加载多个配置文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211206105750285.png" alt="image-20211206105750285" style="zoom:67%;" />

使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271052774.png" alt="image-20230127105238711" style="zoom:67%;" />

### 注意事项

> 我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271054033.png" alt="image-20230127105429963" style="zoom:80%;" />



# 多环境开发

讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。

> 日常开发中至少有三个环境，分别是开发环境（`dev`），测试环境（`test`），生产环境（`prod`）。
>
> 不同的环境的各种配置都不相同，比如数据库，端口，`IP`地址等信息。
>
> 那么这么多环境如何区分，如何打包呢？
>
> 本篇文章就来介绍一下`Spring Boot` 中多环境如何配置，如何打包。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211206110958819.png" alt="image-20211206110958819" style="zoom:67%;" />

## yml单文件版

那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251804495.png" alt="image-20220725180449422" style="zoom: 67%;" />

### 多环境实例

```yaml
server:
  port: 80
```

如何想设计两组环境呢？中间使用三个减号分隔开

```yaml
server:
  port: 80
---
server:
  port: 81
```

如何区分两种环境呢？起名字呗

```yaml
spring:
	profiles: pro
server:
	port: 80
---
spring:
	profiles: dev
server:
	port: 81
```

那用哪一个呢？设置默认启动哪个就可以了

```yaml
spring:
	profiles:
		active: pro		# 启动pro
---
spring:
	profiles: pro
server:
	port: 80
---
spring:
	profiles: dev
server:
	port: 81
```

就这么简单，再多来一组环境也OK

```yaml
spring:
	profiles:
		active: pro		# 启动pro
---
spring:
	profiles: pro
server:
	port: 80
---
spring:
	profiles: dev
server:
	port: 81
---
spring:
	profiles: test
server:
	port: 82
```

### 注意事项

其中关于环境名称定义上述格式是过时格式，标准格式如下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251806821.png" alt="image-20220725180605750" style="zoom:67%;" />

```yaml
spring:
	config:
    	activate:
        	on-profile: pro
```

## yml多文件版⭐

将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271101215.png" alt="image-20230127110121126" style="zoom:67%;" />

> - 主配置文件中设置公共配置（全局）
> - 环境分类配置文件中常用于设置冲突属性（局部）

## properties多文件版

SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271104612.png" alt="image-20230127110424514" style="zoom:67%;" />

## 指定运行的环境⭐

虽然你创建了各个环境的配置文件，但是`Spring Boot` 仍然不知道你要运行哪个环境，有以下两种方式指定：

### 配置文件中指定

在`application.properties`或者`application.yml`文件中指定，内容如下：

```properties
# 指定运行环境为测试环境
spring.profiles.active=test
```

> 如果没有指定运行的环境，`Spring Boot` 默认会加载`application.properties`文件，而这个的文件又告诉`Spring Boot` 去找`test`环境的配置文件。

### 运行 jar 的时候指定

`Spring Boot` 内置的环境切换能够在运行`Jar`包的时候指定环境，命令如下：

```
java -jar xxx.jar --spring.profiles.active=test
```

以上命令指定了运行的环境是`test`，是不是很方便呢？

## 多环境独立配置⭐

> 作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。
>

### include版

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271107831.png" alt="image-20230127110705742" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271107650.png" alt="image-20230127110758590" style="zoom:67%;" />

### group版⭐

> 从Spring2.4版开始使用group属性替代include属性，降低了配置书写量
>
> 使用group属性定义多种主环境与子环境的包含关系

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271109747.png" alt="image-20230127110944669" style="zoom:67%;" />

## 多环境开发控制(了解)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271111517.png" alt="image-20230127111123438" style="zoom:60%;" />

多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。

要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。

maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。

> - 先在maven环境中设置用什么具体的环境
> - 在SpringBoot中读取maven设置的环境即可

### maven中设置多环境

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271115889.png" alt="image-20230127111500792" style="zoom:67%;" />

```xml
<profiles>
    <profile>
        <id>env_dev</id>
        <properties>
            <profile.active>dev</profile.active>
        </properties>
        <activation>
            <activeByDefault>true</activeByDefault>		<!--默认启动环境-->
        </activation>
    </profile>
    <profile>
        <id>env_pro</id>
        <properties>
            <profile.active>pro</profile.active>
        </properties>
    </profile>
</profiles>
```

### 配置文件设置值

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251815416.png" alt="image-20220725181551351" style="zoom:67%;" />

```yaml
spring:
	profiles:
    	active: @profile.active@
```

上面的@属性名@就是读取maven中配置的属性值的语法格式。

当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值。基于SpringBoot读取Maven配置属性的前提下，在Idea下测试工程时pom.xml每次更新需要手动compile方可生效



# 日志

## 日志作用

> - 编程期调试代码
> - 运营期记录信息
> - 记录日常运营重要信息（峰值流量、平均响应时长……）
> - 记录应用报错信息（错误堆栈）
> - 记录运维过程数据（扩容、宕机、报警……）

或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。

## 常用的日志框架

常见的日志框架有`log4j`、`logback`、`log4j2`

> log4j：这个日志框架显示是耳熟能详了，在Spring开发中是经常使用，但是据说log4j官方已经不再更新了，而且在性能上比logback、log4j2差了很多。

> logback：是由log4j创始人设计的另外一个开源日志框架，logback相比之于log4j性能提升了10以上，初始化内存加载也更小了。作为的Spring Boot默认的日志框架肯定是有着不小的优势。

> log4j2：晚于logback推出，官网介绍性能比logback高，但谁知道是不是王婆卖瓜自卖自夸，坊间流传，log4j2在很多思想理念上都是照抄logback，因此即便log4j2是Apache官方项目，Spring等许多框架项目没有将它纳入主流。此处完全是作者道听途说，不必当真，题外话而已。

日志框架很多，究竟如何选择能够适应现在的项目开发，当然不是普通程序员考虑的，但是为了更高的追求，至少应该了解一下，哈哈。

## 如何使用日志

在业务中肯定需要追溯日志，那么如何在自己的业务中输出日志呢？其实常用的有两种方式，下面一一介绍。

> 第一种其实也是很早之前常用的一种方式，只需要在代码添加如下：
>

```java
private final Logger log= LoggerFactory.getLogger(DemoApplicationTests.class);
```

这种方式显然比较鸡肋，如果每个类中都添加一下岂不是很low。别着急，lombok为我们解决了这个难题。

> 第二种方式：使用lombok简化日志输出

```xml
<dependency>
   <groupId>org.projectlombok</groupId>
   <artifactId>lombok</artifactId>
</dependency>
```

使用也是很简单，只需要在类上标注一个注解`@Slf4j`即可，日志的使用格式非常固定，直接上操作步骤：

```JAVA
@RestController
@RequestMapping("/books")
@Slf4j
public class BookController extends BaseClass{
    // 创建日志工厂
    private static final Logger log = LoggerFactory.getLogger(BookController.class);
    @GetMapping
    public String getById(){
        log.debug("debug...");
        log.info("info...");
        log.warn("warn...");
        log.error("error...");
        return "springboot is running...2";
    }
}
```

上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。

## 调整日志级别⭐

### 日志级别

> 几种常见的日志级别由低到高分为：`TRACE < DEBUG < INFO < WARN < ERROR < FATAL`。如何理解这个日志级别呢？很简单，如果项目中的日志级别设置为`INFO`，那么比它更低级别的日志信息就看不到了，即是`TRACE`、`DEBUG`日志将会不显示。
>

> - TRACE：**运行堆栈信息，使用率低**
> - DEBUG：**程序员调试代码使用**
> - INFO：**记录运维过程数据**
> - WARN：**记录运维过程报警数据**
> - ERROR：**记录错误堆栈信息**
> - FATAL：**灾难信息，合并计入ERROR**

> 一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。

```yaml
# 开启debug模式，输出调试信息，常用于检查系统运行状况，还可以再设置更细粒度的控制
debug: true

# 设置日志级别，root表示根节点，即整体应用日志级别
logging:
	level:
    	root: debug
```

### 定义日志级别

Spring Boot中默认的日志级别是INFO，但是可以自己定制日志级别，如下：

```properties
logging.level.root=DEBUG
```

日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种

上面是将所有的日志的级别都改成了`DEBUG`，Spring Boot还支持`package`级别的日志级别调整，格式为：`logging.level.xxx=xxx`，如下：

```properties
logging.level.com.example.demo=INFO
```

那么完整的配置如下：

```properties
logging.level.root=DEBUG
logging.level.com.example.demo=INFO
```



## 日志组⭐

> 设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别，**可以通过日志组或代码包的形式进行日志显示级别的控制**
>

```yml
logging:
  group:
    # 自定义组名，设置当前组中所包含的包
    controller: com.it.controller
    dao: com.it.dao
    service: com.it.service
  level:
    # 如果设置跟节点的日志等级，那么根节点就是最低的日志等级
    root: info
    # 为对应组设置日志级别
    controller: info
    dao: warn
    service: info
    # 不用上面的group名称，直接使用
    com.it.entity: debug
```

说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。

## 调整日志格式

日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。

![image-20211206123431222](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211206123431222.png)

从上图可以看出，输出的日志的默认元素如下：

> 1. 时间日期：精确到毫秒
> 2. 日志级别：ERROR, WARN, INFO, DEBUG , TRACE
> 3. 进程ID
> 4. 分隔符：— 标识实际日志的开始
> 5. 线程名：方括号括起来（可能会截断控制台输出）
> 6. Logger名：通常使用源代码的类名
> 7. 日志内容

对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。

默认的日志格式在第一张图已经看到了，有时我们需要定制自己需要的日志输出格式，这样在排查日志的时候能够一目了然。

定制日志格式有两个配置，分别是控制台的输出格式和文件中的日志输出格式，如下：

1. `logging.pattern.console`：控制台的输出格式
2. `logging.pattern.file`：日志文件的输出格式

例如配置如下：

```properties
logging.pattern.console=%d{yyyy/MM/dd-HH:mm:ss} [%thread] %-5level %logger- %msg%n

logging.pattern.file=%d{yyyy/MM/dd-HH:mm} [%thread] %-5level %logger- %msg%n
```

```yml
logging:
	pattern:
    	console: "%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n"
```

上面的配置编码的含义如下：

```
%d{HH:mm:ss.SSS}——日志输出时间

%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用

%-5level——日志级别，并且使用5个字符靠左对齐

%logger- ——日志输出者的名字

%msg——日志消息

%n——平台的换行符
```



## 日志输出到文件

Spring Boot中日志默认是输出到控制台的，但是在生产环境中显示不可行的，因此需要配置日志输出到日志文件中。

其中有两个重要配置如下：

1. `logging.file.path`：指定日志文件的路径
2. `logging.file.name`：日志的文件名，默认为`spring.log`

注意：官方文档说这两个属性不能同时配置，否则不生效，因此只需要配置一个即可。

指定输出的文件为当前项目路径的`logs`文件下，默认生成的日志文件为`spring.log`，如下：

```sh
logging.file.path=./logs
```

记录日志到文件中格式非常简单，设置日志文件名即可

```YAML
logging:
	file:
    	name: server.log
```

虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：

**日志文件中还有一些其他的属性，比如日志文件的最大size，保留几天的日志等等，下面会介绍到。**

```YAML
logging:
	logback:
    	rollingpolicy:
        	max-file-size: 3KB
            file-name-pattern: server.%d{yyyy-MM-dd}.%i.log
```

以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。

## 自定义日志配置

Spring Boot官方文档指出，根据不同的日志系统，可以按照如下的日志配置文件名就能够被正确加载，如下：

1. **`Logback`**：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy
2. **`Log4j`**：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml
3. **`Log4j2`**：log4j2-spring.xml, log4j2.xml
4. **`JDK (Java Util Logging)`**：logging.properties

Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置。因此只需要在`src/resources`文件夹下创建`logback-spring.xml`即可，配置文件内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="60 seconds" debug="false">
    <!-- 定义日志存放目录 -->
    <property name="logPath" value="logs"/>
    <!-- 日志输出的格式-->
    <property name="PATTERN" 
     value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t-%L] %-5level %logger{36} %L %M - %msg%xEx%n"/>
    <contextName>logback</contextName>

    <!--输出到控制台 ConsoleAppender-->
    <appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender">
        <!--展示格式 layout-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>${PATTERN}</pattern>
        </layout>
       <!--过滤器，只有过滤到指定级别的日志信息才会输出，
           如果level为ERROR，那么控制台只会输出ERROR日志-->
      <!--<filter class="ch.qos.logback.classic.filter.ThresholdFilter">-->
      <!--      <level>ERROR</level>-->
      <!--</filter>-->
    </appender>

    <!--正常的日志文件，输出到文件中-->
    <appender name="fileDEBUGLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高，
        所以我们使用下面的策略，可以避免输出 Error 的日志-->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!--过滤 Error-->
            <level>Error</level>
            <!--匹配到就禁止-->
            <onMatch>DENY</onMatch>
            <!--没有匹配到就允许-->
            <onMismatch>ACCEPT</onMismatch>
        </filter>

        <!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则
            如果同时有<File>和<FileNamePattern>，那么当天日志是<File>，明天会自动把今天
            的日志改名为今天的日期。即，<File> 的日志都是当天的。
        -->
        <File>${logPath}/log_demo.log</File>
        <!--滚动策略，按照时间滚动 TimeBasedRollingPolicy-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    <!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间-->
            <FileNamePattern>${logPath}/log_demo_%d{yyyy-MM-dd}.log</FileNamePattern>
            <!--只保留最近90天的日志-->
            <maxHistory>90</maxHistory>
            <!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志-->
            <!--<totalSizeCap>1GB</totalSizeCap>-->
        </rollingPolicy>
        <!--日志输出编码格式化-->
        <encoder>
            <charset>UTF-8</charset>
            <pattern>${PATTERN}</pattern>
        </encoder>
    </appender>

    <!--输出ERROR日志到指定的文件中-->
    <appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
   <!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter-->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>Error</level>
        </filter>
        <!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则
            如果同时有<File>和<FileNamePattern>，那么当天日志是<File>，明天会自动把今天
            的日志改名为今天的日期。即，<File> 的日志都是当天的。
        -->
        <File>${logPath}/error.log</File>
        <!--滚动策略，按照时间滚动 TimeBasedRollingPolicy-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    <!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间-->
            <FileNamePattern>${logPath}/error_%d{yyyy-MM-dd}.log</FileNamePattern>
            <!--只保留最近90天的日志-->
            <maxHistory>90</maxHistory>
            <!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志-->
            <!--<totalSizeCap>1GB</totalSizeCap>-->
        </rollingPolicy>
        <!--日志输出编码格式化-->
        <encoder>
            <charset>UTF-8</charset>
            <pattern>${PATTERN}</pattern>
        </encoder>
    </appender>


    <!--指定最基础的日志输出级别-->
    <root level="DEBUG">
        <!--appender将会添加到这个loger-->
        <appender-ref ref="consoleLog"/>
        <appender-ref ref="fileDEBUGLog"/>
        <appender-ref ref="fileErrorLog"/>
    </root>

    <!--定义指定package的日志级别-->
    <logger name="org.springframework" level="DEBUG"></logger>
    <logger name="org.mybatis" level="DEBUG"></logger>
    <logger name="java.sql.Connection" level="DEBUG"></logger>
    <logger name="java.sql.Statement" level="DEBUG"></logger>
    <logger name="java.sql.PreparedStatement" level="DEBUG"></logger>
    <logger name="io.lettuce.*" level="INFO"></logger>
    <logger name="io.netty.*" level="ERROR"></logger>
    <logger name="com.rabbitmq.*" level="DEBUG"></logger>
    <logger name="org.springframework.amqp.*" level="DEBUG"></logger>
    <logger name="org.springframework.scheduling.*" level="DEBUG"></logger>
   <!--定义com.xxx..xx..xx包下的日志信息不上传，
       直接输出到fileDEBUGLog和fileErrorLog这个两个appender中，日志级别为DEBUG-->
    <logger name="com.xxx.xxx.xx"  additivity="false" level="DEBUG">
        <appender-ref ref="fileDEBUGLog"/>
        <appender-ref ref="fileErrorLog"/>
    </logger>

</configuration>
```

当然，如果就不想用Spring Boot推荐的名字，想自己定制也行，只需要在配置文件中指定配置文件名即可，如下：

```properties
logging.config=classpath:logging-config.xml
```

## 完整配置和使用⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271158452.png" alt="image-20230127115836375" style="zoom:67%;" />

生成文件在当前项目目录下

```yml
logging:
  level:
    root: info
  file:
    name: server.log
  logback:
    rollingpolicy:
      max-file-size: 4MB
      file-name-pattern: server.%d{yyyy-MM-dd}.%i.log
```

```java
//lombok提供的记录日志注解
@Slf4j
@RestController
public class TestController {
    @GetMapping("testGet")
    public ResponseBean testGet(){
        log.info("info.....");
        log.error("error.....");
        log.debug("debug....");
        log.warn("warn...");
        return result;
    }
}
```

配置生成日志位置

```yml
logging:
  level:
    root: info
  file:
    path: E:\
  logback:
    rollingpolicy:
      max-file-size: 4MB
      file-name-pattern: server.%d{yyyy-MM-dd}.%i.log
```

> logging.file.name ，设置文件名称，可以是绝对路径，也可以是相对路径。如： logging.file=spring.log
>
> logging.path ，设置目录，会在该目录下创建 spring.log 文件，并写入日志内容
>
> 二者不能同时使用，如若同时使用，则只有 logging.file 生效
>
> 默认情况下，日志文件的大小达到 10MB 时会切分一次，产生新的日志文件



# 内网穿透

官网：https://natapp.cn/tunnel/lists

> 账号：17315118673
>
> 密码：3152177ren

## 应用场景

> 不知道大家在做项目的时候有没有遇到过这样一个需求：让其他同学访问到自己电脑上的网页或服务。比如我们在团队协作开发时，可以随时让别人查看自己电脑上正在开发的网站，而没必要反反复复把开发到一半的项目部署到服务器上、再去更新。再比如我之前在开发微信公众号后台服务时，需要填写一个服务的域名来接受来自微信侧的请求：
>

> 最开始我是填写的某个服务器对应的域名，但后来发现把服务部署到服务器上后调试非常不方便，所以在想着要是微信侧能直接请求我自己电脑上的服务就好了，打个断点 Debug 不是美滋滋？还有其他场景，比如大家想要登录同一个人的电脑来一起写代码、找 Bug、排查问题等等。
>

那怎么样才能实现这个需求呢？

> 答案是 **内网穿透**。先简单解释一下，大多数情况下，我们的个人电脑都处于内网，即没有可公开访问的独立 IP 地址（上网要通过其他网关），因此其他内网用户找不到你，就没办法和你建立连接。
>

> 而内网穿透的作用，就是将内网的电脑暴露到公共网络。可以理解为一个中间人，由于他知道你的电脑地址，所以能帮助其他用户访问到你的计算机。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241055072.png" alt="image-20220824105520013" style="zoom: 67%;" />

> 具体的技术细节和实现方案就不在本文过多介绍了，今天鱼皮直接给大家分享一款免费易用的内网穿透小工具 `NATAPP` ，只需一键，让他人轻松访问你电脑上的指定项目！

## 实现步骤

> 这个工具可以帮助你在公网和本地电脑之间建立一个安全的通道，从而实现内网传透，还能对通道上的流量进行分析。用法非常简单！打开官网，注册登录后，先新建一个隧道。大多数情况下，选择免费隧道就足够了：

### 选择隧道

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241055026.png" alt="image-20220824105500863" style="zoom: 67%;" />

> 选定隧道类别后，需要填写隧道的配置，像支持的协议、本地端口等。举个例子，假如你在自己电脑的 3000 端口启动了个前端 web 项目，那隧道协议就选择 Web、端口选择 3000。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241054853.png" alt="image-20220824105429782" style="zoom: 67%;" />

创建好隧道后，可以得到一个 `authtoken` ，相当于密码，后面启动隧道要用到：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241054738.png" alt="image-20220824105403582" style="zoom:80%;" />

### 修改端口

![image-20230127123951394](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271239461.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271240417.png" alt="image-20230127124005358" style="zoom:67%;" />

### 下载并启动APP

然后我们要在本地启动 NATAPP 程序，先下载对应操作系统的客户端：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241053453.png" alt="image-20220824105344381" style="zoom:67%;" />

下载的是一个压缩包，解压后会得到一个 `natapp.exe` 可执行文件。

然后在该文件所在目录下打开命令行工具（cmd），输入以下命令：

```sh
natapp -authtoken=<上一步获取到的token>
```

看到下图的结果，就表示启动成功啦！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271239940.png" alt="image-20230127123906879" style="zoom:67%;" />

### 访问测试

可以看到 NATAPP 给我们分配了一个 http 公网域名，其他同学输入这个域名就能访问到你本地端口对应的项目了。



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271240059.png" alt="image-20230127124054001" style="zoom:67%;" />

> NATAPP 本身是基于 ngrok 反向代理程序实现的，编程水平还不错的同学，也可以自己试着搭建内网穿透服务。此外，同类工具还有很多，比如花生壳等等，感兴趣的同学也可以去试试~但无论如何，注意安全，不要将电脑的重要端口暴露出去，最好用完就关，更不要拿这种技术去做一些不好的事情！
>



# 监控

## 监控概览

### 监控功能

> 显示监控信息的服务器：用于获取服务信息，并显示对应的信息
>
> 运行的服务：启动时主动上报，告知监控服务器自己需要受到监控

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301280944782.png" alt="image-20230128094434711" style="zoom:67%;" />

### 监控图示

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220320214129797.png" alt="image-20220320214129797" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281428319.png" alt="image-20230128142840244" style="zoom:67%;" />

## 监控实现⭐

> Spring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有**客户端和服务端**两部分，而**监控平台指的就是服务端**。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。
>

### 服务端配置

> 创建一个SpringBoot模块，开始配置，导入springboot admin对应的starter，**版本与当前使用的springboot版本保持一致**，并将其配置成web工程

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.5.4</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
```

添加依赖，注意和上面的SpringBoot版本保持一致

```xml
<!--必须有web依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!--注意是server依赖-->
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-server</artifactId>
    <version>2.5.4</version>
</dependency>
```

上述过程可以通过创建项目时使用勾选的形式完成。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301102432817.png" alt="image-20220301102432817" style="zoom:50%;" />

**步骤②**：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用

```java
@SpringBootApplication
//加上如下注解
@EnableAdminServer
public class Springboot25AdminServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot25AdminServerApplication.class, args);
    }
}
```

```properties
# 应用服务 WEB 访问端口
server.port=8082
```

做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。

:8082/applications

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301103028468.png" alt="image-20220301103028468" style="zoom: 50%;" />

由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。

### 客户端配置

客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。

**步骤①**：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程

```xml
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-client</artifactId>
    <version>2.5.4</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。

**步骤②**：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置

```yaml
spring:
  boot:
    admin:
      client:
        url: http://127.0.0.1:8082/
```

> 做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301103838079.png" alt="image-20220301103838079" style="zoom: 50%;" />

> 可以看到，当前监控了1个程序，点击进去查看详细信息。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281035956.png" alt="image-20230128103516858" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301103936386.png" alt="image-20220301103936386" style="zoom: 50%;" />

> 由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。开放指定信息给服务器看，允许服务器以HTTP请求的方式获取对应的信息
>

### 开放监控信息⭐

```yaml
server:
  port: 8081
spring:
  boot:
    admin:
      client:
        url: http://127.0.0.1:8082/
# 开放监控信息
management:
  endpoint:
    health:
      show-details: always
  endpoints:
    web:
      exposure:
        include: "*"
```

> 上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301104742563.png" alt="image-20220301104742563" style="zoom: 50%;" />

但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。

```yaml
management:
  endpoint:
    health:
      show-details: always
```

健康明细信息如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301105116554.png" alt="image-20220301105116554" style="zoom: 50%;" />

目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。

```yaml
endpoints:
  web:
    exposure:
      include: "*"
```

配置后再刷新服务器页面，就可以看到所有的信息了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301105554494.png" alt="image-20220301105554494" style="zoom: 50%;" />

以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。



### 监控多个客户端

> 可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301110352170.png" alt="image-20220301110352170" style="zoom: 50%;" />

进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。类加载面板中可以查阅到开发者自定义的类，如左图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301161246835.png" alt="image-20220301161246835" style="zoom: 67%;" /><img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301161949431.png" alt="image-20220301161949431" style="zoom: 67%;" />

映射中可以查阅到当前应用配置的所有请求

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301162008737.png" alt="image-20220301162008737" style="zoom: 67%;" />

性能指标中可以查阅当前应用独有的请求路径统计数据

 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301161906949.png" alt="image-20220301161906949" style="zoom: 67%;" /><img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301162040670.png" alt="image-20220301162040670" style="zoom: 67%;" />

## 监控原理

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281048567.png" alt="image-20230128104838509" style="zoom:60%;" />

通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301170214076.png" alt="image-20220301170214076" style="zoom: 67%;" />

首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。

![image-20220301170723057](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301170723057.png)

其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息

```JSON
{
    "status": "UP",
    "components": {
        "diskSpace": {
            "status": "UP",
            "details": {
                "total": 297042808832,
                "free": 72284409856,
                "threshold": 10485760,
                "exists": true
            }
        },
        "ping": {
            "status": "UP"
        }
    }
}
```

当前信息与监控面板中的数据存在着对应关系

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301171025615.png" alt="image-20220301171025615" style="zoom:50%;" />

原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。

到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。

![image-20220301171437817](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301171437817.png)

​		这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。

Actuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator**可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求**/actuator/端点名称**来获取详细信息。以下列出了所有端点信息说明：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281056171.png" alt="image-20230128105650073" style="zoom:67%;" />

![image-20230128105711983](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281057072.png)



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281058019.png" alt="image-20230128105820938" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281059951.png" alt="image-20230128105939884" style="zoom:67%;" />

上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。

```yaml
management:
  endpoint:
    health:						# 端点名称
      show-details: always
    info:						# 端点名称
      enabled: true				# 是否开放
```

为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：

```YAML
management:
  endpoints:
    enabled-by-default: true	# 是否开启默认端点，默认值true
```

上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。

```YAML
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。

```YAML
management:
  endpoint:		# 具体端点的配置
    health:
      show-details: always
    info:
      enabled: true
  endpoints:	# 全部端点的配置
    web:
      exposure:
        include: "*"
    enabled-by-default: true
```

## 自定义监控指标

端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。

### INFO端点

info端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息

#### 配置形式

> 在yml文件中通过设置info节点的信息就可以快速配置端点信息，高版本配置失效(不懂为啥)
>

```yaml
info:
  appName: @project.artifactId@
  version: @project.version@
  name: @project.name@
  basedir: @project.basedir@
  description: @project.description@
  company: 传智教育
  author: itheima
```

配置完毕后，对应信息显示在监控平台上

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301174133248.png" alt="image-20220301174133248" style="zoom:50%;" />

也可以通过请求端点信息路径获取对应json信息

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301174241310.png" alt="image-20220301174241310" style="zoom:50%;" />

#### 编程形式

> 通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存
>

```java
@Component
public class InfoConfig implements InfoContributor {
    @Override
    public void contribute(Info.Builder builder) {
        //添加单个信息
        builder.withDetail("runTime",System.currentTimeMillis());
        Map<String, Object> infoMap = new HashMap<>();
        infoMap.put("startTime", LocalDateTime.now());
        infoMap.put("天气","很好");
        //添加一组信息
        builder.withDetails(infoMap);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281131505.png" alt="image-20230128113138435" style="zoom:50%;" />

#### 注意事项

> 在配置文件中设置属性可能不生效，但是可以通过读取配置文件方式获取信息

```java
@Component
public class InfoConfig implements InfoContributor {
    
    @Value("${info.name}")
    private String name;

    @Override
    public void contribute(Info.Builder builder) {
        //添加单个信息
        builder.withDetail("runTime",System.currentTimeMillis());
        Map<String, Object> infoMap = new HashMap<>();
        infoMap.put("startTime", LocalDateTime.now());
        infoMap.put("天气","很好");
        infoMap.put("name1",name);
        //添加一组信息
        builder.withDetails(infoMap);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281138242.png" alt="image-20230128113804169" style="zoom: 50%;" />

### Health端点

> health端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。
>

```java
@Component
public class HealthConfig extends AbstractHealthIndicator {
    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception {
        boolean condition = true;
        if(condition) {
            //设置运行状态为启动状态
            builder.status(Status.UP);
            builder.withDetail("runTime", System.currentTimeMillis());
            Map<String, Object> infoMap = new HashMap<>();
            infoMap.put("buildTime", "2022");
            builder.withDetails(infoMap);
        }else{
            //设置运行状态为不在服务状态
            builder.status(Status.OUT_OF_SERVICE);
            builder.withDetail("上线了吗？","你做梦");
        }
    }
}
```

当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301174751845.png" alt="image-20220301174751845" style="zoom:50%;" />

### Metrics端点

metrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。

```JAVA
@Service
public class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService {
    @Autowired
    private BookDao bookDao;

    private Counter counter;

    public BookServiceImpl(MeterRegistry meterRegistry){
        counter = meterRegistry.counter("用户付费操作次数：");
    }

    @Override
    public boolean delete(Integer id) {
        //每次执行删除业务等同于执行了付费业务
        counter.increment();
        return bookDao.deleteById(id) > 0;
    }
}
```

在性能指标中就出现了自定义的性能指标监控项

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301175101812.png" alt="image-20220301175101812" style="zoom:50%;" />

### 自定义端点

可以根据业务需要自定义端点，方便业务监控

```JAVA
@Component
@Endpoint(id="pay",enableByDefault = true)
public class PayEndpoint {
    @ReadOperation
    public Object getPay(){
        Map payMap = new HashMap();
        payMap.put("level 1","300");
        payMap.put("level 2","291");
        payMap.put("level 3","666");
        return payMap;
    }
}
```

由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220301175355482.png" alt="image-20220301175355482" style="zoom:50%;" />



## 实时日志查看

想要查看监控项目中的日志信息，有一个前提条件，前提条件是你被监控的 Spring Boot 项目，必须配置了日志的保存路径或者日志保存文件名，只有配置这两项中的任意一项，你的 Spring Boot 项目才会将日志保存到磁盘上，这样才能通过 SBA 查看到，我配置的是日志路径，在 Spring Boot 的 application配置文件中添加以下配置：

```yml
# 设置日志保存路径
logging:
  file:
    path: D:\\SpringBoot新项目\\Test1\\src\\main\\resources\\static
```

设置完成之后，重启你的 Spring Boot 项目，然后刷新 SBA 页面，最终展示效果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205181905139.png" alt="image-20220518190518992" style="zoom:80%;" />

此时我们就可以查看实时的日志信息了，当然你也可以随时下载日志，如果需要的话。



## 邮箱提醒功能

[Spring Boot Admin 报警提醒和登录验证功能实现！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247500091&idx=1&sn=2740b376d3f68447b676edc5171f0915&chksm=fbcfac03ccb825158a4d21d325eeed31e8dca8e5518dae4c4ccca280f30b55f540e2a2ca2170&mpshare=1&scene=23&srcid=0518pHeLsFDwq0O8PkamE3oA&sharer_sharetime=1652869919747&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

报警提醒功能是基于邮箱实现的，当然也可以使用其他的提醒功能，如钉钉或飞书机器人提醒也是可以的，但邮箱报警功能的实现成本最低，所以本文我们就来看邮箱的报警提醒功能的具体实现。在监控的模块添加即可

### 配置邮箱信息

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

```properties
spring.mail.default-encoding=UTF-8
# 配置邮箱的账户名（这个是上面配置发送邮件的账户名）
spring.mail.username=17315118673@163.com
# 配置发送邮箱
spring.boot.admin.notify.mail.from=17315118673@163.com
# 配置接收邮箱
spring.boot.admin.notify.mail.to=1597374863@qq.com
# 配置邮箱 smtp 地址（qq 发送邮箱的固定 host 是 smtp.qq.com）
spring.mail.host=smtp.163.com
# 配置邮箱授权码（此处为授权码，而非密码，获取授权码本文下一步有说明）
spring.mail.password=HUSBWQHLTSIVPKOC
```

注意在email里开启smtp功能，配置在邮件模块里有，重启项目

### 测试邮箱功能

> 经过以上配置之后，**无需添加任何代码！！！无需添加任何代码！！！无需添加任何代码！！！**就可以实现项目状态改变的邮件提醒功能了。关闭我本地被监控的 Spring Boot 项目，邮箱会收到项目离线信息，如下图所示：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205181930571.png" alt="image-20220518193009483" style="zoom:67%;" />

当我把被监控的 Spring Boot 项目启动之后，邮箱会收到服务器启动邮件，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205181930635.png" alt="image-20220518193040542" style="zoom:67%;" />

也就是说，当你配置好了收、发邮箱之后，Spring Boot Admin 会在被监控的项目停机或启动时，自动发送邮件到接收提醒的邮箱了。

### 注意事项

报警功能注意事项有以下几个：

1. 发送邮件的邮箱必须开启 SMTP 服务。
2. 发送邮箱无需设置密码，只需要为配置项“spring.mail.password”设置邮箱授权码即可。
3. 发送邮箱和接收邮箱可以是同一个邮箱地址。
4. SBA 邮箱报警提醒功能无需添加任何代码，只需要添加相应的框架支持，然后再配置上正确的收、发邮箱即可。

### 配置多个通知邮箱

通常项目的报警功能，需要通知的是一群相关负责人，而不是一个人，比如可能会通知运维负责人、程序负责人，还有项目经理等，而 SBA 多人提醒邮箱的配置也很容易，只需要在 SBA 的配置文件中添加多个收件邮箱即可，多个邮箱间使用英文逗号隔开，如下配置所示：

```properties
# 配置接收邮箱
spring.boot.admin.notify.mail.to=xxx@qq.com,yyy@qq.com
```

## 访问权限(添加账号密码)

在 SBA 的依赖文件 pom.xml 中添加如下配置：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

设置登录账户

在 SBA 的配置文件 application.properties 中添加如下配置：

```properties
# 设置登录用户名、密码和角色
spring.security.user.name=java666
spring.security.user.password=java666
spring.security.user.roles=SBA_ADMIN
```

权限资源设置

接下来在 SBA 项目中，添加以下资源设置类，如下代码所示（直接复制到项目中即可使用）：

```java
@EnableWebSecurity
@Configuration(proxyBeanMethods = false)
public class AdminSecurityConfig extends WebSecurityConfigurerAdapter {
    private final String adminContextPath;

    public AdminSecurityConfig(AdminServerProperties adminServerProperties) {
        this.adminContextPath = adminServerProperties.getContextPath();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        SavedRequestAwareAuthenticationSuccessHandler successHandler = new 
            SavedRequestAwareAuthenticationSuccessHandler();
        successHandler.setTargetUrlParameter("redirectTo");
        successHandler.setDefaultTargetUrl(adminContextPath + "/");
        http.authorizeRequests()
                .antMatchers(adminContextPath + "/assets/**").permitAll()
                .antMatchers(adminContextPath + "/login").permitAll()
                .antMatchers(adminContextPath + "/instances/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage(adminContextPath + 
                                       "/login").successHandler(successHandler).and()
                .logout().logoutUrl(adminContextPath + "/logout").and()
                .httpBasic().and()
                .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .ignoringAntMatchers(
                        adminContextPath + "/instances",
                        adminContextPath + "/actuator/**"
                );
    }

    @Override
    public void configure(WebSecurity web) {
        web.ignoring().antMatchers("/actuator/**");
    }
}
```

访问测试，此时访问 SBA 监控系统就需要输入用户名和密码才能正常使用了，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205182135269.png" alt="image-20220518213546136" style="zoom:80%;" />

我们输入 2.2 步骤中设置的用户名和密码即可登录，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205182138882.png" alt="image-20220518213810799" style="zoom:80%;" />

点击注销就退出 SBA 系统了。



# 原理篇

# 自动配置

> 自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行
>

## bean加载方式

> 关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312133409.png" alt="image-20230131213314334" style="zoom:67%;" />

### XML

创建maven项目，引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.9</version>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.16</version>
    </dependency>
</dependencies>
```

在resource包下创建applicationContext1.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--xml方式声明自己开发的bean,class配置文件位置-->
    <bean id="cat" class="com.itheima.bean.Cat"/>
    <bean class="com.itheima.bean.Dog"/>

    <!--xml方式声明第三方开发的bean-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"/>
    <bean class="com.alibaba.druid.pool.DruidDataSource"/>
    <bean class="com.alibaba.druid.pool.DruidDataSource"/>
</beans>
```

```java
public class Cat {}
```

```java
public class Dog {}
```

测试

```java
public class App1 {
    public static void main(String[] args) {
        ApplicationContext ctx = new 
            ClassPathXmlApplicationContext("applicationContext1.xml");
        Object cat = ctx.getBean("cat");
        System.out.println(cat);
        Dog dog = ctx.getBean(Dog.class);
        System.out.println(dog);
        String[] names = ctx.getBeanDefinitionNames();
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220405172738622.png" alt="image-20220405172738622" style="zoom:50%;" />

### XML+注解

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
    ">
    <!--指定加载bean的位置，component-->
    <context:component-scan base-package="com.itheima.bean,com.itheima.config"/>
</beans>
```

> 使用@Component及其衍生注解@Controller 、@Service、@Repository定义bean
>

```java
@Component("cat1")
public class Cat {
}
```

> 使用@Bean定义**第三方bean**，并将所在类定义为配置类或Bean
>

```java
@Component
public class DbConfig {
	@Bean
	public DruidDataSource getDataSource(){
		DruidDataSource ds = new DruidDataSource();
		return ds; 
    } 
}
```

测试

```java
public class App2 {
    public static void main(String[] args) {
        ApplicationContext ctx = new 
            ClassPathXmlApplicationContext("applicationCOntext2.xml");
        String[] names = ctx.getBeanDefinitionNames();
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220405173637630.png" alt="image-20220405173637630" style="zoom: 50%;" />

### 注解

无需配置文件

```java
@Configuration
@ComponentScan("com.itheima")
public class SpringConfig {
	@Bean
	public DruidDataSource getDataSource(){
		DruidDataSource ds = new DruidDataSource();
			return ds; 
    } 
}
```

@Configuration配置项如果不用于被扫描可以省略，测试

```java
public class App3 {
    public static void main(String[] args) {
        ApplicationContext ctx = new 
            AnnotationConfigApplicationContext(SpringConfig3.class);
        String[] names = ctx.getBeanDefinitionNames();
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220405174525551.png" alt="image-20220405174525551" style="zoom: 50%;" />

### @Import

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312130742.png" alt="image-20230131213033670" style="zoom:67%;" />

### 上下文对象

> 使用上下文对象在容器初始化完毕后注入bean

![image-20230131213116757](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312131837.png)

### ImportSelector接口

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312131928.png" alt="image-20230131213145849" style="zoom:67%;" />

### ImportBeanDefinitionRegistrar接口

![image-20230131213216994](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312132075.png)

### BeanDefinitionRegistryPostProcessor

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312132026.png" alt="image-20230131213245949" style="zoom:67%;" />

## bean加载扩展

> 扩展1：初始化实现FactoryBean接口的类，实现对bean加载到容器之前的批处理操作
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312127941.png" alt="image-20230131212702856" style="zoom:67%;" />

> 扩展2：加载配置类并加载配置文件（系统迁移）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312127587.png" alt="image-20230131212726525" style="zoom:67%;" />

> 扩展3：使用proxyBeanMethods=true可以保障调用此方法得到的对象是从容器中获取的而不是重新创建的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312128027.png" alt="image-20230131212827941" style="zoom:67%;" />

> 使用@Import注解导入配置类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312129927.png" alt="image-20230131212941871" style="zoom:67%;" />

## bean的加载控制

bean的加载控制指根据特定情况对bean进行选择性加载以达到适用于项目的目标。

使用@Conditional注解的派生注解设置各种组合条件控制bean的加载

匹配指定类

```java
public class SpringConfig {
	@Bean
	@ConditionalOnClass(Mouse.class)
	public Cat tom(){
		return new Cat();
	} 
}
```

未匹配指定类

```java
public class SpringConfig {
	@Bean
	@ConditionalOnClass(Mouse.class)
	@ConditionalOnMissingClass("com.itheima.bean.Wolf")
	public Cat tom(){
		return new Cat();
	} 
}
```

匹配指定类型的bean

```java
@Import(Mouse.class)
public class SpringConfig {
	@Bean
	@ConditionalOnBean(Mouse.class)
	public Cat tom(){
		return new Cat();
	} 
}
```

匹配指定名称的bean



### 自动配置原理

1. 收集Spring开发者的编程习惯，整理开发过程使用的常用技术列表——>(**技术集A**)

2. 收集常用技术(**技术集A**)的使用参数，整理开发过程中每个技术的常用设置列表——>(**设置集B**)

3. 初始化SpringBoot基础环境，加载用户自定义的bean和导入的其他坐标，形成**初始化环境**

4. 将**技术集A**包含的所有技术都定义出来，在Spring/SpringBoot启动时默认全部加载

5. 将技术集A中具有使用条件的技术约定出来，设置成按条件加载，由开发者决定是否使用该技术（与**初始化环境**比对）

6. 将**设置集**B作为默认配置加载（约定大于配置），减少开发者配置工作量

7. 开放**设置集B**的配置覆盖接口，由开发者根据自身需要决定是否覆盖默认配置

```java
public final class SpringFactoriesLoader {
	public static final String FACTORIES_RESOURCE_LOCATION = 
        "META-INF/spring.factories"; }
```

```xml
<dependency> 
    <groupId>org.springframework.boot</groupId> 
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>2.5.4</version>
</dependency>
```

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration { 
}
```

```java
@ConfigurationProperties(prefix = "spring.redis")
public class RedisProperties {
	private String url;
	private String host = "localhost";
	private int port = 6379; 
}
```



#### 小结

1. 先开发若干种技术的标准实现

2. SpringBoot启动时加载所有的技术实现对应的自动配置类

3. 检测每个配置类的加载条件是否满足并进行对应的初始化

4. 切记是先加载所有的外部资源，然后根据外部资源进行条件比对



### 变更自动配置

自定义自动配置（META-INF/spring.factories）

```apl
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.itheima.bean.CartoonCatAndMouse
```

控制SpringBoot内置自动配置类加载

```yaml
spring:
  autoconfigure:
    exclude: 
      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration
      - org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration
```

```apl
@EnableAutoConfiguration(excludeName = "",exclude = {})
```

变更自动配置：去除tomcat自动配置（条件激活），添加jetty自动配置（条件激活）

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-web</artifactId>
   <!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件-->
   <exclusions>
      <exclusion>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-tomcat</artifactId>
      </exclusion>
   </exclusions>
</dependency>
<!--添加Jetty起步依赖，匹配自动配置条件-->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

1. 通过配置文件exclude属性排除自动配置

2. 通过注解@EnableAutoConfiguration属性排除自动配置项

3. 启用自动配置只需要满足自动配置条件即可

4. 可以根据需求开发自定义自动配置项



# 自动配置原理





# 自定义starter⭐

就是开发一个maven依赖包，提供给SpringBoot使用

- 案例：统计独立IP访问次数

- 自定义starter

- 辅助功能开发

## 记录独立IP访问次数

### 功能描述

> 本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。
>

> 例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。
>

```c
         IP访问监控
+-----ip-address-----+--num--+
|     192.168.0.135  |   15  |
|     61.129.65.248  |   20  |
+--------------------+-------+
```

### 技术分析

在进行具体制作之前，先对功能做具体的分析

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312137102.png" alt="image-20230131213732030" style="zoom:67%;" />

### 代码实现

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207262102613.png" alt="image-20220726210253522" style="zoom:50%;" />

删除测试文件夹

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207262104691.png" alt="image-20220726210443638" style="zoom: 67%;" />

#### pom配置

```xml
<!--重点：导入依赖就以这三个为准，修改它们即可-->
<groupId>com.it</groupId>
<artifactId>ip_springboot_starter</artifactId>
<version>1.1</version>

<!--这个依赖是本包功能需要的依赖，因此引入，其他需要依赖也照样可以引入-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

#### 业务功能开发

新建service包下的IpCountService类

```java
import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

public class IpCountService {
    //计数集合
    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();

    //当前request对象的注入工作由当前使用的starter的工程提供自动装配
    @Resource
    private HttpServletRequest request;

    public Map<String,Integer> count(){
        String ipAddress = request.getRemoteAddr();
        System.out.println("----------------------"+ipAddress);
        if(ipCountMap.containsKey(ipAddress)){
            ipCountMap.put(ipAddress,ipCountMap.get(ipAddress) + 1);
        }else{
            ipCountMap.put(ipAddress,1);
        }
        System.out.println("IP:"+ipAddress);
        return ipCountMap;
    }
}
```

#### 自动配置代码

创建autoconfig.IpAutoConfiguation

```java
import com.it.service.IpCountService;
import org.springframework.context.annotation.Bean;

public class IpAutoConfiguation {

    @Bean
    public IpCountService ipCountService() {
        return new IpCountService();
    }
}
```

META-INF

在resources包下创建META-INF包，然后在该包下创建spring.factories

加上如下内容，注意下面指定自动配置类的地址

```apl
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.it.autoconfig.IpAutoConfiguation  
```

#### MVN装配

对maven进行执行clean和install命令即可，每次修改都要重新执行该命令

切记使用之前先clean后install安装到maven仓库，确保资源更新

### 进行使用

在新的SpringBoot项目里

导入依赖

```xml
<dependency>
    <groupId>com.it</groupId>
    <artifactId>ip_springboot_starter</artifactId>
    <version>1.1</version>
</dependency>
```

注入依赖

```java
import com.it.service.IpCountService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import java.util.Map;

@RestController
public class testIp {

    @Resource
    private IpCountService ipCountService;

    @GetMapping("/getCount")
    public Map<String, Integer> getCount() {
        Map<String, Integer> count = ipCountService.count();
        return count;
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207262119925.png" alt="image-20220726211946856" style="zoom:67%;" />



## 功能性完善

当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。

### 添加定时任务

修改处：添加@EnableScheduling注解

定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。

```java
@EnableScheduling
public class IpAutoConfiguation {
    @Bean
    public IpCountService ipCountService() {
        return new IpCountService();
    }
}
```

添加定时任务方法

定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。

```java
import org.springframework.scheduling.annotation.Scheduled;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

public class IpCountService {
    //计数集合
    private Map<String,Integer> ipCountMap = new HashMap<String,Integer>();

    //当前request对象的注入工作由当前使用的starter的工程提供自动装配
    @Resource
    private HttpServletRequest request;

    public Map<String,Integer> count(){
        // 获取当前请求的ip地址
        String ipAddress = request.getRemoteAddr();
        System.out.println("----------------------"+ipAddress);
        // 经典计数操作
        // 判断当前ip地址是否存在计数集合中,如果存在则计数加1,如果不存在则计数为1
        if(ipCountMap.containsKey(ipAddress)){
            ipCountMap.put(ipAddress,ipCountMap.get(ipAddress) + 1);
        }else{
            ipCountMap.put(ipAddress,1);
        }
        System.out.println("IP:"+ipAddress);
        return ipCountMap;
    }

    // 每5s执行一次
    @Scheduled(cron = "0/5 * * * * ?")
    public void print(){
        System.out.println("         IP访问监控");
        System.out.println("+-----ip-address-----+--num--+");
        for (Map.Entry<String, Integer> entry : ipCountMap.entrySet()) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(String.format("|%18s  |%5d  |",key,value));
        }
        System.out.println("+--------------------+-------+");
    }
}
```

其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。

每次运行效果之前先clean然后install，切记切记！！

继续执行调用接口即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207262156591.png" alt="image-20220726215657535" style="zoom:67%;" />

#### 配置功能参数





### 开启yml提示功能

我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。

Springboot提供有专用的工具实现此功能，仅需要导入下列坐标。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。

```JAVA
{
  "groups": [
    {
      "name": "tools.ip",
      "type": "cn.itcast.properties.IpProperties",
      "sourceType": "cn.itcast.properties.IpProperties"
    }
  ],
  "properties": [
    {
      "name": "tools.ip.cycle",
      "type": "java.lang.Long",
      "description": "日志显示周期",
      "sourceType": "cn.itcast.properties.IpProperties",
      "defaultValue": 5
    },
    {
      "name": "tools.ip.cycle-reset",
      "type": "java.lang.Boolean",
      "description": "是否周期内重置数据",
      "sourceType": "cn.itcast.properties.IpProperties",
      "defaultValue": false
    },
    {
      "name": "tools.ip.model",
      "type": "java.lang.String",
      "description": "日志输出模式  detail：详细模式  simple：极简模式",
      "sourceType": "cn.itcast.properties.IpProperties"
    }
  ],
  "hints": [
    {
      "name": "tools.ip.model",
      "values": [
        {
          "value": "detail",
          "description": "详细模式."
        },
        {
          "value": "simple",
          "description": "极简模式."
        }
      ]
    }
  ]
}
```



## 加解密starter

[如何优雅的实现 SpringBoot 接口参数加密解密？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247500503&idx=2&sn=e65f25ca1fea9741248f9f89fa615b42&chksm=fc2c7edfcb5bf7c9078ccadc567bf8bf29872a61410b74a9bb76b59ddf3e5d4fc61d214aba58&mpshare=1&scene=23&srcid=0722Fi19UyXAo7nxBQQlEYyk&sharer_sharetime=1658505641726&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

因为有小伙伴刚好问到 **RequestBodyAdvice** 的用法，今天就抽空撸一篇文章和大家聊聊这个话题。

加密解密本身并不是难事，问题是在何时去处理？定义一个过滤器，将请求和响应分别拦截下来进行处理也是一个办法，这种方式虽然粗暴，但是灵活，因为可以拿到一手的请求参数和响应数据。不过 SpringMVC 中给我们提供了 ResponseBodyAdvice 和 RequestBodyAdvice，利用这两个工具可以对请求和响应进行预处理，非常方便。

### 开发加解密 starter

为了让我们开发的这个工具更加通用，也为了复习一下自定义 Spring Boot Starter，这里我们就将这个工具做成一个 stater，以后在 Spring Boot 项目中直接引用就可以。

首先我们创建一个 Spring Boot 项目，引入 spring-boot-starter-web 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <scope>provided</scope>
    <version>2.4.3</version>
</dependency>
```

因为我们这个工具是为 Web 项目开发的，以后必然使用在 Web 环境中，所以这里添加依赖时 scope 设置为 provided。

依赖添加完成后，我们先来定义一个加密工具类备用，加密这块有多种方案可以选择，对称加密、非对称加密，其中对称加密又可以使用 AES、DES、3DES 等不同算法，这里我们使用 Java 自带的 Cipher 来实现对称加密，使用 AES 算法：

```java
public class AESUtils {

    private static final String AES_ALGORITHM = "AES/ECB/PKCS5Padding";

    // 获取 cipher
    private static Cipher getCipher(byte[] key, int model) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES");
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(model, secretKeySpec);
        return cipher;
    }

    // AES加密
    public static String encrypt(byte[] data, byte[] key) throws Exception {
        Cipher cipher = getCipher(key, Cipher.ENCRYPT_MODE);
        return Base64.getEncoder().encodeToString(cipher.doFinal(data));
    }

    // AES解密
    public static byte[] decrypt(byte[] data, byte[] key) throws Exception {
        Cipher cipher = getCipher(key, Cipher.DECRYPT_MODE);
        return cipher.doFinal(Base64.getDecoder().decode(data));
    }
}
```

这个工具类比较简单，不需要多解释。需要说明的是，加密后的数据可能不具备可读性，因此我们一般需要对加密后的数据再使用 Base64 算法进行编码，获取可读字符串。换言之，上面的 AES 加密方法的返回值是一个 Base64 编码之后的字符串，AES 解密方法的参数也是一个 Base64 编码之后的字符串，先对该字符串进行解码，然后再解密。

接下来我们封装一个响应工具类备用，这个大家如果经常看松哥视频已经很了解了：

```java
public class RespBean {
    private Integer status;
    private String msg;
    private Object obj;

    public static RespBean build() {
        return new RespBean();
    }

    public static RespBean ok(String msg) {
        return new RespBean(200, msg, null);
    }

    public static RespBean ok(String msg, Object obj) {
        return new RespBean(200, msg, obj);
    }

    public static RespBean error(String msg) {
        return new RespBean(500, msg, null);
    }

    public static RespBean error(String msg, Object obj) {
        return new RespBean(500, msg, obj);
    }

    private RespBean() {
    }

    private RespBean(Integer status, String msg, Object obj) {
        this.status = status;
        this.msg = msg;
        this.obj = obj;
    }

    public Integer getStatus() {
        return status;
    }

    public RespBean setStatus(Integer status) {
        this.status = status;
        return this;
    }

    public String getMsg() {
        return msg;
    }

    public RespBean setMsg(String msg) {
        this.msg = msg;
        return this;
    }

    public Object getObj() {
        return obj;
    }

    public RespBean setObj(Object obj) {
        this.obj = obj;
        return this;
    }
}
```

接下来我们定义两个注解 `@Decrypt` 和 `@Encrypt`：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,ElementType.PARAMETER})
public @interface Decrypt {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Encrypt {
}
```

这两个注解就是两个标记，在以后使用的过程中，哪个接口方法添加了 @Encrypt 注解就对哪个接口的数据加密返回，哪个接口/参数添加了 @Decrypt 注解就对哪个接口/参数进行解密。这个定义也比较简单，没啥好说的，需要注意的是 `@Decrypt` 比 `@Encrypt` 多了一个使用场景就是 `@Decrypt` 可以用在参数上。

考虑到用户可能会自己配置加密的 key，因此我们再来定义一个 EncryptProperties 类来读取用户配置的 key：

```java
@ConfigurationProperties(prefix = "spring.encrypt")
public class EncryptProperties {
    private final static String DEFAULT_KEY = "www.itboyhub.com";
    private String key = DEFAULT_KEY;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }
}
```

这里我设置了默认的 key 是 `www.itboyhub.com`，key 是 16 位字符串，松哥这个网站地址刚好满足。以后如果用户想自己配置 key，只需要在 application.properties 中配置 `spring.encrypt.key=xxx` 即可。

所有准备工作做完了，接下来就该正式加解密了。

因为松哥这篇文章一个很重要的目的是想和大家分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，RequestBodyAdvice 在做解密的时候倒是没啥问题，而 ResponseBodyAdvice 在做加密的时候则会有一些局限，不过影响不大，还是我前面说的，如果想非常灵活的掌控一切，那还是自定义过滤器吧。这里我就先用这两个工具来实现了。

另外还有一点需要注意，ResponseBodyAdvice 在你使用了 @ResponseBody 注解的时候才会生效，RequestBodyAdvice 在你使用了 @RequestBody 注解的时候才会生效，换言之，前后端都是 JSON 交互的时候，这两个才有用。不过一般来说接口加解密的场景也都是前后端分离的时候才可能有的事。

先来看接口加密：

```java
@EnableConfigurationProperties(EncryptProperties.class)
@ControllerAdvice
public class EncryptResponse implements ResponseBodyAdvice<RespBean> {
    private ObjectMapper om = new ObjectMapper();
    @Autowired
    EncryptProperties encryptProperties;
    @Override
    public boolean supports(MethodParameter returnType, 
                            Class<? extends HttpMessageConverter<?>> converterType) {
        return returnType.hasMethodAnnotation(Encrypt.class);
    }

    @Override
    public RespBean beforeBodyWrite(RespBean body, MethodParameter returnType, 
                                    MediaType selectedContentType, 
                            Class<? extends HttpMessageConverter<?>> selectedConverterType, 
                                    ServerHttpRequest request, 
                                    ServerHttpResponse response) {
        byte[] keyBytes = encryptProperties.getKey().getBytes();
        try {
            if (body.getMsg()!=null) {
                body.setMsg(AESUtils.encrypt(body.getMsg().getBytes(),keyBytes));
            }
            if (body.getObj() != null) {
                body.setObj(AESUtils.encrypt(om.writeValueAsBytes(body.getObj()), keyBytes));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return body;
    }
}
```

我们自定义 EncryptResponse 类实现 ResponseBodyAdvice接口，泛型表示接口的返回类型，这里一共要实现两个方法：

1. supports：这个方法用来判断什么样的接口需要加密，参数 returnType 表示返回类型，我们这里的判断逻辑就是方法是否含有 `@Encrypt` 注解，如果有，表示该接口需要加密处理，如果没有，表示该接口不需要加密处理。
2. beforeBodyWrite：这个方法会在数据响应之前执行，也就是我们先对响应数据进行二次处理，处理完成后，才会转成 json 返回。我们这里的处理方式很简单，RespBean 中的 status 是状态码就不用加密了，另外两个字段重新加密后重新设置值即可。
3. 另外需要注意，自定义的 ResponseBodyAdvice 需要用 `@ControllerAdvice` 注解来标记。

再来看接口解密：

```java
@EnableConfigurationProperties(EncryptProperties.class)
@ControllerAdvice
public class DecryptRequest extends RequestBodyAdviceAdapter {
    @Autowired
    EncryptProperties encryptProperties;
    @Override
    public boolean supports(MethodParameter methodParameter, 
                  Type targetType, Class<? extends HttpMessageConverter<?>> converterType) {
        return methodParameter.hasMethodAnnotation(Decrypt.class) || methodParameter
              .hasParameterAnnotation(Decrypt.class);
    }

    @Override
    public HttpInputMessage beforeBodyRead(final HttpInputMessage inputMessage, 
                                           MethodParameter parameter, Type targetType, 
                                           Class<? extends HttpMessageConverter<?>> 
                                           converterType) throws IOException {
        byte[] body = new byte[inputMessage.getBody().available()];
        inputMessage.getBody().read(body);
        try {
            byte[] decrypt = AESUtils.decrypt(body, encryptProperties.getKey().getBytes());
            final ByteArrayInputStream bais = new ByteArrayInputStream(decrypt);
            return new HttpInputMessage() {
                @Override
                public InputStream getBody() throws IOException {
                    return bais;
                }

                @Override
                public HttpHeaders getHeaders() {
                    return inputMessage.getHeaders();
                }
            };
        } catch (Exception e) {
            e.printStackTrace();
        }
        return super.beforeBodyRead(inputMessage, parameter, targetType, converterType);
    }
}
```

1. 首先大家注意，DecryptRequest 类我们没有直接实现 `RequestBodyAdvice` 接口，而是继承自 RequestBodyAdviceAdapter 类，该类是 RequestBodyAdvice 接口的子类，并且实现了接口中的一些方法，这样当我们继承自 RequestBodyAdviceAdapter 时，就只需要根据自己实际需求实现某几个方法即可。
2. supports：该方法用来判断哪些接口需要处理接口解密，我们这里的判断逻辑是方法上或者参数上含有 `@Decrypt` 注解的接口，处理解密问题。
3. beforeBodyRead：这个方法会在参数转换成具体的对象之前执行，我们先从流中加载到数据，然后对数据进行解密，解密完成后再重新构造 HttpInputMessage 对象返回。

接下来，我们再来定义一个自动化配置类，如下：

```java
@Configuration
@ComponentScan("org.javaboy.encrypt.starter")
public class EncryptAutoConfiguration {

}
```

这个也没啥好说的，比较简单。

最后，resources 目录下定义 META-INF，然后再定义 spring.factories 文件，内容如下：

```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.javaboy.encrypt.starter.autoconfig.EncryptAutoConfiguration
```

这样当项目启动时，就会自动加载该配置类。

至此，我们的 starter 就开发完成啦。

### 打包发布

我们可以将项目安装到本地仓库，也可以发布到线上供他人使用。

#### 安装到本地仓库

安装到本地仓库比较简单，直接 `mvn install`，或者在 IDEA 中，点击右边的 Maven，然后双击 install，如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207271040262.png" alt="image-20220727104036198" style="zoom:67%;" />

#### 发布到线上

发不到线上我们可以使用 JitPack 来做。

首先我们在 GitHub 上创建一个仓库，将我们的代码上传上去，这个过程应该不用我多说吧。

上传成功后，点击右边的 `Create a new release` 按钮，发布一个正式版，如下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYkKibqrFY0genrce6sG0SF78O6ViaKic07PQpN0VKCKGQUZWzZQn7dJicMqvkqWiaZbnrRUHicWaffEYejw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYkKibqrFY0genrce6sG0SF78HEfzfhp72GFNUHFwQgYf8mkEQKTPcxicW0GGx4qK5flMYySoE60MUbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

发布成功后，打开 jitpack，输入仓库的完整路径，点击 lookup 按钮，查找到之后，再点击 `Get it` 按钮完成构建，如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYkKibqrFY0genrce6sG0SF78qtficJX94j6mJkCPShgceJklkKocmnjggcldqIzgCwzWKhdcpfSgPhw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

构建成功后，JitPack 上会给出项目引用方式：

<img src="https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYkKibqrFY0genrce6sG0SF78yyVnELRjNz3M5MibUF8z8Gf7wLibQx4pJwKStm6UJRS8HXkmiclQdUPpQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

注意引用时将 tag 改成你具体的版本号。

至此，我们的工具就已经成功发布了！小伙伴们可以通过如下方式引用这个 starter：

```xml
<dependencies>
    <dependency>
        <groupId>com.github.lenve</groupId>
        <artifactId>encrypt-spring-boot-starter</artifactId>
        <version>0.0.3</version>
    </dependency>
</dependencies>
<repositories>
    <repository>
        <id>jitpack.io</id>
        <url>https://jitpack.io</url>
    </repository>
</repositories>
```

### 应用

我们创建一个普通的 Spring Boot 项目，引入 web 依赖，再引入我们刚刚的 starter 依赖，如下：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>com.github.lenve</groupId>
        <artifactId>encrypt-spring-boot-starter</artifactId>
        <version>0.0.3</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<repositories>
    <repository>
        <id>jitpack.io</id>
        <url>https://jitpack.io</url>
    </repository>
</repositories>
```

然后再创建一个实体类备用：

```java
public class User {
    private Long id;
    private String username;
    //省略 getter/setter
}
```

创建两个测试接口：

```java
@RestController
public class HelloController {
    @GetMapping("/user")
    @Encrypt
    public RespBean getUser() {
        User user = new User();
        user.setId((long) 99);
        user.setUsername("javaboy");
        return RespBean.ok("ok", user);
    }

    @PostMapping("/user")
    public RespBean addUser(@RequestBody @Decrypt User user) {
        System.out.println("user = " + user);
        return RespBean.ok("ok", user);
    }
}
```

第一个接口使用了 `@Encrypt` 注解，所以会对该接口的数据进行加密（如果不使用该注解就不加密），第二个接口使用了 `@Decrypt` 所以会对上传的参数进行解密，注意 `@Decrypt` 注解既可以放在方法上也可以放在参数上。

接下来启动项目进行测试。

首先测试 get 请求接口：

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYkKibqrFY0genrce6sG0SF78JWzVWRMMQItptxdlOwaKRsajUMbtkOcUsMic1llcZvPRAqZFtYMzNjQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，返回的数据已经加密。

再来测试 post 请求：

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYkKibqrFY0genrce6sG0SF787aQIoZTicO6fEYeWjgRFbo8qOcCd9U8n6qibZhPdgFC2WibCl5oBGZBJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，参数中的加密数据已经被还原了。

如果用户想要修改加密密钥，可以在 application.properties 中添加如下配置：

```apl
spring.encrypt.key=1234567890123456
```

加密数据到了前端，前端也有一些 js 工具来处理加密数据，这个松哥后面有空再和大家说说 js 的加解密。





# SpringBoot启动流程

## 启动流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312142705.png" alt="image-20230131214200633" style="zoom:67%;" />

## 监听器类型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301312141892.png" alt="image-20230131214136796" style="zoom:67%;" />

## 启动流程解析

其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。

​		springboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：

- 环境属性（Environment）
- 系统配置（spring.factories）
- 参数（Arguments、application.properties）

​		以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。

```apl
Springboot30StartupApplication【10】->SpringApplication.run(Springboot30StartupApplication.class, args);
    SpringApplication【1332】->return run(new Class<?>[] { primarySource }, args);
        SpringApplication【1343】->return new SpringApplication(primarySources).run(args);
            SpringApplication【1343】->SpringApplication(primarySources)
            # 加载各种配置信息，初始化各种配置对象
                SpringApplication【266】->this(null, primarySources);
                    SpringApplication【280】->public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources)
                        SpringApplication【281】->this.resourceLoader = resourceLoader;
                        # 初始化资源加载器
                        SpringApplication【283】->this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
                        # 初始化配置类的类名信息（格式转换）
                        SpringApplication【284】->this.webApplicationType = WebApplicationType.deduceFromClasspath();
                        # 确认当前容器加载的类型
                        SpringApplication【285】->this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();
                        # 获取系统配置引导信息
                        SpringApplication【286】->setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
                        # 获取ApplicationContextInitializer.class对应的实例
                        SpringApplication【287】->setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
                        # 初始化监听器，对初始化过程及运行过程进行干预
                        SpringApplication【288】->this.mainApplicationClass = deduceMainApplicationClass();
                        # 初始化了引导类类名信息，备用
            SpringApplication【1343】->new SpringApplication(primarySources).run(args)
            # 初始化容器，得到ApplicationContext对象
                SpringApplication【323】->StopWatch stopWatch = new StopWatch();
                # 设置计时器
                SpringApplication【324】->stopWatch.start();
                # 计时开始
                SpringApplication【325】->DefaultBootstrapContext bootstrapContext = createBootstrapContext();
                # 系统引导信息对应的上下文对象
                SpringApplication【327】->configureHeadlessProperty();
                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）
                    java.awt.headless=true
                SpringApplication【328】->SpringApplicationRunListeners listeners = getRunListeners(args);
                # 获取当前注册的所有监听器
                SpringApplication【329】->listeners.starting(bootstrapContext, this.mainApplicationClass);
                # 监听器执行了对应的操作步骤
                SpringApplication【331】->ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
                # 获取参数
                SpringApplication【333】->ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
                # 将前期读取的数据加载成了一个环境对象，用来描述信息
                SpringApplication【333】->configureIgnoreBeanInfo(environment);
                # 做了一个配置，备用
                SpringApplication【334】->Banner printedBanner = printBanner(environment);
                # 初始化logo
                SpringApplication【335】->context = createApplicationContext();
                # 创建容器对象，根据前期配置的容器类型进行判定并创建
                SpringApplication【363】->context.setApplicationStartup(this.applicationStartup);
                # 设置启动模式
                SpringApplication【337】->prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
                # 对容器进行设置，参数来源于前期的设定
                SpringApplication【338】->refreshContext(context);
                # 刷新容器环境
                SpringApplication【339】->afterRefresh(context, applicationArguments);
                # 刷新完毕后做后处理
                SpringApplication【340】->stopWatch.stop();
                # 计时结束
                SpringApplication【341】->if (this.logStartupInfo) {
                # 判定是否记录启动时间的日志
                SpringApplication【342】->    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
                # 创建日志对应的对象，输出日志信息，包含启动时间
                SpringApplication【344】->listeners.started(context);
                # 监听器执行了对应的操作步骤
                SpringApplication【345】->callRunners(context, applicationArguments);
                # 调用运行器
                SpringApplication【353】->listeners.running(context);
                # 监听器执行了对应的操作步骤
```

上述过程描述了springboot程序启动过程中做的所有的事情，这个时候好奇宝宝们就会提出一个问题。如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？

遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。

```JAVA
public class Abc implements InitializingBean, DisposableBean {
    public void destroy() throws Exception {
        //销毁操作
    }
    public void afterPropertiesSet() throws Exception {
        //初始化操作
    }
}
```



## 监听器解析

springboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。

springboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：

- org.springframework.boot.context.event.ApplicationStartingEvent
  - 应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent
- org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent
  - 环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent
- org.springframework.boot.context.event.ApplicationContextInitializedEvent
  - 上下文初始化事件
- org.springframework.boot.context.event.ApplicationPreparedEvent
  - 应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent
- org.springframework.context.event.ContextRefreshedEvent
  - 上下文刷新事件
- org.springframework.boot.context.event.ApplicationStartedEvent
  - 应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent
- org.springframework.boot.context.event.ApplicationReadyEvent
  - 应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求
- org.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）



## 自定义监听器⭐

上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。

可以在这里进行清内存，监控启动等很多操作

### 实现流程

在resource目录下创建该文件夹和文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207261009199.png" alt="image-20220726100907105" style="zoom:67%;" />

```apl
# 配置监听器位置
org.springframework.context.ApplicationListener=\
  com.it.test.MyListener
```

在java目录里自定义内容

```java
import org.springframework.boot.context.event.ApplicationStartingEvent;
import org.springframework.context.ApplicationListener;

// ApplicationStartingEvent>只干预启动事件，可以不加此泛型，表示干预所有过程
// 泛型可用类型很多
public class MyListener implements ApplicationListener<ApplicationStartingEvent> {

    @Override
    public void onApplicationEvent(ApplicationStartingEvent event) {
        System.out.println(event.getSource());
        System.out.println(event.getClass());
        System.out.println(event.getTimestamp());
    }
}
```

启动项目

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207261014932.png" alt="image-20220726101441857" style="zoom:50%;" />

按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。

### 监听器支持类型

```java
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

// ApplicationStartingEvent>只干预启动事件，可以不加此泛型，表示干预所有过程
public class MyListener implements ApplicationListener{

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        System.out.println(event.getClass().getName());
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207261021277.png" alt="image-20220726102103215" style="zoom:67%;" />



























