



# 热部署

## devtools 热部署

```xml
<dependency>   
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```

> 启动项目，在启动过程中，修改代码，然后激活热部署，查看结果，激活热部署：**Ctrl** + **F9**

### 自动启动热部署

> 每次修改项目都要执行：**Ctrl** + **F9**，太麻烦，推荐自动部署，按ctrl+shift+alt+/，点击注册表
>
> 激活方式：**IDEA失去焦点5秒后启动热部署**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271446340.png" alt="image-20230127144641251" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271448337.png" alt="image-20230127144853198" style="zoom: 50%;" />

### 热部署范围配置

> 默认不触发重启的目录列表

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271451635.png" alt="image-20230127145106549" style="zoom:67%;" />

> 自定义不参与重启排除项

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271451125.png" alt="image-20230127145149040" style="zoom:67%;" />

### 关闭热部署

#### 配置文件关闭

> 优缺点：配置简单，但是优先级低，容易被其他配置文件覆盖，导致配置失效

```yml
spring:
  devtools:
    restart:
      enabled: false
```

#### 系统级属性关闭⭐

设置高优先级属性禁用热部署

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271457165.png" alt="image-20230127145703076" style="zoom:67%;" />

## JRebel 热部署

激活示例：https://blog.csdn.net/weixin_43296313/article/details/121439057

通过`Idea`的偏好设置找到插件框，输入`Jrebel and XRebel for IntelliJ`安装插件

激活程序：https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271513563.png" alt="image-20230127151304438" style="zoom:67%;" />

点击启动即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271517785.png" alt="image-20230127151749690" style="zoom:67%;" />

激活需要生成uuid，下面是uuid的生成网站：[Online UUID Generator Tool](https://www.uuidgenerator.net/version1)

> 点击help-->JRebel-->Activation，即可激活程序

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271522651.png" alt="image-20230127152253521" style="zoom:67%;" />

> 最后把JRebel设置为offline模式 点一下work offline即可激活成功，使用和上面一样，开启自动编译即可

<img src="https://img-blog.csdnimg.cn/a816e54961df43a9b79f24c3f06bf102.png" alt="img" style="zoom: 50%;" />

# 跨域

项目地址：https://gitee.com/mydb/springboot-examples/tree/master/spring-boot-cross

## 跨域三种情况

在请求时，如果出现了以下情况中的任意一种，那么它就是跨域请求：

1. **协议不同，如 http 和 https；**
2. **域名不同；**
3. **端口不同。**

也就是说，**即使域名相同，如果一个使用的是 http，另一个使用的是 https，那么它们也属于跨域访问**。常见的跨域问题如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211111530.png" alt="image-20230221111147466" style="zoom:80%;" />

## 跨域问题演示

接下来，我们使用两个 Spring Boot 项目来演示跨域的问题，其中一个是端口号为 8080 的前端项目，另一个端口号为 9090 的后端接口项目。

### 前端网站

前端项目只需要在 resources 下放两个文件，一个用于发送 ajax 请求的 jquery.js，另一个是 html 前端页面，工程目录如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211112873.png" alt="image-20230221111221769" style="zoom:45%;" />

其中前端页面 index.html 的代码如下：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>跨域测试页面</title>
    <script src="js/jquery.min.js"></script>
</head>
<body>
<h1>跨域测试</h1>
<div>
    <input type="button" onclick="mySubmit()" value=" 发送跨域请求 ">
</div>
<script>
    function mySubmit() {
        // 发送跨域请求
        jQuery.ajax({
            url: ":9090/test",
            type: "POST",
            data: {"name": "Java"},
            success: function (result) {
                alert("返回数据：" + result.data);
            }
        });
    }
</script>
</body>
</html>
```

### 后端接口

后端接口项目首先先在 application.properties 配置文件中，设置项目的端口号为 9090，如下所示：

```properties
server.port=9090
```

然后创建一个后端控制器，返回一个 JSON 格式的数据，实现代码如下：

```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.HashMap;

@RestController
public class TestController {
    @RequestMapping("/test")
    public HashMap<String, Object> test() {
        return new HashMap<String, Object>() {{
            put("state", 200);
            put("data", "success");
            put("msg", "");
        }};
    }
}
```

以上两个项目创建并启动成功之后，使用前端项目访问后端接口，因为端口不一样，所以也属于跨域访问，运行结果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211113738.png" alt="image-20230221111310670" style="zoom:67%;" />

## 解决跨域问题

在 Spring  Boot 中跨域问题有很多种解决方案，比如以下 5 个：

1. **使用 @CrossOrigin 注解实现跨域；**
2. **通过配置文件实现跨域；**
3. **通过 CorsFilter 对象实现跨域；**
4. **通过 Response 对象实现跨域；**
5. **通过实现 ResponseBodyAdvice 实现跨域。**

当然如果你愿意的话，还可以使用过滤器来实现跨域，但它的实现和第 5 种实现类似，所以本文就不赘述了。

### 通过注解跨域

**使用 @CrossOrigin 注解可以轻松的实现跨域，此注解既可以修饰类，也可以修饰方法。当修饰类时，表示此类中的所有接口都可以跨域；当修饰方法时，表示此方法可以跨域**，它的实现如下：

```java
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.HashMap;

@RestController
@CrossOrigin(origins = "*")
public class TestController {
    @RequestMapping("/test")
    public HashMap<String, Object> test() {
        return new HashMap<String, Object>() {{
            put("state", 200);
            put("data", "success");
            put("msg", "");
        }};
    }
}
```

以上代码的执行结果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211115779.png" alt="image-20230221111522707" style="zoom:80%;" />

> 从上图中可以看出，前端项目访问另一个后端项目成功了，也就说明它解决了跨域问题。**优缺点分析**此方式虽然虽然实现（跨域）比较简单，但细心的朋友也能发现，**使用此方式只能实现局部跨域，当一个项目中存在多个类的话，使用此方式就会比较麻烦（需要给所有类上都添加此注解）。**

### 通过配置文件跨域

接下来我们**通过设置配置文件的方式就可以实现全局跨域**了，它的实现步骤如下：

> - 创建一个新配置文件；
> - 添加 @Configuration 注解，实现 WebMvcConfigurer 接口；
> - 重写 addCorsMappings 方法，设置允许跨域的代码。

具体实现代码如下：

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration // 一定不要忽略此注解
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // 所有接口
                .allowCredentials(true) // 是否发送 Cookie
                .allowedOriginPatterns("*") // 支持域
                .allowedMethods(new String[]{"GET", "POST", "PUT", "DELETE"}) // 支持方法
                .allowedHeaders("*")
                .exposedHeaders("*");
    }
}
```

### 通过 CorsFilter 跨域

此实现方式和上一种实现方式类似，**它也可以实现全局跨域**，它的具体实现代码如下：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration // 一定不能忽略此注解
public class MyCorsFilter {
    @Bean
    public CorsFilter corsFilter() {
        // 1.创建 CORS 配置对象
        CorsConfiguration config = new CorsConfiguration();
        // 支持域
        config.addAllowedOriginPattern("*");
        // 是否发送 Cookie
        config.setAllowCredentials(true);
        // 支持请求方式
        config.addAllowedMethod("*");
        // 允许的原始请求头部信息
        config.addAllowedHeader("*");
        // 暴露的头部信息
        config.addExposedHeader("*");
        // 2.添加地址映射
        UrlBasedCorsConfigurationSource corsConfigurationSource = new 
            UrlBasedCorsConfigurationSource();
        corsConfigurationSource.registerCorsConfiguration("/**", config);
        // 3.返回 CorsFilter 对象
        return new CorsFilter(corsConfigurationSource);
    }
}
```

### 通过 Response 跨域

**此方式是解决跨域问题最原始的方式，但它可以支持任意的 Spring Boot 版本（早期的 Spring Boot 版本也是支持的）。但此方式也是局部跨域，它应用的范围最小，设置的是方法级别的跨域**，它的具体实现代码如下：

```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpServletResponse;
import java.util.HashMap;

@RestController
public class TestController {
    @RequestMapping("/test")
    public HashMap<String, Object> test(HttpServletResponse response) {
        // 设置跨域
        response.setHeader("Access-Control-Allow-Origin", "*");
        return new HashMap<String, Object>() {{
            put("state", 200);
            put("data", "success");
            put("msg", "");
        }};
    }
}
```

### 通过 ResponseBodyAdvice 跨域

通过重写 ResponseBodyAdvice 接口中的 beforeBodyWrite（返回之前重写）方法，我们可以对所有的接口进行跨域设置，它的具体实现代码如下：

```java
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

@ControllerAdvice
public class ResponseAdvice implements ResponseBodyAdvice {
    /**
     * 内容是否需要重写（通过此方法可以选择性部分控制器和方法进行重写）
     * 返回 true 表示重写
     */
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }
    /**
     * 方法返回之前调用此方法
     */
    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, 
                                  MediaType selectedContentType,
                                  Class selectedConverterType, ServerHttpRequest request,
                                  ServerHttpResponse response) {
        // 设置跨域
        response.getHeaders().set("Access-Control-Allow-Origin", "*");
        return body;
    }
}
```

**此实现方式也是全局跨域，它对整个项目中的所有接口有效。**

## 原理分析

> 为什么通过以上方法设置之后，就可以实现不同项目之间的正常交互呢？这个问题的答案也很简单，我们之前在说跨域时讲到：“**跨域问题本质是浏览器的行为，它的初衷是为了保证用户的访问安全，防止恶意网站窃取数据**”，

> 那想要解决跨域问题就变得很简单了，**只需要告诉浏览器这是一个安全的请求，“我是自己人”就行了**，那怎么告诉浏览器这是一个正常的请求呢？

> 只需要**在返回头中设置“Access-Control-Allow-Origin”参数即可解决跨域问题，此参数就是用来表示允许跨域访问的原始域名的，当设置为“\*”时，表示允许所有站点跨域访问**，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211114675.png" alt="image-20230221111406592" style="zoom:67%;" />

> 所以**以上 5 种解决跨域问题的本质都是给响应头中加了一个 Access-Control-Allow-Origin 的响应头而已。**

# 文件上传和下载

## 简单介绍 

### 文件上传介绍

文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过

程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。

文件上传时，对页面的form表单有如下要求：

- method="post" 采用post方式提交数据
- enctype="multipart/form-data" 采用multipart格式上传文件
- type="file" 使用input的file控件上传

```html
<form method="post" action="/common/upload" enctype="multipart/form-data">
    <input name="myFile" type="file"  />
    <input type="submit" value="提交" /> 
</form>
```

目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。

例如ElementUI中提供的upload上传组件：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220415172804129.png" alt="image-20220415172804129" style="zoom:67%;" />

服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件，`这两个组件都在web依赖里面`：

- commons-fileupload

- commons-io

Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声

明一个MultipartFile类型的参数即可接收上传的文件，例如：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220415172951901.png" alt="image-20220415172951901" style="zoom:67%;" />

### 文件下载介绍

文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。

通过浏览器进行文件下载，通常有两种表现形式：

- 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录

- 直接在浏览器中打开

通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程。



## 配置项

### 首要配置

```xml
<!--lombok依赖：写日志-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.20</version>
</dependency>
<!--web依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

```properties
# 单个文件上传大小,值可以使用后缀“MB”或“KB”分别表示兆字节或千字节
spring.servlet.multipart.max-file-size=100MB
# 最大请求大小。值可以使用后缀“MB”或“KB”分别表示兆字节或千字节
spring.servlet.multipart.max-request-size=100MB
```

> 如果使用了nginx，还需配置nginx最大上传文件大小,nginx默认1m

```nginx
#user  nobody;
worker_processes  1;

events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    client_max_body_size 100m; # 就是这个参数
    sendfile        on;
    keepalive_timeout  65;
	# 引入自定义配置文件
	include leadnews.conf/*.conf;
}
```

除了这两个配置之外常用的配置：

- spring.servlet.multipart.enabled=true，是否⽀持 multipart 上传⽂件(默认是)
- spring.servlet.multipart.file-size-threshold=0，⽀持⽂件写⼊磁盘(默认是)
- spring.servlet.multipart.location=，上传⽂件的临时⽬录
- spring.servlet.multipart.max-file-size=10Mb，最⼤⽀持⽂件⼤⼩
- spring.servlet.multipart.max-request-sizee=10Mb，最⼤⽀持请求⼤⼩
- spring.servlet.multipart.resolve-lazily=false，是否⽀持 multipart 上传⽂件时懒加载

设置基础路径

```java
//设置基础路径
private final String basePath = "E:\\";
```

### 可选配置

```properties
# 是否启用对分段上传的支持
spring.servlet.multipart.enabled = true

# 将文件写入磁盘的阈值。值可以使用后缀“MB”或“KB”分别表示兆字节或千字节。
spring.servlet.multipart.file-size-threshold = 100MB

# 上传文件的中间位置
spring.servlet.multipart.location = D:/temp

# 是否在文件或参数访问时懒惰地解析多部分请求
spring.servlet.multipart.resolve-lazily = false 
```

## 文件上传

### 上传单个文件

```java
//设置基础路径
private final String basePath = "E:\\";
```

```java
//文件上传
@PostMapping("/upload")
public String upload(MultipartFile file){
    //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除
    log.info(file.toString());
    //原始文件名
    String originalFilename = file.getOriginalFilename();//abc.jpg
    String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
    //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖: abc.jpg
    String fileName = UUID.randomUUID().toString() + suffix;

    //创建一个目录对象
    File dir = new File(basePath);
    //判断当前目录是否存在
    if(!dir.exists()){
        //目录不存在，需要创建
        dir.mkdirs();
    }
    try {
        // 将临时文件转存到指定位置
        file.transferTo(new File(basePath + fileName));
    } catch (IOException e) {
        e.printStackTrace();
    }
    return fileName;
}
```

返回文件名

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220415180710579.png" alt="image-20220415180710579" style="zoom: 67%;" />



### 上传多个文件

特别注意点：MultipartFile[]后面跟的file名称要和前端匹配，不然文件长度就是0

```java
@PostMapping("/uploadManyFile")
public String save23(MultipartFile[] file) throws IOException {
    if(file.length == 0){
        return "请选择要上传的文件";
    }
    List<String> list = new ArrayList<>();
    for (MultipartFile multipartFile : file) {
        if(multipartFile.isEmpty()){
            return "文件上传失败";
        }
        //取得当前上传文件的文件名称
        String originalFilename = multipartFile.getOriginalFilename();
        //生成文件名
        String fileName = UUID.randomUUID() +"&"+ originalFilename;
        //转移文件路径
        String pathname = "E:\\"+fileName;
        list.add(pathname);
        multipartFile.transferTo(new File(pathname));
    }
    System.out.println(list.get(0));
    return "上传了："+list.size()+"个文件";
}
```

在resource下的static目录创建Upload.html测试

注意看input的name，要和后台参数相同

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>多文件上传</title>
</head>
<body>
<form action=":8080//uploadManyFile" method="post"
      enctype="multipart/form-data">
    <input type="file" name="file" value="请选择文件" multiple>
    <input type="submit" value="上传">
</form>
</body>
</html>
```

当然，如果不相同，可以用@RequestParam

```java
public String save23(@RequestParam("files") MultipartFile[] file)
```

对应前端

```html
<input type="file" name="files" value="请选择文件" multiple>
```



## 文件下载

[Spring boot下载文件的2种方式 - kribee - 博客园 (cnblogs.com)](https://www.cnblogs.com/kribee/p/14307540.html)

```java
@GetMapping("/download1")
public ResponseEntity<InputStreamResource> downloadFile(String fileName)
        throws IOException {
    log.info("进入下载方法...");
    //读取文件(找到文件)
    String filePath = "E://" + fileName;
    FileSystemResource file = new FileSystemResource(filePath);
    //设置响应头
    HttpHeaders headers = new HttpHeaders();
    headers.add("Cache-Control", "no-cache, no-store, must-revalidate");
    headers.add("Content-Disposition", 
                String.format("attachment; filename=\"%s\"", file.getFilename()));
    headers.add("Pragma", "no-cache");
    headers.add("Expires", "0");

    return ResponseEntity
            .ok()
            .headers(headers)
            .contentLength(file.contentLength())
            .contentType(MediaType.parseMediaType("application/octet-stream"))
            .body(new InputStreamResource(file.getInputStream()));
}
```

输入文件位置

```apl
:8080/download1?fileName=a.png
```

即可下载文件

## 图片回显

```java
//设置基础路径
private final String basePath = "D:\\";
//文件下载
@GetMapping("/download")
public void download(String name, HttpServletResponse response){
    try {
        //输入流，通过输入流读取文件内容
        FileInputStream fileInputStream = new
                                          FileInputStream(new File(basePath + name));

        //输出流，通过输出流将文件写回浏览器
        ServletOutputStream outputStream = response.getOutputStream();
		//设置文件类型：这里设置成图片
        response.setContentType("image/jpeg");
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fileInputStream.read(bytes)) != -1){
            outputStream.write(bytes,0,len);
            outputStream.flush();
        }
        //关闭资源
        outputStream.close();
        fileInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

这个文件回显不能在swagger里测试，直接在浏览器中测试

```apl
:8080/download?name=26d6502b-68f6-4d34-8601-ef2450cca694.png
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220415180539025.png" alt="image-20220415180539025" style="zoom: 50%;" />



## 文件删除

```java
//删除文件
@DeleteMapping("/deleteFile")
public String delete1(String fileName) throws IOException {
    File file = new File(basePath + fileName);
    boolean delete = file.delete();
    System.out.println(delete);
    return "删除成功";
}
```

输入图片路径即可删除

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220415180454556.png" alt="image-20220415180454556" style="zoom: 50%;" />



# 统一结果，统一异常，实体类⭐

## 统一结果返回

> 目前的前后端开发大部分数据的传输格式都是json，因此定义一个统一规范的数据格式有利于前后端的交互

### 统一结果的一般形式

> 1. 是否响应成功；
> 2. 响应状态码；
> 3. 状态码描述；
> 4. 响应数据
> 5. 其他标识符

### 结果类枚举

前三者可定义结果枚举，如：success，code，message

```java
@Getter
public enum ResultCodeEnum {
    SUCCESS(true,200,"成功"),
    UNKNOWN_ERROR(false,201,"未知错误"),
    PARAM_ERROR(false,202,"参数错误"),
    NULL_POINT(false,207,"空指针异常"),
    HTTP_CLIENT_ERROR(false,208,"http异常")
    ;

    // 响应是否成功
    private final Boolean success;
    // 响应状态码
    private final Integer code;
    // 响应信息
    private final String message;

    ResultCodeEnum(boolean success, Integer code, String message) {
        this.success = success;
        this.code = code;
        this.message = message;
    }
}
```



### 统一结果类

第5个属于自定义返回，利用前4者可定义统一返回对象，统一结果类使用参考mybatis-plus中R对象的设计

**注意：**

1. 外接只可以调用统一返回类的方法，不可以直接创建，影刺构造器私有；
2. 内置静态方法，返回对象；
3. 为便于自定义统一结果的信息，建议使用链式编程，将返回对象设类本身，即return this;
4. 响应数据由于为json格式，可定义为JsonObject或Map形式；

```java
@Data
public class R {
    private Boolean success;

    private Integer code;

    private String message;

    private Map<String, Object> data = new HashMap<>();

    // 构造器私有
    private R(){}

    // 通用返回成功
    public static R ok() {
        R r = new R();
        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());
        r.setCode(ResultCodeEnum.SUCCESS.getCode());
        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());
        return r;
    }

    // 通用返回失败，未知错误
    public static R error() {
        R r = new R();
        r.setSuccess(ResultCodeEnum.UNKNOWN_ERROR.getSuccess());
        r.setCode(ResultCodeEnum.UNKNOWN_ERROR.getCode());
        r.setMessage(ResultCodeEnum.UNKNOWN_ERROR.getMessage());
        return r;
    }

    // 设置结果，形参为结果枚举
    public static R setResult(ResultCodeEnum result) {
        R r = new R();
        r.setSuccess(result.getSuccess());
        r.setCode(result.getCode());
        r.setMessage(result.getMessage());
        return r;
    }

    /**------------使用链式编程，返回类本身-----------**/ 
    // 自定义返回数据
    public R data(Map<String,Object> map) {
        this.setData(map);
        return this;
    }

    // 通用设置data
    public R data(String key,Object value) {
        this.data.put(key, value);
        return this;
    }

    // 自定义状态信息
    public R message(String message) {
        this.setMessage(message);
        return this;
    }

    // 自定义状态码
    public R code(Integer code) {
        this.setCode(code);
        return this;
    }

    // 自定义返回结果
    public R success(Boolean success) {
        this.setSuccess(success);
        return this;
    }
}
```

### 控制层返回

视图层使用统一结果

```java
@RestController
@RequestMapping("/api/v1/users")
public class TeacherAdminController {

    @Autowired
    private UserService userService;

    @GetMapping
    public R list() {
        List<Teacher> list = teacherService.list(null);
        return R.ok().data("itms", list).message("用户列表");
    }
}    
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204201625559.png" alt="image-20220420162534458" style="zoom: 50%;" />



## 统一异常处理

[Java项目构建基础：统一结果，统一异常，统一日志！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247485175&idx=2&sn=032bb4e1eaadb63dcc9b356dd7be5582&chksm=fc2fbaffcb5833e9b1512ca7fd66c64b92b9f2302410ace0e0d20682322df3a3fd7829ccff00&mpshare=1&scene=23&srcid=0415AHnhIQVflWOqVNd2N85Q&sharer_sharetime=1650032207164&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> 使用统一返回结果时，还有一种情况，就是程序的保存是由于运行时异常导致的结果，有些异常我们可以无法提前预知，不能正常走到我们return的R对象返回。

因此，我们需要定义一个统一的全局异常来捕获这些信息，并作为一种结果返回控制层

### @ControllerAdvice

该注解为统一异常处理的核心

> 是一种作用于控制层的切面通知（Advice），该注解能够将通用的@ExceptionHandler、@InitBinder和@ModelAttributes方法收集到一个类型，并应用到所有控制器上

该类中的设计思路：

1. 使用@ExceptionHandler注解捕获指定或自定义的异常；
2. 使用@ControllerAdvice集成@ExceptionHandler的方法到一个类中；
3. 必须定义一个通用的异常捕获方法，便于捕获未定义的异常信息；
4. 自定一个异常类，捕获针对项目或业务的异常;
5. 异常的对象信息补充到统一结果枚举中；

### 自定义全局异常类

```java
@Data
public class CMSException extends RuntimeException {
    private Integer code;

    public CMSException(Integer code, String message) {
        super(message);
        this.code = code;
    }

    public CMSException(ResultCodeEnum resultCodeEnum) {
        super(resultCodeEnum.getMessage());
        this.code = resultCodeEnum.getCode();
    }

    @Override
    public String toString() {
        return "CMSException{" + "code=" + code + ", message=" + this.getMessage() + '}';
    }
}
```

### 统一异常处理器

```java
// ...
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@ControllerAdvice
public class GlobalExceptionHandler {

    /**-------- 通用异常处理方法 --------**/
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R error(Exception e) {
        e.printStackTrace();
        return R.error(); // 通用异常结果
    }

    /**-------- 指定异常处理方法 --------**/
    @ExceptionHandler(NullPointerException.class)
    @ResponseBody
    public R error(NullPointerException e) {
        e.printStackTrace();
        return R.setResult(ResultCodeEnum.NULL_POINT);
    }

    @ExceptionHandler(HttpClientErrorException.class)
    @ResponseBody
    public R error(IndexOutOfBoundsException e) {
        e.printStackTrace();
        return R.setResult(ResultCodeEnum.HTTP_CLIENT_ERROR);
    }
    
    /**-------- 自定义定异常处理方法 --------**/
    @ExceptionHandler(CMSException.class)
    @ResponseBody
    public R error(CMSException e) {
        e.printStackTrace();
        return R.error().message(e.getMessage()).code(e.getCode());
    }
}
```

### 控制层展示

制造一个空指针

```java
@GetMapping("findAll")
public R findAll() {
    List<SysRole> roleList = sysRoleService.list();
    int i = 1/0;
    return R.ok().data("data", roleList);
}
```

以下为展示当遇到null指定异常时，返回的结果信息

```json
{
  "success": false,
  "code": 20007,
  "message": "空指针异常",
  "data": {}
}
```

推荐博客《SpringBoot之全局异常处理》：https://juejin.im/post/5cbc744a6fb9a0685a3f01a7

## 实体类规范

### 概念

在讲具体的概念之前，我们先简单的讲一讲我们`MVC`开发模式。

**MVC的简单定义：**

`M`层负责与数据库打交道；

`C`层负责业务逻辑的编写；

`V`层负责给用户展示（针对于前后端不分离的项目，不分离项目那种编写模版的方式）。

而我们今天要说的`VO，BO，PO，DO，DTO`呢，就是穿梭在这`M、V、C`层之间的`实体传输对象`。

![图片](https://mmbiz.qpic.cn/mmbiz_png/7Eb5lRuVqbRM2eTvZsKcneaCgI4oRAIticMQiaKgBZpgoKIdIEMcsz0jic6iaHj0OeUVQOHkicXaIRnACibicGBOvS8XA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- VO（`View Object`）：**视图对象**，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。
- DTO（`Data Transfer Object`）：**数据传输对象**，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，更符合泛指用于展示层与服务层之间的数据传输对象。
- BO（`Business Object`）：**业务对象**，把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。
- PO（`Persistent Object`）：**持久化对象**，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。
- DO（`Domain Object`）：**领域对象**，就是从现实世界中抽象出来的有形或无形的业务实体。

### 有必要用吗？

项目中真的有必要定义`VO，BO，PO，DO，DTO`吗？

还是要理性看待这个问题，要看我们项目“目的地”是什么。

如果项目比较小，是一个简单的`MVC`项目，又是`单兵作战`，我不建议使用`VO，BO，PO，DO，DTO`，直接用`POJO`负责各个层来传输就好，因为这种项目的“目的地”是快速完成。

而我们更多的时候，是持续迭代的团队协作项目，这个时候我们就建议用`VO，BO，PO，DO，DTO`，而且团队内要达成共识，形成一个`标准规范`。

1. 业务复杂，人员协同性要求高的场景下，这些规范性的东西不按着来虽然不会出错，程序照样跑，但是遵守规范会让程序更具扩展性和可读性；
2. 让类语义更明确，很容易知道类的含义；

其实就是提升项目的`可扩展性`、`可维护性`与`可阅读性`。

提升这些性能的尽头是`经济效益`。

### 总结

这篇文章很短，最后稍微总结一下，不管用哪种方式，只要团队内定义好一种适应的协同规范就行。

没有一个`绝对好`与`绝对坏`的方式方法。

团队规范的尽头能提升项目的`可扩展性`、`可维护性`与`可阅读性`，从而降低bug率。

另附这些概念命名规范：

> - 数据对象：xxxPO，xxx即为数据表名。(也可DO)
> - 数据传输对象：xxxDTO，xxx为业务领域相关的名称。
> - 展示对象：xxxVO，xxx一般为网页名称。
> - 业务对象：xxxBO，xxx是业务名称。



# knife4j

> 文档地址：https://doc.xiaominfo.com/，knife4j是为Java MVC框架集成Swagger生成Api文档解决方案

## API文档

前后端分离开发模式中，api文档是最好的沟通方式。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。

> 1、及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)
>
> 2、规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)
>
> 3、一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)
>
> 4、可测性 (直接在接口文档上进行测试，以方便理解业务)

## 集成knife4j

> knife4j属于service模块公共资源，因此我们集成到service-uitl模块

### 添加依赖

操作模块：service-uitl

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi2-spring-boot-starter</artifactId>
    <version>4.1.0</version>
</dependency>
```

### 配置文件

```yml
knife4j:
  enable: true
  openapi:
    title: Knife4j官方文档
    description: 我是测试
    email: xiaoymin@foxmail.com
    concat: 八一菜刀
    url: https://docs.xiaominfo.com
    version: v4.0
    license: Apache 2.0
    license-url: https://stackoverflow.com/
    terms-of-service-url: https://stackoverflow.com/
    group:
      test1:
        group-name: 接口
        api-rule: package
        api-rule-resources:
          - com.it.controller
```

```
spring.profiles.active=a
```

### 访问路径

http://127.0.0.1:8003/doc.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305271058093.png" alt="image-20230527105816957" style="zoom:80%;" />



# 全局日期格式化

[没想到 SpringBoot 能这样做全局日期格式化，有点香！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247484753&idx=2&sn=4b36ab766895db197b04d1d120e68d89&chksm=fc2fb959cb58304fc8ade04b97d46e338e481e447e91078b4c522c6b0a647aaced1c993007cb&mpshare=1&scene=23&srcid=0415CzJxHE2nXW7LWgLNVP3W&sharer_sharetime=1650032049620&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

时间格式化是使用频率非常高的，如何让时间格式化变得既简单又不用重复造轮子，那么就应将它抽象出来，作为全局的日期格式化处理，下面就结合实践简单介绍下几种优化方案。

我们的 `API` 接口返回结果，需要对其中某一个 `date` 字段属性进行特殊的格式化处理，通常会用到 `SimpleDateFormat` 工具处理。

```java
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
Date stationTime = dateFormat.parse(dateFormat.format(PayEndTime()));
```

可一旦处理的地方较多，不仅 `CV` 操作频繁，还产生很多重复臃肿的代码，而此时如果能将时间格式统一配置，就可以省下更多时间专注于业务开发了。

可能很多人觉得统一格式化时间很简单啊，像下边这样配置一下就行了，但事实上这种方式只对 `date` 类型生效。

```java
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
```

而很多项目中用到的时间和日期`API` 比较混乱， `java.util.Date` 、 `java.util.Calendar` 和 `java.time LocalDateTime` 都存在，所以全局时间格式化必须要同时兼容性新旧 `API`。

看看配置全局时间格式化前，接口返回时间字段的格式。

```java
@Data
public class OrderDTO {

    private LocalDateTime createTime;

    private Date updateTime;
}
```

很明显不符合页面上的显示要求（**有人抬杠为啥不让前端解析时间，我只能说睡服代码比说服人容易得多~**）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207241701223.png" alt="image-20220724170124127" style="zoom:67%;" />

## 前端格式化

```js
function dateFormat(fmt, date) {
    let ret;
    const opt = {
        "Y+": date.getFullYear().toString(),        // 年
        "m+": (date.getMonth() + 1).toString(),     // 月
        "d+": date.getDate().toString(),            // 日
        "H+": date.getHours().toString(),           // 时
        "M+": date.getMinutes().toString(),         // 分
        "S+": date.getSeconds().toString()          // 秒
        // 有其他格式化字符需求可以继续添加，必须转化成字符串
    };
    for (let k in opt) {
        ret = newRegExp("(" + k + ")").exec(fmt);
        if (ret) {
            fmt = fmt.replace(ret[1],(ret[1].length == 1) ? (opt[k]):
                              (opt[k].padStart(ret[1].length, "0")))
        };
    };
    return fmt;
}
```

方法调用：

```js
let date = newDate();
dateFormat("YYYY-mm-dd HH:MM:SS", date);

>>> 2021-07-25 21:45:12
```



## Jackson

**以上两种后端格式化的实现都有一个致命的缺点，它们在进行时间格式化的时候，都需要对核心业务类做一定的修改**，这就相当为了解决一个问题，又引入了一个新的问题，那有没有简单一点、优雅一点的解决方案呢？

答案是：有的。我们可以不改任何代码，只需要在配置文件中设置一下就可以实现时间格式化的功能了。

### 简单实现

首先，我们找到 Spring Boot 的配置文件 application.properties（或 application.yml），只需要在 application.properties 配置文件中添加以下两行配置：

```properties
# 格式化全局时间字段，只能对Date类型生效，LocalDateTime不生效
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
# 指定时间区域类型
spring.jackson.time-zone=GMT+8
```

### 原理分析

为什么在配置文件中设置一下，就可以实现所有时间字段的格式化了呢？

这是因为 Controller 在返回数据时，会自动调用 Spring Boot 框架中内置的 JSON 框架 Jackson，对返回的数据进行统一的 JSON 格式化处理，在处理的过程中它会判断配置文件中是否设置了“spring.jackson.date-format=yyyy-MM-dd HH:mm:ss”，如果设置了，那么 Jackson 框架在对时间类型的字段输出时就会执行时间格式化的处理，这样我们就通过配置来实现全局时间字段的格式化功能了。

为什么要指定时间区域类型“spring.jackson.time-zone=GMT+8”呢？

> 最现实的原因是，如果我们不指定时间区域类型，那么查询出来的时间就会比预期的时间少 8 个小时，这因为我们（中国）所处的时间区域比世界时间少 8 个小时导致的，而当我们设置了时区之后，我们的时间查询才会和预期时间保持一致。

### GMT格林尼治时间

时间区域设置中的“GMT” 是什么意思？

Greenwich Mean Time (GMT) **格林尼治时间**，也叫做世界时间。

格林尼治是英国伦敦南郊原皇家格林尼治天文台所在地，地球本初子午线的标界处，世界计算时间和经度的起点。以其海事历史、作为本初子午线的标准点、以及格林尼治时间以其命名而闻名于世。这里地势险要，风景秀丽，兼具历史和地方风情，也是伦敦在泰晤士河的东方门户。

不光是天文学家使用格林尼治时间，就是在新闻报刊上也经常出现这个名词。我们知道各地都有各地的地方时间。如果对国际上某一重大事情，用地方时间来记录，就会感到复杂不便．而且将来日子一长容易搞错。因此，天文学家就提出一个大家都能接受且又方便的记录方法，那就是以格林尼治的地方时间为标准。

以本初子午线的平子夜起算的平太阳时。又称格林尼治平时或格林尼治时间。各地的地方平时与世界时之差等于该地的地理经度。1960年以前曾作为基本时间计量系统被广泛应用。由于地球自转速率曾被认为是均匀的,因此在1960年以前,世界时被认为是一种均匀时。由于地球自转速度变化的影响，它不是一种均匀的时间系统，它与原子时或力学时都没有任何理论上的关系,只有通过观测才能对它们进行比较。后来世界时先后被历书时和原子时所取代，但在日常生活、天文导航、大地测量和宇宙飞行等方面仍属必需；同时，世界时反映地球自转速率的变化，是地球自转参数之一，仍为天文学和地球物理学的基本资料。



## JsonFormat注解

注意事项：`只是获取数据时进行格式化，存储数据时还是正常的该是Date该是LocalTime就是那样，不变`

使用`@JsonFormat`注解格式化时间，应该算是一个基本操作了，大部分开发者都应用此种方式，简单方便。

`@JsonFormat` 注解方式严格意义上不能叫全局时间格式化，应该叫部分格式化，因为`@JsonFormat` 注解需要用在实体类的时间字段上，而只有使用相应的实体类，对应的字段才能进行格式化。

```java
import java.time.LocalDateTime;
import java.util.Date;

@Data
public class User {
    private Integer id;
    private String name;
    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private Date updateTime;
    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd")
    private Date updateTime1;
}
```

进行测试使用

```java
@GetMapping("/hello1")
public User hello1() {
    User u = new User();
    u.setId(1);
    u.setName("张三");
    u.setCreateTime(LocalDateTime.now());
    u.setUpdateTime(new Date());
    return u;
}
```

结果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220416155816160.png" alt="image-20220416155816160" style="zoom: 55%;" />

测试一下结果，发现 `Date` 类型和 `LocalDateTime` 类型都格式化成功，但还是有个问题，这样做仍然比较繁琐，每个实体类的日期字段都要加`@JsonFormat`注解，重复的工作量也不小。接着往下看~

## JsonComponent 注解（推荐）

这是我个人比较推荐的一种方式，前边看到使用 `@JsonFormat` 注解并不能完全做到全局时间格式化，所以接下来我们使用 `@JsonComponent` 注解自定义一个全局格式化类，分别对 `Date` 和 `LocalDate` 类型做格式化处理。

```java
@JsonComponent
public class DateFormatConfig {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    /**
     * @description date 类型全局时间格式化
     */
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilder() {
        return builder -> {
            TimeZone tz = TimeZone.getTimeZone("UTC");
            DateFormat df = new SimpleDateFormat(pattern);
            df.setTimeZone(tz);
            builder.failOnEmptyBeans(false)
                    .failOnUnknownProperties(false)
                    .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
                    .dateFormat(df);
        };
    }

    /**
     * @description LocalDate 类型全局时间格式化
     */
    @Bean
    public LocalDateTimeSerializer localDateTimeDeserializer() {
        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));
    }

    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -> builder.serializerByType(LocalDateTime.class, 
                                                   localDateTimeDeserializer());
    }
}
```

看到 `Date` 和 `LocalDate` 两种时间类型格式化成功，此种方式有效。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207241704210.png" alt="image-20220724170417108" style="zoom:67%;" />

但还有个问题，实际开发中如果我有个字段不想用全局格式化设置的时间样式，**想自定义格式怎么办？**

那就需要和 `@JsonFormat` 注解配合使用了。

```java
@Data
public class OrderDTO {

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd")
    private LocalDateTime createTime;

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd")
    private Date updateTime;
}
```

从结果上我们看到 `@JsonFormat` 注解的优先级比较高，会以 `@JsonFormat` 注解的时间格式为主。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207241704311.png" alt="image-20220724170441208" style="zoom:67%;" />

## Configuration 注解

`Springboot` 已经为我们提供了日期格式化 `${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}`，这里我们需要进行全局配置，配置比较简单，也无需在实体类属性上添加`@JsonFormat`注解。

只需要用`@Configuration`定义一个配置类，注入两个`Bean`即可完成全局日期格式化处理，这种方式也是当前我项目中正在用的方式。

这种全局配置的实现方式与上边的效果是一样的

> **注意**：在使用此种配置后，字段手动配置`@JsonFormat` 注解将不再生效。

### 实体类

```java
@Data
public class User {
    private Integer id;
    private String name;
    private LocalDateTime createTime;
    private Date updateTime;
}
```

### 配置类

```java
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
//声明为配置类
@Configuration
public class LocalDateTimeSerializerConfig {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    @Bean
    public Jackson2ObjectMapperBuilder mapperBuilder() {
        Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder = new
                                    Jackson2ObjectMapperBuilder();
        return jackson2ObjectMapperBuilder.dateFormat(new SimpleDateFormat(pattern))
                .serializerByType(LocalDateTime.class, localDateTimeSerializer())
                .deserializerByType(LocalDateTime.class, localDateTimeDeserializer());
    }
    @Bean
    public LocalDateTimeSerializer localDateTimeSerializer() {
        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));
    }

    @Bean
    public LocalDateTimeDeserializer localDateTimeDeserializer() {
        return new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(pattern));
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220416162845389.png" alt="image-20220416162845389" style="zoom:67%;" />

这种方式可支持 `Date` 类型和 `LocalDateTime` 类型并存，那么有一个问题就是现在全局时间格式是`yyyy-MM-dd HH:mm:ss`，但有的字段却需要`yyyy-MM-dd`格式咋整？

那就需要配合`@JsonFormat`注解使用，在特定的字段属性添加`@JsonFormat`注解即可，因为`@JsonFormat`注解优先级比较高，会以`@JsonFormat`注解标注的时间格式为主。

方式二

```java
@Configuration
public class DateFormatConfig2 {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    public static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    @Bean
    @Primary
    public ObjectMapper serializingObjectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer());
        javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer());
        objectMapper.registerModule(javaTimeModule);
        return objectMapper;
    }

    /**
     * @description Date 时间类型装换
     */
    @Component
    public class DateSerializer extends JsonSerializer<Date> {
        @Override
        public void serialize(Date date, JsonGenerator gen, SerializerProvider provider)
            throws IOException {
            String formattedDate = dateFormat.format(date);
            gen.writeString(formattedDate);
        }
    }

    /**
     * @description Date 时间类型装换
     */
    @Component
    public class DateDeserializer extends JsonDeserializer<Date> {

        @Override
        public Date deserialize(JsonParser jsonParser, 
                                DeserializationContext deserializationContext) 
            throws IOException {
            try {
                return dateFormat.parse(jsonParser.getValueAsString());
            } catch (ParseException e) {
                throw new RuntimeException("Could not parse date", e);
            }
        }
    }

    /**
     * @description LocalDate 时间类型装换
     */
    public class LocalDateTimeSerializer extends JsonSerializer<LocalDateTime> {
        @Override
        public void serialize(LocalDateTime value, JsonGenerator gen, 
                              SerializerProvider serializers) throws IOException {
            gen.writeString(value.format(DateTimeFormatter.ofPattern(pattern)));
        }
    }

    /**
     * @description LocalDate 时间类型装换
     */
    public class LocalDateTimeDeserializer extends JsonDeserializer<LocalDateTime> {
        @Override
        public LocalDateTime deserialize(JsonParser p, 
                                         DeserializationContext deserializationContext)
            throws IOException {
            return LocalDateTime.parse(p.getValueAsString(),
                                       DateTimeFormatter.ofPattern(pattern));
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207241707264.png" alt="image-20220724170707163" style="zoom:67%;" />

# 循环重试

## 消息重试原因

在实际工作中，重处理是一个非常常见的场景，比如:

> - 发送消息失败。
> - 调用远程服务失败。
> - 争抢锁失败。

这些错误可能是因为网络波动造成的，等待过后重处理就能成功。通常来说，会用`try/catch`，`while`循环之类的语法来进行重处理，但是这样的做法缺乏统一性，并且不是很方便，要多写很多代码。

## Spring-Retry

然而`spring-retry`却可以通过注解，在不入侵原有业务逻辑代码的方式下，优雅的实现重处理功能。

> @EnableRetry - 表示开启重试机制 
>
> @Retryable - 表示这个方法需要重试，它有很丰富的参数，可以满足你对重试的需求 
>
> @Backoff - 表示重试中的退避策略 
>
> @Recover - 兜底方法，即多次重试后还是失败就会执行这个方法

@Retryable是什么？

spring系列的`spring-retry`是另一个实用程序模块，可以帮助我们以标准方式处理任何特定操作的重试。在`spring-retry`中，所有配置都是基于简单注释的。

### 基本配置

POM依赖

```xml
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
```

启用@Retryable

```java
@EnableRetry
@SpringBootApplication
public class HelloApplication {
    public static void main(String[] args) {
        SpringApplication.run(HelloApplication.class, args);
    }
}
```

### 简单使用⭐

在方法上添加@Retryable

```java
public interface TestRetryService {
    int test(int code) throws Exception;
}
```

```java
import com.mail.elegant.service.TestRetryService;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import java.time.LocalTime;
 
@Service
public class TestRetryServiceImpl implements TestRetryService {
    @Override
    
    @Retryable(value = Exception.class,
    		  maxAttempts = 3,
               backoff = @Backoff(delay = 2000,multiplier = 1.5))
    public int test(int code) throws Exception{
        System.out.println("test被调用,时间："+LocalTime.now());
          if (code==0){
              throw new Exception("情况不对头！");
          }
        System.out.println("test被调用,情况对头了！");
        return 200;
    }
}
```

调用

```java
@GetMapping("/getCode")
public int getCode(int code) throws Exception {
    return testRetryService.test(code);
}
```

访问：正常情况,请求体不是0

:8080/getCode

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220412204703143.png" alt="image-20220412204703143" style="zoom:67%;" />

异常情况

请求体code=0

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220412204804943.png" alt="image-20220412204804943" style="zoom:80%;" />

来简单解释一下注解中几个参数的含义：

- `value`：抛出指定异常才会重试
- `include`：和value一样，默认为空，当exclude也为空时，默认所有异常
- `exclude`：指定不处理的异常
- `maxAttempts`：最大重试次数，默认3次
- `backoff`：重试等待策略，默认使用`@Backoff`，`@Backoff`的value默认为1000L，我们设置为2000L；`multiplier`（指定延迟倍数）默认为0，表示固定暂停1秒后进行重试，如果把`multiplier`设置为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒。

**当重试耗尽时还是失败，会出现什么情况呢？**

当重试耗尽时，`RetryOperations`可以将控制传递给另一个回调，即`RecoveryCallback`。`Spring-Retry`还提供了`@Recover`注解，用于@Retryable重试失败后处理方法。如果不需要回调方法，可以直接不写回调方法，那么实现的效果是，重试次数完了后，如果还是没成功没符合业务判断，就抛出异常。



### 重试回调函数(可选)

重试达到最大重试次数时，调用`@Recover`的方法

该方法正常写在service方法下面即可，不用写接口

```java
@Recover
public int recover(Exception e, int code){
   System.out.println("回调方法执行！！！！");
   //记日志到数据库 或者调用其余的方法
    return 400;
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220412205129960.png" alt="image-20220412205129960" style="zoom:67%;" />

可以看到传参里面写的是 `Exception e`，这个是作为回调的接头暗号（重试次数用完了，还是失败，我们抛出这个`Exception e`通知触发这个回调方法）。对于`@Recover`注解的方法，需要特别注意的是：

- 方法的返回值必须与`@Retryable`方法一致
- 方法的第一个参数，必须是Throwable类型的，建议是与`@Retryable`配置的异常一致，其他的参数，需要哪个参数，写进去就可以了（`@Recover`方法中有的）
- 该回调方法与重试方法写在同一个实现类里面

### 注意事项

> - 由于是基于AOP实现，所以不支持类里自调用方法
> - 如果重试失败需要给@Recover注解的方法做后续处理，那这个重试的方法不能有返回值，只能是void
> - 方法内不能使用try catch，只能往外抛异常
> - @Recover注解来开启重试失败后调用的方法(注意,需跟重处理方法在同一个类中)，此注解注释的方法参数一定要是@Retryable抛出的异常，否则无法识别，可以在该方法中进行日志处理。



## Guava-Retry(推荐)

Guava retryer工具与spring-retry类似，都是通过定义重试者角色来包装正常逻辑重试，但是Guava retryer有更优的策略定义，在支持重试次数和重试频度控制基础上，能够兼容支持多个异常或者自定义实体对象的重试源定义，让重试功能有更多的灵活性。Guava Retryer也是线程安全的，入口调用逻辑采用的是`Java.util.concurrent.Callable`的call

> guava-retrying是谷歌的Guava库的一个小扩展，允许为任意函数调用创建可配置的重试策略，比如与正常运行时间不稳定的远程服务对话的函数调用。

### 1. 简单使用⭐

pom.xml加入依赖

```xml
<!-- https://mvnrepository.com/artifact/com.github.rholder/guava-retrying -->
<dependency>
    <groupId>com.github.rholder</groupId>
    <artifactId>guava-retrying</artifactId>
    <version>2.0.0</version>
</dependency>
```

更改一下测试的任务方法

```java
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.RandomUtils;
import org.springframework.remoting.RemoteAccessException;

@Slf4j
public class RetryDemoTask {
    
    public static boolean retryTask(String param) {
        log.info("收到请求参数:{}", param);

        int i = RandomUtils.nextInt(0, 11);
        log.info("随机生成的数:{}", i);
        if (i < 2) {
            log.info("为0,抛出参数异常.");
            throw new IllegalArgumentException("参数异常");
        } else if (i < 5) {
            log.info("为1,返回true.");
            return true;
        } else if (i < 7) {
            log.info("为2,返回false.");
            return false;
        } else {
            //为其他
            log.info("大于2,抛出自定义异常.");
            throw new RemoteAccessException("大于2,抛出自定义异常");
        }
    }
}
```

使用测试

这里设定跟Spring-Retry不一样，我们可以根据返回的结果来判断是否重试，比如返回false我们就重试

```java
@Test
public void fun01(){
    // RetryerBuilder 构建重试实例 retryer,可以设置重试源且可以支持多个重试源
    // 可以配置重试次数或重试超时时间，以及可以配置等待时间间隔
    Retryer<Boolean> retryer = RetryerBuilder.<Boolean> newBuilder()
            .retryIfExceptionOfType(RemoteAccessException.class)//设置异常重试源
            .retryIfResult(res-> res==false)  //设置根据结果重试
            //设置等待间隔时间
            .withWaitStrategy(WaitStrategies.fixedWait(3, TimeUnit.SECONDS)) 
            .withStopStrategy(StopStrategies.stopAfterAttempt(3)) //设置最大重试次数
            .build();
    try {
        // 调用类中重试方法
        retryer.call(() -> RetryDemoTask.retryTask("abc"));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

运行测试一下

遇到了我们指定的需要重试的异常，进行重试，间隔是3秒

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241441150.png" alt="image-20220824144154879" style="zoom:80%;" />

重试次数超过了最大重试次数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241443992.png" alt="image-20220824144357834" style="zoom:67%;" />

返回为true，直接结束重试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241443145.png" alt="image-20220824144333057" style="zoom:67%;" />

遇到了没有指定重试的异常，结束重试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241443139.png" alt="image-20220824144310970" style="zoom:80%;" />

返回false，重试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241442233.png" alt="image-20220824144254123" style="zoom:67%;" />

### 2. 重试时机

RetryerBuilder的**retryIfXXX()方法用来设置在什么情况下进行重试，总体上可以分为**根据执行异常进行重试**和**根据方法执行结果进行重试两类。我们可以更灵活的配置重试策略，比如:

#### 1 根据异常进行重试

| 方法                                   | 描述                                                         |
| :------------------------------------- | :----------------------------------------------------------- |
| retryIfException()                     | 当方法执行抛出异常 isAssignableFrom Exception.class 时重试   |
| retryIfRuntimeException()              | 当方法执行抛出异常 isAssignableFrom RuntimeException.class 时重试 |
| retryIfException(Predicate exception)  | 这里当发生异常时，会将异常传递给exceptionPredicate，那我们就可以通过传入的异常进行更加自定义的方式来决定什么时候进行重试 |
| retryIfExceptionOfType(exceptionClass) | 当方法执行抛出异常 isAssignableFrom 传入的exceptionClass 时重试 |

#### 2 根据返回结果进行重试

retryIfResult(@Nonnull Predicate resultPredicate) 这个比较简单，当我们传入的resultPredicate返回true时则进行重试

```java
retryIfExceptionOfType(NullPointerException.class)// 只在抛出空指针异常重试
```

**retryIfResult:**`retryIfResult` 可以指定你的 `Callable` 方法在返回值的时候进行重试，如

```java
// 返回false重试  
.retryIfResult(Predicates.equalTo(false))   

//以_error结尾才重试  
.retryIfResult(Predicates.containsPattern("_error$"))

//返回为空时重试
.retryIfResult(res-> res==null)
```

**RetryListener：** 当发生重试之后，假如我们需要做一些额外的处理动作，比如log一下异常，那么可以使用`RetryListener`。每次重试之后，`guava-retrying` 会自动回调我们注册的监听。可以注册多个`RetryListener`，会按照注册顺序依次调用。

```java
.withRetryListener(new RetryListener() {
    @Override
    public <V> void onRetry(Attempt<V> attempt) {
        log.error("第【{}】次调用失败" , attempt.getAttemptNumber());
    }
})
```



### 4. 停止重试策略StopStrategy

停止重试策略用来决定什么时候不进行重试，其接口com.github.rholder.retry.StopStrategy，停止重试策略的实现类均在com.github.rholder.retry.StopStrategies中，它是一个策略工厂类。

```java
public interface StopStrategy {

    /**
     * Returns <code>true</code> if the retryer should stop retrying.
     *
     * @param failedAttempt the previous failed {@code Attempt}
     * @return <code>true</code> if the retryer must stop, <code>false</code> otherwise
     */
    boolean shouldStop(Attempt failedAttempt);
}
```

#### 1 NeverStopStrategy

此策略将永远重试，永不停止，查看其实现类，直接返回了false

```java
@Override
public boolean shouldStop(Attempt failedAttempt) {
 return false;
}
```

#### 2 StopAfterAttemptStrategy

当执行次数到达指定次数之后停止重试，查看其实现类：

```java
private static final class StopAfterAttemptStrategy implements StopStrategy {
     private final int maxAttemptNumber;

     public StopAfterAttemptStrategy(int maxAttemptNumber) {
            Preconditions.checkArgument(maxAttemptNumber >= 1, 
                                        "maxAttemptNumber must be >= 1 but is %d", 
                                        maxAttemptNumber);
            this.maxAttemptNumber = maxAttemptNumber;
     }

     @Override
     public boolean shouldStop(Attempt failedAttempt) {
            return failedAttempt.getAttemptNumber() >= maxAttemptNumber;
     }
}
```

#### 3 StopAfterDelayStrategy

当距离方法的第一次执行超出了指定的delay时间时停止，也就是说一直进行重试，当进行下一次重试的时候会判断从第一次执行到现在的所消耗的时间是否超过了这里指定的delay时间，查看其实现：

```java
private static final class StopAfterAttemptStrategy implements StopStrategy {
      private final int maxAttemptNumber;

      public StopAfterAttemptStrategy(int maxAttemptNumber) {
            Preconditions.checkArgument(maxAttemptNumber >= 1, 
                                        "maxAttemptNumber must be >= 1 but is %d", 
                                        maxAttemptNumber);
            this.maxAttemptNumber = maxAttemptNumber;
      }

      @Override
      public boolean shouldStop(Attempt failedAttempt) {
            return failedAttempt.getAttemptNumber() >= maxAttemptNumber;
      }
}
```

### 5. 重试间隔策略、重试阻塞策略

这两个策略放在一起说，它们合起来的作用就是用来控制重试任务之间的间隔时间，以及如何任务在等待时间间隔时如何阻塞。也就是说WaitStrategy决定了重试任务等待多久后进行下一次任务的执行，BlockStrategy用来决定任务如何等待。它们两的策略工厂分别为com.github.rholder.retry.WaitStrategies和BlockStrategies。关注公众号：“码猿技术专栏”，回复关键词：“1111” 获取阿里内部Java调优手册

#### 1 BlockStrategy

##### 1 ThreadSleepStrategy

这个是BlockStrategies，决定如何阻塞任务，其主要就是通过**Thread.sleep()**来进行阻塞的，查看其实现：

```java
@Immutable
private static class ThreadSleepStrategy implements BlockStrategy {

     @Override
     public void block(long sleepTime) throws InterruptedException {
          Thread.sleep(sleepTime);
     }
}
```

#### 2 WaitStrategy

##### 1 IncrementingWaitStrategy

该策略在决定任务间隔时间时，返回的是一个递增的间隔时间，即每次任务重试间隔时间逐步递增，越来越长，查看其实现：

```java
private static final class IncrementingWaitStrategy implements WaitStrategy {
    private final long initialSleepTime;
    private final long increment;

    public IncrementingWaitStrategy(long initialSleepTime,
                                      long increment) {
          Preconditions.checkArgument(initialSleepTime >= 0L, 
                                      "initialSleepTime must be >= 0 but is %d", 
                                      initialSleepTime);
          this.initialSleepTime = initialSleepTime;
          this.increment = increment;
    }

    @Override
    public long computeSleepTime(Attempt failedAttempt) {
      long result = initialSleepTime + (increment * (failedAttempt.getAttemptNumber() - 1));
           return result >= 0L ? result : 0L;
      }
}
```

该策略输入一个起始间隔时间值和一个递增步长，然后每次等待的时长都递增increment时长。

##### 2 RandomWaitStrategy

顾名思义，返回一个随机的间隔时长，我们需要传入的就是一个最小间隔和最大间隔，然后随机返回介于两者之间的一个间隔时长，其实现为：

```java
private static final class RandomWaitStrategy implements WaitStrategy {
     private static final Random RANDOM = new Random();
     private final long minimum;
     private final long maximum;

     public RandomWaitStrategy(long minimum, long maximum) {
            Preconditions.checkArgument(minimum >= 0, "minimum must be >= 0 but is %d", 
                                        minimum);
            Preconditions.checkArgument(maximum > minimum, 
                  "maximum must be > minimum but maximum is %d and minimum is",
                                        maximum, minimum);

            this.minimum = minimum;
            this.maximum = maximum;
     }

     @Override
     public long computeSleepTime(Attempt failedAttempt) {
          long t = Math.abs(RANDOM.nextLong()) % (maximum - minimum);
          return t + minimum;
     }
}
```

##### 3 FixedWaitStrategy

该策略是返回一个固定时长的重试间隔。查看其实现：

```java
private static final class FixedWaitStrategy implements WaitStrategy {
     private final long sleepTime;

     public FixedWaitStrategy(long sleepTime) {
         Preconditions.checkArgument(sleepTime >= 0L, 
                                     "sleepTime must be >= 0 but is %d", sleepTime);
         this.sleepTime = sleepTime;
     }

     @Override
     public long computeSleepTime(Attempt failedAttempt) {
          return sleepTime;
     }
}
```

##### 4 ExceptionWaitStrategy

该策略是由方法执行异常来决定是否重试任务之间进行间隔等待，以及间隔多久。

```java
private static final class ExceptionWaitStrategy<T extends Throwable>
    implements WaitStrategy {
    private final Class<T> exceptionClass;
    private final Function<T, Long> function;

    public ExceptionWaitStrategy(@Nonnull Class<T> exceptionClass, 
                                     @Nonnull Function<T, Long> function) {
         this.exceptionClass = exceptionClass;
         this.function = function;
    }

    @SuppressWarnings({"ThrowableResultOfMethodCallIgnored", 
                       "ConstantConditions", "unchecked"})
    @Override
    public long computeSleepTime(Attempt lastAttempt) {
          if (lastAttempt.hasException()) {
              Throwable cause = lastAttempt.getExceptionCause();
              if (exceptionClass.isAssignableFrom(cause.getClass())) {
                  return function.apply((T) cause);
              }
          }
          return 0L;
    }
}
```

##### 5 CompositeWaitStrategy

这个没啥好说的，顾名思义，就是一个策略的组合，你可以传入多个WaitStrategy，然后所有WaitStrategy返回的间隔时长相加就是最终的间隔时间。查看其实现：

```java
private static final class CompositeWaitStrategy implements WaitStrategy {
      private final List<WaitStrategy> waitStrategies;

      public CompositeWaitStrategy(List<WaitStrategy> waitStrategies) {
            Preconditions.checkState(!waitStrategies.isEmpty(), 
                                     "Need at least one wait strategy");
            this.waitStrategies = waitStrategies;
      }

      @Override
      public long computeSleepTime(Attempt failedAttempt) {
          long waitTime = 0L;
          for (WaitStrategy waitStrategy : waitStrategies) {
              waitTime += waitStrategy.computeSleepTime(failedAttempt);
          }
          return waitTime;
      }
}
```

##### 6 FibonacciWaitStrategy

这个策略与IncrementingWaitStrategy有点相似，间隔时间都是随着重试次数的增加而递增的，不同的是，FibonacciWaitStrategy是按照斐波那契数列来进行计算的，使用这个策略时，我们需要传入一个乘数因子和最大间隔时长，其实现就不贴了

##### 7 ExponentialWaitStrategy

这个与IncrementingWaitStrategy、FibonacciWaitStrategy也类似，间隔时间都是随着重试次数的增加而递增的，但是该策略的递增是呈指数级递增。查看其实现：

```java
private static final class ExponentialWaitStrategy implements WaitStrategy {
      private final long multiplier;
      private final long maximumWait;

      public ExponentialWaitStrategy(long multiplier,
                                     long maximumWait) {
          Preconditions.checkArgument(multiplier > 0L, 
                                      "multiplier must be > 0 but is %d", multiplier);
          Preconditions.checkArgument(maximumWait >= 0L, 
                                      "maximumWait must be >= 0 but is %d", maximumWait);
          Preconditions.checkArgument(multiplier < maximumWait, 
                                      "multiplier must be < maximumWait but is %d",
                                      multiplier);
          this.multiplier = multiplier;
          this.maximumWait = maximumWait;
      }

      @Override
      public long computeSleepTime(Attempt failedAttempt) {
          double exp = Math.pow(2, failedAttempt.getAttemptNumber());
          long result = Math.round(multiplier * exp);
          if (result > maximumWait) {
              result = maximumWait;
          }
          return result >= 0L ? result : 0L;
      }
}
```

### 6. 重试监听器RetryListener

当发生重试时，将会调用RetryListener的onRetry方法，此时我们可以进行比如记录日志等额外操作。

```java
public int realAction(int num) {
    if (num <= 0) {
        throw new IllegalArgumentException();
    }
    return num;
}

@Test
public void guavaRetryTest001() throws ExecutionException, RetryException {
    Retryer<Integer> retryer = RetryerBuilder.<Integer>newBuilder().retryIfException()
        .withRetryListener(new MyRetryListener())
        // 设置最大执行次数3次
        .withStopStrategy(StopStrategies.stopAfterAttempt(3)).build();
     retryer.call(() -> realAction(0));
}

private static class MyRetryListener implements RetryListener {

    @Override
    public <V> void onRetry(Attempt<V> attempt) {
        System.out.println("第" + attempt.getAttemptNumber() + "次执行");
    }
}
```

输出：

```
第1次执行
第2次执行
第3次执行
```

### 7. 重试原理

其实到这一步之后，实现原理大概就很清楚了，就是由上述各种策略配合从而达到了非常灵活的重试机制。在这之前我们看一个上面没说的东东-Attempt

```java
public interface Attempt<V> {
    public V get() throws ExecutionException;

    public boolean hasResult();
    
    public boolean hasException();

    public V getResult() throws IllegalStateException;

    public Throwable getExceptionCause() throws IllegalStateException;

    public long getAttemptNumber();

    public long getDelaySinceFirstAttempt();
}
```

通过接口方法可以知道Attempt这个类包含了任务执行次数、任务执行异常、任务执行结果、以及首次执行任务至今的时间间隔，那么我们后续的不管重试时机、还是其他策略都是根据此值来决定。

接下来看关键执行入口Retryer##call：

```java
public V call(Callable<V> callable) throws ExecutionException, RetryException {
    long startTime = System.nanoTime();

    // 执行次数从1开始
    for (int attemptNumber = 1; ; attemptNumber++) {
        Attempt<V> attempt;
        try {
            // 尝试执行
            V result = attemptTimeLimiter.call(callable);

            // 执行成功则将结果封装为ResultAttempt
            attempt = new Retryer.ResultAttempt<V>(result, attemptNumber, 
                                                     TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));
        } catch (Throwable t) {
            // 执行异常则将结果封装为ExceptionAttempt
            attempt = new Retryer.ExceptionAttempt<V>(t, attemptNumber, 
                                                 TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));
        }

        // 这里将执行结果传给RetryListener做一些额外事情
        for (RetryListener listener : listeners) {
            listener.onRetry(attempt);
        }

        // 这个就是决定是否要进行重试的地方，如果不进行重试直接返回结果，
        // 执行成功就返回结果，执行失败就返回异常
        if (!rejectionPredicate.apply(attempt)) {
            return attempt.get();
        }

        // 到这里，说明需要进行重试，则此时先决定是否到达了停止重试的时机，如果到达了则直接返回异常
        if (stopStrategy.shouldStop(attempt)) {
            throw new RetryException(attemptNumber, attempt);
        } else {
            // 决定重试时间间隔
            long sleepTime = waitStrategy.computeSleepTime(attempt);
            try {
                // 进行阻塞
                blockStrategy.block(sleepTime);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RetryException(attemptNumber, attempt);
            }
        }
    }
}
```



# AOP日志记录

## 应用场景

需要灵活使用共性需求的地方都可以使用该方案

> - 收集上报指定关键方法的入参、执行时间、返回结果等关键信息，用在后期调优
> - 关键方法在幂等性前置校验(基于本地消息表)
> - 类似Spring-Retry模块，提供关键方法多次调用重试机制
> - 提供关键方法自定义快速熔断，服务降级等职责
> - 关键方法的共性入参校验
> - 关键方法在执行后的扩展行为，例如记录日志、启动其他任务等
> - ......

## 实现案例

### pom

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--lombok-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    <!--aop切面-->
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
    </dependency>
</dependencies>
```

### 接口

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
//作用在方法上
@Target(ElementType.METHOD)
//@Retention作用是被它定义的注解要保留多久，RunTime运行时
@Retention(RetentionPolicy.RUNTIME)
//接口+@，表示说明注解
public @interface MethodExporter {
}
```

### 切面类

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import java.util.Date;

//关键代码1：说明当前对象是一个切面
@Aspect
//关键代码2：允许Spring IOC对当前对象实例化并管理
@Component
@Slf4j
public class MethodExporterAspect {
    //关键代码3：说明切面的作用范围，任何增加@MethodExporter的目标方法都将在执行方法前执行该切面方法
    //@Around环绕通知，最强大的通知类型，可以控制方法的入参、执行、返回结果等各方面细节
    //这里写的是接口路径
    @Around("@annotation(com.it.annoation.MethodExporter)")
    public Object methodExporter(ProceedingJoinPoint joinPoint) throws Throwable {
        //计算方法执行时间
        long st = new Date().getTime();
        //执行目标方法，获取方法返回值
        Object proceed = joinPoint.proceed();
        long et = new Date().getTime();
        //这里用于封装结果json
        ObjectMapper mapper = new ObjectMapper();
        //获取执行方法的参数getArgs
        String jsonParam = mapper.writeValueAsString(joinPoint.getArgs());
        //将返回结果json序列化
        String jsonResult = null;
        if (proceed != null) {
            jsonResult = mapper.writeValueAsString(proceed);
        }else {
            jsonResult = "null";
        }
        //模拟上报服务器过程
        log.info("正在上报服务器调用过程：\ntarget:{}.{}\nexecution:{}ms,\nparameter:{}\nresult:{}"
                ,joinPoint.getTarget().getClass().getSimpleName()
                ,joinPoint.getSignature().getName()
                ,(et-st)
                ,jsonParam
                ,jsonResult);
        return proceed;
    }
}
```

### 使用

```java
import com.it.annoation.MethodExporter;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Random;

@RestController
public class SampleController {

    //在这里直接把注解写在方法上即可
    @MethodExporter
    @GetMapping("list")
    public Map<String, String> list(int page, int rows) {
        Map<String, String> result = new LinkedHashMap<>();
        result.put("code","0");
        result.put("message","success");
        //休眠测试用
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return result;
    }
}
```

### 测试

```
:8080/list?page=1&rows=100
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220411101517891.png" alt="image-20220411101517891" style="zoom:67%;" />

# 缓存

## 缓存简介

### 缓存功能

企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220226154148303.png" alt="image-20220226154148303" style="zoom:67%;" />

> 应用程序直接与数据库打交道，访问效率低。为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种**临时的数据存储机制**，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220226154233010.png" alt="image-20220226154233010" style="zoom:67%;" />

使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高

> - 缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质
> - 使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能
> - 此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。

### 缓冲使用步骤

- 启用缓存
- 设置进入缓存的数据
- 设置读取缓存的数据

Spring定义了`CacheManager`和`Cache`接口统一不同的缓存技术。其中`CacheManager`是Spring提供的各种缓存技术的抽象接口，而`Cache`接口包含缓存的读、写、删等各种操作。

针对不同的缓存技术，需要实现不同的`CacheManager`，Spring预先定义了主流缓存框架的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061758140.png" alt="image-20220706175843038" style="zoom:67%;" />

> Spring Boot 为我们预留接口扩展，方便我们自动配置 EhCache、Redis、Guava、ConcurrentMap等缓存，默认使用ConcurrentMapCacheManager。Spring Boot的`application.yaml`配置文件，使用`spring.cache`前缀属性进行配置。

## 基于HashMap缓存

> 基于HashMap的缓存使用弊端很多，比如无法释放缓存，缓存内容过多，这里只是演示

```java
private HashMap<Integer,User> cache = new HashMap<>();

@GetMapping("getById/{id}")
public R getById(@PathVariable("id") Integer id) {
    // 如果当前缓存中没有本次要查询的数据，则进行查询，否则直接从缓存中获取数据返回
    User Cacheuser = cache.get(id);
    if (Cacheuser == null) {
        User user = userService.getById(id);
        cache.put(id,user);
        return R.ok().data("records",user);
    }
    return R.ok().data("records",Cacheuser);
}
```

> 多次访问，只打印一次查询，使用到了缓存

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291054759.png" alt="image-20230129105424668" style="zoom:80%;" />

## 基于SpringCache缓存

springboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。

**步骤①**：导入springboot提供的缓存技术对应的starter

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

**步骤②**：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存

```java
@SpringBootApplication
//开启缓存功能
@EnableCaching
public class Springboot19CacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot19CacheApplication.class, args);
    }
}
```

**步骤③**：设置操作的数据是否使用缓存

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;
	// cacheSpace就是缓存空间名，#id就是获取到的id
    @Cacheable(value="cacheSpace",key="#id")
    public Book getById(Integer id) {
        return bookDao.selectById(id);
    }
}
```

> 在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。
>

> 使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。
>

## 更改为Ehcache缓存

Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式

**步骤①**：导入Ehcache的坐标

```xml
<dependency>
    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache</artifactId>
</dependency>
```

此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。

**步骤②**：配置缓存技术实现使用Ehcache

```yaml
spring:
  cache:
    type: ehcache
    ehcache:
      config: ehcache.xml
```

配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。

由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"
         updateCheck="false">
    <diskStore path="D:\ehcache" />

    <!--默认缓存策略 -->
    <!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false-->
    <!-- diskPersistent：是否启用磁盘持久化-->
    <!-- maxElementsInMemory：最大缓存数量-->
    <!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘-->
    <!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，
        可用于记录时效性数据，例如验证码-->
    <!-- timeToLiveSeconds：最大存活时间-->
    <!-- memoryStoreEvictionPolicy：缓存清除策略-->
    <defaultCache
        eternal="false"
        diskPersistent="false"
        maxElementsInMemory="1000"
        overflowToDisk="false"
        timeToIdleSeconds="60"
        timeToLiveSeconds="60"
        memoryStoreEvictionPolicy="LRU" />
   <!--上面配置的是默认缓存，这边配置的是自定义配置(可选)注意name，是用来区分不同的缓存位置 -->
    <cache
        name="smsCode"
        eternal="false"
        diskPersistent="false"
        maxElementsInMemory="1000"
        overflowToDisk="false"
        timeToIdleSeconds="10"
        timeToLiveSeconds="10"
        memoryStoreEvictionPolicy="LRU" />
</ehcache>
```



**开启缓存：**

入口启动类添加注解 `@EnableCaching`

注意前面的案例中，设置了数据保存的位置是smsCode

```java
@Component
@CacheConfig(cacheNames = "userCache")
public class UserService {

    @Cacheable(key = "#id")
    public User getUserById(Long id) {
        System.out.println("缓存中无值");
        User user = User.builder().id(id).userName("雪糕(" + id + ")").age(18)
                                  .address("杭州").build();
        return user;
    }

    @CachePut(key = "#user.id")
    public User updateUser(User user) {
        user.setUserName("雪糕（new name）");
        return user;
    }

    @CacheEvict(key = "#id")
    public void deleteById(Long id) {
        System.out.println("db 删除数据，id=" + id);
    }
}
```

- @CacheConfig  作用于类上，用来描述该类中所有方法使用的缓存名称。当然也可以不使用该注解，直接在具体方法上的缓存注解里配置名称
- @Cacheable 用于查询方法上，表示将一个方法的返回值缓存起来。默认情况下，缓存的 key 就是方法的参数，缓存的 value 就是方法的返回值
- @CachePut  更新操作，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的 key 上
- @CacheEvict  删除操作，当数据库中的数据删除后，相关的缓存数据也要自动清除。

除了采用 `@Cacheable` 、`@CachePut` 等方法注解解耦式操作缓存外，我们也可以使用 `CacheManager`显示方式手动来操作缓存。

这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。

到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。

## 更改为Redis缓存

详见Redis笔记

上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。

比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。

**步骤①**：导入redis的坐标

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

**步骤②**：配置缓存技术实现使用redis

```yaml
spring:
  redis:
    host: localhost
    port: 6379
  cache:
    type: redis
```

> 如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。
>

```yaml
spring:
  redis:
    host: localhost
    port: 6379
  cache:
    type: redis
    redis:
      use-key-prefix: false
      key-prefix: sms_
      cache-null-values: false
      time-to-live: 10s
```

## jetcache缓存整合⭐

> jetCache对SpringCache进行了封装，在原有功能基础上实现了多级缓存、缓存统计、自动刷新、异步调用、数据报表等功能。jetCache设定了本地缓存与远程缓存的多级缓存解决方案
>

> 本地缓存（Local）：LinkedHashMap、Caffeine
>
> 远程缓存（Remote）：Redis、Tair

> 为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以LinkedHashMap+Redis的方案实现本地与远程缓存方案同时使用。
>

### 纯远程方案

**步骤①**：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis

```xml
<dependency>
    <groupId>com.alicp.jetcache</groupId>
    <artifactId>jetcache-starter-redis</artifactId>
    <version>2.6.2</version>
</dependency>
```

**步骤②**：远程方案基本配置

```yaml
jetcache:
  remote:
    default:
      type: redis
      host: localhost
      port: 6379
      poolConfig:
        maxTotal: 50
```

其中poolConfig是必配项，否则会报错

**步骤③**：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation

```java
@SpringBootApplication
//jetcache启用缓存的主开关
@EnableCreateCacheAnnotation
public class Springboot20JetCacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot20JetCacheApplication.class, args);
    }
}
```

**步骤④**：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。

```java
@Service
public class SMSCodeServiceImpl implements SMSCodeService {
    @Autowired
    private CodeUtils codeUtils;
    
    @CreateCache(name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)
    private Cache<String ,String> jetCache;

    public String sendCodeToSMS(String tele) {
        String code = codeUtils.generator(tele);
        jetCache.put(tele,code);
        return code;
    }

    public boolean checkCode(SMSCode smsCode) {
        String code = jetCache.get(smsCode.getTele());
        return smsCode.getCode().equals(code);
    }
}
```

通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。

上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：

```yaml
jetcache:
  remote:
    default:
      type: redis
      host: localhost
      port: 6379
      poolConfig:
        maxTotal: 50
    sms:
      type: redis
      host: localhost
      port: 6379
      poolConfig:
        maxTotal: 50
```

如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可

```JAVA
@Service
public class SMSCodeServiceImpl implements SMSCodeService {
    @Autowired
    private CodeUtils codeUtils;
    
    @CreateCache(area="sms",name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)
    private Cache<String ,String> jetCache;

    public String sendCodeToSMS(String tele) {
        String code = codeUtils.generator(tele);
        jetCache.put(tele,code);
        return code;
    }

    public boolean checkCode(SMSCode smsCode) {
        String code = jetCache.get(smsCode.getTele());
        return smsCode.getCode().equals(code);
    }
}
```

### 纯本地方案

远程方案中，**配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已**。

**步骤①**：导入springboot整合jetcache对应的坐标starter

```xml
<dependency>
    <groupId>com.alicp.jetcache</groupId>
    <artifactId>jetcache-starter-redis</artifactId>
    <version>2.6.2</version>
</dependency>
```

**步骤②**：本地缓存基本配置

缓存注解已经默认导入了fastjson，不用手动添加fastjson

```yaml
jetcache:
  local:
    default:
      type: linkedhashmap
      keyConvertor: fastjson
```

为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。

**步骤③**：启用缓存

```java
@SpringBootApplication
//jetcache启用缓存的主开关
@EnableCreateCacheAnnotation
public class Springboot20JetCacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot20JetCacheApplication.class, args);
    }
}
```

**步骤④**：创建缓存对象Cache时，标注当前使用本地缓存

```java
@Service
public class SMSCodeServiceImpl implements SMSCodeService {
    @CreateCache(name="jetCache_",
                 expire = 1000,
                 timeUnit = TimeUnit.SECONDS,
                 cacheType = CacheType.LOCAL)
    private Cache<String ,String> jetCache;

    public String sendCodeToSMS(String tele) {
        String code = codeUtils.generator(tele);
        jetCache.put(tele,code);
        return code;
    }

    public boolean checkCode(SMSCode smsCode) {
        String code = jetCache.get(smsCode.getTele());
        return smsCode.getCode().equals(code);
    }
}
```

cacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType=CacheType.LOCAL即使用本地缓存。

### 		本地+远程方案

本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。

```YAML
jetcache:
  local:
    default:
      type: linkedhashmap
      keyConvertor: fastjson
  remote:
    default:
      type: redis
      host: localhost
      port: 6379
      poolConfig:
        maxTotal: 50
    sms:
      type: redis
      host: localhost
      port: 6379
      poolConfig:
        maxTotal: 50
```

在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。

```java
@Service
public class SMSCodeServiceImpl implements SMSCodeService {
    @CreateCache(name="jetCache_"
                 ,expire = 1000
                 ,timeUnit = TimeUnit.SECONDS
                 ,cacheType = CacheType.BOTH)
    private Cache<String ,String> jetCache;
}
```

cacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息

![image-20230129112303321](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291123437.png)

以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。

**方法缓存**

jetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可

**步骤①**：导入springboot整合jetcache对应的坐标starter

```xml
<dependency>
    <groupId>com.alicp.jetcache</groupId>
    <artifactId>jetcache-starter-redis</artifactId>
    <version>2.6.2</version>
</dependency>
```

**步骤②**：配置缓存

```yaml
jetcache:
  local:
    default:
      type: linkedhashmap
      keyConvertor: fastjson
  remote:
    default:
      type: redis
      host: localhost
      port: 6379
      keyConvertor: fastjson
      valueEncode: java
      valueDecode: java
      poolConfig:
        maxTotal: 50
    sms:
      type: redis
      host: localhost
      port: 6379
      poolConfig:
        maxTotal: 50
```

由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。

注意，为了实现Object类型的值进出redis，**需要保障进出redis的Object类型的数据必须实现序列化接口**。

```JAVA
@Data
public class Book implements Serializable {
    private Integer id;
    private String type;
    private String name;
    private String description;
}
```

**步骤③**：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存

```java
@SpringBootApplication
//jetcache启用缓存的主开关
@EnableCreateCacheAnnotation
//开启方法注解缓存
@EnableMethodCache(basePackages = "com.itheima")
public class Springboot20JetCacheApplication {
    public static void main(String[] args) {
        SpringApplication.run(Springboot20JetCacheApplication.class, args);
    }
}
```

**步骤④**：使用注解@Cached标注当前方法使用缓存

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;
    
    @Override
    @Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)
    public Book getById(Integer id) {
        return bookDao.selectById(id);
    }
}
```

### 远程方案的数据同步

由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据

**更新缓存**

```JAVA
@CacheUpdate(name="book_",key="#book.id",value="#book")
public boolean update(Book book) {
    return bookDao.updateById(book) > 0;
}
```

**删除缓存**

```JAVA
@CacheInvalidate(name="book_",key = "#id")
public boolean delete(Integer id) {
    return bookDao.deleteById(id) > 0;
}
```

**定时刷新缓存**

```JAVA
@Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)
@CacheRefresh(refresh = 5)
public Book getById(Integer id) {
    return bookDao.selectById(id);
}
```

### 数据报表

jetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可

```yaml
jetcache:
  statIntervalMinutes: 1
```

设置后，每1分钟在控制台输出缓存数据命中信息

```CMD
[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003
cache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime
---------+-------+-------+------+-------+-------+---------+--------------+--------------
book_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188
---------+-------+-------+------+-------+-------+---------+--------------+--------------
```

**总结**

> 1. jetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案
> 2. jetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种
> 3. 注意数据进入远程缓存时的类型转换问题
> 4. jetcache提供方法缓存，并提供了对应的缓存更新与刷新功能
> 5. jetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况

# MongoDB

> MongoDB是一个开源、高性能、无模式的文档型数据库。NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库 

## 应用场景

![image-20230128161506611](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281615921.png)

## 基础命令

### 连接

```c
mongo --host=127.0.0.1 --port=27017
```

### 增删改

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281620556.png" alt="image-20230128162005446" style="zoom:67%;" />

```sql
db.book.insert({
    "id": 1,
	"name": "SpringBoot基础",
	"type": "Spring"
})
```

```sql
db.book.remove({id:2})
db.book.update({id:1},{"name": "SpringBoot2进阶","type": "Spring3"})
```

### 基础查询⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281622717.png" alt="image-20230128162229611" style="zoom:50%;" />

### 条件查询⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281623417.png" alt="image-20230128162301315" style="zoom: 67%;" />

## 整合Mongo

### 依赖配置

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-mongodb</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```

### 配置文件

```yml
spring:
  data:
    mongodb:
      host: 127.0.0.1
      port: 27017
      database: t1
```

### 实体类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Integer id;
    private String name;
    private String password;
    private String phone;
}
```

### 测试

```java
@SpringBootTest
class Demo1ApplicationTests {

    @Autowired
    MongoTemplate mongoTemplate;

    @Test
    void testSave() {
        User user = new User(1,"任","312","123");
        mongoTemplate.save(user);
    }
    
    @Test
    void testFindAll(){
        List<User> all = mongoTemplate.findAll(User.class);
        System.out.println(all);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281711753.png" alt="image-20230128171139661" style="zoom: 67%;" />

# 定时任务

大家都用过闹钟，闹钟可以说是一种定时任务。 比如我们设定了周一到周五早上7点半的时间响铃，那么闹钟就会在周一到周五的早上7点半进行响铃，这种就是定时的任务。时间定在 周一到周五的早上7点半 ，任务就是 响铃。

那么，在 Java 中，如何实现这样的功能呢？即如何实现定时任务呢？

## Timer & TimerTask

### 基础语法

> 在 java.util 包下，有这么 3 个东西，分别是 Timer 类、TimerTask 接口、TimerThread 类，这 3 个东西就可以帮我们实现定时任务。Timer 有这么 2 个方法（当然不止这两个，还有 4 个相关的）

```java
// 延迟delay秒后执行task任务
public void schedule(TimerTask task, long delay);
// 延迟delay秒后，以period间隔时间执行task任务
public void schedule(TimerTask task, long delay, long period);
```

> TimerTask 有个 run() 抽象方法，那我们可以实现这个抽象方法作为我们的任务逻辑，由于 TimerTask 是接口，需要一个类实现它，那我们下面就用匿名内部类的方式来实现这个接口。

### 延迟1s执行

```java
public static void timer1() {
    // 单线程
    Timer timer = new Timer();
    log.info("1秒后执行任务A，A当前时间 {}", LocalDateTime.now());
    // 1秒后执行
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            log.info("任务A 当前时间 {}", LocalDateTime.now());
        }
    }, 1000); // 这里 1000，就是代表延迟 1000 毫秒后再执行
}
```

### 间隔2s执行

```java
public static void timer2() {
    Timer timer = new Timer();
    // 每隔2秒执行一次这个任务
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            log.info("任务B 当前时间 {}", LocalDateTime.now());
        }
        // 延迟0秒，隔 2000 毫秒后再一次执行，达到定时任务的效果
    }, 0, 2000);
}
```

所以，任务 B 会每隔 2 秒执行一次。到这里，我们通过 Timer 实现了定时任务。



## Cron规则

### Cron 生成工具

> Cron表达式的详细用法 Cron 生成工具：cron.qqe2.com/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291011276.png" alt="image-20230129101139165" style="zoom:50%;" />

### 制定策略

**cron** 表达式是一个字符串，该字符串由 `6` 个空格分为 `7` 个域，每一个域代表一个时间含义。 格式如下

```apl
[秒] [分] [时] [日] [月] [周] [年]
```

> 注意：通常定义 “年” 的部分可以省略，实际常用的由 前六部分组成。cron表达式中各时间元素使用**空格**进行分割，表达式有至少6个（也可能7个）
>

### 通配符含义

| **字段**   | 允许                           | **允许的特殊字符** |
| ---------- | ------------------------------ | ------------------ |
| 秒         | 0-59                           | , - * /            |
| 分         | 0-59                           | , - * /            |
| 时         | 0-23                           | , - * /            |
| 日         | 0~31(但是你需要考虑你月的天数) | , - * ? / L W C    |
| 月         | 1-12 或者 JAN-DEC              | , - * /            |
| 周         | 1-7 或者 SUN-SAT               | , - * ? / L C #    |
| 年（可选） | 留空, 1970-2099                |                    |

- ,  这里指的是在两个以上的时间点中都执行，如果我们在 “分” 这个域中定义为 8,12,35 ，则**表示分别  在第8分，第12分 第35分执行该定时任务**。

- -这个比较好理解就是指定在某个域的连续范围，如果我们在 “时” 这个域中定义 1-6，**则表示在1到6点之间每小时都触发一次**，用 , 表示 1,2,3,4,5,6

* *表示**所有值，可解读为 “每”**。 如果在“日”这个域中设置 *,表示每一天都会触发。
* ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的8号触发一个操作，但不关心是周几，我们可以这么设置 0 0 0 8 * ?
* / 在某个域上**周期性触发**，该符号将其所在域中的表达式分为两个部分，其中第一部分是起始值，除了秒以外都会降低一个单位，比如 在 “秒” 上定义 5/10 表示从 第 5 秒开始 每 10 秒执行一次，而在 “分” 上则表示从 第 5 秒开始 每 10 分钟执行一次。
* L 表示英文中的LAST 的意思，只能在 “日”和“周”中使用。在“日”中设置，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年), 在“周”上表示周六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在“周”上设置”7L”这样的格式,则表示“本月最后一个周六”
* W 表示离指定日期的最近那个工作日(周一至周五)触发，只能在 “日” 中使用且只能用在具体的数字之后。若在“日”上置”15W”，表示离每月15号最近的那个工作日触发。假如15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果是 “1W” 就只能往本月的下一个最近的工作日推不能跨月往上一个月推。
* \#表示每月的第几个周几，只能作用于 “周” 上。例如 ”2#3” 表示在每月的第三个周二

### CRON示例

> - 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点
> - 0/20 * * * * ?  每隔20秒执行一次
> - 0 0/30 9-17 * * ?  朝九晚五工作时间内每半小时
> - 0 0 12 ? * WED 表示每个星期三中午12点 
> - "0 0 12 * * ?" 每天中午12点触发 
> - "0 15 10 ? * *" 每天上午10:15触发 
> - "0 15 10 * * ?" 每天上午10:15触发 
> - "0 15 10 * * ? *" 每天上午10:15触发 

> - "0 15 10 * * ? 2005" 2005年的每天上午10:15触发 
> - "0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 
> - "0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 
> - "0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 
> - "0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 
> - "0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 
> - "0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 
> - "0 15 10 15 * ?" 每月15日上午10:15触发 
> - "0 15 10 L * ?" 每月最后一日的上午10:15触发 
> - "0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 
> - "0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 
> - "0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发 

## Quartz

Quartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂

### 相关概念

> - 工作（Job）：用于定义具体执行的工作
> - 工作明细（JobDetail）：用于描述定时工作相关的信息
> - 触发器（Trigger）：描述了工作明细与调度器的对应关系
> - 调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则

工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多

### 依赖引入

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```

### 定义要执行的任务

定义具体要执行的任务，继承QuartzJobBean

```java
@Component
public class MyQuartz extends QuartzJobBean {

    @Autowired
    protected UserDao userDao;

    @Override
    protected void executeInternal(JobExecutionContext context) {
        List<User> list = userDao.selectList(null);
        System.out.println(list);
        System.out.println("quartz task run...");
    }
}
```

### 定义工作明细与触发器

定义工作明细与触发器，并绑定对应关系

```java
@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail printJobDetail(){
        //绑定具体的工作
        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();
    }

    @Bean
    public Trigger printJobTrigger(){
        ScheduleBuilder<CronTrigger> schedBuilder = CronScheduleBuilder
                                                    .cronSchedule("0/5 * * * * ?");
        //绑定对应的工作明细
        return TriggerBuilder.newTrigger()
                .forJob(printJobDetail()).withSchedule(schedBuilder).build();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301282317601.png" alt="image-20230128231759473" style="zoom:67%;" />

## Spring Task

使用SpringBoot创建定时任务非常简单，目前主要有以下三种创建方式

### 基本语法

```java
// 上一次开始执行时间点后3秒再次执行
@Scheduled(fixedRate=3000)
// 上一次执行完毕时间点3秒再次执行；
@Scheduled(fixedDelay=3000)
// 第一次延迟1秒执行，然后在上一次执行完毕时间点3秒再次执行
@Scheduled(initialDelay=1000, fixedDelay=3000)
// 按**cron**规则执行
@Scheduled(cron="* * * * * ?")
```

### 基于注解实现⭐

> Spring Boot 如何解决多个定时任务阻塞问题？配置任务调度线程池，poolSize能让多个定时任务同时执行
>

```yml
spring:
  task:
    scheduling:
      pool:
        size: 10  # 任务调度线程池大小 默认 1
      thread-name-prefix: ssm_ # 调度线程名称前缀 默认 scheduling-
      shutdown:
        await-termination: false # 线程池关闭时等待所有任务完成
        await-termination-period: 10s # 调度线程关闭前最大等待时间，确保最后一定关闭
```

> 直接设置定时任务即可

```java
//用@Configuation也行
@Component
@EnableScheduling //定时任务注解
public class Sheduler {

    //每隔2秒执行一次
    @Scheduled(fixedRate = 2000)
    public void testTasks() {
        System.out.println("定时任务A执行：" + LocalTime.now());
    }

    //每隔2秒执行一次
    @Scheduled(fixedRate = 2000)
    public void testTasks1() {
        System.out.println("定时任务B执行：" + LocalTime.now());
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291030275.png" alt="image-20230129103011198" style="zoom:67%;" />

### 基于接口实现(热更新)

> 只要修改数据库字段内容即可实现改变执行时间，启动类上也要加上@EnableScheduling注解
>

#### 数据库表

```sql
CREATE TABLE `cron`  (
  `cron_id` varchar(30) NOT NULL PRIMARY KEY,
  `cron` varchar(30) NOT NULL  
);
INSERT INTO `cron` VALUES ('1', '0/15 * * * * ?');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211126111200597.png" alt="image-20211126111200597" style="zoom: 80%;" />

#### 代码配置

接下来用mybatis或者mybatisplus进行字段搜索cron即可

pom

```xml
<!--mybatis-plus，注意groupId是baomidou-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.0.5</version>
</dependency>
<!--mysql-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.30</version>
</dependency>

<!--lombok用来简化实体类-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.12</version>
</dependency>
```

application.properties

```properties
# mysql数据库连接
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/girls?serverTimezone=GMT%2B8
spring.datasource.username=root
spring.datasource.password=123456
# 数据库字段的下划线转驼峰
mybatis-plus.configuration.map-underscore-to-camel-case=true
```

entity

```java
@Data
public class cron {
    private int cronId;
    private String cron;
}
```

mapper

```java
@Mapper
@Repository
public interface CornMapper extends BaseMapper<cron> {
    //简单查找cron
    @Select("select cron from cron limit 1")
    String getCron();
}
```

创建定时器

```java
@Configuration //1.主要用于标记配置类，兼备Component的效果
@EnableScheduling
public class DynamicScheduleTask implements SchedulingConfigurer {

    @Autowired
    private CornMapper cronMapper;

    //这个方法是继承接口重写的方法
    @Override
    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {
        scheduledTaskRegistrar.addTriggerTask(
                //1.添加任务内容Runnable
                () -> System.out.println("执行动态定时任务: " + 
                                         LocalDateTime.now().toLocalTime()),
                //2.设置执行周期Trigger
                triggerContext -> {
                    //2.1 从数据库获取执行周期
                    String cron = cronMapper.getCron();
                    //2.2 合法性校验
                    if (StringUtils.isEmpty(cron)) {
                        System.out.println("校验规则为空，不合理");
                    }
                    //2.3 返回执行周期(Date)
                    return new CronTrigger(cron).nextExecutionTime(triggerContext);
                }
        );
    }
}
```

启动执行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211126122403857.png" alt="image-20211126122403857" style="zoom:67%;" />

修改数据库表的内容，可以发现：控制台的执行时间也对应改变了(不用重启项目)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211126122513994.png" alt="image-20211126122513994" style="zoom: 80%;" />



# 邮件

> 在开发中，经常会碰到Email邮件发送的场景，如注册、找回密码、发送验证码、向用户发送邮件、邮件的应用场景有很多。
>

## 邮箱协议开启

> - SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于**发送**电子邮件的传输协议
> - POP3（Post Office Protocol - Version 3）：用于**接收**电子邮件的标准协议
> - IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议

现在实现的是163邮箱发送

登入163邮箱，这个功能默认是开启的。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211011132401158.png" alt="image-20211011132401158" style="zoom: 50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211011132449269.png" alt="image-20211011132449269" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211011132520648.png" alt="image-20211011132520648" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220321111814827.png" alt="image-20220321111814827" style="zoom:67%;" />

## 基本配置

### pom

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

### application.properties

```properties
spring.mail.default-encoding=UTF-8
# 发送邮件服务器：如果是qq则是smtp.qq.com
spring.mail.host=smtp.163.com
#发送者的邮箱账号
spring.mail.username=17315118673@163.com
#发送者的授权码
spring.mail.password=HUSBWQHLTSIVPKOC
#端口
spring.mail.port=25
#协议
spring.mail.protocol=smtp
```

## 简单邮件

```java
public interface MailService {
    //发送简单普通邮件：收件人、主题、内容
    void sendSimpleMail(String to, String subject);
}
```

```java
@Service
public class MailServiceImpl implements MailService {

    //直接注入即可使用，用来最后调用send方法
    @Autowired
    JavaMailSender jsm;
    //注入发送者的邮箱
    @Value("${spring.mail.username}")
    private String username;

    //分别输入收件人，主题，和内容
    public void sendSimpleMail(String to, String subject){
        //建立邮箱消息
        SimpleMailMessage message = new SimpleMailMessage();
        //发送者
        message.setFrom(username);
        //接收者
        message.setTo(to);
        //发送标题
        message.setSubject(subject);
        //发送内容,生成6位验证码
        Random r = new Random();
        StringBuilder sum = new StringBuilder();
        for (int i = 0; i < 6; i++) {
            int j = r.nextInt(10);
            sum.append(j);
        }
        message.setText("验证码为"+sum);
        //通过JavaMailSender发送邮件
        jsm.send(message);
    }
}
```

```java
@RestController
public class MailController {

    @Autowired
    private MailService mailService;

    @GetMapping("/sendSimpleMail")
    //分别输入收件人，主题，和内容
    public String sendSimpleMail(String to,String subject){
        mailService.sendSimpleMail(to, subject);
        return "发送成功";
    }
}    
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281804983.png" alt="image-20230128180404903" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281803201.png" alt="image-20230128180339110" style="zoom:67%;" />

## HTML修饰邮件

```java
public interface MailService {
    //发送HTML邮件：发送人、主题、内容
    void sendHTMLMail(String to, String subject, String content) ;
}
```

```java
@Service
public class MailServiceImpl implements MailService {
    //直接注入即可使用，用来最后调用send方法
    @Autowired
    JavaMailSender jsm;
    
    //注入发送者的邮箱
    @Value("${spring.mail.username}")
    private String username;
 
    @Override
    public void sendHTMLMail(String to, String subject, String content){
        //建立邮箱消息
        MimeMessage message = jsm.createMimeMessage();
        try {
            MimeMessageHelper messageHelper = new MimeMessageHelper(message, true);
            //发送者
            messageHelper.setFrom(username);
            //接收者
            messageHelper.setTo(to);
            //发送标题
            messageHelper.setSubject(subject);
            //邮件内容，HTML格式
            content = "<h1>"+content+"</h1>" +
                      "<div style=\"color:red;font-size: 25px;\">"+content+"</div>";
            messageHelper.setText(content, true);
            //发送邮件
            jsm.send(message);
        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("邮件发送失败");
        }
    }
}
```

```java
@GetMapping("/sendHTMLMail")
//分别输入收件人，主题，和内容
public String sendHTMLMail(String to,String subject,String content) 
    throws MessagingException {
    mailService.sendHTMLMail(to,subject,content);
    return "发送成功";
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281846165.png" alt="image-20230128184604081" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281846622.png" alt="image-20230128184643538" style="zoom:67%;" />

## 带附件的邮件

```java
public interface MailService {
    //发送带附件的邮件
    void sendAttachmentMailMail(String to, String subject, String content,
                                MultipartFile file) ;
}
```

```java
@Service
public class MailServiceImpl implements MailService {

    //直接注入即可使用，用来最后调用send方法
    @Autowired
    JavaMailSender jsm;
    
    //注入发送者的邮箱
    @Value("${spring.mail.username}")
    private String username;

    @Override
    public void sendAttachmentMailMail(String to, String subject, String content, 
                                       MultipartFile file) {
        //建立邮箱消息
        MimeMessage message = jsm.createMimeMessage();
        try {
            //true同上，表示支持多组件：如附件，图片，HTML等
            MimeMessageHelper messageHelper = new MimeMessageHelper(message, true);
            //发送者
            messageHelper.setFrom(username);
            //接收者
            messageHelper.setTo(to);
            //发送标题
            messageHelper.setSubject(subject);
            String filename = file.getOriginalFilename();
            //添加附件，多次调用该方法可以添加多个附件
            messageHelper.addAttachment(filename,file);
            //邮件内容，HTML格式
            content = "<h1>"+content+"</h1>";
            messageHelper.setText(content, true);
            //发送邮件
            jsm.send(message);
        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("邮件发送失败");
        }
    }
}
```

```java
@RestController
public class MailController {

    @Autowired
    private MailService mailService;

    @PostMapping("/sendAttachmentMail")
    //分别输入收件人，主题，和内容
    public String sendAttachmentMail(String to, String subject, String content, 
                                     MultipartFile file){
        mailService.sendAttachmentMailMail(to,subject,content, file);
        return "发送成功";
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281843249.png" alt="image-20230128184358157" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281844382.png" alt="image-20230128184428293" style="zoom:50%;" />

## 显示图片的邮件

### 网络图片⭐

> 网络图片没那么多弯弯绕，和HTML修饰的图片发送一致

```java
public interface MailService {
    //发送带图片的邮件：发送人、主题、内容
    void sendHTMLMail(String to, String subject, String content) ;
}
```

```java
@Service
public class MailServiceImpl implements MailService {

    //直接注入即可使用，用来最后调用send方法
    @Autowired
    JavaMailSender jsm;
    //注入发送者的邮箱
    @Value("${spring.mail.username}")
    private String username;

    @Override
    public void sendHTMLMail(String to, String subject, String content){
        //建立邮箱消息
        MimeMessage message = jsm.createMimeMessage();
        try {
            MimeMessageHelper messageHelper = new MimeMessageHelper(message, true);
            //发送者
            messageHelper.setFrom(username+"(小甜甜)");
            //接收者
            messageHelper.setTo(to);
            //发送标题
            messageHelper.setSubject(subject);
            //邮件内容，HTML格式
            content = "<h1>"+content+"</h1>" +
                      "<div style=\"color:red;font-size: 25px;\">"+content+"</div>"+
                      "<img src='h19/9c91167166fbb24fa92e2c1b42994bc6.jpg'>";
            messageHelper.setText(content, true);
            //发送邮件
            jsm.send(message);
        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("邮件发送失败");
        }
    }
}
```

```java
@GetMapping("/sendHTMLMail")
//分别输入收件人，主题，和内容
public String sendHTMLMail(String to,String subject,String content)
        throws MessagingException {
    //可以先在html页面中写好语句，再复制到这里就行，要插入的内容用引引加加方式放入值即可
    mailService.sendHTMLMail(to,subject,content);
    return "发送成功";
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281829210.png" alt="image-20230128182939126" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281828769.png" alt="image-20230128182822551" style="zoom:67%;" />

### 本地图片

> 相对复杂

```java
public interface MailService {
    //发送带图片的邮件
    void sendImgMailMail(String to, String subject, String content,
                         String imgPath,String imgId) ;
}
```

```java
@Service
public class MailServiceImpl implements MailService {

    //直接注入即可使用，用来最后调用send方法
    @Autowired
    JavaMailSender jsm;
    //注入发送者的邮箱
    @Value("${spring.mail.username}")
    private String username;


    @Override
    public void sendImgMailMail(String to, String subject, String content,
                                String imgPath,String imgId) {
        //建立邮箱消息
        MimeMessage message = jsm.createMimeMessage();
        try {
            //true同上，表示支持多组件：如附件，图片，HTML等
            MimeMessageHelper messageHelper = new MimeMessageHelper(message, true);
            //发送者
            messageHelper.setFrom(username);
            //接收者
            messageHelper.setTo(to);
            //发送标题
            messageHelper.setSubject(subject);
            //邮件内容，HTML格式
            messageHelper.setText(content, true);
            //添加图片
            FileSystemResource file = new FileSystemResource(new File(imgPath));
            //重复调用可以添加多个图片
            messageHelper.addInline(imgId, file);
            //发送邮件
            jsm.send(message);
        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("邮件发送失败");
        }
    }
}
```

```java
@RestController
public class MailController {

    @Autowired
    private MailService mailService;

    @GetMapping("/sendImgMail")
    //分别输入收件人，主题，和内容
    public String sendImgMail(String to, String subject, String content){
        String imgPath = "C:\\Users\\renshuo\\OneDrive\\图片\\g2.jpg";
        String imgId = "001";
        //这里的cid是必须写的，用来标注静态资源，同时也要写html骨架
        //不然图片不会显示，则会被当作附件了
        String content1 = "<html><body><h1>"+content+"</h1><img src=\"cid:"
                          +imgId+"+\"></img>" + "</body></html>";
        mailService.sendImgMailMail(to,subject,content1, imgPath,imgId);
        return "发送成功";
    }
}
```

## 扩展技巧

> 将发送者设置成如下(内容)，这样就能改变发送人名

```java
//发送者
message.setFrom(username+"(小甜甜)");
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281809773.png" alt="image-20230128180911696" style="zoom:67%;" />



# 分布式限流

[SpringBoot 如何进行限流？老鸟们都这么玩的！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247494944&idx=2&sn=2088981fddb7807ab525c56f5060cfef&chksm=fc2c5128cb5bd83ea690a173f728eeb84a58d9f7de25adf2456384a1ea8bc3979cb258a59587&mpshare=1&scene=23&srcid=0415aZO5AQJrTcptD1AQr01g&sharer_sharetime=1650025222475&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

[5种限流算法，7种限流方式，挡住突发流量？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&mid=2247504120&idx=1&sn=d5cd83fb3124ef690c685463b7fa7a4b&chksm=c286bf39f5f1362f34d21c34b095ded0e6965e545bc210de2463ea8a6aaa3f2b2a816dc9b993&mpshare=1&scene=23&srcid=05143fdPERjGMP5RAdy9Plt9&sharer_sharetime=1652490973026&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

[我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&mid=2247484077&idx=1&sn=c873e011a3c921737c1b0bf24ddc6c68&chksm=9b859250acf21b469355d0ebfe0b58a36407260bedb0f038cee2a50bec83e3dc839a21d85871&mpshare=1&scene=23&srcid=0723j70pNdDSTPvhZWVeDoCv&sharer_sharetime=1658589109659&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> Guava 、nginx和lua限流

## 限流入门

### 为什么要进行限流

因为互联网系统通常都要面对大并发大流量的请求，在突发情况下（最常见的场景就是秒杀、抢购），瞬时大流量会直接将系统打垮，无法对外提供服务。那为了防止出现这种情况最常见的解决方案之一就是限流，当请求达到一定的并发数或速率，就进行等待、排队、降级、拒绝服务等。

例如，12306购票系统，在面对高并发的情况下，就是采用了限流。在流量高峰期间经常会出现提示语；"当前排队人数较多，请稍后再试！"

**显然只有少人数能用远比所有人都不能用更符合我们的预期，因此这个时候我们要使用「限流」了**。

### 限流分类

限流的实现方案有很多种，磊哥这里稍微理了一下，**限流的分类**如下所示：

1. **合法性验证限流**：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；
2. **容器限流**：比如 Tomcat、Nginx 等限流手段，其中 Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数；
3. **服务端限流**：比如我们在服务器端通过限流算法实现限流，此项也是我们本文介绍的重点。

合法性验证限流为最常规的业务代码，就是普通的验证码和 IP 黑名单系统，本文就不做过多的叙述了，我们重点来看下后两种限流的实现方案：容器限流和服务端限流。

## 分布式限流重要概念

时间 限流基于某段时间范围或者某个时间点，也就是我们常说的“时间窗口”，比如对每分钟、每秒钟的时间窗口做限定 资源 基于可用资源的限制，比如设定最大访问次数，或最高可用连接数

上面两个维度结合起来看，限流就是在某个时间窗口对资源访问做限制，比如设定每秒最多100个访问请求。但在真正的场景里，我们不止设置一种限流规则，而是会设置多个限流规则共同作用，主要的几种限流规则如下：

### 1）QPS和连接数控制

针对上图中的连接数和QPS(query per second)限流来说，我们可以设定IP维度的限流，也可以设置基于单个服务器的限流。在真实环境中通常会设置多个维度的限流规则，比如设定同一个IP每秒访问频率小于10，连接数小于5，再设定每台机器QPS最高1000，连接数最大保持200。

更进一步，我们可以把某个服务器组或整个机房的服务器当做一个整体，设置更high-level的限流规则，这些所有限流规则都会共同作用于流量控制。

- **阈值**：在一个单位时间内允许的请求量。`如 QPS 限制为10，说明 1 秒内最多接受 10 次请求`。
- **拒绝策略**：超过阈值的请求的拒绝策略，`常见的拒绝策略有直接拒绝、排队等待等`。

### 2）传输速率

对于“传输速率”大家都不会陌生，比如资源的下载速度。有的网站在这方面的限流逻辑做的更细致，比如普通注册用户下载速度为100k/s，购买会员后是10M/s，这背后就是基于用户组或者用户标签的限流逻辑。

### 3）黑白名单

黑白名单是各个大型企业应用里很常见的限流和放行手段，而且黑白名单往往是动态变化的。举个例子，如果某个IP在一段时间的访问次数过于频繁，被系统识别为机器人用户或流量攻击，那么这个IP就会被加入到黑名单，从而限制其对系统资源的访问，这就是我们俗称的“封IP”。

我们平时见到的爬虫程序，比如说爬知乎上的美女图片，或者爬券商系统的股票分时信息，这类爬虫程序都必须实现更换IP的功能，以防被加入黑名单。有时我们还会发现公司的网络无法访问12306这类大型公共网站，这也是因为某些公司的出网IP是同一个地址，因此在访问量过高的情况下，这个IP地址就被对方系统识别，进而被添加到了黑名单。使用家庭宽带的同学们应该知道，大部分网络运营商都会将用户分配到不同出网IP段，或者时不时动态更换用户的IP地址。

白名单就更好理解了，相当于御赐金牌在身，可以自由穿梭在各种限流规则里，畅行无阻。比如某些电商公司会将超大卖家的账号加入白名单，因为这类卖家往往有自己的一套运维系统，需要对接公司的IT系统做大量的商品发布、补货等等操作。

### 4）分布式环境

所谓的分布式限流，其实道理很简单，一句话就可以解释清楚。分布式区别于单机限流的场景，它把整个分布式环境中所有服务器当做一个整体来考量。比如说针对IP的限流，我们限制了1个IP每秒最多10个访问，不管来自这个IP的请求落在了哪台机器上，只要是访问了集群中的服务节点，那么都会受到限流规则的制约。

从上面的例子不难看出，我们必须将限流信息保存在一个“中心化”的组件上，这样它就可以获取到集群中所有机器的访问状态，目前有两个比较主流的限流方案：

网关层限流

- 将限流规则应用在所有流量的入口处

中间件限流

- 将限流信息存储在分布式环境中某个中间件里（比如Redis缓存），每个组件都可以从这里获取到当前时刻的流量统计，从而决定是拒绝服务还是放行流量

## 限流方案常用算法讲解

### 1. 计数器限流

计数器限流算法是最为简单粗暴的解决方案，主要用来限制总并发数，比如数据库连接池大小、线程池大小、接口访问并发数等都是使用计数器算法。

如：使用 AomicInteger 来进行统计当前正在并发执行的次数，如果超过域值就直接拒绝请求，提示系统繁忙。

### 2. 令牌桶算法

令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。

系统会维护一个令牌（`token`）桶，以一个恒定的速度往桶里放入令牌（`token`），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（`token`），当桶里没有令牌（`token`）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。

Token Bucket令牌桶算法是目前应用最为广泛的限流算法，顾名思义，它有以下两个关键角色：

- 令牌 获取到令牌的Request才会被处理，其他Requests要么排队要么被直接丢弃
- 桶 用来装令牌的地方，所有Request都从这个桶里面获取令牌

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205141020451.png" alt="image-20220514102032384" style="zoom:80%;" />

#### 令牌生成

这个流程涉及到令牌生成器和令牌桶，前面我们提到过令牌桶是一个装令牌的地方，既然是个桶那么必然有一个容量，也就是说令牌桶所能容纳的令牌数量是一个固定的数值。

对于令牌生成器来说，它会根据一个预定的速率向桶中添加令牌，比如我们可以配置让它以每秒100个请求的速率发放令牌，或者每分钟50个。注意这里的发放速度是匀速，也就是说这50个令牌并非是在每个时间窗口刚开始的时候一次性发放，而是会在这个时间窗口内匀速发放。

在令牌发放器就是一个水龙头，假如在下面接水的桶子满了，那么自然这个水（令牌）就流到了外面。在令牌发放过程中也一样，令牌桶的容量是有限的，如果当前已经放满了额定容量的令牌，那么新来的令牌就会被丢弃掉。

#### 令牌获取

每个访问请求到来后，必须获取到一个令牌才能执行后面的逻辑。假如令牌的数量少，而访问请求较多的情况下，一部分请求自然无法获取到令牌，那么这个时候我们可以设置一个“缓冲队列”来暂存这些多余的令牌。

缓冲队列其实是一个可选的选项，并不是所有应用了令牌桶算法的程序都会实现队列。当有缓存队列存在的情况下，那些暂时没有获取到令牌的请求将被放到这个队列中排队，直到新的令牌产生后，再从队列头部拿出一个请求来匹配令牌。

当队列已满的情况下，这部分访问请求将被丢弃。在实际应用中我们还可以给这个队列加一系列的特效，比如设置队列中请求的存活时间，或者将队列改造为PriorityQueue，根据某种优先级排序，而不是先进先出。算法是死的，人是活的，先进的生产力来自于不断的创造，在技术领域尤其如此。

### 3. 漏桶算法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207281648389.png" alt="image-20220728164818297" style="zoom: 50%;" />

漏桶算法的前半段和令牌桶类似，但是操作的对象不同，令牌桶是将令牌放入桶里，而漏桶是将访问请求的数据包放到桶里。同样的是，如果桶满了，那么后面新来的数据包将被丢弃。

漏桶算法的后半程是有鲜明特色的，它永远只会以一个恒定的速率将数据包从桶内流出。打个比方，如果我设置了漏桶可以存放100个数据包，然后流出速度是1s一个，那么不管数据包以什么速率流入桶里，也不管桶里有多少数据包，漏桶能保证这些数据包永远以1s一个的恒定速度被处理。



### 4. 漏桶 vs 令牌桶的区别

根据它们各自的特点不难看出来，这两种算法都有一个“恒定”的速率和“不定”的速率。令牌桶是以恒定速率创建令牌，但是访问请求获取令牌的速率“不定”，反正有多少令牌发多少，令牌没了就干等。而漏桶是以“恒定”的速率处理请求，但是这些请求流入桶的速率是“不定”的。

> 从这两个特点来说，漏桶的天然特性决定了它不会发生突发流量，就算每秒1000个请求到来，那么它对后台服务输出的访问速率永远恒定。而令牌桶则不同，其特性可以“预存”一定量的令牌，因此在应对突发流量的时候可以在短时间消耗所有令牌，其突发流量处理效率会比漏桶高，但是导向后台系统的压力也会相应增多。

## 限流实现⭐

### Guava限流

1.引入maven

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>30.1-jre</version>
</dependency>
```

2.简单示例

```java
public static void t1() throws InterruptedException {
    // qps 2
    RateLimiter rateLimiter = RateLimiter.create(2);
    for (int i = 0; i < 10; i++) {
        String time = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);
        System.out.println(time + ":" + rateLimiter.tryAcquire());
        Thread.sleep(250);
    }
}
```

代码中限制 QPS 为 2，也就是每隔 500ms 生成一个令牌，但是程序每隔 250ms 获取一次令牌，所以两次获取中只有一次会成功。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205141046452.png" alt="image-20220514104613398" style="zoom:80%;" />



2.编写Controller

```java
@RestController  
@Slf4j  
public class Controller{  
    //每秒钟可以创建两个令牌  
    RateLimiter limiter = RateLimiter.create(2.0);  
      
    //非阻塞限流  
    @GetMapping("/tryAcquire")  
    public String tryAcquire(Integer count){  
        //count 每次消耗的令牌  
        if(limiter.tryAcquire(count)){  
            log.info("成功，允许通过，速率为{}",limiter.getRate());  
            return "success";  
        }else{  
            log.info("错误，不允许通过，速率为{}",limiter.getRate());  
            return "fail";  
        }  
    }  
      
    //限定时间的非阻塞限流  
    @GetMapping("/tryAcquireWithTimeout")  
    public String tryAcquireWithTimeout(Integer count, Integer timeout){  
        //count 每次消耗的令牌  timeout 超时等待的时间  
        if(limiter.tryAcquire(count,timeout,TimeUnit.SECONDS)){  
            log.info("成功，允许通过，速率为{}",limiter.getRate());  
            return "success";  
        }else{  
            log.info("错误，不允许通过，速率为{}",limiter.getRate());  
            return "fail";  
        }  
    }  
      
    //同步阻塞限流  
    @GetMapping("/acquire")  
    public String acquire(Integer count){  
        limiter.acquire(count);  
        log.info("成功，允许通过，速率为{}",limiter.getRate());  
        return "success";  
    }  
}  
```

以上用到了RateLimiter的2个核心方法：`create()`、`tryAcquire()`，以下为详细说明

- acquire() 获取一个令牌, 改方法会阻塞直到获取到这一个令牌, 返回值为获取到这个令牌花费的时间
- acquire(int permits) 获取指定数量的令牌, 该方法也会阻塞, 返回值为获取到这 N 个令牌花费的时间
- tryAcquire() 判断时候能获取到令牌, 如果不能获取立即返回 false
- tryAcquire(int permits) 获取指定数量的令牌, 如果不能获取立即返回 false
- tryAcquire(long timeout, TimeUnit unit) 判断能否在指定时间内获取到令牌, 如果不能获取立即返回 false
- tryAcquire(int permits, long timeout, TimeUnit unit) 同上

从以上日志可以看出，1秒钟内只有2次成功，其他都失败降级了，说明我们已经成功给接口加上了限流功能。

当然了，我们在实际开发中并不能直接这样用。至于原因嘛，你想呀，你每个接口都需要手动给其加上tryAcquire()，业务代码和限流代码混在一起，而且明显违背了DRY原则，代码冗余，重复劳动。代码评审时肯定会被老鸟们给嘲笑一番，啥破玩意儿！



### Tomcat限流

Tomcat 8.5 版本的最大线程数在 conf/server.xml 配置中，如下所示：

```c
<Connector port="8080" protocol="HTTP/1.1"
          connectionTimeout="20000"
          maxThreads="150"
          redirectPort="8443" />
```

其中 `maxThreads` 就是 Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。

> 小贴士：maxThreads 的值可以适当的调大一些，此值默认为 150（Tomcat 版本 8.5.42），但这个值也不是越大越好，要看具体的硬件配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。

### 基于Nginx的限流

#### 1. IP限流

1.编写Controller

```java
@RestController  
@Slf4j  
public class Controller{  
    //nginx测试使用  
    @GetMapping("/nginx")  
    public String nginx(){  
        log.info("Nginx success");  
    }  
}  
```

2.修改host文件，添加一个网址域名

```java
127.0.0.1   www.test.com  
```

3.修改nginx，将步骤2中的域名，添加到路由规则当中

打开nginx的配置文件

```java
vim /usr/local/nginx/conf/nginx.conf  
```

添加一个服务

```apl
#根据IP地址限制速度  
#1）$binary_remote_addr   binary_目的是缩写内存占用，remote_addr表示通过IP地址来限流  
#2）zone=iplimit:20m   iplimit是一块内存区域（记录访问频率信息），20m是指这块内存区域的大小  
#3）rate=1r/s  每秒放行1个请求  
limit_req_zone $binary_remote_addr zone=iplimit:20m rate=1r/s;  
  
server{  
    server_name www.test.com;  
    location /access-limit/ {  
        proxy_pass http://127.0.0.1:8080/;  
          
        #基于ip地址的限制  
        #1）zone=iplimit 引用limit_rep_zone中的zone变量  
        #2）burst=2  设置一个大小为2的缓冲区域，
        #   当大量请求到来，请求数量超过限流频率时，将其放入缓冲区域  
        #3）nodelay   缓冲区满了以后，直接返回503异常  
        limit_req zone=iplimit burst=2 nodelay;  
    }  
}  
```

4.访问地址，测试是否限流

> www.test.com/access-limit/nginx



#### 2. 多维度限流(完整方案)

1.修改nginx配置

```apl
#根据IP地址限制速度  
limit_req_zone $binary_remote_addr zone=iplimit:20m rate=10r/s;  
#根据服务器级别做限流  
limit_req_zone $server_name zone=serverlimit:10m rate=1r/s;  
#根据ip地址的链接数量做限流  
limit_conn_zone $binary_remote_addr zone=perip:20m;  
#根据服务器的连接数做限流  
limit_conn_zone $server_name zone=perserver:20m;  
  
server{  
    server_name www.test.com;  
    location /access-limit/ {  
        proxy_pass http://127.0.0.1:8080/;   
        #基于ip地址的限制  
        limit_req zone=iplimit burst=2 nodelay;  
        #基于服务器级别做限流  
        limit_req zone=serverlimit burst=2 nodelay;  
        #基于ip地址的链接数量做限流  最多保持100个链接  
        limit_conn zone=perip 100;  
        #基于服务器的连接数做限流 最多保持100个链接  
        limit_conn zone=perserver 1;  
        #配置request的异常返回504（默认为503）  
        limit_req_status 504;  
        limit_conn_status 504;  
    }  
      
     location /download/ {  
        #前100m不限制速度  
        limit_rate_affer 100m;  
        #限制速度为256k  
        limit_rate 256k;  
     }  
}  
```

#### 3. 控制速率

我们需要使用 `limit_req_zone` 用来限制单位时间内的请求数，即速率限制，示例配置如下：

```apl
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;
server { 
    location / { 
        limit_req zone=mylimit;
    }
}
```

以上配置表示，限制每个 IP 访问的速度为 2r/s，因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。

我们使用单 IP 在 10ms 内发并发送了 6 个请求的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101809612.png" alt="image-20220710180940506" style="zoom:80%;" />

从以上结果可以看出他的执行符合我们的预期，只有 1 个执行成功了，其他的 5 个被拒绝了（第 2 个在 501ms 才会被正常执行）。

**速率限制升级版**

上面的速率控制虽然很精准但是应用于真实环境未免太苛刻了，真实情况下我们应该控制一个 IP 单位总时间内的总访问次数，而不是像上面那么精确但毫秒，我们可以使用 burst 关键字开启此设置，示例配置如下：

```apl
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;
server { 
    location / { 
        limit_req zone=mylimit burst=4;
    }
}
```

burst=4 表示每个 IP 最多允许4个突发请求，如果单个 IP 在 10ms 内发送 6 次请求的结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101810500.png" alt="image-20220710181001394" style="zoom:80%;" />

从以上结果可以看出，有 1 个请求被立即处理了，4 个请求被放到 burst 队列里排队执行了，另外 1 个请求被拒绝了。

#### 4. 控制并发数

利用 `limit_conn_zone` 和 `limit_conn` 两个指令即可控制并发数，示例配置如下：

```apl
limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;
server {
    ...
    limit_conn perip 10;
    limit_conn perserver 100;
}
```

其中 limit_conn perip 10 表示限制单个 IP 同时最多能持有 10 个连接；limit_conn perserver 100 表示 server 同时能处理并发连接的总数为 100 个。

> 小贴士：只有当 request header 被后端处理后，这个连接才进行计数。

### 基于Redis+Lua的分布式限流

#### 1.Lua脚本

Lua是一个很小巧精致的语言，它的诞生（1993年）甚至比JDK 1.0还要早。Lua是由标准的C语言编写的，它的源码部分不过2万多行C代码，甚至一个完整的Lua解释器也就200k的大小。

Lua往大了说是一个新的编程语言，往小了说就是一个脚本语言。对于有编程经验的同学，拿到一个Lua脚本大体上就能把业务逻辑猜的八九不离十了。

Redis内置了Lua解释器，执行过程保证原子性

#### 2.Lua安装

安装Lua：

1.参考`http://www.lua.org/ftp/`教程，下载5.3.5_1版本，本地安装

如果你使用的是Mac，那建议用brew工具直接执行brew install lua就可以顺利安装，有关brew工具的安装可以参考`https://brew.sh/`网站，使用brew安装后的目录在`/usr/local/Cellar/lua/5.3.5_1`

2.安装IDEA插件，在IDEA->Preferences面板，Plugins，里面Browse repositories，在里面搜索lua，然后就选择同名插件lua。安装好后重启IDEA

3.配置Lua SDK的位置：`IDEA->File->Project Structure`,选择添加Lua，路径指向Lua SDK的bin文件夹

4.都配置好之后，在项目中右键创建Module，左侧栏选择lua，点下一步，选择lua的sdk，下一步，输入lua项目名，完成

#### 3.编写hello lua

```apl
print 'Hello Lua'  
```

#### 4.编写模拟限流

```lua
-- 模拟限流  
  -- 用作限流的key  
local key = 'my key'  
  
-- 限流的最大阈值  
local limit = 2  
  
-- 当前限流大小  
local currentLimit = 2  
  
-- 是否超过限流标准  
if currentLimit + 1 > limit then  
    print 'reject'  
    return false  
else  
    print 'accept'  
    return true  
end  
```

#### 5.限流组件封装

1.添加maven

```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-redis</artifactId>  
</dependency>  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-aop</artifactId>  
</dependency>  
<dependency>  
    <groupId>com.google.guava</groupId>  
    <artifactId>guava</artifactId>  
    <version>18.0</version>  
</dependency>  
```

2.添加Spring配置

不是重要内容就随便写点，主要就是把reids配置一下

```properties
server.port=8080  
spring.redis.database=0  
spring.redis.host=localhost  
spring.redis.port=6376  
```

3.编写限流脚本

lua脚本放在resource目录下就可以了

```lua
-- 获取方法签名特征  
local methodKey = KEYS[1]  
redis.log(redis.LOG_DEBUG,'key is',methodKey)  
  
-- 调用脚本传入的限流大小  
local limit = tonumber(ARGV[1])  
  
-- 获取当前流量大小  
local count = tonumber(redis.call('get',methodKey) or "0")  
  
--是否超出限流值  
if count + 1 >limit then  
    -- 拒绝访问  
    return false  
else  
    -- 没有超过阈值  
    -- 设置当前访问数量+1  
    redis.call('INCRBY',methodKey,1)  
    -- 设置过期时间  
    redis.call('EXPIRE',methodKey,1)  
    -- 放行  
    return true  
end  
```

4.使用`spring-data-redis`组件集成Lua和Redis

创建限流类

```java
@Service  
@Slf4j  
public class AccessLimiter{  
    @Autowired  
    private StringRedisTemplate stringRedisTemplate;  
    @Autowired  
    private RedisScript<Boolean> rateLimitLua;  
  
    public void limitAccess(String key,Integer limit){  
        boolean acquired = stringRedisTemplate.execute(  
            rateLimitLua,//lua脚本的真身  
            Lists.newArrayList(key),//lua脚本中的key列表  
            limit.toString()//lua脚本的value列表  
        );  
  
        if(!acquired){  
            log.error("Your access is blocked,key={}",key);  
            throw new RuntimeException("Your access is blocked");  
        }  
    }  
}  
```

创建配置类

```java
@Configuration  
public class RedisConfiguration{  
    public RedisTemplate<String,String> redisTemplate(RedisConnectionFactory factory){  
        return new StringRedisTemplate(factory);  
    }  
      
    public DefaultRedisScript loadRedisScript(){  
        DefaultRedisScript redisScript = new DefaultRedisScript();  
        redisScript.setLocation(new ClassPathResource("rateLimiter.lua"));  
        redisScript.setResultType(java.lang.Boolean.class);  
        return redisScript;  
    }  
}  
```

5.在Controller中添加测试方法验证限流效果

```java
@RestController  
@Slf4j  
public class Controller{  
    @Autowired  
    private AccessLimiter accessLimiter;  
      
    @GetMapping("test")  
    public String test(){  
        accessLimiter.limitAccess("ratelimiter-test",1);  
        return "success";  
    }  
}   
```

#### 6.编写限流注解

1.新增注解

```java
@Target({ElementType.METHOD})  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
public @interface AccessLimiterAop{  
    int limit();  
      
    String methodKey() default "";  
}  
```

2.新增切面

```java
@Slf4j  
@Aspect  
@Component  
public class AccessLimiterAspect{  
    @Autowired  
    private AccessLimiter  accessLimiter;  
  
    //根据注解的位置，自己修改  
    @Pointcut("@annotation(com.gyx.demo.annotation.AccessLimiter)")  
    public void cut(){  
        log.info("cut");  
    }  
      
    @Before("cut()")  
    public void before(JoinPoint joinPoint){  
        //获取方法签名，作为methodkey  
        MethodSignature signature =(MethodSignature) joinPoint.getSignature();  
        Method method = signature.getMethod();  
        AccessLimiterAop annotation = method.getAnnotation(AccessLimiterAop.class);  
          
        if(annotation == null){  
            return;  
        }  
        String key = annotation.methodKey();  
        Integer limit = annotation.limit();  
        //如果没有设置methodKey，就自动添加一个  
        if(StringUtils.isEmpty(key)){  
            Class[] type = method.getParameterType();  
            key = method.getName();  
            if (type != null){  
                String paramTypes=Arrays.stream(type)  
                    .map(Class::getName)  
                    .collect(Collectors.joining(","));  
                    key += "#"+paramTypes;  
            }  
        }  
          
        //调用redis  
        return accessLimiter.limitAccess(key,limit);  
    }  
}  
```

3.在Controller中添加测试方法验证限流效果

```java
@RestController  
@Slf4j  
public class Controller{  
    @Autowired  
    private AccessLimiter accessLimiter;  
      
    @GetMapping("test")  
    @AccessLImiterAop(limit =1)  
    public String test(){  
        return "success";  
    }  
} 
```

### 基于AOP实现接口限流(重要)

基于AOP的实现方式也非常简单，实现过程如下：

#### 第一步：加入AOP依赖

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

#### 第二步：自定义限流注解

```java
import java.lang.annotation.*;
import java.util.concurrent.TimeUnit;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Documented
public @interface Limit {
    /**
     * 资源的key,唯一
     * 作用：不同的接口，不同的流量控制
     */
    String key() default "";

    /**
     * 最多的访问限制次数
     */
    double permitsPerSecond () ;

    /**
     * 获取令牌最大等待时间
     */
    long timeout();

    /**
     * 获取令牌最大等待时间,单位(例:分钟/秒/毫秒) 默认:毫秒
     */
    TimeUnit timeunit() default TimeUnit.MILLISECONDS;

    /**
     * 得不到令牌的提示语
     */
    String msg() default "系统繁忙,请稍后再试.";
}
```

#### 第三步：使用AOP切面拦截限流注解

```java
import com.google.common.collect.Maps;
import com.google.common.util.concurrent.RateLimiter;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;
import java.util.Map;

@Slf4j
@Aspect
@Component
public class LimitAop {
    /**
     * 不同的接口，不同的流量控制
     * map的key为 Limiter.key
     */
    private final Map<String, RateLimiter> limitMap = Maps.newConcurrentMap();

    @Around("@annotation(com.it.config.Limit)")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        //拿limit的注解
        Limit limit = method.getAnnotation(Limit.class);
        if (limit != null) {
            //key作用：不同的接口，不同的流量控制
            String key=limit.key();
            RateLimiter rateLimiter = null;
            //验证缓存是否有命中key
            if (!limitMap.containsKey(key)) {
                // 创建令牌桶
                rateLimiter = RateLimiter.create(limit.permitsPerSecond());
                limitMap.put(key, rateLimiter);
                log.info("新建了令牌桶={}，容量={}",key,limit.permitsPerSecond());
            }
            rateLimiter = limitMap.get(key);
            // 拿令牌
            boolean acquire = rateLimiter.tryAcquire(limit.timeout(),
                                                     limit.timeunit());
            // 拿不到命令，直接返回异常提示
            if (!acquire) {
                log.info("令牌桶={}，获取令牌失败",key);
                // this.responseFail(limit.msg());
                log.info(limit.msg());
                return null;
            }
        }
        return joinPoint.proceed();
    }
}
```

#### 第四步：给需要限流的接口加上注解

```java
import com.it.config.Limit;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.concurrent.TimeUnit;

@Slf4j
@RestController
@RequestMapping("/limit")
public class LimitController {
    
    @GetMapping("/test2")
    @Limit(key = "limit2", permitsPerSecond = 1, timeout = 50, 
           timeunit = TimeUnit.MILLISECONDS,msg = "当前排队人数较多，请稍后再试！")
    public String limit2() {
        log.info("令牌桶limit2获取令牌成功");
        return "ok";
    }


    @GetMapping("/test3")
    @Limit(key = "limit3", permitsPerSecond = 2, timeout = 50, 
           timeunit = TimeUnit.MILLISECONDS,msg = "系统繁忙，请稍后再试！")
    public String limit3() {
        log.info("令牌桶limit3获取令牌成功");
        return "ok";
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220416172542468.png" alt="image-20220416172542468" style="zoom:67%;" />



# 参数校验

不知道大家平时的业务开发过程中 controller 层的参数校验都是怎么写的？是否也存在下面这样的直接判断？

```java
public String add(UserVO userVO) {
    if(userVO.getAge() == null){
        return "年龄不能为空";
    }
    if(userVO.getAge() > 120){
        return "年龄不能超过120";
    }
    if(userVO.getName().isEmpty()){
        return "用户名不能为空";
    }
    // 省略一堆参数校验...
    return "OK";
}
```

业务代码还没开始写呢，光参数校验就写了一堆判断。这样写虽然没什么错，但是给人的感觉就是：不优雅，不专业。

其实`Spring`框架已经给我们封装了一套校验组件：validation。其特点是简单易用，自由度高。接下来咱使用`springboot-2.3.1.RELEASE`搭建一个简单的 Web 工程，给大家一步一步讲解在开发过程中如何优雅地做参数校验。

## 1. 环境搭建

从`springboot-2.3`开始，校验包被独立成了一个`starter`组件，所以需要引入如下依赖：

```xml
<!--校验组件-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

而`springboot-2.3`之前的版本只需要引入 web 依赖就可以了。

## 2. 内置注解

内置的校验注解有很多，罗列如下：

`Bean Validation` 内嵌的注解很多，基本实际开发中已经够用了，注解如下：

| 注解                        | 详细信息                                                 |
| :-------------------------- | :------------------------------------------------------- |
| @Null                       | 被注释的元素必须为 null                                  |
| @NotNull                    | 被注释的元素必须不为 null                                |
| @AssertTrue                 | 被注释的元素必须为 true                                  |
| @AssertFalse                | 被注释的元素必须为 false                                 |
| @Min(value)                 | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |
| @Max(value)                 | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |
| @DecimalMin(value)          | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |
| @DecimalMax(value)          | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |
| @Size(max, min)             | 被注释的元素的大小必须在指定的范围内                     |
| @Digits (integer, fraction) | 被注释的元素必须是一个数字，其值必须在可接受的范围内     |
| @Past                       | 被注释的元素必须是一个过去的日期                         |
| @Future                     | 被注释的元素必须是一个将来的日期                         |
| @Pattern(value)             | 被注释的元素必须符合指定的正则表达式                     |

> 以上是`Bean Validation`的内嵌的注解，但是`Hibernate Validator`在原有的基础上也内嵌了几个注解

| 注解      | 详细信息                               |
| :-------- | :------------------------------------- |
| @Email    | 被注释的元素必须是电子邮箱地址         |
| @Length   | 被注释的字符串的大小必须在指定的范围内 |
| @NotEmpty | 被注释的字符串的必须非空               |
| @Range    | 被注释的元素必须在合适的范围内         |

## 3 如何使用？⭐

参数校验分为**简单校验**、**嵌套校验**、**分组校验**。

### 1 简单校验

简单的校验即是没有嵌套属性，直接在需要的元素上标注约束注解即可。如下：

```java
@Data
public class ArticleDTO {

    @NotNull(message = "文章id不能为空")
    @Min(value = 1,message = "文章ID不能为负数")
    private Integer id;

    @NotBlank(message = "文章内容不能为空")
    private String content;

    @NotBlank(message = "作者Id不能为空")
    private String authorId;

    @Future(message = "提交时间不能为过去时间")
    @JsonFormat(pattern="yyyy-mm-dd hh:mm:ss")
    private Date submitTime;
}
```

> 同一个属性可以指定多个约束，如`@NotNull`和`@MAX`,其中的`message`属性指定了约束条件不满足时的提示信息

以上约束标记完成之后，要想完成校验，需要在`controller`层的接口标注`@Valid`注解以及声明一个`BindingResult`类型的参数来接收校验的结果。下面简单的演示下添加文章的接口，如下：

```java
ObjectMapper mapper = new ObjectMapper();

@PostMapping("add")
public String add(@Valid @RequestBody ArticleDTO articleDTO, BindingResult bindingResult) throws JsonProcessingException {
    //如果有错误提示信息
    if (bindingResult.hasErrors()) {
        Map<String , String> map = new HashMap<>();
        bindingResult.getFieldErrors().forEach( (item) -> {
            String message = item.getDefaultMessage();
            String field = item.getField();
            map.put( field , message );
        } );
        //返回提示信息
        return mapper.writeValueAsString(map);
    }
    return "success";
}
```

> 仅仅在属性上添加了约束注解还不行，还需在接口参数上标注`@Valid`注解并且声明一个`BindingResult`类型的参数来接收校验结果。

### 2 分组校验

举个栗子：上传文章不需要传文章`ID`，但是修改文章需要上传文章`ID`，并且用的都是同一个`DTO`接收参数，此时的约束条件该如何写呢？

此时就需要对这个文章`ID`进行分组校验，上传文章接口是一个分组，不需要执行`@NotNull`校验，修改文章的接口是一个分组，需要执行`@NotNull`的校验。

> 所有的校验注解都有一个`groups`属性用来指定分组，`Class<?>[]`类型，没有实际意义，因此只需要定义一个或者多个接口用来区分即可。

```java
@Data
public class ArticleDTO {

    /**
     * 文章ID只在修改的时候需要检验，因此指定groups为修改的分组
     */
    @NotNull(message = "文章id不能为空",groups = UpdateArticleDTO.class )
    @Min(value = 1,message = "文章ID不能为负数",groups = UpdateArticleDTO.class)
    private Integer id;

    /**
     * 文章内容添加和修改都是必须校验的，groups需要指定两个分组
     */
    @NotBlank(message = "文章内容不能为空",
              groups = {AddArticleDTO.class,UpdateArticleDTO.class})
    private String content;

    @NotBlank(message = "作者Id不能为空",groups = AddArticleDTO.class)
    private String authorId;

    /**
     * 提交时间是添加和修改都需要校验的，因此指定groups两个
     */
    @Future(message = "提交时间不能为过去时间",
            groups = {AddArticleDTO.class,UpdateArticleDTO.class})
    private Date submitTime;
    
    //修改文章的分组
    public interface UpdateArticleDTO{}

    //添加文章的分组
    public interface AddArticleDTO{}

}
```

> JSR303本身的`@Valid`并不支持分组校验，但是Spring在其基础提供了一个注解`@Validated`支持分组校验。`@Validated`这个注解`value`属性指定需要校验的分组。

```java
/**
  * 添加文章
  * @Validated：这个注解指定校验的分组信息
*/
@PostMapping("/add")
public String add(@Validated(value = ArticleDTO.AddArticleDTO.class) 
                  @RequestBody ArticleDTO articleDTO, BindingResult bindingResult) 
    throws JsonProcessingException {
      //如果有错误提示信息
      if (bindingResult.hasErrors()) {
          Map<String , String> map = new HashMap<>();
          bindingResult.getFieldErrors().forEach( (item) -> {
              String message = item.getDefaultMessage();
              String field = item.getField();
              map.put( field , message );
          } );
          //返回提示信息
          return objectMapper.writeValueAsString(map);
      }
      return "success";
}
```

### 3 嵌套校验

嵌套校验简单的解释就是一个实体中包含另外一个实体，并且这两个或者多个实体都需要校验。

举个栗子：文章可以有一个或者多个分类，作者在提交文章的时候必须指定文章分类，而分类是单独一个实体，有`分类ID`、`名称`等等。大致的结构如下：

```java
public class ArticleDTO{
  ...文章的一些属性.....
  
  //分类的信息
  private CategoryDTO categoryDTO;
}
```

此时文章和分类的属性都需要校验，这种就叫做嵌套校验。

> 嵌套校验很简单，只需要在嵌套的实体属性标注`@Valid`注解，则其中的属性也将会得到校验，否则不会校验。

如下**文章分类实体类校验**：

```java
/**
 * 文章分类
 */
@Data
public class CategoryDTO {
    @NotNull(message = "分类ID不能为空")
    @Min(value = 1,message = "分类ID不能为负数")
    private Integer id;

    @NotBlank(message = "分类名称不能为空")
    private String name;
}
```

文章的实体类中有个嵌套的文章分类`CategoryDTO`属性，需要使用`@Valid`标注才能嵌套校验，如下：

```java
@Data
public class ArticleDTO {

    @NotBlank(message = "文章内容不能为空")
    private String content;

    @NotBlank(message = "作者Id不能为空")
    private String authorId;

    @Future(message = "提交时间不能为过去时间")
    private Date submitTime;

    /**
     * @Valid这个注解指定CategoryDTO中的属性也需要校验
     */
    @Valid
    @NotNull(message = "分类不能为空")
    private CategoryDTO categoryDTO;
  }
```

`Controller`层的添加文章的接口同上，需要使用`@Valid`或者`@Validated`标注入参，同时需要定义一个`BindingResult`的参数接收校验结果。

> 嵌套校验针对**分组查询**仍然生效，如果嵌套的实体类（比如`CategoryDTO`）中的校验的属性和接口中`@Validated`注解指定的分组不同，则不会校验。

`JSR-303`针对`集合`的嵌套校验也是可行的，比如`List`的嵌套校验，同样需要在属性上标注一个`@Valid`注解才会生效，如下：

```java
@Data
public class ArticleDTO {
    /**
     * @Valid这个注解标注在集合上，将会针对集合中每个元素进行校验
     */
    @Valid
    @Size(min = 1,message = "至少一个分类")
    @NotNull(message = "分类不能为空")
    private List<CategoryDTO> categoryDTOS;
  }
```

> 总结：嵌套校验只需要在需要校验的元素（单个或者集合）上添加`@Valid`注解，接口层需要使用`@Valid`或者`@Validated`注解标注入参。

## 如何接收校验结果？

接收校验的结果的方式很多，不过实际开发中最好选择一个优雅的方式，下面介绍常见的两种方式。

### BindingResult 接收

这种方式需要在`Controller`层的每个接口方法参数中指定，Validator会将校验的信息自动封装到其中。这也是上面例子中一直用的方式。如下：

```java
@PostMapping("/add")
public String add(@Valid @RequestBody ArticleDTO articleDTO, BindingResult bindingResult){}
```

这种方式的弊端很明显，每个接口方法参数都要声明，同时每个方法都要处理校验信息，显然不现实，舍弃。

> 此种方式还有一个优化的方案：使用`AOP`，在`Controller`接口方法执行之前处理`BindingResult`的消息提示，不过这种方案仍然**不推荐使用**。

### 全局异常捕捉

参数在校验失败的时候会抛出的`MethodArgumentNotValidException`或者`BindException`两种异常，可以在全局的异常处理器中捕捉到这两种异常，将提示信息或者自定义信息返回给客户端。

全局异常捕捉之前有单独写过一篇文章，不理解的可以看[满屏的try-catch，你不瘆得慌？](https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484881&idx=1&sn=7de738f8950b2a63a549d22a49bc435e&scene=21#wechat_redirect)。

作者这里就不再详细的贴出其他的异常捕获了，仅仅贴一下参数校验的异常捕获（**仅仅举个例子，具体的返回信息需要自己封装**），如下：

```java
@RestControllerAdvice
public class ExceptionRsHandler {

    @Autowired
    private ObjectMapper objectMapper;

    /**
     * 参数校验异常步骤
     */
    @ExceptionHandler(value= {MethodArgumentNotValidException.class , BindException.class})
    public String onException(Exception e) throws JsonProcessingException {
        BindingResult bindingResult = null;
        if (e instanceof MethodArgumentNotValidException) {
            bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();
        } else if (e instanceof BindException) {
            bindingResult = ((BindException)e).getBindingResult();
        }
        Map<String,String> errorMap = new HashMap<>(16);
        bindingResult.getFieldErrors().forEach((fieldError)->
                errorMap.put(fieldError.getField(),fieldError.getDefaultMessage())
        );
        return objectMapper.writeValueAsString(errorMap);
    }

}
```

## spring-boot-starter-validation做了什么？

这个启动器的自动配置类是`ValidationAutoConfiguration`，最重要的代码就是注入了一个`Validator`（校验器）的实现类，代码如下：

```java
@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@ConditionalOnMissingBean(Validator.class)
public static LocalValidatorFactoryBean defaultValidator() {
  LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
  MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory();
  factoryBean.setMessageInterpolator(interpolatorFactory.getObject());
  return factoryBean;
}
```

这个有什么用呢？`Validator`这个接口定义了校验的方法，如下：

```java
<T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups);


<T> Set<ConstraintViolation<T>> validateProperty(T object,
              String propertyName,
              Class<?>... groups);
                           
<T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
              String propertyName,
              Object value,
              Class<?>... groups);
......
```

> 这个`Validator`可以用来自定义实现自己的校验逻辑，有些大公司完全不用JSR-303提供的`@Valid`注解，而是有一套自己的实现，其实本质就是利用`Validator`这个接口的实现。

## 如何自定义校验？

虽说在日常的开发中内置的约束注解已经够用了，但是仍然有些时候不能满足需求，需要自定义一些校验约束。

**举个栗子：有这样一个例子，传入的数字要在列举的值范围中，否则校验失败。**

### 自定义校验注解

首先需要自定义一个校验注解，如下：

```java
@Documented
@Constraint(validatedBy = { EnumValuesConstraintValidator.class})
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@NotNull(message = "不能为空")
public @interface EnumValues {
    /**
     * 提示消息
     */
    String message() default "传入的值不在范围内";

    /**
     * 分组
     * @return
     */
    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * 可以传入的值
     * @return
     */
    int[] values() default { };
}
```

根据`Bean Validation API` 规范的要求有如下三个属性是必须的：

1. `message`：定义消息模板，校验失败时输出
2. `groups`：用于校验分组
3. `payload`：`Bean Validation API` 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被API自身所使用。

除了以上三个必须要的属性，添加了一个`values`属性用来接收限制的范围。

该校验注解头上标注的如下一行代码：

```java
@Constraint(validatedBy = { EnumValuesConstraintValidator.class})
```

这个`@Constraint`注解指定了通过哪个校验器去校验。

> 自定义校验注解可以复用内嵌的注解，比如`@EnumValues`注解头上标注了一个`@NotNull`注解，这样`@EnumValues`就兼具了`@NotNull`的功能。

### 自定义校验器

`@Constraint`注解指定了校验器为`EnumValuesConstraintValidator`，因此需要自定义一个。

自定义校验器需要实现`ConstraintValidator<A extends Annotation, T>`这个接口，第一个泛型是`校验注解`，第二个是`参数类型`。代码如下：

```java
/**
 * 校验器
 */
public class EnumValuesConstraintValidator implements ConstraintValidator<EnumValues,Integer> {
    /**
     * 存储枚举的值
     */
    private  Set<Integer> ints=new HashSet<>();

    /**
     * 初始化方法
     * @param enumValues 校验的注解
     */
    @Override
    public void initialize(EnumValues enumValues) {
        for (int value : enumValues.values()) {
            ints.add(value);
        }
    }

    /**
     *
     * @param value  入参传的值
     * @param context
     * @return
     */
    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {
        //判断是否包含这个值
        return ints.contains(value);
    }
}
```

> 如果约束注解需要对其他数据类型进行校验，则可以的自定义对应数据类型的校验器，然后在约束注解头上的`@Constraint`注解中指定其他的校验器。

### 演示

校验注解和校验器自定义成功之后即可使用，如下：

```java
@Data
public class AuthorDTO {
    @EnumValues(values = {1,2},message = "性别只能传入1或者2")
    private Integer gender;
}
```



## 3. 规范返回值

待校验参数多了之后我们希望一次返回所有校验失败信息，方便接口调用方进行调整，这就需要统一返回格式，常见的就是封装一个结果类。

```java
public class ResultInfo<T>{
    private Integer status;
    private String message;
    private T response;
    // 省略其他代码...
}
```

改造一下`controller` 方法，第二版：

```java
public ResultInfo add2(@Validated UserVO userVO, BindingResult result) {
    List<FieldError> fieldErrors = result.getFieldErrors();
    List<String> collect = fieldErrors.stream()
            .map(o -> o.getDefaultMessage())
            .collect(Collectors.toList());
    return new ResultInfo<>().success(400,"请求参数错误",collect);
}
```

请求该方法时，所有的错误参数就都返回了：

```json
{
    "status": 400,
    "message": "请求参数错误",
    "response": [
        "年龄必须在[1,120]之间",
        "bg 字段的整数位最多为3位，小数位最多为1位",
        "name 不能为空",
        "email 格式错误"
    ]
}
```

## 4. 全局异常处理

每个`Controller`方法中如果都写一遍`BindingResult`信息的处理，使用起来还是很繁琐。可以通过全局异常处理的方式统一处理校验异常。

当我们写了`@validated`注解，不写`BindingResult`的时候，Spring 就会抛出异常。由此，可以写一个全局异常处理类来统一处理这种校验异常，从而免去重复组织异常信息的代码。

全局异常处理类只需要在类上标注`@RestControllerAdvice`，并在处理相应异常的方法上使用`@ExceptionHandler`注解，写明处理哪个异常即可。

```java
@RestControllerAdvice
public class GlobalControllerAdvice {
    private static final String BAD_REQUEST_MSG = "客户端请求参数错误";
    // <1> 处理 form data方式调用接口校验失败抛出的异常 
    @ExceptionHandler(BindException.class)
    public ResultInfo bindExceptionHandler(BindException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        List<String> collect = fieldErrors.stream()
                .map(o -> o.getDefaultMessage())
                .collect(Collectors.toList());
        return new ResultInfo().success(HttpStatus.BAD_REQUEST.value(), 
                                        BAD_REQUEST_MSG, collect);
    }
    // <2> 处理 json 请求体调用接口校验失败抛出的异常 
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResultInfo methodArgumentNotValidExceptionHandler(MethodArgumentNotValidException
                                                             e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        List<String> collect = fieldErrors.stream()
                .map(o -> o.getDefaultMessage())
                .collect(Collectors.toList());
        return new ResultInfo().success(HttpStatus.BAD_REQUEST.value(), 
                                        BAD_REQUEST_MSG,
                                        collect);
    }
    // <3> 处理单个参数校验失败抛出的异常
    @ExceptionHandler(ConstraintViolationException.class)
    public ResultInfo constraintViolationExceptionHandler(ConstraintViolationException e) {
        Set<ConstraintViolation<?>> constraintViolations = e.getConstraintViolations();
        List<String> collect = constraintViolations.stream()
                .map(o -> o.getMessage())
                .collect(Collectors.toList());
        return new ResultInfo().success(HttpStatus.BAD_REQUEST.value(), 
                                        BAD_REQUEST_MSG, collect);
    }
}
```

事实上，在全局异常处理类中，我们可以写多个异常处理方法，我总结了三种参数校验时可能引发的异常：

1. 使用form data方式调用接口，校验异常抛出 BindException
2. 使用 json 请求体调用接口，校验异常抛出 MethodArgumentNotValidException
3. 单个参数校验异常抛出ConstraintViolationException

> 注：单个参数校验需要在参数上增加校验注解，并在类上标注`@Validated`。

全局异常处理类可以添加各种需要处理的异常，比如添加一个对`Exception.class`的异常处理，当所有`ExceptionHandler`都无法处理时，由其记录异常信息，并返回友好提示。

## 5.分组校验

如果同一个参数，需要在不同场景下应用不同的校验规则，就需要用到分组校验了。比如：新注册用户还没起名字，我们允许`name`字段为空，但是不允许将名字更新为空字符。

分组校验有三个步骤：

1. 定义一个分组类（或接口）
2. 在校验注解上添加`groups`属性指定分组
3. `Controller`方法的`@Validated`注解添加分组类

```java
public interface Update extends Default{
}
public class UserVO {
    @NotBlank(message = "name 不能为空",groups = Update.class)
    private String name;
    // 省略其他代码...
}

@PostMapping("update")
public ResultInfo update(@Validated({Update.class}) UserVO userVO) {
    return new ResultInfo().success(userVO);
}
```

细心的同学可能已经注意到，自定义的`Update`分组接口继承了`Default`接口。校验注解(如：`@NotBlank`)和`@validated`默认都属于`Default.class`分组，这一点在`javax.validation.groups.Default`注释中有说明

```java
/**
 * Default Jakarta Bean Validation group.
 * <p>
 * Unless a list of groups is explicitly defined:
 * <ul>
 *     <li>constraints belong to the {@code Default} group</li>
 *     <li>validation applies to the {@code Default} group</li>
 * </ul>
 * Most structural constraints should belong to the default group.
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}
```

在编写`Update`分组接口时，如果继承了`Default`，下面两个写法就是等效的：

```java
@Validated({Update.class})
@Validated({Update.class,Default.class})
```

请求一下`/update`接口可以看到，不仅校验了`name`字段，也校验了其他默认属于`Default.class`分组的字段

```java
{
    "status": 400,
    "message": "客户端请求参数错误",
    "response": [
        "name 不能为空",
        "age 不能为空",
        "email 不能为空"
    ]
}
```

如果`Update`不继承`Default`，`@Validated({Update.class})`就只会校验属于`Update.class`分组的参数字段，修改后再次请求该接口得到如下结果，可以看到， 其他字段没有参与校验：

```java
{
    "status": 400,
    "message": "客户端请求参数错误",
    "response": [
        "name 不能为空"
    ]
}
```

## 6.递归校验

如果 UserVO 类中增加一个 OrderVO 类的属性，而 OrderVO 中的属性也需要校验，就用到递归校验了，只要在相应属性上增加`@Valid`注解即可实现（对于集合同样适用）

OrderVO类如下

```java
public class OrderVO {
    @NotNull
    private Long id;
    @NotBlank(message = "itemName 不能为空")
    private String itemName;
    // 省略其他代码...
}
```

在 UserVO 类中增加一个 OrderVO 类型的属性

```java
public class UserVO {
    @NotBlank(message = "name 不能为空",groups = Update.class)
    private String name;
    //需要递归校验的OrderVO
    @Valid
    private OrderVO orderVO;
    // 省略其他代码...
}   
```

调用请求验证如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021745294.png" alt="image-20220702174557190" style="zoom:67%;" />



## 7. 自定义校验

Spring 的 validation 为我们提供了这么多特性，几乎可以满足日常开发中绝大多数参数校验场景了。但是，一个好的框架一定是方便扩展的。有了扩展能力，就能应对更多复杂的业务场景，毕竟在开发过程中，**唯一不变的就是变化本身**。

Spring Validation允许用户自定义校验，实现很简单，分两步：

1. 自定义校验注解
2. 编写校验者类

代码也很简单，结合注释你一看就能懂

```java
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {HaveNoBlankValidator.class})// 标明由哪个类执行校验逻辑
public @interface HaveNoBlank {
 
    // 校验出错时默认返回的消息
    String message() default "字符串中不能含有空格";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * 同一个元素上指定多个该注解时使用
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        NotBlank[] value();
    }
}
public class HaveNoBlankValidator implements ConstraintValidator<HaveNoBlank, String> {
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // null 不做检验
        if (value == null) {
            return true;
        }
        if (value.contains(" ")) {
            // 校验失败
            return false;
        }
        // 校验成功
        return true;
    }
}
```

自定义校验注解使用起来和内置注解无异，在需要的字段上添加相应注解即可，同学们可以自行验证

# 获取用户IP属地

## 基本介绍

[微博头条等展示用户ip属地，我用java轻松搞定 (qq.com)](https://mp.weixin.qq.com/s?__biz=MjM5MzEwODY4Mw==&mid=2257487506&idx=1&sn=a7dd11a05e897685b65e66c421148ce2&chksm=a5e621369291a82074acd46965086d4c94d08574431ee8e3d14e82f1245b2698929fadb4f839&mpshare=1&scene=23&srcid=0722zRGu6HlyqB53ZP2LXwJ0&sharer_sharetime=1658488364968&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

https://www.dreamlu.net/mica2x/index.html

当前SpringBoot版本2.6.3

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207222112145.png" alt="image-20220722211242061" style="zoom: 67%;" />

```xml
<dependency>
    <groupId>net.dreamlu</groupId>
    <artifactId>mica-ip2region</artifactId>
    <version>2.6.8</version>
</dependency>
```

全部的查询客户端单次查询都在 **0.x** 毫秒级别，内置了三种查询算法

- **memory** 算法：整个数据库全部载入内存，单次查询都在0.1x毫秒内，C语言的客户端单次查询在0.00x毫秒级别
- **binary** 算法：基于二分查找，基于ip2region.db文件，不需要载入内存，单次查询在0.x毫秒级别
- **b-tree** 算法：基于btree算法，基于ip2region.db文件，不需要载入内存，单词查询在0.x毫秒级别，比binary算法快

## Ip2regionSearcher实现

```java
@Autowired
private Ip2regionSearcher regionSearcher;
```

```java
@Test
public void getIp() {
    IpInfo ipInfo = regionSearcher.btreeSearch("183.211.122.123");
    if (ipInfo != null) {
        System.out.println("IP信息："+ipInfo.getAddressAndIsp());
        System.out.println("IP所在国："+ipInfo.getCountry());
        System.out.println("IP所在省："+ipInfo.getProvince());
        System.out.println("IP所在市："+ipInfo.getCity());
        System.out.println("IP服务商："+ipInfo.getIsp());
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207222129816.png" alt="image-20220722212902748" style="zoom:67%;" />

```java
@Test
public void getIp1() {
    String addressAndIsp = regionSearcher.getAddressAndIsp("183.211.122.123");
    if (StringUtils.hasText(addressAndIsp)) {
        // 将IP地址和服务商信息分割
        String replace = addressAndIsp.replace(" ", "|");
        System.out.println(replace);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207222129090.png" alt="image-20220722212943028" style="zoom:80%;" />

## 爬虫方式实现

> 细心的朋友肯定发现了，下面有个网站：www.ip138.com，没错，百度这个IP的搜索是基于`ip138` 提供的功能。
>

> 接下来我们只要拿到这个网页的结构，直接解析出来我们想要的数据即可。基于Jsoup的html解析
>

```xml
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.14.3</version>
</dependency>
```

然后就可以写工具方法啦，简单的几行代码即可完成，大家可以直接 Copy我的，包导入我都帮你准备好了：

```java
public static void s1() {
    try {
        Document document = Jsoup.connect("https://2022.ip138.com/").get();
        // 通过 Xpath 直接获取了网页里面的内容
        String ip = document.selectXpath("/html/body/p[1]/a[1]").get(0).text(); 
        String ipInfo = document.selectXpath("/html/body/p[1]").get(0).text();
        String city = ipInfo.substring(ipInfo.lastIndexOf("来自：") + 3);
        System.out.println(ip);
        System.out.println(city);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

通过运行这个方法，可以看到，控制台打印了IP和城市信息，也就是我们想要的`IP属地信息`啦！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208212300230.png" alt="image-20220821225852414" style="zoom: 80%;" />

> 是不是非常 Easy？在你的项目里，你可以在登录的时候记录当前登录用户的IP和登录地点，也可以在用户发表文章和评论的时候显示出他的IP属地，非常实用哦~
>

# 验证码

## 验证码生成

本效果是利用easy-captcha工具包实现，首先需要添加相关依赖到pom.xml中，代码如下：

```
<dependency>
    <groupId>com.github.whvcse</groupId>
    <artifactId>easy-captcha</artifactId>
    <version>1.6.2</version>
</dependency>
```

### 验证码格式

easy-captcha验证码工具支持GIF、中文、算术等类型，分别通过下面几个实例对象实现：

- SpecCaptcha（PNG类型的静态图片验证码）
- GifCaptcha（Gif类型的图片验证码）
- ChineseCaptcha（GIF类型中文图片验证码）
- ArithmeticCaptcha（算术类型的图片验证码）

字符类型分为以下几种：

- TYPE_DEFAULT：数字和字母混合
- TYPEONLYNUMBER：纯数字
- TYPEONLYCHAR：纯字母
- TYPEONLYUPPER：纯大写字母
- TYPEONLYLOWER：纯小写字母
- TYPENUMAND_UPPER：数字和大写字母混合

### 后端逻辑的实现

```
package com.yanx.controller;
 
import com.wf.captcha.SpecCaptcha;
import com.wf.captcha.base.Captcha;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.thymeleaf.util.StringUtils;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
 
@Controller
public class KapchaController {
    @GetMapping("/kaptcha")
    public void defaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws IOException {
        httpServletResponse.setHeader("Cache-Control","no-store");
        httpServletResponse.setHeader("Pragma","no-cache");
        httpServletResponse.setDateHeader("Expires",0);
        httpServletResponse.setContentType("image/gif");
 
        //三个参数分别为宽、高、位数
        SpecCaptcha captcha=new SpecCaptcha(75,30,4);
 
        //设置类型为数字和字母混合
        captcha.setCharType(Captcha.TYPE_DEFAULT);
 
        //设置字体
        captcha.setCharType(Captcha.FONT_9);
 
        //验证码存入session
        httpServletRequest.getSession().setAttribute("verifyCode",captcha.text().toLowerCase());
 
        //输出图片流
        captcha.out(httpServletResponse.getOutputStream());
    }
 
}
```

这里控制器新增了defaultKaptcha()方法，该方法所拦截处理的路径为`/kaptcha`

### 前端逻辑的实现

在static目录中新建kaptcha.html页面,代码如下：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>验证码</title>
</head>
<body>
 <img src="/kaptcha" onclick="this.src='/kaptcha?t=new Date()'">
</body>
</html>
```

访问后端验证码路径/kaptcha,验证码为图片形式。onclick方法为点击该标签时可以动态切换显示验证码。

启动Spring Boot项目，打开浏览器输入地址：

:8080/kaptcha.html

效果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YJibzamcBJebplVZkZM51pwIR8HXaCvy1CSWxb12ULiccHMcl5iadiaZqoh3nTpJr1j8lsicozI5xG2iaNEhickwcdZdQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 验证码验证

### 后端代码

```
package com.yanx.controller;
 
import com.wf.captcha.SpecCaptcha;
import com.wf.captcha.base.Captcha;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.thymeleaf.util.StringUtils;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
 
@Controller
public class KapchaController {
    @GetMapping("/kaptcha")
    public void defaultKaptcha(HttpServletRequest httpServletRequest, 
    HttpServletResponse httpServletResponse) throws IOException {
        httpServletResponse.setHeader("Cache-Control","no-store");
        httpServletResponse.setHeader("Pragma","no-cache");
        httpServletResponse.setDateHeader("Expires",0);
        httpServletResponse.setContentType("image/gif");
 
        //三个参数分别为宽、高、位数
        SpecCaptcha captcha=new SpecCaptcha(75,30,4);
 
        //设置类型为数字和字母混合
        captcha.setCharType(Captcha.TYPE_DEFAULT);
 
        //设置字体
        captcha.setCharType(Captcha.FONT_9);
 
        //验证码存入session
        httpServletRequest.getSession().setAttribute("verifyCode",captcha.text().toLowerCase());
 
        //输出图片流
        captcha.out(httpServletResponse.getOutputStream());
    }
 
    @GetMapping("/verify")
    @ResponseBody
    public String verify(@RequestParam("code") String code, HttpSession session){
        if(StringUtils.isEmpty(code)){
            return "验证码不能为空";
        }
        String kapchaCode = session.getAttribute("verifyCode")+"";
        if(StringUtils.isEmpty(kapchaCode)||!code.toLowerCase().equals(kapchaCode)){
            return "验证码输入错误";
        }
        return "验证成功";
    }
}
```

### 前端代码

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>验证码验证</title>
</head>
<body>
 
<img src="/kaptcha" onclick="this.src='/kaptcha?d=new Date()'">
 
<br>
<input type="text" maxlength="5" id="code" placeholder="请输入验证码"/>
<button id="verify">验证</button>
<br/>
<p id="verifyResult"></p>
 
</body>
 
<script src="https://s3.pstatp.com/cdn/expire-1-M/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" >
  $(function(){
  //验证按钮点击事件
   $('#verify').click(function(){
    var code=$('#code').val();
    $.ajax({
      type:'GET',//方法类型
      url:'/verify?code='+code,
      success:function(result){
        $('#verifyResult').html(result);
      },
      error:function(){
        alert('请求失败');
      },
    });
   });
  });
</script>
</html>
```

### 效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304172111112.png" alt="image-20230417211119901" style="zoom:67%;" />

# Lombok

## Lombok使用

首先我们添加一下 maven 依赖。

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.22</version>
    <scope>provided</scope>
</dependency>
```

然后我们创建一个 Account 的 class 来演示我们一下我们的各种操作。

```java
@Getter
@Setter
@ToString
public class Account {
    private String id;
    private String name;
}
```

默认情况下，我们在调用 Account 的`toString()` 方法之后，输出的结果可能如下：

```
Account(id=12345, name=account)
```

这是一种比较标准的格式输出。

## Lombok配置

### 父类 toString() 的调用

现在假设我们有一个 `SavingAccount` 的 class 继承于 Account ，我们调用 SavingAccount 的 toString() 方法时，希望把 Account 的一些属性也能够一起输出， 这个时候我们可以设置 callSupper 属性来达到我们的目的。

```java
@ToString(callSupper = true)
public class SavingAccount extends Account {
    private String savingAccountId;
    // 省略 get set
}
```

上述代码的操作，就能把父类 Account 的属性都输出出来：

```
SavingAccount(super=Account(id=12345, name=An account), savingAccountId=6789)
```

### 省略字段名称

我们知道默认输出的时候，会包含字段名称，我们可以通过设置 includeFieldNames 来控制，是否显示属性名称。

```java
@ToString(includeFieldNames = false)
public class Account {
    private String id;
    private String name;
    // 省略 get set
}
```

把 includeFieldNames 设置为 false 之后，输出结果如下

```
Account(12345, An account)
```

### 使用字段代替 Getter

我们知道 getter 方法提供了用于打印的字段值。如果该类不包含某个特定字段的getter方法，那么Lombok会直接访问该字段并获取其值。
我们可以通过设置 `doNotUseGetters` 属性为 true，将 Lombok 配置为总是使用直接的字段值而不是getter。

```java
@ToString(doNotUseGetters = true)
public class Account {
    private String id;
    private String name;
    // ignored getter
    public String getId() {
        return "this is the id:" + id;
    }
    // standard getters and setters
}
```

如果没有这个属性，我们会得到通过调用getters得到的输出。

```
Account(id=this is the id:12345, name=An account)
```

相反，通过设置doNotUseGetters属性，输出实际上显示了id字段的值，而没有调用getter。

```
Account(id=12345, name=An account)
```

### 字段的包含和排除

假设我们想从字符串表示中排除某些字段，例如，密码、其他敏感信息或大的JSON结构。我们可以通过@ToString.Exclude注解来省略这些字段。
让我们把名字字段从我们的表示中排除

```java
@ToString
public class Account {

    private String id;

    @ToString.Exclude
    private String name;

}
```

或者，我们可以只指定输出中所需的字段，我可以通过使用 `@ToString(onlyExplicitlyIncluded = true) `和 `@ToString.Include`来实现。

```java
@ToString(onlyExplicitlyIncluded = true)
public class Account {
    @ToString.Include
    private String id;
    private String name;
}
```

上述两种方法，最终输出，都只能输出 id 字段。

```java
Account(id=12345)
```

另外，Lombok 会自动忽略以$ 开头的变量，但是我们可以通过 @ToString.Include 来强制Lombok输出。

### 输出排序

默认情况下，Lombok 的输出，是按照字段定义的顺序进行输出的，我可以通过设置 @ToString.Include 来进行排序。
我们先修改一下 Account 的字段顺序， 然后对 id 进行标记顺序。

```java
@ToString
public class Account {
    private String name;
    @ToString.Include(rank = 1)
    private String id;
}
```

现在 id 字段输出的时候，会排在 name 的前面

```
Account(id=12345, name=An account)
```

Lombok 输出的规则大致如下：

- rank 排名越大，排序越靠前
- 默认的排序值为0
- 相同的排序通过根据字段定义顺序输出

## 方法输出

除了字段之外，我们也可以包括一个不需要参数的实例方法的输出。我们可以通过用@ToString.Include标记无参数的实例方法来做到这一点。

```java
@ToString
public class Account {
    private String id;
    private String name;
    
    @ToString.Include
    String description() {
        return "Account description";
    }
}
```

这里 description 将会作为输出 key 进行打印输出。

```
Account(id=12345, name=An account, description=Account description)
```

如果指定的方法名称与字段名称相匹配，那么该方法就会优先于字段。换句话说，输出包含方法调用的结果，而不是匹配字段的值。

### 修改字段名称

我们可以通过 @ToString.Include 的属性来修改字段的名称。

```java
@ToString
public class Account {
    @ToString.Include(name = "identification")
    private String id;
    private String name;
}
```

现在输出结果中，将不会包含字段名称id ，将会输出 identification。

```
Account(identification=12345, name=An account)
```

### 打印数组

Lombok 使用 Arrays.deepToString() 方法打印数组，将数组元素转换为其相应的字符串表示。但是数组有可能包含直接引用或间接循环引用。为了避免无限递归及其相关的运行时错误，该方法将任何从自身内部对数组的循环引用渲染为"[[...]]"。
让我们通过给我们的账户类添加一个对象数组字段来看看。

```java
@ToString
public class Account {
    private String id;
    private Object[] relatedAccounts;
}
```

这 relatedAccounts 数组的打印如下

```
Account(id=12345, relatedAccounts=[54321, [...]])
```

重要的是，循环引用被deepToString()方法检测到，并且被Lombok适当地呈现出来，没有引起任何StackOverflowError。

## 注意点

有几个细节值得一提，对避免产生意外的结果很重要。

- 在类中存在任何名为toString()的方法（不管返回类型如何），Lombok不会生成其 toString() 方法。
- 不同版本的Lombok可能会改变生成方法的输出格式。在任何情况下，我们应该避免依赖解析toString()方法输出的代码。所以这其实不应该是一个问题。
- 我们还可以在枚举上添加这个注解。这将产生一个枚举值跟随枚举类名称的表示，例如，AccounType.SAVING。

























