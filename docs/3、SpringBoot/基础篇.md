

# Spring Boot概述

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301252211970.png" alt="image-20230125221059344" style="zoom: 33%;" />

## 什么是SpringBoot

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260940755.png" alt="image-20230126094007627" style="zoom:67%;" />

## Spring Boot 主要特点

> - 创建独立的Spring应用，为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验
> - 直接嵌入应用服务器，如**tomcat、jetty、undertow**等；不需要去部署war包
> - 提供固定的启动器依赖去简化组件配置；**实现开箱即用**
> - 自动地配置Spring和其它有需要**的第三方依赖**
> - 提供了一些大型项目中常见的非功能性特性，如**内嵌服务器、安全、指标，健康检测、外部化配置**等
> - 绝对没有代码生成，也无需 XML 配置。

## Spring VS SpringBoot

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031163827515.png" alt="image-20211031163827515" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301252227120.png" alt="image-20230125222742044" style="zoom:67%;" />

> 1. 开发SpringBoot程序可以根据向导进行联网快速制作 
> 2. SpringBoot程序需要基于JDK8进行制作
> 3. SpringBoot程序中需要使用何种功能通过勾选选择技术 
> 4. 运行SpringBoot程序通过运行Application程序入口进行

## 前置知识⭐

### 基础篇 

> -  Java基础语法 
> -  Spring与SpringMVC 
> -  知道**Spring是用来管理bean，能够基于Restful实现页面请求交互功能** 
> -  Mybatis与Mybatis-Plus ，基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块 
> -  数据库MySQL 能够读懂基础CRUD功能的SQL语句 

### 服务器 

> -  知道服务器与web工程的关系，熟悉web服务器的基础配置 
> -  maven  知道maven的依赖关系，知道什么是**依赖范围，依赖传递，排除依赖，可选依赖，继承** 
> -  web技术（含vue，ElementUI) 知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定

### 实用篇

> - Linux（CenterOS7） 熟悉常用的Linux基础指令，熟悉Linux系统目录结构 
> - 实用开发技术  缓存：Redis、MongoDB、…… 
> - 消息中间件:RocketMq、RabbitMq、……

# 工程创建

## 基于IDEA创建工程

需求：可以在浏览器中访问:8080/hello输出一串字符

### 实现步骤

1. idea创建SpringBoot工程；
2. 添加依赖（启动器依赖，spring-boot-starter-web）；
4. 创建处理器Controller；
5. 测试

1、创建新模块，选择Spring Initializr，并配置模块相关基础信息

![image-20211031163635981](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031163635981.png)

2、选择当前模块需要使用的技术集

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031163721797.png" alt="image-20211031163721797" style="zoom: 80%;" />

```java
@RestController
@RequestMapping("/books")
public class HelloController {

    @GetMapping("hello")
    public String hello(){
        System.out.println("springboot is running...");
        return "springboot is running...";
    }
}
```

只需要写controller，注意方法返回值类型为String，在浏览器上输出了返回值。注意，不配置端口时默认是8080

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301252222723.png" alt="image-20230125222234667" style="zoom:80%;" />

### 查看启动

> 注意查看：端口(默认8080)、Tomcat服务器、Tomcat版本

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251407490.png" alt="image-20220725140716401" style="zoom:67%;" />

## 基于官网创建工程

基于SpringBoot官网创建项目，地址：https://start.spring.io/，解压压缩包用idea打开即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251414319.png" alt="image-20220725141410248" style="zoom:80%;" />

## 基于阿里云创建工程

基于阿里云创建项目，地址：https://start.aliyun.com/

![image-20211031164116945](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031164116945.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301252235160.png" alt="image-20230125223505092" style="zoom:67%;" />

## 基于Maven创建工程

> 创建普通Maven工程
>
> 继承spring-boot-starter-parent
>
> 添加依赖spring-boot-starter-web
>
> 制作引导类Application

### 创建maven模块

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260924337.png" alt="image-20230126092439232" style="zoom: 60%;" />

### 手动导入坐标

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260929107.png" alt="image-20230126092949015" style="zoom:67%;" />

### 手动创建引导类

```java
package com.itheima;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class,args);
	}
}
```



# 项目结构

## 隐藏指定文件文件夹⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031171225733.png" alt="image-20211031171225733" style="zoom: 80%;" />

>  Setting → File Types → Ignored Files and Folders
>
> 输入要隐藏的文件名，支持*号通配符
>
> 回车确认添加

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260935355.png" alt="image-20230126093521276" style="zoom:67%;" />

## parent

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260943201.png" alt="image-20230126094344138" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260956681.png" alt="image-20230126095627565" style="zoom:60%;" />

![image-20230126095841216](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301260958285.png)

## starter

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261001586.png" alt="image-20230126100142527" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261001757.png" alt="image-20230126100047154" style="zoom:67%;" />

## parent & starter应用场景

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261003383.png" alt="image-20230126100330304" style="zoom:67%;" />

## 引导类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261007908.png" alt="image-20230126100721676" style="zoom:67%;" />

## 内嵌服务器

### 内置服务器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261018046.png" alt="image-20230126101819985" style="zoom:67%;" />

### 内嵌Tomcat

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261017386.png" alt="image-20230126101718296" style="zoom: 50%;" />

### 变更服务器⭐

> Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty

使用maven依赖管理变更起步依赖，先排除依赖，再添加需要的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <!--web起步环境中,排除tomcat依赖-->
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!--加上Jetty起步依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251444728.png" alt="image-20220725144405632" style="zoom:67%;" />



# 基础配置

## 复制工程⭐

> 原则：保留工程基础结构、抹掉原始工程痕迹，进入文件夹中操作，不要在idea中复制

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261024766.png" alt="image-20230126102454668" style="zoom:60%;" />



## 属性配置 ⭐

### 修改端口

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251452979.png" alt="image-20220725145256926" style="zoom:67%;" />

```properties
# 应用服务 WEB 访问端口
server.port=80
```

### 修改日志级别、banner

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261039352.png" alt="image-20230126103914283" style="zoom:60%;" />

```properties
# 应用名称
spring.application.name=demo
# 应用服务 WEB 访问端口
server.port=8080

# 关闭输出栏的banner图框显示
# spring.main.banner-mode=off
# 启动栏的banner，可以换成图片
spring.banner.image.location=static/s1.jpg

# 设置日志相关info、debug,warn，error
logging.level.root = info
```

### 其他内置属性

SpringBoot内置属性查询：[Common Application Properties (spring.io)](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties.core.spring.banner.image.location)

官方文档中参考文档第一项：Application Properties

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207251455170.png" alt="image-20220725145559068" style="zoom:67%;" />

## 访问静态资源

> 现在static目录下放置资源

> 注意：要先 mvn clean一下项目再运行，不然访问不了

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261911929.png" alt="image-20230126191142832" style="zoom:67%;" />

可以直接访问这些静态文件

:8080/pic/g4.jpg

:8080/y1.png

![image-20230126191642041](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261916319.png)

# Banner详细配置

Spring Boot 在启动的时候，我们或许想要把自己公司的 logo，或者是项目的 logo 放上去，我们可以试试本文的这些方法，可以让你快速制作一些 Spring Boot 项目启动时的彩蛋，以提高项目的辨识度，或者是纯碎为了给枯燥的生活平添一些乐趣，那么本文这些内容能很好的帮助到你。

本文知识点，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102305404.png" alt="image-20220710230532317" style="zoom:67%;" />

## Banner效果展示

Spring Boot 默认的 banner 图展示效果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102305298.png" alt="image-20220710230555212" style="zoom: 50%;" />

我们可以把它变成这样的：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102306665.png" alt="image-20220710230611587" style="zoom:67%;" />

或者是这样的：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102306006.png" alt="image-20220710230633883" style="zoom: 50%;" />

简直秀的飞起，**不但能自定义内容，还能自定义颜色**，那接下来我们就来看它是如何实现的吧。

## Banner自定义

> 自定义 banner 的实现方式有两种，一种是通过重写自定义的 Banner 类来实现，另一种通过 txt 文件来实现
>

### 重写Banner类

首先，需要自定义类实现 Banner 接口，实现代码如下：

```java
import org.springframework.boot.Banner;
import org.springframework.core.env.Environment;
import java.io.PrintStream;

public class MyBanner implements Banner {
    private static final String BANNER =
            "  ___ ___         .__  .__          \n" +
                    " /   |   \\   ____ |  | |  |   ____  \n" +
                    "/    ~    \\_/ __ \\|  | |  |  /  _ \\ \n" +
                    "\\    Y    /\\  ___/|  |_|  |_(  <_> )\n" +
                    " \\___|_  /  \\___  >____/____/\\____/ \n" +
                    "       \\/       \\/                  ";

    @Override
    public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
        out.println(BANNER);
        out.println();
    }
}
```

其中 `BANNER` 变量为自定义 banner 的内容，我这放入了一个 `hello`，然后在 Spring Boot 启动时设置 Banner 类为自定义类，实现代码如下：

```java
public static void main(String[] args) {
    SpringApplication springApplication = new SpringApplication(DemoApplication.class);
    // 设置自定义 Banner
    springApplication.setBanner(new MyBanner());
    // 启动 Spring Boot
    springApplication.run(args);
}
```

最终的执行效果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102307453.png" alt="image-20220710230726368" style="zoom:50%;" />

### 通过txt文件实现⭐

> 我们可以在 Spring Boot 工程的 /src/main/resources 目录下创建一个 banner.txt 文件，然后将 ASCII 字符画复制进去，就能替换默认的 banner 了，此种方式实现起来比较简单，且是无代码侵入式的，推荐使用这种方式。
>

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjXdXJ1Qc4kALpzLCMlCM8WbXZODrUicicHSBMmDQsxdT8wpfWOn7vX3KnZJFNDTzcw026wQbQia6eWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

之所以可以使用 banner.txt 文件的方式实现自定义 banner 是因为 Spring Boot 框架在启动时会按照以下顺序，查找 banner 信息：

> - 先在 Classpath 下找 文件 banner.gif 或 banner.jpg 或 banner.png , 先找到谁就用谁；
> - 以上都没有就在 Classpath 下找 banner.txt；
> - 如果都没找到才会使用默认的 SpringBootBanner。

所以我们才能使用 banner.txt 自定义 banner 信息，当然你也可以使用图片的方式来自定义 banner。

> 小技巧：我们可以使用 banner.gif 来实现动态 banner 的效果，动手试试吧。

## Banner样式控制

上面讲了 banner 文字部分的修改，我们还可以修改 banner 的演示以及其他属性，例如字体的样式，粗体、斜体等，Spring Boot 为提供了三个枚举类来设定这些样式，他们分别是：

### 设置颜色

- AnsiColor：用来设定字符的前景色；
- AnsiBackground：用来设定字符的背景色。
- AnsiStyle：用来控制加粗、斜体、下划线等等。

例如，我们可以使用 AnsiColor 来设置颜色，banner.txt 中的信息如下：

```java
${AnsiColor.BRIGHT_RED}  _  _              _       _
${AnsiColor.BRIGHT_RED} | || |    ___     | |     | |     ___
${AnsiColor.BRIGHT_YELLOW} | __ |   / -_)    | |     | |    / _ \
${AnsiColor.BRIGHT_YELLOW} |_||_|   \___|   _|_|_   _|_|_   \___/
${AnsiColor.BRIGHT_RED}_|"""""|_|"""""|_|"""""|_|"""""|_|"""""|
${AnsiColor.BRIGHT_RED}"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'
```

最终的展示效果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102308348.png" alt="image-20220710230859263" style="zoom:50%;" />

### 输出全局变量

在 banner.txt 中我们还可以输出一些全局变量，例如：

- ${application.version}：用来获取 MANIFEST.MF 文件中的版本号；
- ${application.formatted-version}：格式化后的 ${application.version} 版本信息；
- ${spring-boot.version}：Spring Boot 版本号；
- ${spring-boot.formatted-version}：格式化后的 ${spring-boot.version} 版本信息。

使用示例如下：

```apl
      /¯¯¯¯\     
    o-|[][]|-o   
      |_--_|     
   /¯¯¯¯¯¯¯¯¯¯\  
   |||  «»  |||  
   |||      |||  
  (o)|      |(o) 
     |  ||  |    
     |__||__|    
     |__||__|

Spring Boot 版本：${spring-boot.version}
```

## Banner在线生成⭐

在线生成 banner 的地址：

- https://www.bootschool.net/ascii
- http://www.network-science.de/ascii/
- http://patorjk.com/software/taag/
- http://www.degraeve.com/img2txt.php

推荐使用第一种和第三种，使用缩略图如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102310153.png" alt="image-20220710231044056" style="zoom: 50%;" />

## Banner关闭

如果我们需要隐藏 banner 信息，可以通过以下**三种方法**实现。

### 1.通过代码关闭Banner

我们可以在 Spring Boot 启动（run）之前设置隐藏 banner，实现代码如下：

```java
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication springApplication = new SpringApplication(DemoApplication.class);
        // 隐藏 banner
        springApplication.setBannerMode(Banner.Mode.OFF);
        // 启动 Spring Boot
        springApplication.run(args);
    }
}
```

### 2.通过配置文件隐藏Banner⭐

在 Spring Boot 的配置文件 `application.properties` 通过设置如下配置来隐藏 banner 的显示，配置如下：

```properties
spring.main.banner-mode=off
```

### 3.在Idea中隐藏Banner

我们可以在 Idea 的调试配置中隐藏 banner，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102314444.png" alt="image-20220710231441331" style="zoom:50%;" />

## 附：彩蛋

文章的末尾，附一个七彩佛祖的 banner 内容：

在resource目录下创建banner.txt即可

```apl
${AnsiColor.BRIGHT_GREEN}$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
${AnsiColor.BRIGHT_YELLOW}$$                                _.ooOoo._                               $$
${AnsiColor.BRIGHT_RED}$$                               o888888888o                              $$
${AnsiColor.BRIGHT_CYAN}$$                               88"  .  "88                              $$
${AnsiColor.BRIGHT_MAGENTA}$$                               (|  ^_^  |)                              $$
${AnsiColor.BRIGHT_GREEN}$$                               O\   =   /O                              $$
${AnsiColor.BRIGHT_RED}$$                            ____/`-----'\____                           $$
${AnsiColor.BRIGHT_CYAN}$$                          .'  \\|       |$$  `.                         $$
${AnsiColor.BRIGHT_MAGENTA}$$                         /  \\|||   :   |||$$  \                        $$
${AnsiColor.BRIGHT_GREEN}$$                        /  _|||||  -:-  |||||-  \                       $$
${AnsiColor.BRIGHT_YELLOW}$$                        |   | \\\   -   $$/ |   |                       $$
${AnsiColor.BRIGHT_GREEN}$$                        | \_|  ''\-----/''  |   |                       $$
${AnsiColor.BRIGHT_YELLOW}$$                        \  .-\___  `-`  ____/-. /                       $$
${AnsiColor.BRIGHT_CYAN}$$                      ___`. .'   /--.--\   `. . ___                     $$
${AnsiColor.BRIGHT_RED}$$                    ."" '<  `.____\_<|>_/____.'  >'"".                  $$
${AnsiColor.BRIGHT_GREEN}$$                  | | :  `- \`.;`.\ _ /``;.`/ - ` : | |                 $$
${AnsiColor.BRIGHT_YELLOW}$$                  \  \ `-.   \_ ___\ /___ _/   .-` /  /                 $$
${AnsiColor.BRIGHT_CYAN}$$            ========`-.____`-.____\_____/____.-`____.-'========         $$
${AnsiColor.BRIGHT_MAGENTA}$$                                  `=---='                               $$
${AnsiColor.BRIGHT_YELLOW}$$            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        $$
${AnsiColor.BRIGHT_GREEN}$$                     佛祖保佑          永无BUG         永不修改         $$
${AnsiColor.BRIGHT_YELLOW}$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
${AnsiColor.BRIGHT_YELLOW}
```

实现效果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207102311657.png" alt="image-20220710231110534" style="zoom:50%;" />

# 配置文件

## 配置文件概览

### 三种格式配置

> - SpringBoot提供了2种配置文件类型：properteis和yml/yaml 
> - 默认配置文件名称：application 
> - 配置文件加载顺序：properties > yml > yaml
> - **不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261047663.png" alt="image-20230126104726586" style="zoom:67%;" />

### 自动提示功能消失

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261053296.png" alt="image-20230126105302202" style="zoom:67%;" />

## properties 格式

常见的一种配置文件格式，Spring中也是用这种格式，语法结构很简单，结构为：`key=value`。具体如下：

```properties
userinfo.name=myjszl
userinfo.age=25
userinfo.active=true
userinfo.created-date=2018/03/31 16:54:30
userinfo.map.k1=v1
userinfo.map.k2=v2
```

上述配置文件中对应的实体类如下：

```java
@Data
@ToString
public class UserInfo {
    private String name;
    private Integer age;
    private Boolean active;
    private Map<String,Object> map;
    private Date createdDate;
    private List<String> hobbies;
}
```

结构很简单，无非就是`key=value`这种形式，也是在开发中用的比较多的一种格式。

## YML 格式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261046977.png" alt="image-20230126104654891" style="zoom:67%;" />

> 以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用tab代替空格。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261109549.png" alt="image-20230126110913449" style="zoom:67%;" />

## YML 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261111123.png" alt="image-20230126111110039" style="zoom:67%;" />

## 如何使用YML文件

在`src/resources`文件夹下创建一个`application.yml`文件。支持的类型主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。

具体的示例如下：

```yml
userinfo:
    age: 25
    name: myjszl
    active: true
    created-date: 2018/03/31 16:54:30
    map: {k1: v1,k2: v2}
    hobbies:
      - one
      - two
      - three
```

上述配置文件对应的实体类如下：

```java
@Data
@ToString
public class UserInfo {
    private String name;
    private Integer age;
    private Boolean active;
    private Map<String,Object> map;
    private Date createdDate;
    private List<String> hobbies;
}
```

1. **字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字符**
2. **数组类型，短横线后面要有空格；对象类型，冒号后面要有空格**
3. **YAML是以空格缩进的程度来控制层级关系，但不能用tab键代替空格，大小写敏感**

## YML数据格式⭐

注意：冒号后要跟上**一个空格**

```yml
jdbc:
  driverClassName: com.mysql.jdbc.Driver
  url: jdbc:mysql://127.0.0.1:3306/heima
  username: root
  password: 123456
```

如果两个properties和yml两个配置文件都有，会把两个文件的配置合并，如果有重复属性，以properties中的为准。

### 字面量类型

![image-20230126111519440](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261115526.png)

### 数组类型

在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261120349.png" alt="image-20230126112005247" style="zoom:67%;" />

```yml
# 对象数组格式
users:
  -
    name: Tom
    age: 4
  -
    name: Jerry
    age: 5
# 对象数组单行格式
users2: [{name: Tom1,age: 4},{name: Jerry1,age: 5}]
```



### 变量引用⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261135286.png" alt="image-20230126113526211" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261136792.png" alt="image-20230126113618707" style="zoom:67%;" />

```yml
# 纯量
msg1: 'hello \n world' # 加引号进行忽略转义字符

# 参数引用：引用上面写的值
data:
  ms: ${msg1}
```



### 字符串

字符串是最简单的配置，也是最常见的配置。再spring中，字符串可以代引号，也可以不带引号。所以下面三行的配置效果，是一样的。

```yml
str1: ksdfjsdlkfjdsf skdfljs
str1: 'ksdfjsdlkfjdsf skdfljs'
str1: "ksdfjsdlkfjdsf skdfljs"
```

那么，如何支持多行文本呢？毕竟有些需求，就是这么作死。写法如下：

```yml
str1: |
  ksdfjsdlkfjdsf skdfljs
  ksdfjsdlkfjdsf skdfljs
  ksdfjsdlkfjdsf skdfljs
```

注意，后面不需要有其他的画蛇添足的结束表示，一切都是靠缩进来证明的。当然，你也可以把 `|`换成`>`，效果是一样的。

```yml
str1: >
  ksdfjsdlkfjdsf skdfljs
  ksdfjsdlkfjdsf skdfljs
  ksdfjsdlkfjdsf skdfljs
```

要命的是，它还有第三种写法。

```yml
str1: "ksdfjsdlkfjdsf skdfljs
  ksdfjsdlkfjdsf skdfljs
  ksdfjsdlkfjdsf skdfljs"
```

### 对象类型

由字典，很容易可以扩展到对象。因为对象，也是一堆属性的集合。json已经证明，这些属性，就是一堆KV，我们的yaml也是如此。

假设有如下的代码，我们需要构造dog中的数据。

第一种yml的写法，是这样。

```yml
dog:
  xjjdog1: i am xjjdog1
  xjjdog2: i am xjjdog2
```

而另一种方式，是把json数据直接给写到文件里。

```yml
dog: {xjjdog1: 'i am xjjdog1',xjjdog2: 'i am xjjdog2'}
```

当然，多个层次，可以在一行之中平铺开。比如prefix是super.dog，那么yml文件就可以这么写。

```yml
#  行内写法
super.dog: {xjjdog1: 'i am xjjdog1',xjjdog2: 'i am xjjdog2'}
person1: {age: 22}
```

### 特殊类型

即使是这样，yaml也比xml简单的多。它也有很多特殊的写法。比如这个。

```yml
str1: !!str 2021-06-03
```

它的意思是，把2021-06-04，强制转化成字符串。这样的强制转化有很多，但大多数时候你不会用。但如果你想要把你的yaml文件变得复杂，让别人不敢动，那就可以这么做。

```yml
!!int               # 整数类型
!!float             # 浮点类型
!!bool              # 布尔类型
!!str               # 字符串类型
!!binary            # 也是字符串类型
!!timestamp         # 日期时间类型
!!null              # 空值
!!set               # 集合
!!omap, !!pairs     # 键值列表或对象列表
!!seq               # 序列，也是列表
!!map               # 键值表
```

既然yml文件有这么多复杂的写法，那么我们就可以去玩一把。比如下面的写法。

```yml
from: &d !!str 2021-06-04
str1: *d
```

这个配置，和上面的配置，效果是一样的，`&`的意思是标记，我们给它起了个名字，叫做`d`；`*`的意思是引用，我们在需要它的地方引用一把就可以了。

yml中的key，竟然也可以用对象或者复杂的结构作为key。为了标识是一个特殊的key，我们还要做一点处理。

```yml
?[blue, reg, green]: Color
```

上面这个配置的`?`，就是说，我下面要进行一个比较复杂的配置了，你准备好了么？

## 配置多个yml文件

> 多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称`必须为application-*.yml`，并且这些配置文件必须要在application.yml配置文件中**激活之后才可以使用**。
>
> 如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。

> 在多个配置文件时，需要将这些文件在application.yml文件中进行激活：注意：填写文件名时，只需要填后缀。比如application-abc.yml只需要写成 abc 即可，多个配置文件用逗号隔开，如下
>

```yml
# 激活配置文件;需要指定其它的配置文件名称
spring:
  profiles:
    active: abc,def
```

# 读取配置文件⭐

## @Value

### 使用基础

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261128481.png" alt="image-20230126112856382" style="zoom:60%;" />

```java
@RestController
public class TestValueController {
	//读取对象
    @Value("${person.name}")
    private String name;
	//读取数组
    @Value("${address[0]}")
    private String add1;
	//读取常量
    @Value("${msg1}")
    private String msg1;
    //读取引用
    @Value("${data.ms}")
    private String ms;

    @GetMapping("getValue")
    public String getValue(){
        System.out.println(name+add1+msg1+ms);
        return "1";
    }
}
```

### 注意事项

> @value注解属性static无法获取值

```java
@Value("${appId}")
private static String appid;
```

这样是无法直接获得值的，需要这样写

```java
private static String appid;

@Value("${appId}")
public void setAppid(String appId) {
    this.appid = appid;
}
```



## @Environment  

第二种：简单一点，数据封装全部数据到Environment对象

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031194429203.png" alt="image-20211031194429203" style="zoom:80%;" />

```java
@RestController
public class TestValueController {

    @Autowired
    private Environment env;

    @GetMapping("getValue")
    public String getValue(){
        System.out.println(env.getProperty("person1.age"));
        System.out.println(env.getProperty("address[1]"));
        return "1";
    }
}
```



## @ConfigurationProperties ⭐

### 基本语法

> 第三种：复杂一点，上面的Enveriment是封装所有数据，但是我要自定义封装指定数据，怎么做？自定义对象封装指定数据，属性类中名字要对的上，同时生成对应的get/set方法
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211031194901916.png" alt="image-20211031194901916" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271558093.png" alt="image-20230127155853991" style="zoom:67%;" />

### 使用实例⭐

yml

```yml
datasource:
  driver-class-name: com.mysql.cj.jdbc.Driver
  url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC
  username: root
  password: root
```

实体类

```java
@Component
// prefix是yml对应的属性名
@ConfigurationProperties(prefix = "datasource")
public class DataSource {
    // 这里面的属性名要和yml里的属性名保持字母一致，大小写无所谓，因为松散绑定
    private String driverClassName;
    private String url;
    private String userName;
    private String password;
    // 省略了getter/setter和toString方法
}
```

测试

```java
@RestController
@RequestMapping("/books")
public class HelloController {
    
    @Autowired
    private DataSource dataSource;

    @GetMapping("getCon")
    public String getCon(){
        System.out.println(dataSource);
        System.out.println(dataSource.getDriverClassName());
        System.out.println(dataSource.getUrl());
        System.out.println(dataSource.getUserName());
        System.out.println(dataSource.getPassword());
        return "springboot is running...";
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261206074.png" alt="image-20230126120600007" style="zoom:67%;" />

### 注意事项

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271556985.png" alt="image-20230127155658905" style="zoom:67%;" />

加上此依赖可以实现普通实体类上属性在yml上写属性有提示。也能去掉@ConfigurationProperties产生的类上提示信息

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

### 第三方bean绑定

#### 正常绑定方式

```yml
servers:
  # 驼峰模式
  ipAddress: 192.168.0.1
  # 常量模式(全部大写)
  port: 2345
  # 随意模式
  timeout: -1
```

```java
@Component
@Data
@ConfigurationProperties(prefix = "servers")
public class ServerConfig {
    private String ipAddress;
    private int port;
    private long timeout;
}
```

```java
@SpringBootApplication
public class SpringBootDemoApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext ctx = SpringApplication
                                             .run(SpringBootDemoApplication.class, args);
        ServerConfig bean = ctx.getBean(ServerConfig.class);
        System.out.println(bean);
    }

}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271616674.png" alt="image-20230127161633580" style="zoom:67%;" />

#### 第三方bean绑定方式

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.15</version>
</dependency>
```

```yml
datasource:
  driver-class-name: com.mysql.cj.jdbc.Driver123
```

```java
@SpringBootApplication
public class SpringBootDemoApplication {

    @Bean
    @ConfigurationProperties(prefix = "datasource")
    public DruidDataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        return ds;
    }

    public static void main(String[] args) {
        ConfigurableApplicationContext ctx = SpringApplication
                                             .run(SpringBootDemoApplication.class, args);
        DruidDataSource bean1 = ctx.getBean(DruidDataSource.class);
        System.out.println(bean1.getDriverClassName());
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271626220.png" alt="image-20230127162623132" style="zoom:67%;" />

### EnableConfigurationProperties

> 主类加上这个注解，这些配置类就不用再加上@Component了

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271629357.png" alt="image-20230127162935265" style="zoom:67%;" />

```java
@Component
@Data
@ConfigurationProperties(prefix = "servers")
public class ServerConfig {
    private String ipAddress;
    private int port;
    private long timeout;
}
```

更改为

```java
@Data
@ConfigurationProperties(prefix = "servers")
public class ServerConfig {
    private String ipAddress;
    private int port;
    private long timeout;
}
```

```java
@SpringBootApplication
@EnableConfigurationProperties(ServerConfig.class)
public class SpringBootDemoApplication {
    
}
```



### 松散绑定

> @ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上
>
> @Value注解不支持松散绑定规则，绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271634129.png" alt="image-20230127163438015" style="zoom:60%;" />

```java
@Component
@Data
@ConfigurationProperties(prefix = "servers")
public class ServerConfig {
    private String ipAddress;
    private int port;
    private long timeout;
}
```

注意看application.yml中，与上面一一对应，全部都能正常读取

```yml
servers:
  # 驼峰模式
  ipAddress: 192.168.0.1
  # 常量模式(全部大写)
  PORT: 2345
  # 随意模式
  TiMeouT: -1
```

读取属性测试

```java
@SpringBootTest
class SpringBootDemoApplicationTests {

    @Autowired
    private ServerConfig config;

    @Test
    public void getAll() {
        String ipAddress = config.getIpAddress();
        int port = config.getPort();
        long timeout = config.getTimeout();
        System.out.println("ipAddress = " + ipAddress);
        System.out.println("timeout = " + timeout);
        System.out.println("port = " + port);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271638778.png" alt="image-20230127163811691" style="zoom:80%;" />

![image-20230127155825828](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271558923.png)

### 常用计量单位

> JDK8支持的时间与空间计量单位

![image-20230127165549990](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271655141.png)

```yml
servers:
  # 驼峰模式
  ip-address: 192.168.0.1
  # 常量模式(全部大写)
  PORT: 2345
  serverTimeOut: 30
  dataSize: 20
```

```java
@Data
@Component
@ConfigurationProperties(prefix = "servers")
public class ServerConfig {
    private String ipAddress;
    private int port;
    @DurationUnit(ChronoUnit.MINUTES)
    private Duration serverTimeout;
    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize dataSize;
}
```

```java
@SpringBootTest
class SpringBootDemoApplicationTests {

    @Autowired
    private ServerConfig config;

    @Test
    public void getAll() {
        String ipAddress = config.getIpAddress();
        Duration serverTimeout = config.getServerTimeout();
        DataSize dataSize = config.getDataSize();
        System.out.println("ipAddress = " + ipAddress);
        System.out.println("serverTimeout = " + serverTimeout);
        System.out.println("dataSize = " + dataSize);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271702429.png" alt="image-20230127170234339" style="zoom:67%;" />

# 参数校验

[SpringBoot 实现各种参数校验，写得太好了，建议收藏！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247496197&idx=2&sn=2df7fe8ba6adec81eba16b819eff56e4&chksm=fc2c4e0dcb5bc71b4a2548742526df1300e691932cb364c05a1a7368f513cc171e4f08adb19c&mpshare=1&scene=23&srcid=0522kWR3eZpv64DsrZ0FvEcs&sharer_sharetime=1653149502624&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> Java API规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。
>

> Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。接下来，我们以spring-boot项目为例，介绍Spring Validation的使用。
>

## 基础实验

### 引入依赖

如果spring-boot版本小于2.3.x，spring-boot-starter-web会自动传入hibernate-validator依赖。如果spring-boot版本大于2.3.x，则需要手动引入依赖：

```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.0.1.Final</version>
</dependency>
```

对于web服务来说，为防止非法参数对业务造成影响，在Controller层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：

- POST、PUT请求，使用requestBody传递参数；
- GET请求，使用requestParam/PathVariable传递参数。

下面我们简单介绍下requestBody和requestParam/PathVariable的参数校验实战！

### RequestBody参数校验

POST、PUT请求一般会使用requestBody传递参数，这种情况下，后端使用DTO对象进行接收。只要给DTO对象加上@Validated注解就能实现自动参数校验。比如，有一个保存User的接口，要求userName长度是2-10，account和password字段长度是6-20。

`如果校验失败，会抛出MethodArgumentNotValidException异常，Spring默认会将其转为400（Bad Request）请求`。

> DTO表示数据传输对象（Data Transfer Object），用于服务器和客户端之间交互传输使用的。在spring-web项目中可以表示用于接收请求参数的Bean对象。

在DTO字段上声明约束注解

```java
@Data
public class UserDTO {

    private Long userId;

    @NotNull
    @Length(min = 2, max = 10)
    private String userName;

    @NotNull
    @Length(min = 6, max = 20)
    private String account;

    @NotNull
    @Length(min = 6, max = 20)
    private String password;
}
```

在方法参数上声明校验注解

```java
@PostMapping("/save")
public Result saveUser(@RequestBody @Validated UserDTO userDTO) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}
```

这种情况下，使用@Valid和@Validated都可以。

### RequestParam/PathVariable参数校验

GET请求一般会使用requestParam/PathVariable传参。如果参数比较多(比如超过6个)，还是推荐使用DTO对象接收。

否则，推荐将一个个参数平铺到方法入参中。在这种情况下，必须在Controller类上标注@Validated注解，并在入参上声明约束注解(如@Min等)。如果校验失败，会抛出ConstraintViolationException异常。

代码示例如下：

```java
@RequestMapping("/api/user")
@RestController
@Validated
public class UserController {
    // 路径变量
    @GetMapping("{userId}")
    public Result detail(@PathVariable("userId") @Min(10000000000000000L) Long userId) {
        // 校验通过，才会执行业务逻辑处理
        UserDTO userDTO = new UserDTO();
        userDTO.setUserId(userId);
        userDTO.setAccount("11111111111111111");
        userDTO.setUserName("xixi");
        userDTO.setAccount("11111111111111111");
        return Result.ok(userDTO);
    }

    // 查询参数
    @GetMapping("getByAccount")
    public Result getByAccount(@Length(min = 6, max = 20) @NotNull String  account) {
        // 校验通过，才会执行业务逻辑处理
        UserDTO userDTO = new UserDTO();
        userDTO.setUserId(10000000000000003L);
        userDTO.setAccount(account);
        userDTO.setUserName("xixi");
        userDTO.setAccount("11111111111111111");
        return Result.ok(userDTO);
    }
}
```

### 统一异常处理(推荐)

`前面说过，如果校验失败，会抛出MethodArgumentNotValidException或者ConstraintViolationException异常。在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示`。

比如我们系统要求无论发送什么异常，http的状态码必须返回200，由业务码去区分系统的异常情况。

统一返回结果

```java
@Data
@Accessors(chain = true)
public class Result<T> implements Serializable {

    private static final long serialVersionUID = -504027247149928390L;

    private int code;
    private String msg;
    private String exceptionMsg;
    private T body;

    public static <T> Result ok(T body) {
        return new Result<>()
                .setBody(body)
                .setCode(BusinessCode.成功.code())
                .setMsg(BusinessCode.成功.message());
    }

    public static Result ok() {
        return new Result<>()
                .setCode(BusinessCode.成功.code())
                .setMsg(BusinessCode.成功.message());
    }

    public static Result fail(ReturnCode returnCode) {
        return new Result<>()
                .setCode(returnCode.code())
                .setMsg(returnCode.message());
    }

    public static Result fail(ReturnCode returnCode, String exceptionMsg) {
        return new Result<>()
                .setCode(returnCode.code())
                .setMsg(returnCode.message())
                .setExceptionMsg(exceptionMsg);
    }
}
```

统一异常处理

```java
@RestControllerAdvice
public class CommonExceptionHandler {
    @ExceptionHandler({MethodArgumentNotValidException.class})
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Result handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {
        BindingResult bindingResult = ex.getBindingResult();
        StringBuilder sb = new StringBuilder("校验失败:");
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            sb.append(fieldError.getField()).append("：")
                .append(fieldError.getDefaultMessage()).append(", ");
        }
        String msg = sb.toString();
       return Result.fail(BusinessCode.参数校验失败, msg);
    }

    @ExceptionHandler({ConstraintViolationException.class})
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Result handleConstraintViolationException(ConstraintViolationException ex) {
        return Result.fail(BusinessCode.参数校验失败, ex.getMessage());
    }
}
```

没上面Result返回实现类，用下面这个

```java
import org.springframework.http.HttpStatus;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import javax.validation.ConstraintViolationException;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class CommonExceptionHandler {

    @ExceptionHandler({MethodArgumentNotValidException.class})
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Map<Object, Object> 
        handleMethodArgumentNotValidException(MethodArgumentNotValidException ex) {
        BindingResult bindingResult = ex.getBindingResult();
        StringBuilder sb = new StringBuilder("校验失败:");
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            sb.append(fieldError.getField())
                .append("：").append(fieldError.getDefaultMessage()).append(", ");
        }
        String msg = sb.toString();
        Map<Object, Object> map = new HashMap<>();
        map.put("code", HttpStatus.EXPECTATION_FAILED.value());
        map.put("msg", msg);
        return map;
    }

    @ExceptionHandler({ConstraintViolationException.class})
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Map<Object, Object> 
        handleConstraintViolationException(ConstraintViolationException ex) {
        Map<Object, Object> map = new HashMap<>();
        map.put("code", "参数校验失败");
        map.put("msg", ex);
        return map;
    }
}
```

访问测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205221241126.png" alt="image-20220522124132059" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205221241302.png" alt="image-20220522124159241" style="zoom:80%;" />



## 进阶使用

### 分组校验

在实际项目中，可能多个方法需要使用同一个DTO类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在DTO类的字段上加约束注解无法解决这个问题。因此，spring-validation支持了分组校验的功能，专门用来解决这类问题。

还是上面的例子，比如保存User的时候，UserId是可空的，但是更新User的时候，UserId的值必须>=10000000000000000L；其它字段的校验规则在两种情况下一样。这个时候使用分组校验的代码示例如下：

约束注解上声明适用的分组信息groups

```java
@Data
public class UserDTO {

    @Min(value = 10000000000000000L, groups = Update.class)
    private Long userId;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 2, max = 10, groups = {Save.class, Update.class})
    private String userName;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String account;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String password;

    /**
     * 保存的时候校验分组
     */
    public interface Save {
    }

    /**
     * 更新的时候校验分组
     */
    public interface Update {
    }
}
```

@Validated注解上指定校验分组

```java
@PostMapping("/save")
public Result saveUser(@RequestBody @Validated(UserDTO.Save.class) UserDTO userDTO) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}

@PostMapping("/update")
public Result updateUser(@RequestBody @Validated(UserDTO.Update.class) UserDTO userDTO) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}
```

### 嵌套校验

前面的示例中，DTO类里面的字段都是基本数据类型和String类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。

比如，上面保存User信息的时候同时还带有Job信息。需要注意的是，此时DTO类的对应字段必须标记@Valid注解。

```java
@Data
public class UserDTO {

    @Min(value = 10000000000000000L, groups = Update.class)
    private Long userId;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 2, max = 10, groups = {Save.class, Update.class})
    private String userName;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String account;

    @NotNull(groups = {Save.class, Update.class})
    @Length(min = 6, max = 20, groups = {Save.class, Update.class})
    private String password;

    @NotNull(groups = {Save.class, Update.class})
    @Valid
    private Job job;

    @Data
    public static class Job {

        @Min(value = 1, groups = Update.class)
        private Long jobId;

        @NotNull(groups = {Save.class, Update.class})
        @Length(min = 2, max = 10, groups = {Save.class, Update.class})
        private String jobName;

        @NotNull(groups = {Save.class, Update.class})
        @Length(min = 2, max = 10, groups = {Save.class, Update.class})
        private String position;
    }

    /**
     * 保存的时候校验分组
     */
    public interface Save {
    }

    /**
     * 更新的时候校验分组
     */
    public interface Update {
    }
}
```

嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如`List<Job>`字段会对这个list里面的每一个Job对象都进行校验

### 集合校验

如果请求体直接传递了json数组给后台，并希望对数组中的每一项都进行参数校验。此时，如果我们直接使用java.util.Collection下的list或者set来接收数据，参数校验并不会生效！我们可以使用自定义list集合来接收参数：

包装List类型，并声明@Valid注解

```java
public class ValidationList<E> implements List<E> {

    @Delegate // @Delegate是lombok注解
    @Valid // 一定要加@Valid注解
    public List<E> list = new ArrayList<>();

    // 一定要记得重写toString方法
    @Override
    public String toString() {
        return list.toString();
    }
}
```

@Delegate注解受lombok版本限制，1.18.6以上版本可支持。如果校验不通过，会抛出NotReadablePropertyException，同样可以使用统一异常进行处理。

比如，我们需要一次性保存多个User对象，Controller层的方法可以这么写：

```java
@PostMapping("/saveList")
public Result saveList(@RequestBody @Validated(UserDTO.Save.class) 
                       ValidationList<UserDTO> userList) {
    // 校验通过，才会执行业务逻辑处理
    return Result.ok();
}
```

### 自定义校验

业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。

自定义spring validation非常简单，假设我们自定义加密id（由数字或者a-f的字母组成，32-256长度）校验，主要分为两步：

自定义约束注解

```java
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {EncryptIdValidator.class})
public @interface EncryptId {

    // 默认错误消息
    String message() default "加密id格式错误";

    // 分组
    Class<?>[] groups() default {};

    // 负载
    Class<? extends Payload>[] payload() default {};
}
```

实现ConstraintValidator接口编写约束校验器

```java
public class EncryptIdValidator implements ConstraintValidator<EncryptId, String> {

    private static final Pattern PATTERN = Pattern.compile("^[a-f\\d]{32,256}$");

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // 不为null才进行校验
        if (value != null) {
            Matcher matcher = PATTERN.matcher(value);
            return matcher.find();
        }
        return true;
    }
}
```

这样我们就可以使用@EncryptId进行参数校验了！

### 编程式校验

> 上面的示例都是基于注解来实现自动校验的，在某些情况下，我们可能希望以编程方式调用验证。这个时候可以注入javax.validation.Validator对象，然后再调用其api

```java
@Autowired
private javax.validation.Validator globalValidator;

// 编程式校验
@PostMapping("/saveWithCodingValidate")
public Result saveWithCodingValidate(@RequestBody UserDTO userDTO) {
    Set<ConstraintViolation<UserDTO>> validate = globalValidator.validate(userDTO,
                                                                         UserDTO.Save.class);
    // 如果校验通过，validate为空；否则，validate包含未校验通过项
    if (validate.isEmpty()) {
        // 校验通过，才会执行业务逻辑处理

    } else {
        for (ConstraintViolation<UserDTO> userDTOConstraintViolation : validate) {
            // 校验失败，做其它逻辑
            System.out.println(userDTOConstraintViolation);
        }
    }
    return Result.ok();
}
```

### 快速失败(Fail Fast)

Spring Validation默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启Fali Fast模式，一旦校验失败就立即返回。

```java
@Bean
public Validator validator() {
    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)
            .configure()
            // 快速失败模式
            .failFast(true)
            .buildValidatorFactory();
    return validatorFactory.getValidator();
}
```



## Spring-Validation

### 添加依赖

Spring Boot整合JSR-303只需要添加一个`starter`即可，如下：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

### 内嵌注解(重点)

`Bean Validation` 内嵌的注解很多，基本实际开发中已经够用了，注解如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207011025109.png" alt="image-20220701102519993" style="zoom:67%;" />

以上是`Bean Validation`的内嵌的注解，但是`Hibernate Validator`在原有的基础上也内嵌了几个注解，如下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207011027213.png" alt="image-20220701102728123" style="zoom:67%;" />

### 如何使用？

参数校验分为**简单校验**、**嵌套校验**、**分组校验**。

#### 定义全局异常处理

```java
@RestControllerAdvice
public class ExceptionRsHandler {

    @Resource
    private ObjectMapper objectMapper;

    // 参数校验异常步骤
    @ExceptionHandler(value= {MethodArgumentNotValidException.class , BindException.class})
    public String onException(Exception e) throws JsonProcessingException {
        BindingResult bindingResult = null;
        if (e instanceof MethodArgumentNotValidException) {
            bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();
        } else if (e instanceof BindException) {
            bindingResult = ((BindException)e).getBindingResult();
        }
        //添加异常信息
        Map<String,String> errorMap = new HashMap<>(16);
        bindingResult.getFieldErrors().forEach((fieldError)->
                errorMap.put(fieldError.getField(),fieldError.getDefaultMessage())
        );
        return objectMapper.writeValueAsString(errorMap);
    }
}
```

#### 简单校验

简单的校验即是没有嵌套属性，直接在需要的元素上标注约束注解即可。如下：

```java
@Data
public class ArticleDTO {

    @NotNull(message = "文章id不能为空")
    @Min(value = 1,message = "文章ID不能为负数")
    private Integer id;

    @NotBlank(message = "文章内容不能为空")
    private String content;

    @NotBlank(message = "作者Id不能为空")
    private String authorId;

    @Future(message = "提交时间不能为过去时间")
    private Date submitTime;
}
```

> 同一个属性可以指定多个约束，比如`@NotNull`和`@MAX`,其中的`message`属性指定了约束条件不满足时的提示信息。

以上约束标记完成之后，要想完成校验，需要在`controller`层的接口标注`@Valid`注解以及声明一个`BindingResult`类型的参数来接收校验的结果。

下面简单的演示下添加文章的接口，如下：

```java
@PostMapping("/add")
public String add(@Valid @RequestBody ArticleDTO articleDTO)  {
    return "添加数据成功";
}
```

```js
{"submitTime":"提交时间不能为过去时间","id":"文章ID不能为负数"}
```

> 仅仅在属性上添加了约束注解还不行，还需在接口参数上标注`@Valid`注解并且声明一个`BindingResult`类型的参数来接收校验结果。

#### 分组校验

举个栗子：上传文章不需要传文章`ID`，但是修改文章需要上传文章`ID`，并且用的都是同一个`DTO`接收参数，此时的约束条件该如何写呢？

此时就需要对这个文章`ID`进行分组校验，上传文章接口是一个分组，不需要执行`@NotNull`校验，修改文章的接口是一个分组，需要执行`@NotNull`的校验。

> 所有的校验注解都有一个`groups`属性用来指定分组，`Class<?>[]`类型，没有实际意义，因此只需要定义一个或者多个接口用来区分即可。

```java
@Data
public class ArticleDTO {

    /**
     * 文章ID只在修改的时候需要检验，因此指定groups为修改的分组
     */
    @NotNull(message = "文章id不能为空",groups = UpdateArticleDTO.class )
    @Min(value = 1,message = "文章ID不能为负数",groups = UpdateArticleDTO.class)
    private Integer id;

    /**
     * 文章内容添加和修改都是必须校验的，groups需要指定两个分组
     */
    @NotBlank(message = "文章内容不能为空",
              groups = {AddArticleDTO.class,UpdateArticleDTO.class})
    private String content;

    @NotBlank(message = "作者Id不能为空",groups = AddArticleDTO.class)
    private String authorId;

    /**
     * 提交时间是添加和修改都需要校验的，因此指定groups两个
     */
    @Future(message = "提交时间不能为过去时间",
            groups = {AddArticleDTO.class,UpdateArticleDTO.class})
    private Date submitTime;
    
    //修改文章的分组
    public interface UpdateArticleDTO{}

    //添加文章的分组
    public interface AddArticleDTO{}

}
```

> JSR303本身的`@Valid`并不支持分组校验，但是Spring在其基础提供了一个注解`@Validated`支持分组校验。`@Validated`这个注解`value`属性指定需要校验的分组。

#### 嵌套校验

嵌套校验简单的解释就是一个实体中包含另外一个实体，并且这两个或者多个实体都需要校验。

举个栗子：文章可以有一个或者多个分类，作者在提交文章的时候必须指定文章分类，而分类是单独一个实体，有`分类ID`、`名称`等等。大致的结构如下：

```java
public class ArticleDTO{
  // ...文章的一些属性.....
  
  // 分类的信息
  private CategoryDTO categoryDTO;
}
```

此时文章和分类的属性都需要校验，这种就叫做嵌套校验。

> 嵌套校验很简单，只需要在嵌套的实体属性标注`@Valid`注解，则其中的属性也将会得到校验，否则不会校验。

如下**文章分类实体类校验**：

```java
/**
 * 文章分类
 */
@Data
public class CategoryDTO {
    @NotNull(message = "分类ID不能为空")
    @Min(value = 1,message = "分类ID不能为负数")
    private Integer id;

    @NotBlank(message = "分类名称不能为空")
    private String name;
}
```

文章的实体类中有个嵌套的文章分类`CategoryDTO`属性，需要使用`@Valid`标注才能嵌套校验，如下：

```java
@Data
public class ArticleDTO {

    @NotBlank(message = "文章内容不能为空")
    private String content;

    @NotBlank(message = "作者Id不能为空")
    private String authorId;

    @Future(message = "提交时间不能为过去时间")
    private Date submitTime;

    /**
     * @Valid这个注解指定CategoryDTO中的属性也需要校验
     */
    @Valid
    @NotNull(message = "分类不能为空")
    private CategoryDTO categoryDTO;
  }
```

`Controller`层的添加文章的接口同上，需要使用`@Valid`或者`@Validated`标注入参，同时需要定义一个`BindingResult`的参数接收校验结果。

> 嵌套校验针对**分组查询**仍然生效，如果嵌套的实体类（比如`CategoryDTO`）中的校验的属性和接口中`@Validated`注解指定的分组不同，则不会校验。

`JSR-303`针对`集合`的嵌套校验也是可行的，比如`List`的嵌套校验，同样需要在属性上标注一个`@Valid`注解才会生效，如下：

```java
@Data
public class ArticleDTO {
    /**
     * @Valid这个注解标注在集合上，将会针对集合中每个元素进行校验
     */
    @Valid
    @Size(min = 1,message = "至少一个分类")
    @NotNull(message = "分类不能为空")
    private List<CategoryDTO> categoryDTOS;
  }
```

> 总结：嵌套校验只需要在需要校验的元素（单个或者集合）上添加`@Valid`注解，接口层需要使用`@Valid`或者`@Validated`注解标注入参。

### 如何接收校验结果

接收校验的结果的方式很多，不过实际开发中最好选择一个优雅的方式，下面介绍常见的两种方式。

#### BindingResult(不推荐)

这种方式需要在`Controller`层的每个接口方法参数中指定，Validator会将校验的信息自动封装到其中。这也是上面例子中一直用的方式。如下：

```java
@PostMapping("/add")
public String add(@Valid @RequestBody ArticleDTO articleDTO, BindingResult bindingResult){}
```

这种方式的弊端很明显，每个接口方法参数都要声明，同时每个方法都要处理校验信息，显然不现实，舍弃。

> 此种方式还有一个优化的方案：使用`AOP`，在`Controller`接口方法执行之前处理`BindingResult`的消息提示，不过这种方案仍然**不推荐使用**。

#### 全局异常捕捉

参数在校验失败的时候会抛出的`MethodArgumentNotValidException`或者`BindException`两种异常，可以在全局的异常处理器中捕捉到这两种异常，将提示信息或者自定义信息返回给客户端。

全局异常捕捉之前有单独写过一篇文章，不理解的可以看[满屏的try-catch，你不瘆得慌？](https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247484881&idx=1&sn=7de738f8950b2a63a549d22a49bc435e&scene=21#wechat_redirect)。

作者这里就不再详细的贴出其他的异常捕获了，仅仅贴一下参数校验的异常捕获（**仅仅举个例子，具体的返回信息需要自己封装**），如下：

```java
@RestControllerAdvice
public class ExceptionRsHandler {

    @Autowired
    private ObjectMapper objectMapper;

    /**
     * 参数校验异常步骤
     */
    @ExceptionHandler(value= {MethodArgumentNotValidException.class , BindException.class})
    public String onException(Exception e) throws JsonProcessingException {
        BindingResult bindingResult = null;
        if (e instanceof MethodArgumentNotValidException) {
            bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();
        } else if (e instanceof BindException) {
            bindingResult = ((BindException)e).getBindingResult();
        }
        Map<String,String> errorMap = new HashMap<>(16);
        bindingResult.getFieldErrors().forEach((fieldError)->
                errorMap.put(fieldError.getField(),fieldError.getDefaultMessage())
        );
        return objectMapper.writeValueAsString(errorMap);
    }

}
```



### 如何自定义校验

虽说在日常的开发中内置的约束注解已经够用了，但是仍然有些时候不能满足需求，需要自定义一些校验约束。

**举个栗子：有这样一个例子，传入的数字要在列举的值范围中，否则校验失败。**

#### 自定义校验注解

首先需要自定义一个校验注解，如下：

```java
@Documented
@Constraint(validatedBy = { EnumValuesConstraintValidator.class})
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@NotNull(message = "不能为空")
public @interface EnumValues {
    /**
     * 提示消息
     */
    String message() default "传入的值不在范围内";

    /**
     * 分组
     * @return
     */
    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * 可以传入的值
     * @return
     */
    int[] values() default { };
}
```

根据`Bean Validation API` 规范的要求有如下三个属性是必须的：

1. `message`：定义消息模板，校验失败时输出
2. `groups`：用于校验分组
3. `payload`：`Bean Validation API` 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被API自身所使用。

除了以上三个必须要的属性，添加了一个`values`属性用来接收限制的范围。

该校验注解头上标注的如下一行代码：

```java
@Constraint(validatedBy = { EnumValuesConstraintValidator.class})
```

这个`@Constraint`注解指定了通过哪个校验器去校验。

> 自定义校验注解可以复用内嵌的注解，比如`@EnumValues`注解头上标注了一个`@NotNull`注解，这样`@EnumValues`就兼具了`@NotNull`的功能。

#### 自定义校验器

`@Constraint`注解指定了校验器为`EnumValuesConstraintValidator`，因此需要自定义一个。

自定义校验器需要实现`ConstraintValidator<A extends Annotation, T>`这个接口，第一个泛型是`校验注解`，第二个是`参数类型`。代码如下：

```java
/**
 * 校验器
 */
public class EnumValuesConstraintValidator implements ConstraintValidator<EnumValues,Integer> {
    /**
     * 存储枚举的值
     */
    private  Set<Integer> ints=new HashSet<>();

    /**
     * 初始化方法
     * @param enumValues 校验的注解
     */
    @Override
    public void initialize(EnumValues enumValues) {
        for (int value : enumValues.values()) {
            ints.add(value);
        }
    }

    /**
     *
     * @param value  入参传的值
     * @param context
     * @return
     */
    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {
        //判断是否包含这个值
        return ints.contains(value);
    }
}
```

> 如果约束注解需要对其他数据类型进行校验，则可以的自定义对应数据类型的校验器，然后在约束注解头上的`@Constraint`注解中指定其他的校验器。

#### 演示

校验注解和校验器自定义成功之后即可使用，如下：

```java
@Data
public class AuthorDTO {
    @EnumValues(values = {1,2},message = "性别只能传入1或者2")
    private Integer gender;
}
```





# 整合第三方技术

## 整合JUnit

### 语法详解

```xml
<!-- 默认导入 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261253102.png" alt="image-20230126125341033" style="zoom:67%;" />

```java
@SpringBootTest
class SpringBootDemoApplicationTests {
    @Test
    void contextLoads() {
        System.out.println("你好，时间");
    }
}
```

### 注意事项

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261257928.png" alt="image-20230126125702857" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261257707.png" alt="image-20230126125737647" style="zoom:67%;" />

```java
// 该测试类不在com.it包下，因此要加上classes
@SpringBootTest(classes = SpringBootApplication.class)
public class t1 {
    @Test
    void contextLoads() {
        System.out.println("你好，时间");
    }
}
```

## 整合MyBatis

①：创建新模块，选择Spring初始化，并配置模块相关基础信息

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261300827.png" alt="image-20230126130057721" style="zoom:67%;" />

②：选择当前模块需要使用的技术集（MyBatis、MySQL）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261301840.png" alt="image-20230126130124744" style="zoom:67%;" />

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!--mybatis依赖-->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.2.2</version>
    </dependency>
    <!--mysql依赖-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!--lombok依赖-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    
</dependencies>
```

③：设置数据源参数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261302647.png" alt="image-20230126130214565" style="zoom:67%;" />

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
    username: root
    password: 123456
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261302479.png" alt="image-20230126130232399" style="zoom:67%;" />

④：定义数据层接口与映射配置

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261303468.png" alt="image-20230126130324381" style="zoom:67%;" />

```java
@Data
public class User {
    private Integer id;
    private String name;
    private String password;
    private String phone;
}
```

```java
@Mapper
public interface UserDao {

    @Select("select * from user")
    public List<User> getAllUsers();

    @Select("select * from user where id = #{id}")
    public User getById(Integer id);
    
}
```

⑤：测试类中注入dao接口，测试功能

![image-20230126130533524](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261305615.png)

```java
@SpringBootTest
class SpringBootDemoApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    public void getAll() {
        List<User> allUsers = userDao.getAllUsers();
        allUsers.forEach(System.out::println);
    }

    @Test
    public void getById() {
        User u1 = userDao.getById(1);
        System.out.println(u1);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261326772.png" alt="image-20230126132630688" style="zoom:67%;" />

## 整合MyBatis-Plus

①：手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--mysql依赖-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!--mybatis-plus依赖-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.2</version>
    </dependency>
    <!--lombok依赖-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```

配置连接

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
    username: root
    password: 123456
```

定义数据层接口与映射配置，继承**BaseMapper**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261333650.png" alt="image-20230126133317566" style="zoom:67%;" />

```java
@Data
public class User {
    private Integer id;
    private String name;
    private String password;
    private String phone;
}
```

```java
@Mapper
public interface UserDao extends BaseMapper<User> {
    
}
```

测试结果

```java
@SpringBootTest
class SpringBootDemoApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    public void getAll() {
        List<User> list = userDao.selectList(null);
        list.forEach(System.out::println);
    }

    @Test
    public void getById() {
        User user = userDao.selectById(1);
        System.out.println(user);
    }
}
```



## 整合Druid

### 添加Druid依赖

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.15</version>
</dependency>
```

### 配置Druid

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
```

```yml
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
      username: root
      password: 123456
```

## 整合 Lombok

> lombok是一个插件工具；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211007181840474.png" alt="image-20211007181840474" style="zoom: 80%;" />

### 使用流程

> 1. 在IDEA中安装lombok插件；
> 2. 添加lombok对应的依赖到项目pom.xml文件；
> 3. 改造实体类使用lombok注解

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.16</version>
</dependency>
```

### 注解分析

#### @Getter and @Setter

使用`@Getter`和/或`@Setter`注释任何字段，以使`lombok`自动生成默认的`getter / setter`。

默认的`getter`只是返回该字段，如果该字段被称为`foo`，则名为`getFoo`（如果该字段的类型为`boolean`，则为`isFoo`）。

默认生成的 `getter / setter`方法是公共的，除非你明确指定一个`AccessLevel`。合法访问级别为`PUBLIC，PROTECTED，PACKAGE和PRIVATE`。

你还可以在类上添加`@Getter`和/或`@Setter`注释。在这种情况下，就好像你使用该注释来注释该类中的所有非静态字段一样。

你始终可以使用特殊的`AccessLevel.NONE`访问级别来手动禁用任何字段的`getter / setter`生成。这使你可以覆盖类上的`@Getter，@Setter或@Data`注释的行为。

```java
public class GetterSetterExample {
  
  @Getter 
  @Setter 
  private int age = 10;
  
  @Setter(AccessLevel.PROTECTED) 
  private String name;
  
  @Override 
  public String toString() {
    return String.format("%s (age: %d)", name, age);
  }
}
```

#### @ToString

任何类定义都可以使用`@ToString`注释，以使`lombok`生成`toString()`方法的实现。

默认情况下，将打印所有非静态字段。如果要跳过某些字段，可以使用`@ ToString.Exclude`注释这些字段。或者，可以通过使用`@ToString（onlyExplicitlyIncluded = true）`，然后使用`@ToString.Include`标记要包含的每个字段，来确切指定希望使用的字段。

通过将`callSuper`设置为`true`，可以将`toString`的超类实现的输出包含到输出中。请注意，`java.lang.Object中toString()` 的默认实现几乎毫无意义。

```java
import lombok.ToString;

@ToString
public class ToStringExample {
  private static final int STATIC_VAR = 10;
  private String name;
  private Shape shape = new Square(5, 10);
  private String[] tags;
  @ToString.Exclude 
  private int id;
  
  public String getName() {
    return this.name;
  }
  
  @ToString(callSuper=true, includeFieldNames=true)
  public static class Square extends Shape {
    private final int width, height;
    
    public Square(int width, int height) {
      this.width = width;
      this.height = height;
    }
  }
}
```

#### @EqualsAndHashCode

任何类定义都可以使用`@EqualsAndHashCode`进行注释，以使`lombok`生成`equals(Object other)`和`hashCode()`方法的实现。默认情况下，它将使用所有非静态，非瞬态字段，但是您可以通过使用`@EqualsAndHashCode.Include`标记类型成员来修改使用哪些字段（甚至指定要使用各种方法的输出）。 `@EqualsAndHashCode.Exclude`。或者，可以通过使用@ `EqualsAndHashCode.Include`标记并使用`@EqualsAndHashCode(onlyExplicitlyIncluded = true)`来精确指定要使用的字段或方法。

如果将`@EqualsAndHashCode`应用于扩展另一个类的类，则此功能会有些棘手。通常，为此类自动生成`equals`和`hashCode`方法是一个坏主意，因为超类还定义了字段，该字段也需要`equals / hashCode`代码，但不会生成此代码。通过将`callSuper`设置为`true`，可以在生成的方法中包括超类的`equals`和`hashCode`方法。

```java
import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class EqualsAndHashCodeExample {
  private transient int transientVar = 10;
  private String name;
  private double score;
  @EqualsAndHashCode.Exclude 
  private Shape shape = new Square(5, 10);
  private String[] tags;
  @EqualsAndHashCode.Exclude 
  private int id;
  
  public String getName() {
    return this.name;
  }
  
  @EqualsAndHashCode(callSuper=true)
  public static class Square extends Shape {
    private final int width, height;
    
    public Square(int width, int height) {
      this.width = width;
      this.height = height;
    }
  }
}
```

#### @AllArgsConstructor

 @RequiredArgsConstructor and @NoArgsConstructor

`@NoArgsConstructor`将生成没有参数的构造函数。如果字段由final修饰，则将导致编译器错误，除非使用`@NoArgsConstructor(force = true)`，否则所有final字段都将初始化为`0 / false / null`。对于具有约束的字段(例如`@NonNull`字段)，不会生成任何检查。

`@RequiredArgsConstructor`为每个需要特殊处理的字段生成一个带有1个参数的构造函数。所有未初始化的final字段都会获取一个参数，以及所有未声明其位置的未标记为`@NonNull`的字段。

`@AllArgsConstructor`为类中的每个字段生成一个带有1个参数的构造函数。标有`@NonNull`的字段将对这些参数进行空检查。

```java
@RequiredArgsConstructor(staticName = "of")
@AllArgsConstructor(access = AccessLevel.PROTECTED)
public class ConstructorExample<T> {
  private int x, y;
  @NonNull 
  private T description;
  
  @NoArgsConstructor
  public static class NoArgsExample {
    @NonNull 
    private String field;
  }
}
```

#### @Data⭐

> @Data是一个方便的快捷方式批注，它将 @ToString，@EqualsAndHashCode，@ Getter / @Setter和@RequiredArgsConstructor的功能捆绑在一起

#### @Value

> @Value注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法
>

#### @Builder

构建者模式，只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：

```java
User buildUser = User.builder().username("riemann").password("123").build();
```

可配合`@Singular`注解使用，`@Singular`注解使用在jdk内部集合类型的属性，`Map`类型的属性以及`Guava`的`com.google.common.collect` 的属性上。例如 未标注`@Singular`的属性，一般`setter`时，会直接覆盖原来的引用，标注了`@Singular`的属性，集合属性支持添加操作，会在属性原来的基础上增加。

```java
import lombok.Builder;
import lombok.Singular;
import java.util.Set;

@Builder
public class BuilderExample {
    @Builder.Default 
    private long created = System.currentTimeMillis();
    private String name;
    private int age;
    @Singular 
    private Set<String> occupations;
}
```

#### @Accessors⭐

链式风格

`@Accessors`批注用于配置`lombok`如何生成和查找`getter`和`setter`。

默认情况下，`lombok`遵循针对`getter`和`setter`的`bean`规范：例如，名为`Pepper`的字段的`getter`是`getPepper`。但是，有些人可能希望打破`bean`规范，以得到更好看的`API`。 `@Accessors`允许您执行此操作。

可标注在类或属性上，当然最实用的功能还是标注到类上。

标注到类上，`chain`属性设置为`true`时，类的所有属性的`setter`方法返回值将为`this`，用来支持`setter`方法的链式写法。如：

```java
new User().setUsername("riemann").setPassword("123");
```

`fluent`属性设置为`true`时，类的所有`getter`，`setter`方法将省略`get`和`set`前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：

```java
User user = new User().username("riemann").password("123");
String username = user.username();
String password = user.password();
```

标注到属性上，使用`prefix`设置需要省略的属性生成`getter`，`setter`方法时的前缀，且属性必须为驼峰式命名。

```java
@Accessors(prefix = "r")
@Getter
@Setter
private String rUsername = "riemann";
```

编译之后为

```java
public String getUsername() {
    return rUsername;
}
public void setUsername(String rUsername) {
    this.rUsername = rUsername;
}
```



# 拦截器

## 什么是拦截器？

> Spring MVC中的拦截器（`Interceptor`）类似于Servlet中的过滤器（`Filter`），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。

## 如何自定义一个拦截器？

自定义一个拦截器非常简单，只需要实现`HandlerInterceptor`这个接口即可，该接口有三个可以实现的方法

> - `preHandle()`方法：该方法会在控制器方法前执行，其返回值表示是否知道如何写一个接口。中断后续操作。当其返回值为`true`时，表示继续向下执行；当其返回值为`false`时，会中断后续的所有操作（包括调用下一个拦截器和控制器类中的方法执行等）。
> - `postHandle()`方法：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。
> - `afterCompletion()`方法：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。

## 如何使其在Spring Boot中生效？

其实想要在Spring Boot生效其实很简单，只需要定义一个配置类，实现`WebMvcConfigurer`这个接口，并且实现其中的`addInterceptors()`方法即可，代码演示如下：

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private XXX xxx;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //不拦截的uri
        final String[] commonExclude = {}};
        registry.addInterceptor(xxx).excludePathPatterns(commonExclude);
    }
}
```

## 举个栗子

开发中可能会经常遇到短时间内由于用户的重复点击导致几秒之内重复的请求，可能就是在这几秒之内由于各种问题，比如`网络`，`事务的隔离性`等等问题导致了数据的重复等问题，因此在日常开发中必须规避这类的重复请求操作，今天就用拦截器简单的处理一下这个问题。

在接口执行之前先对指定接口（比如标注某个`注解`的接口）进行判断，如果在指定的时间内（比如`5秒`）已经请求过一次了，则返回重复提交的信息给调用者。

### 根据什么判断这个接口已经请求了？

> 根据项目的架构可能判断的条件也是不同的，比如`IP地址`，`用户唯一标识`、`请求参数`、`请求URI`等等其中的某一个或者多个的组合。

### 这个具体的信息存放在哪里？

> 由于是`短时间`内甚至是瞬间并且要保证`定时失效`，肯定不能存在事务性数据库中了，因此常用的几种数据库中只有`Redis`比较合适了。

### 如何实现？

第一步，先自定义一个注解，可以标注在类或者方法上，如下：

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RepeatSubmit {
    // 默认失效时间5秒
    long seconds() default 5;
}
```

第二步，创建一个拦截器，**注入到IOC容器中**，实现的思路很简单，判断controller的类或者方法上是否标注了`@RepeatSubmit`这个注解，如果标注了，则拦截判断，否则跳过，代码如下：

```java
/**
 * 重复请求的拦截器
 * @Component：该注解将其注入到IOC容器中
 */
@Component
public class RepeatSubmitInterceptor implements HandlerInterceptor {

    /**
     * Redis的API
     */
    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    /**
     * preHandler方法，在controller方法之前执行
     * 
     * 判断条件仅仅是用了uri，实际开发中根据实际情况组合一个唯一识别的条件。
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
        if (handler instanceof HandlerMethod){
            //只拦截标注了@RepeatSubmit该注解
            HandlerMethod method=(HandlerMethod)handler;
            //标注在方法上的@RepeatSubmit
            RepeatSubmit repeatSubmitByMethod = 
                AnnotationUtils.findAnnotation(method.getMethod(),
                                               RepeatSubmit.class);
            //标注在controler类上的@RepeatSubmit
            RepeatSubmit repeatSubmitByCls = AnnotationUtils
                .findAnnotation(method.getMethod().getDeclaringClass(), 
                                RepeatSubmit.class);
            //没有限制重复提交，直接跳过
            if (Objects.isNull(repeatSubmitByMethod)&&Objects.isNull(repeatSubmitByCls))
                return true;

            // todo: 组合判断条件，这里仅仅是演示，实际项目中根据架构组合条件
            //请求的URI
            String uri = request.getRequestURI();

            //存在即返回false，不存在即返回true
            Boolean ifAbsent = stringRedisTemplate.opsForValue()
                .setIfAbsent(uri, "", 
                             Objects.nonNull(repeatSubmitByMethod)?repeatSubmitByMethod
                             .seconds():repeatSubmitByCls.seconds(), 
                             TimeUnit.SECONDS);

            //如果存在，表示已经请求过了，直接抛出异常，由全局异常进行处理返回指定信息
            if (ifAbsent!=null&&!ifAbsent)
                throw new RepeatSubmitException();
        }
        return true;
    }
}
```

第三步，在Spring Boot中配置这个拦截器，代码如下：

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private RepeatSubmitInterceptor repeatSubmitInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //不拦截的uri
        final String[] commonExclude = {"/error", "/files/**"};
        registry.addInterceptor(repeatSubmitInterceptor).excludePathPatterns(commonExclude);
    }
}
```

OK，拦截器已经配置完成，只需要在需要拦截的接口上标注`@RepeatSubmit`这个注解即可，如下：

```java
@RestController
@RequestMapping("/user")
//标注了@RepeatSubmit注解，全部的接口都需要拦截
@RepeatSubmit
public class LoginController {

    @RequestMapping("/login")
    public String login(){
        return "login success";
    }
}
```

此时，请求这个URI:`:8080/springboot-demo/user/login`在5秒之内只能请求一次。

**注意**：标注在方法上的超时时间会覆盖掉类上的时间，因为如下一段代码：

```java
Boolean ifAbsent = stringRedisTemplate.opsForValue().setIfAbsent(uri, "", Objects.nonNull(repeatSubmitByMethod)?repeatSubmitByMethod.seconds():repeatSubmitByCls.seconds(), TimeUnit.SECONDS);
```

这段代码的失效时间先取值`repeatSubmitByMethod`中配置的，如果为null，则取值`repeatSubmitByCls`配置的。

## 举个栗子2

### 编写拦截器

```java
@Slf4j
public class MyInterceptor implements HandlerInterceptor {
    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        log.debug("这是preHandle");
        return true;
    }

    public void postHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler, 
                           @Nullable ModelAndView modelAndView) throws Exception {
        log.debug("这是postHandle");
    }

    public void afterCompletion(HttpServletRequest request, 
                                HttpServletResponse response, 
                                Object handler, 
                                @Nullable Exception ex) throws Exception {
        log.debug("afterCompletion");
    }
}
```

### 注册并添加拦截器

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    //注册拦截器
    @Bean
    public MyInterceptor myInterceptor(){
        return new MyInterceptor();
    }

    //添加拦截器到spring mvc拦截器
    public void addInterceptors(InterceptorRegistry registry) {
         registry.addInterceptor(myInterceptor()).addPathPatterns("/**");
    }
}
```



# 对象复制

[SpringBoot 如何进行对象复制，老鸟们都这么玩的！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247493931&idx=2&sn=23525c40fcfb2886ee240aadafce211d&chksm=fc2c5523cb5bdc35401c6ae19b7a352b626248be40f1a4a97619b92e4b9972ee4adefa85901f&mpshare=1&scene=23&srcid=0415HYhy6BEnxTPmPFcZVOCs&sharer_sharetime=1650025458866&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 对象复制概览

### 为什么需要对象复制

在工作中，我们经常要进行各种对象之间的转换

> - PO：persistent object 持久对象，**对应数据库中的一条记录**
> - VO：view object 表现层对象，**最终返回给前端的对象**
> - DTO：data transfer object数据传输对象，**如dubbo服务之间传输的对象**

如上，是我们平时开发中最常见的三层MVC架构模型，编辑操作时Controller层接收到前端传来的DTO对象，在Service层需要将`DTO`转换成`DO`，然后在数据库中保存。查询操作时Service层查询到DO对象后需要将`DO`对象转换成`VO`对象，然后通过Controller层返回给前端进行渲染。这中间会涉及到大量的对象转换

> 所以我们必须要找一个第三方工具来帮我们实现对象转换。看到这里有同学可能会问，为什么不能前后端都统一使用DO对象呢？这样就不存在对象转换呀？
>

> 设想一下如果我们不想定义 DTO 和 VO，直接将 DO 用到数据访问层、服务层、控制层和外部访问接口上。此时该表删除或则修改一个字段，DO 必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。

> 通过定义不同的 DTO 可以控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，不需要考虑对其它业务的影响，如果使用同一个对象则可能因为 “不敢乱改” 而产生很多不优雅的兼容性行为。

### 对象复制工具类推荐

对象复制的类库工具有很多，除了常见的Apache的`BeanUtils`，Spring的`BeanUtils`，`Cglib BeanCopier`，还有重量级组件`MapStruct`，`Orika`，`Dozer`，`ModelMapper`等。

**如果没有特殊要求，这些工具类都可以直接使用，除了Apache的`BeanUtils`**。原因在于`Apache BeanUtils`底层源码为了追求完美，加了过多的包装，使用了很多反射，做了很多校验，所以导致性能较差，并在阿里巴巴开发手册上强制规定避免使用 **Apache BeanUtils**。

## 常规复制

提起对象转换，每个程序员都不陌生，比如项目中经常涉及到的DO、DTO、VO之间的转换，举个例子，假设现在有个OrderDTO，定义如下所示：

```java
public static void test2(){
    Student student = new Student("1","javadaily","jianzh5@163.com","as");
    Teacher teacher = new Teacher();
    // 直接使用set和get方法
    teacher.setId(student.getId());
    teacher.setName(student.getName());
    teacher.setEmailAddress(student.getEmail());
    System.out.println("student："+student);
    System.out.println("teacher："+teacher);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291552231.png" alt="image-20230129155247150" style="zoom:67%;" />

## BeanUtils基本使用

### 准备数据

定义两个实体类，分别是Teacher和Student

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String id;
    private String name;
    private String email;
    private String phone;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Teacher {
    private String id;
    private String name;
    private String emailAddress;
}
```

### 简单使用⭐

> Spring 属性复制工具类类名与 `Apache` 一样，基本用法也差不多。我先来看下 Spring **BeanUtils** 基本用法。同样，我们先引入依赖，从名字我们可以看出，**BeanUtils** 位于 `Spring-Beans` 模块，这里我们依然使用最新模块。
>

```java
@Test
public void test1(){
    Student student = new Student("1","javadaily","jianzh5@163.com","as");
    Teacher teacher = new Teacher();
    //进行拷贝，只能拷贝名称相同的属性，不同无法拷贝
    BeanUtils.copyProperties(student,teacher);
    System.out.println("student："+student);
    System.out.println("teacher："+teacher);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220418174337179.png" alt="image-20220418174337179" style="zoom:67%;" />

### 注意事项

两个具有很多相同属性的JavaBean，相同的变量名进行是赋值，使用set方法太麻烦，可以直接使用：

> - b中的存在的属性，a中一定要有，但是a中可以有多余的属性；
> - a中与b中相同的属性都会被替换，不管是否有值；
> - a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；
> - Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；
> - 如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；
> - spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下

从上面的对比图我们可以得到一些结论：

> - 字段名不一致，属性无法复制
> - 类型不一致，属性无法复制。但是注意，如果类型为基本类型以及基本类型的包装类，这种可以转化
> - 嵌套对象字段，**将会与源对象使用同一对象**，即使用**浅拷贝**

### 忽略属性

> 除了这个方法之外，Spring BeanUtils 还提供了一个重载方法：可以忽略某些不想被复制过去的属性

```java
public static void copyProperties(Object source, Object target, String... ignoreProperties) 
```

```java
public static void test1(){
    Student student = new Student("1","javadaily","jianzh5@163.com","as");
    Teacher teacher = new Teacher();
    // 进行拷贝，只能拷贝名称相同的属性，不同无法拷贝，不去拷贝"id","name"
    // copyProperties(Object source, Object target, String... ignoreProperties) 
    BeanUtils.copyProperties(student,teacher,"id","name");
    System.out.println("student："+student);
    System.out.println("teacher："+teacher);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291550632.png" alt="image-20230129155004540" style="zoom:67%;" />



### 踩坑经历

#### 1 包装类型转基本类型问题

```java
java.lang.IllegalArgumentException
```

细心的你可能会发现，OrderDTO中的userId字段，我定义的是Long类型：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211131108330.png" alt="image-20221113110847264" style="zoom:50%;" />

而OrderVO中的userId字段，我定义的是long类型：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211131108980.png" alt="image-20221113110855913" style="zoom:50%;" />

然后我们运行下下面所示的代码：

```java
public static void main(String[] args) {
    OrderDTO orderDTO = new OrderDTO();
    orderDTO.setId(1L);
    orderDTO.setUserId(null);
    orderDTO.setOrderNo("20210518000001");
    orderDTO.setGmtCreated(new Date());

    OrderVO orderVO = new OrderVO();
    BeanUtils.copyProperties(orderDTO, orderVO);
}
```

会看到代码抛了`java.lang.IllegalArgumentException`异常：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211131109730.png" alt="image-20221113110907672" style="zoom:67%;" />

#### 2 空格问题

> 假设OrderVO的orderNo字段，是用户自定义的，用户不小心输入了空格，使用`BeanUtils.copyProperties`后，空格会带入到OrderDTO的orderNo字段，如果不小心，就会把脏数据落到数据库（而我们希望的是去除空格再落库的），造成一系列后续问题：
>

```java
public static void main(String[] args) {
    OrderVO orderVO = new OrderVO();
    orderVO.setId(1L);
    orderVO.setUserId(123L);
    // 模拟空格场景
    orderVO.setOrderNo(" 20210518000001 ");
    orderVO.setGmtCreated(new Date());

    OrderDTO orderDTO = new OrderDTO();
    BeanUtils.copyProperties(orderVO, orderDTO);

    System.out.println(orderDTO.getOrderNo());
}
```

运行结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211131108812.png" alt="image-20221113110826751" style="zoom:50%;" />

#### 3 查找不到字段引用

使用`BeanUtils.copyProperties`后，会看到字段并没有引用，其实是有用到的，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211131108902.png" alt="image-20221113110815825" style="zoom:50%;" />

有些小伙伴在看代码时，看到字段没有地方引用，可能就忍不住想删掉，结果就导致真正使用该字段的地方取不到值，产生bug。

#### 4 前端误传字段，直接把数据库覆盖

如果接口定义的比较严谨，理论上是不应该存在这种情况的，不过凡事总有特殊，这里举个接口不严谨导致数据被覆盖的例子。假如OrderVO和OrderDTO有如下2个字段：

```java
// 已收金额 单位：分
private Long receivedAmount;

//备注
private String remark;
```

正常情况下，后端只应该使用前端传递的remark字段，`receivedAmount`字段不应该使用，但假如用户修改订单备注时，前端不小心传递了`receivedAmount`字段，并且赋值为null，这时使用`BeanUtils.copyProperties`后，OrderDTO里的`receivedAmount`字段就也为null，如果后端不知道前端传递了这个字段并且操作DB不够严谨，就会导致订单的已收金额被清空，很恐怖，而且不好排查原因。

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufUEVKicJibDnBlqQsjX5HSprQohQx6pbEC7bzum3IwKlpjmKFL2aa5MpibLGGK9WQY4egLbl7416hRQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## BeanUtils避坑指南

我们日常开发中，经常涉及到`DO、DTO、VO`对象属性拷贝赋值，很容易想到`org.springframework.beans.BeanUtils`的`copyProperties `。它会自动通过反射机制获取源对象和目标对象的属性，**并将对应的属性值进行复制**。可以减少手动编写属性复制代码的工作量，提高代码的可读性和维护性。

但是你知道嘛？使用`BeanUtils`的`copyProperties `，会有好几个坑呢，今天给大家盘点一下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxiaNRPNT3HM6pqA2IiawZ1UdHcLibteKVpQgkDwCeQUUd38etLAhRQRuJAEOAicZ37ibeVJUV5CuSiaLJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 类型不匹配

```
@Data  
public class SourceBean {  
    private Long age;  
}  
  
@Data  
public class TargetBean {  
    private String age;  
}  
  
public class Test {  
  
    public static void main(String[] args) {  
        SourceBean source = new SourceBean();  
        source.setAge(25L);  
  
        TargetBean target = new TargetBean();  
        BeanUtils.copyProperties(source, target);  
  
        System.out.println(target.getAge());  //拷贝赋值失败，输出null  
    }  
}  
```

在上述`demo`中，源对象`SourceBean`的`age`属性是一个`Long`类型，而目标对象`TargetBean`的`age`属性是一个`String`类型。由于类型不匹配，`BeanUtils.copyProperties`不会赋值成功的。我跑`demo`的结果，控制台输出`null`。

### 浅拷贝

先给大家复习一下，什么是深拷贝？什么是浅拷贝？

- 浅拷贝是指创建一个新对象，该对象的属性值与原始对象相同，但对于引用类型的属性，仍然共享相同的引用。换句话说，浅拷贝只复制对象及其引用，而不复制引用指向的对象本身。
- 深拷贝是指创建一个新对象，该对象的属性值与原始对象相同，包括引用类型的属性。深拷贝会递归复制引用对象，创建全新的对象，**以确保拷贝后的对象与原始对象完全独立**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxiaNRPNT3HM6pqA2IiawZ1UdMTN51ia4LLqC2uANV0cX300w5sOPYc9xRn1K0QGXarib8aZK9Vh7cZpw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

我再给个代码`demo`给大家看看哈：

```
public class Address {  
    private String city;  
    //getter 和 setter 方法省略  
}  
  
public class Person {  
    private String name;  
    private Address address;  
    //getter 和 setter 方法省略  
}  
  
 Person sourcePerson = new Person();  
 sourcePerson.setName("John");  
 Address address = new Address();  
 address.setCity("New York");  
 sourcePerson.setAddress(address);  
  
 Person targetPerson = new Person();  
 BeanUtils.copyProperties(sourcePerson, targetPerson);  
  
 sourcePerson.getAddress().setCity("London");  
  
 System.out.println(targetPerson.getAddress().getCity());  // 输出为 "London"  
```

在上述示例中，源对象`Person`的属性`address`是一个引用类型。当使用`BeanUtils.copyProperties`方法进行属性复制时，实际上只复制了引用，即目标对象`targetPerson`的 `address` 属性引用和源对象 `sourcePerson` 的 `address` 属性引用指向同一个对象。因此，当修改源对象的`address`对象时，目标对象的`address`对象也会被修改。

大家日常开发中，要注意这个坑哈~

### 属性名称不一致

```
public class SourceBean {  
    private String username;  
  
    // getter 和 setter 方法省略  
}  
  
public class TargetBean {  
    private String userName;  
    // getter 和 setter 方法省略  
}  
  
 SourceBean source = new SourceBean();  
 source.setUsername("捡田螺的小男孩");  
  
 TargetBean target = new TargetBean();  
 BeanUtils.copyProperties(source, target);  
  
 System.out.println(target.getUserName());   // 输出为 null  
```

在上述示例中，源对象`SourceBean` 的属性名称是`username`，而目标对象`TargetBean`的属性名称也是`userName`。**但是**，两个 `username`，一个N是大写，一个n是小写，即**属性名称不一致**，`BeanUtils.copyProperties`方法无法自动映射这些属性（无法忽略大小写自动匹配），因此目标对象的`userName`属性值为`null`。

大家日常开发中，要注意这个坑哈~ **比如大小写不一致，差一两个字母等等**。

### Null 值覆盖

```
@Data  
public class SourceBean {  
  
    private String name;  
    private String address;  
  
}  
  
@Data  
public class TargetBean {  
  
    private String name;  
    private String address;  
}  
  
SourceBean source = new SourceBean();  
source.setName("John");  
source.setAddress(null);  
  
TargetBean target = new TargetBean();  
target.setAddress("田螺address");  
BeanUtils.copyProperties(source, target);  
  
System.out.println(target.getAddress());  // 输出为 null  
```

在上述示例中，源对象 `SourceBean `的 address 属性值为 null。默认情况下，`BeanUtils.copyProperties` 方法会将源对象中的 null 值属性覆盖到目标对象中。因此，目标对象的 address 属性值也为 null。

如果你不希望 null 值覆盖目标对象中的属性，可以使用 `BeanUtils.copyProperties` 方法的重载方法，并传入一个自定义的 `ConvertUtilsBean` 实例来进行配置。

### 注意引入的包

`BeanUtils.copyProperties`其实有两个包，分别是`spring、apache`。大家注意一下哈，这两个包，是有点不一样的：

```
//org.springframework.beans.BeanUtils(源对象在左边，目标对象在右边)  
public static void copyProperties(Object source, Object target) throws BeansException   
//org.apache.commons.beanutils.BeanUtils（源对象在右边，目标对象在左边）  
public static void copyProperties(Object dest, Object orig) throws IllegalAccessException, InvocationTargetException  
```

大家使用的时候，要注意一下哈，注意自己引入的哪个`BeanUtils`，写对应参数位置。

### Boolean类型数据+is属性开头的坑

把`SourceBean和TargetBean`中的都有个属性`isTianLuo`,它们的数据类型保持不变,但是一个为基本类型`boolean`，一个为包装类型`Boolean`

```
@Data  
public class SourceBean {  
    private boolean isTianLuo;  
}  
  
@Data  
public class TargetBean {  
    private Boolean isTianLuo;  
}  
```

跑测试用里的时候，发现赋值不上：

```
SourceBean source = new SourceBean();  
source.setTianLuo(true);  
  
TargetBean target = new TargetBean();  
BeanUtils.copyProperties(source, target);  
System.out.println(target.getIsTianLuo()); // 输出为 null  
```

为什么呢？即使是一个包装类型，一个基本类型，应该可以赋值上才对的。

> 这是因为当属性类型为`boolean`时，属性名以`is`开头,属性名会去掉前面的`is`，因此源对象和目标对象属性对不上啦。

大家使用`BeanUtils.copyProperties`过程中，要注意哈~

### 查找不到字段引用

在某些开发场景呢，如果我们要修改某个字段的赋值，我们可能会全文搜索它的所有`set`方法，看哪些地方引用到。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxiaNRPNT3HM6pqA2IiawZ1Ud1FggYL3P7r7W7tYIgr5HbsylXcvUyFR1RSRh87Wn4AbJicibLd2wicH7g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

但是呢，如果使用`BeanUtils.copyProperties`，**就不知道是否引用到对应的ste方法啦**，**即查找不到字段引用**。这就可能导致你会漏掉修改对应的字段。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxiaNRPNT3HM6pqA2IiawZ1Ud5KibR0ksp0sFdth4npAoZjUuTpnJwicceQ7J6eqWlHfg0EzehabuKDXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 不同内部类，即使相同属性，也是赋值失败

```
@Data  
public class CopySource {  
  
    public String outerName;  
    public CopySource.InnerClass innerClass;  
  
    @Data  
    public static class InnerClass {  
        public String InnerName;  
    }  
}  
  
@Data  
public class CopyTarget {  
    public String outerName;  
    public CopyTarget.InnerClass innerClass;  
  
    @Data  
   public static class InnerClass {  
        public String InnerName;  
    }  
}  
  
CopySource test1 = new CopySource();  
test1.outerName = "outTianluo";  
  
CopySource.InnerClass innerClass = new CopySource.InnerClass();  
innerClass.InnerName = "innerTianLuo";  
test1.innerClass = innerClass;  
  
System.out.println(test1);  
CopyTarget test2 = new CopyTarget();  
BeanUtils.copyProperties(test1, test2);  
  
System.out.println(test2);  //输出CopyTarget(outerName=outTianluo, innerClass=null)  
```

以上`demo`中，`CopySource`和`CopyTarget`各自存在一个内部类`InnerClass`，虽然这个内部类属性也相同，类名也相同，但是在不同的类中，因此`Spring`会认为属性不同,不会`Copy`;

如果要复制成功，可以让他们指向同一个内部类。

### bean对应的属性，没有getter和setter方法，赋值失败

`BeanUtils.copyProperties`要拷贝属性值成功，需要对应的`bean`要有`getter和setter`方法。因为它是用反射拿到set和get方法再去拿属性值和设置属性值的。

```
@Data  
public class SourceBean {  
    private String value;  
}  
  
@Getter   //没有对应的setter方法  
public class TargetBean {  
    private String value;  
}  
  
SourceBean source = new SourceBean();  
source.setValue("捡田螺的小男孩");  
  
TargetBean target = new TargetBean();  
BeanUtils.copyProperties(source, target);  
System.out.println(target.getValue()); //输出null   
```

### BeanUtils.copyProperties + 泛型

如果`BeanUtils.copyProperties`遇到泛型，也是很可能赋值失败的哈。大家看下这个例子：

```
@Data  
public class CopySource {  
  
    public String outerName;  
    public List<CopySource.InnerClass> clazz;  
  
    @Data  
    public static class InnerClass {  
        public String InnerName;  
    }  
}  
  
@ToString  
@Data  
public class CopyTarget {  
    public String outerName;  
    public List<CopyTarget.InnerClass> clazz;  
  
    @Data  
    public static class InnerClass {  
        public String InnerName;  
    }  
}  
  
CopySource test1 = new CopySource();  
test1.outerName = "outTianluo";  
  
CopySource.InnerClass innerClass = new CopySource.InnerClass();  
innerClass.InnerName = "innerTianLuo";  
  
List<CopySource.InnerClass> clazz = new ArrayList<>();  
clazz.add(innerClass);  
test1.setClazz(clazz);  
  
System.out.println(test1);  
CopyTarget test2 = new CopyTarget();  
BeanUtils.copyProperties(test1, test2);  
  
System.out.println(test2);  //输出CopyTarget(outerName=outTianluo, clazz=null)  
```

这里面的例子，`BeanUtils.copyProperties`方法拷贝包含泛型属性的对象`clazz`。`CopyTarget`和`CopySource`的泛型属性类型不匹配，因此拷贝赋值失败。

### 性能问题

由于这些`BeanUtils`类都是采用反射机制实现的，对程序的效率也会有影响。我跑了个`demo`对比：

```
SourceBean sourceBean = new SourceBean();  
sourceBean.setName("tianLuoBoy");  
TargetBean target = new TargetBean();  
  
long beginTime = System.currentTimeMillis();  
for (int i = 0; i < 100000; i++) {  //循环10万次  
      target.setName(sourceBean.getName());  
}  
System.out.println("common setter time:" + (System.currentTimeMillis() - beginTime));  
  
long beginTime1 = System.currentTimeMillis();  
for (int i = 0; i < 100000; i++) {  //循环10万次  
    BeanUtils.copyProperties(sourceBean, target);  
}  
System.out.println("bean copy time:" + (System.currentTimeMillis() - beginTime1));  
  
//输出  
common setter time:3  
bean copy time:331  
```

可以发现，简单的`setter`和`BeanUtils.copyProperties`对比，性能差距非常大。因此，慎用`BeanUtils.copyProperties！！！`

## 对象复制插件⭐

> 虽然`BeanUtils.copyProperties`工具提供了便利，但带来的问题也很多，因此很多公司（包含我现在所在的公司）都禁止在项目中使用该工具。但重复的写对象转换，实在是太繁琐，效率太低了，这里推荐一个IDEA的插件`GenerateAllSetter`，可以一键生成对象的set方法，非常方便，如下图所示：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291603692.png" alt="image-20230129160353604" style="zoom: 67%;" />

### 主要方法

插件使用：在需要生成set方法的对象上(光标放在对象上)，（Windows是`Alt+Enter`），会看到下图所示的选项：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291604407.png" alt="image-20230129160447307" style="zoom:67%;" />

### set方法

点击后会自动生成所有字段（有默认值）的赋值语句：

```java
Teacher teacher = new Teacher();
// 生成如下
teacher.setId("");
teacher.setName("");
teacher.setEmailAddress("");
```

如果生成赋值语句时想不带默认值，可以使用另一个选项：

```java
Teacher teacher = new Teacher();
teacher.setId();
teacher.setName();
teacher.setEmailAddress();
```

### get方法

```java
Teacher teacher = new Teacher();
// 生成如下
String id = teacher.getId();
String name = teacher.getName();
String emailAddress = teacher.getEmailAddress();
```



# 异步调用⭐

“异步调用”对应的是“同步调用”，在实际开发中，有时候为了及时处理请求和进行响应，我们可能使用异步调用

> **同步调用指程序按照定义顺序依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行**；
>
> **异步调用指程序在顺序执行时，不等待异步调用的语句返回结果就执行后面的程序**。
>
> 异步调用的实现有很多，例如**多线程、定时任务、消息队列**等。

## 同步 & 异步实现

### 同步调用实现

下面通过同步调用：定义Task类，创建三个处理函数分别模拟三个执行任务的操作

```java
@Component
public class Task {

    public void doTaskOne() throws Exception {
        System.out.println("开始做任务一");
        long start = System.currentTimeMillis();
        Thread.sleep(1000);
        long end = System.currentTimeMillis();
        System.out.println("完成任务一，耗时：" + (end - start) + "毫秒");
    }

    public void doTaskTwo() throws Exception {
        System.out.println("开始做任务二");
        long start = System.currentTimeMillis();
        Thread.sleep(1000);
        long end = System.currentTimeMillis();
        System.out.println("完成任务二，耗时：" + (end - start) + "毫秒");
    }

    public void doTaskThree() throws Exception {
        System.out.println("开始做任务三");
        long start = System.currentTimeMillis();
        Thread.sleep(1000);
        long end = System.currentTimeMillis();
        System.out.println("完成任务三，耗时：" + (end - start) + "毫秒");
    }

}
```

在单元测试用例中，注入Task对象，并在测试用例中执行doTaskOne、doTaskTwo、doTaskThree三个函数。

```java
@Autowired
private Task task;

@GetMapping("task")
public String task(){
    try {
        long start = System.currentTimeMillis();
        task.doTaskOne();
        task.doTaskTwo();
        task.doTaskThree();
        long end = System.currentTimeMillis();
        System.out.println("完成任务，耗时：" + (end - start) + "毫秒");
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "springboot is running.1234567891011..";
}
```

> 任务一、任务二、任务三顺序的执行完了，换言之doTaskOne、doTaskTwo、doTaskThree三个函数顺序的执行完成

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291210242.png" alt="image-20230129121044125" style="zoom:67%;" />

### 异步调用实现

> 上述的同步调用虽然顺利的执行完了三个任务，但是可以看到执行时间比较长，若这三个任务本身之间不存在依赖关系，可以并发执行的话，同步调用在执行效率方面就比较差，可以考虑通过异步调用的方式来并发执行

```java
@Component
public class Task {
 
    @Async
    public void doTaskOne() throws Exception {
        // 同上内容，省略
    }
 
    @Async
    public void doTaskTwo() throws Exception {
        // 同上内容，省略
    }
 
    @Async
    public void doTaskThree() throws Exception {
        // 同上内容，省略
    }
 
}
```

为了让`@Async`注解能够生效，还需要在Spring Boot的主程序中配置`@EnableAsync`，如下所示：

```java
@SpringBootApplication
@EnableAsync
public class Application {
 
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291215582.png" alt="image-20230129121546510" style="zoom:67%;" />

此时可以反复执行单元测试，您可能会遇到各种不同的结果，比如：

> 没有任何任务相关的输出、有部分任务相关的输出、**乱序的任务相关的输出**

原因是目前doTaskOne、doTaskTwo、doTaskThree三个函数的时候已经是异步执行了。

> 主程序在异步调用之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就自动结束了，导致了不完整或是没有输出任务相关内容的情况。注：@Async所修饰的函数不要定义为static类型，这样异步调用不会生效

## 有返回值的异步⭐

> 为了让doTaskOne、doTaskTwo、doTaskThree能正常结束，假设我们需要统计一下三个任务并发执行共耗时多少，这就需要等到上述三个函数都完成调动之后记录时间，并计算结果。那么我们如何判断上述三个异步调用是否已经执行完成呢？我们需要使用Future来返回异步调用的结果，就像如下方式改造doTaskOne函数：

### 改造函数

```java
@Async
public Future<String> doTaskOne() throws Exception {
    System.out.println("开始做任务一");
    long start = System.currentTimeMillis();
    Thread.sleep(1000);
    long end = System.currentTimeMillis();
    System.out.println("完成任务一，耗时：" + (end - start) + "毫秒");
    return new AsyncResult<>("任务一完成");
}
```

> 按照如上方式改造一下其他两个异步函数之后，下面我们改造一下测试用例，让测试在等待完成三个异步调用之后来做一些其他事情。

### 获取结果⭐

```java
@GetMapping("task")
public void task(){
    try {
        long start = System.currentTimeMillis();
        Future<String> task1 = task.doTaskOne();
        Future<String> task2 = task.doTaskTwo();
        Future<String> task3 = task.doTaskThree();
        while(true) {
            if(task1.isDone() && task2.isDone() && task3.isDone()) {
                break; // 三个任务都调用完成，退出循环等待
            }
        }
        long end = System.currentTimeMillis();
        // 获取回调结果
        String s1 = task1.get();
        String s2 = task2.get();
        String s3 = task3.get();
        System.out.println(s1+"，"+s2+"，"+s3);
        System.out.println("任务全部完成，总耗时：" + (end - start) + "毫秒");
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291238780.png" alt="image-20230129123844712" style="zoom:67%;" />

看看我们做了哪些改变：

> - 在测试用例一开始记录开始时间
> - 在调用三个异步函数的时候，返回Future类型的结果对象
> - 在调用完三个异步函数之后，开启一个循环，根据返回的Future对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。

跳出循环之后，根据`结束时间 - 开始时间`，计算出三个任务并发执行的总耗时。

可以看到，通过异步调用，让任务一、二、三并发执行，有效的减少了程序的总运行时间。

## 异步+线程池⭐

> 默认情况下，Spring使用SimpleAsyncTaskExecutor异步运行这些方法。可以在两个级别上重写默认线程池——应用程序级别或方法级别。
>

> 配置类应实现AsyncConfigurer接口，重写getAsyncExecutor()方法。在这里，我们将返回整个应用程序的Executor，这样一来，它就成为运行以@Async注释的方法的默认Executor。实际上，还可以对线程池做一些配置
>

```java
@Configuration
@EnableAsync
public class SpringPropertiesAsyncConfig implements AsyncConfigurer {
    // 对线程池进行配置
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(20);
        taskExecutor.setMaxPoolSize(200);
        taskExecutor.setQueueCapacity(25);
        taskExecutor.setKeepAliveSeconds(200);
        taskExecutor.setThreadNamePrefix("oKong-");
        // 线程池对拒绝任务（无线程可用）的处理策略，
        // 目前只支持AbortPolicy、CallerRunsPolicy；默认为后者
        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        taskExecutor.initialize();
        return taskExecutor;
    }
}
```

ThreadPoolTaskExecutor配置参数的简单说明：

> - corePoolSize：线程池维护线程的最少数量
> - keepAliveSeconds：允许的空闲时间,当超过了核心线程出之外的线程在空闲时间到达之后会被销毁
> - maxPoolSize：线程池维护线程的最大数量,只有在缓冲队列满了之后才会申请超过核心线程数的线程
> - queueCapacity：缓存队列
> - rejectedExecutionHandler：线程池对拒绝任务（无线程可用）的处理策略。这里采用了CallerRunsPolicy策略，当线程池没有处理能力的时候，该策略会直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。还有一个是AbortPolicy策略：处理程序遭到拒绝将抛出运行时RejectedExecutionException

# 数据层解决方案

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281557819.png" alt="image-20230128155757743" style="zoom:60%;" />

## 数据源解决方案

### 现有数据层技术选型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281437150.png" alt="image-20230128143739082" style="zoom:67%;" />

### 数据源配置格式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281438528.png" alt="image-20230128143815439" style="zoom:67%;" />

### 内嵌数据源

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301272247760.png" alt="image-20230127224755619" style="zoom:60%;" />

### Druid数据源

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.15</version>
</dependency>
```

```yml
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
      username: root
      password: 123456
```

> 查看启动日志，发现成功使用数据源

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281443434.png" alt="image-20230128144310381" style="zoom:67%;" />

### hikari数据源

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
    hikari:
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: root
      password: 123456
      maximum-pool-size: 50
```

## 持久化-->JdbcTemplate

### 基础配置

```xml
<dependencies>
    <!--web依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--mysql依赖-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!--spring-boot-starter-jdbc依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <!--lombok依赖-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```

```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
  jdbc: # 可选配置，可以不配
    template:
      fetch-size: -1 # 缓存行数
      max-rows: 500  # 最大行数
      query-timeout: -1   # 查询超时时间
```

### 实体类

```java
@Data
public class User {
    private Integer id;
    private String name;
    private String password;
    private String phone;
}
```

```java
@Autowired
private JdbcTemplate jdbcTemplate;
```

### 查询所有

```java
@Test
public void testList(){
    String sql = "select * from user";
    List<User> query = jdbcTemplate.query(sql, (rs, rowNum) -> {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        user.setPhone(rs.getString("phone"));
        return user;
    });
    query.forEach(System.out::println);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281504665.png" alt="image-20230128150405263" style="zoom:67%;" />

### 查询单条

```java
@Test
public void testSelectOne(){
    String sql = "select * from user where id = 1";
    List<User> query = jdbcTemplate.query(sql, (rs, rowNum) -> {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        user.setPhone(rs.getString("phone"));
        return user;
    });
    System.out.println(query);
}
```

### 增删改实现

```java
@Test
public void testInsert(){
    String sql = "insert into user values(null,'ls','12321','17315118673')";
    System.out.println(jdbcTemplate.update(sql));
}

@Test
public void testUpdate(){
    String sql = "update user set name = 'rensan' where id = 1";
    System.out.println(jdbcTemplate.update(sql));
}

@Test
public void testDelete(){
    String sql = "delete from user where id = 1";
    System.out.println(jdbcTemplate.update(sql));
}
```

## h2数据库

> SpringBoot提供了3种内嵌数据库供开发者选择，提高开发测试效率H2、HSQL、Derby

### 基础配置

#### 依赖信息

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

#### 配置信息

```yml
spring:
  datasource:
    # SpringBoot可以根据url地址自动识别数据库种类，在保障驱动类存在的情况下，可以省略配置
    driver-class-name: org.h2.Driver
    url: jdbc:h2:~/test
    username: sa
    password: 123456
  h2:
    # H2数据库控制台仅用于开发阶段，线上项目请务必关闭控制台功能，直接设置enable:false
    console:
      enabled: true
      path: /h2
```

### 访问测试

浏览器访问：/h2

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281533850.png" alt="image-20230128153318783" style="zoom:67%;" />

创建表

```sql
CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `name` varchar(30) DEFAULT NULL COMMENT '姓名',
  `password` varchar(255) DEFAULT NULL COMMENT '年龄',
  `phone` char(11) DEFAULT NULL COMMENT '手机号',
  PRIMARY KEY (`id`)
)
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281538303.png" alt="image-20230128153841228" style="zoom:67%;" />

### 结合MybatisPlus

```xml
<!--mybatis-plus依赖-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.2</version>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Integer id;
    private String name;
    private String password;
    private String phone;
}
```

```java
@Mapper
public interface UserDao extends BaseMapper<User> {

}
```

> 注意事项：项目不能启动，不然会提示端口占用

```java
@SpringBootTest
class Demo1ApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    void save() {
        userDao.insert(new User(2,"张三","123","133221"));
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301281552183.png" alt="image-20230128155229112" style="zoom: 67%;" />

# Druid数据库连接池

## 连接池类型

熟悉 web 系统开发的同学，基本都知道，在 Java 生态中开源的常用数据库连接池有以下几种：

> **dbcp**：DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池，DBCP可以直接的在应用程序中使用，**Tomcat的数据源使用的就是DBCP**

> **c3p0**：c3p0是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection和Statement池的DataSources对象

> **druid**：阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQL Server、H2等等。

在数据连接池方面，`druid`和`dbcp`旗鼓相当，而并发方面`druid`的稳定性大于`dbcp`，`c3p0`相比`druid`和`dbcp`，稳定性和执行速度要弱些。

在数据库方面，`postgresql`速度要优于`oracle`，而`oracle`对各个数据源的支持和稳定性要有优势，`mysql`相比`oracle`和`postgresql`，执行速度要弱些。

如果在实际开发中，数据源连接池推荐采用`druid`，数据库的选用方面 `postgresql` > `oracle` > `mysql`。

> Druid是阿里巴巴的一个开源项目，**号称为监控而生的数据库连接池，在功能、性能、扩展性方面都超过其他**，例如 DBCP、C3P0、BoneCP、Proxool、JBoss、DataSource 等连接池，而且Druid已经在阿里巴巴部署了超过600个应用，通过了极为严格的考验，这才收获了大家的青睐！

## Druid数据源概述

**Druid是一个JDBC组件，包含三个部分：**

> - DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。
> - DruidDataSource 高效管理的数据库连接池。
> - SQLParser SQL语法分析

### 强大的监控特性

> Druid内置了一个功能强大的`StatFilter`插件可以监控数据库访问性能，可以清楚知道连接池和SQL的工作情况。
>

> 监控SQL的执行时间、ResultSet持有时间、返回行数、更新行数、错误次数、错误堆栈信息。

> SQL执行的耗时区间分布。什么是耗时区间分布呢？比如说，某个SQL执行了1000次，其中0-1毫秒区间50次，1-10毫秒800次，10-100毫秒100次，100-1000毫秒30次，1-10秒15次，10秒以上5次。通过耗时区间分布，能够非常清楚知道SQL的执行耗时情况。监控连接池的物理连接创建和销毁次数、逻辑连接的申请和关闭次数、非空等待次数、PSCache命中率等。

### 数据库密码加密

> 直接把数据库密码写在配置文件中，容易导致安全问题。`DruidDriver`和`DruidDataSource`都支持`PasswordCallback`。

### SQLParser

> SQL Parser是Druid的一个重要组成部分，它提供了MySql、Oracle、Postgresql、SQL-92的SQL的完整支持，这是一个手写的高性能SQL Parser，支持Visitor模式，使得分析SQL的抽象语法树很方便。简单SQL语句用时10微秒以内，复杂SQL用时30微秒。

> 通过Druid提供的SQL Parser可以在JDBC层拦截SQL做相应处理，比如防御SQL注入（WallFilter）、合并统计没有参数化的SQL(StatFilter的mergeSql)、SQL格式化、分库分表。
>

### 配置参数

> - **stat：** Druid内置提供一个`StatFilter`，用于统计监控信息。
> - **wall：** Druid防御SQL注入攻击的`WallFilter`就是通过Druid的SQL Parser分析。Druid提供的`SQL Parser`可以在JDBC层拦截SQL做相应处理，比如说分库分表、审计等。
> - **log4j2：** 这个就是 日志记录的功能，可以把sql语句打印到log4j2供排查问题。

## Druid 监控实战

[(41条消息) Springboot整合Druid_我是泛滥-CSDN博客_druid springboot](https://blog.csdn.net/weixin_45627031/article/details/108111017)

maven网址：[Maven Repository: com.alibaba » druid (mvnrepository.com)](https://mvnrepository.com/artifact/com.alibaba/druid)

### Druid 数据源坐标

```xml
<!-- 数据连接池 druid-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.8</version>
</dependency>
<!--如果不加入这依赖配置监控统计拦截的filters时这个会报错 filters: stat,wall,log4j-->
<dependency>
   <groupId>log4j</groupId>
   <artifactId>log4j</artifactId>
   <version>1.2.17</version>
</dependency>
```

### 基本配置

```yml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/girls?serverTimezone=GMT%2B8
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
```

### 完整配置

Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以通过spring.datasource.type 指定数据源

```yml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/girls?serverTimezone=UTC
    type: com.alibaba.druid.pool.DruidDataSource
    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入log4j依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
```

注意：指定完成后，要在application.properties中启用，不然不能用

```properties
spring.profiles.include=a
```

### DruidConfig

```java
import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.support.http.StatViewServlet;
import com.alibaba.druid.support.http.WebStatFilter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import javax.sql.DataSource;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Configuration
public class DruidConfig {
    /*
       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建
       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource
       从而让它们生效
       @ConfigurationProperties(prefix = "spring.datasource")：作用就是将 全局配置文件中
       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource
       的同名参数中
     */
    @ConfigurationProperties(prefix = "spring.datasource")
    @Bean
    public DataSource druidDataSource() {
        return new DruidDataSource();
    }
    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new 
            ServletRegistrationBean(new StatViewServlet(), "/druid/*");
        Map<String,String> initParams = new HashMap<>();
        initParams.put("loginUsername","admin");
        initParams.put("loginPassword","123456");
        initParams.put("allow","");//默认就是允许所有访问
        //initParams.put("allow", "localhost")：表示只有本机可以访问
        initParams.put("deny","");
        //设置初始化参数
        bean.setInitParameters(initParams);
        return bean;
    }

    //2、配置一个web监控的filter
    //配置Druid 监控之web 监控的 filter
    //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());
        //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计
        Map<String,String> initParams = new HashMap<>();
        initParams.put("exclusions","*.js,*.css,/druid/*");
        bean.setInitParameters(initParams);
        //"/*" 表示过滤所有请求
        bean.setUrlPatterns(Arrays.asList("/*"));
        return  bean;
    }
}
```

### 访问测试

访问后台：:8081/druid/login.html

Druid就会对sql语句进行监控：查看druid数据源状态监控

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291644817.png" alt="image-20230129164412700" style="zoom:80%;" />

![image-20230129164434658](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291644769.png)

## Spring Druid监控实战⭐

[SpringBoot + Druid DataSource 实现监控 MySQL 性能](https://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&mid=2247513627&idx=1&sn=8b3c7e886ecdcf1a3f7277f2f58a49cb&chksm=fd57669dca20ef8be2438ad5ffd42d80b88a658ef23c6d3d1c4338987af9532fb785ff1b6981&mpshare=1&scene=23&srcid=0217KNhWx44UfZ8tqBAVfcJI&sharer_sharetime=1676609384671&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

druid-spring-boot-starter：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter

### Spring Druid坐标

在pom.xml中引入druid官方提供的Spring Boot Starter组件

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.15</version>
</dependency>
<dependency>
    <groupId>com.newrelic.logging</groupId>
    <artifactId>log4j2</artifactId>
    <version>2.6.0</version>
</dependency>
```

### 配置文件

application.yaml 配置文件配置数据库信息、以及Druid的连接池

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      # Druid数据源配置
      # 初始连接数
      initialSize: 5
      # 最小连接池数量
      minIdle: 10
      # 最大连接池数量
      maxActive: 20
      # 配置获取连接等待超时的时间
      maxWait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      timeBetweenEvictionRunsMillis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      minEvictableIdleTimeMillis: 300000
      # 配置一个连接在池中最大生存的时间，单位是毫秒
      maxEvictableIdleTimeMillis: 900000
      # 配置检测连接是否有效
      validationQuery: SELECT 1
      #申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，
      #执行validationQuery检测连接是否有效。
      testWhileIdle: true
      #配置从连接池获取连接时，是否检查连接有效性，true每次都检查；
      #false不检查。做了这个配置会降低性能。
      testOnBorrow: false
      #配置向连接池归还连接时，是否检查连接有效性，true每次都检查；
      #false不检查。做了这个配置会降低性能。
      testOnReturn: false
      #打开PsCache，并且指定每个连接上PSCache的大小
      poolPreparedStatements: true
      maxPoolPreparedStatementPerConnectionSize: 20
      #配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      filters: stat,wall,log4j2
      #合并多个DruidDatasource的监控数据
      useGlobalDataSourceStat: true
      #通过connectProperties属性来打开mergesql功能罗慢SQL记录
      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500;
      # 配置监控页面(重点)
      stat-view-servlet:
        login-username: admin
        login-password: 123456
        enabled: true
      filter:
        stat:
          log-slow-sql: true
          slow-sql-millis: 2000
```

### 启动测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291659162.png" alt="image-20230129165931025" style="zoom:67%;" />

### sql监控

配置Druid web监控filter（`WebStatFilter`）这个过滤器，作用就是统计web应用请求中所有的数据库信息，比如 发出的sql语句，sql执行的时间、请求次数、请求的url地址、以及seesion监控、数据库表的访问次数，如下配置：

```yml
spring:
  datasource:
    druid:
      ########## 配置WebStatFilter，用于采集web关联监控的数据 ##########
      web-stat-filter:
        enabled: true                   # 启动 StatFilter
        url-pattern: /*                 # 过滤所有url
        exclusions: "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*" # 排除一些不必要的url
        session-stat-enable: true       # 开启session统计功能
        session-stat-max-count: 1000    # session的最大个数,默认100
```

### 慢sql记录

有时候，系统中有些SQL执行很慢，我们希望使用日志记录下来，可以开启Druid的慢SQL记录功能，如下配置：

```yml
spring:
  datasource:
    druid:
      filter:
        stat:
          enabled: true         # 开启DruidDataSource状态监控
          db-type: mysql        # 数据库的类型
          log-slow-sql: true    # 开启慢SQL记录功能
          slow-sql-millis: 2000 # 默认3000毫秒，这里超过2s，就是慢，记录到日志
```

启动后，如果遇到执行慢的SQL，便会输出到日志中



### 获取 Druid 的监控数据

Druid的监控数据可以在开启`StatFilter`后，通过`DruidStatManagerFacade`进行获取;

`DruidStatManagerFacade#getDataSourceStatDataList`该方法可以获取所有数据源的监控数据，除此之外`DruidStatManagerFacade`还提供了一些其他方法，可以按需选择使用。

```
@RestController
@RequestMapping(value = "/druid")
public class DruidStatController {

    @GetMapping("/stat")
    public Object druidStat(){
        // 获取数据源的监控数据
        return DruidStatManagerFacade.getInstance().getDataSourceStatDataList();
    }
}
```

## 参数详解

### 全部配置

| 配置                                      | 缺省值             | 说明                                                         |
| :---------------------------------------- | :----------------- | :----------------------------------------------------------- |
| name                                      |                    | 如果存在多个数据源，监控的时候可以通过名字来区分开来。如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this) |
| url                                       |                    | 连接数据库的url，不同数据库不一样                            |
| username                                  |                    | 连接数据库的用户名                                           |
| password                                  |                    | 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter |
| driverClassName                           |                    | 根据url自动识别 ，这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName |
| initialSize                               | 0                  | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive                                 | 8                  | 最大连接池数                                                 |
| minIdle                                   |                    | 最小连接池数                                                 |
| maxWait                                   |                    | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |
| poolPreparedStatements                    | false              | 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 |
| maxPoolPreparedStatementPerConnectionSize | -1                 | 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 |
| validationQuery⭐                          |                    | 用来检测连接是否有效的sql，要求是一个查询语句，常用select ‘x’。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。 |
| validationQueryTimeout                    |                    | 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 |
| testOnBorrow                              | true               | 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testOnReturn                              | false              | 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 |
| testWhileIdle                             | false              | 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 |
| keepAlive                                 | false （1.0.28）   | 连接池中的minIdle数量以内的连接，空闲时间超过minEvictableIdleTimeMillis，则会执行keepAlive操作。 |
| timeBetweenEvictionRunsMillis             | 1分钟（1.0.14）    | 有两个含义：1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 |
| numTestsPerEvictionRun                    | 30分钟（1.0.14）   | 不再使用，一个DruidDataSource只支持一个EvictionRun           |
| minEvictableIdleTimeMillis                |                    | 连接保持空闲而不被驱逐的最小时间                             |
| connectionInitSqls                        |                    | 物理连接初始化的时候执行的sql                                |
| exceptionSorter                           | 根据dbType自动识别 | 当数据库抛出一些不可恢复的异常时，抛弃连接                   |
| filters                                   |                    | 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：监控统计用的filter:stat， 日志用的filter:log4j 或者 slf4j或者log4j2， 防御sql注入的filter:wall |
| proxyFilters                              |                    | 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 |

### Filter详解

| 别名          | Filter类名                                              |
| :------------ | :------------------------------------------------------ |
| default       | com.alibaba.druid.filter.stat.StatFilter                |
| stat          | com.alibaba.druid.filter.stat.StatFilter                |
| mergeStat     | com.alibaba.druid.filter.stat.MergeStatFilter           |
| encoding      | com.alibaba.druid.filter.encoding.EncodingConvertFilter |
| log4j         | com.alibaba.druid.filter.logging.Log4jFilter            |
| log4j2        | com.alibaba.druid.filter.logging.Log4j2Filter           |
| slf4j         | com.alibaba.druid.filter.logging.Slf4jLogFilter         |
| commonlogging | com.alibaba.druid.filter.logging.CommonsLogFilter       |
| wall          | com.alibaba.druid.wall.WallFilter                       |

### validationQuery详解

其实我们比较需要注意的就是 `validationQuery`这个参数,`validationQuery`是用来验证数据库连接的查询语句，这个查询语句必须是至少返回一条数据的SELECT语句。每种数据库都有各自的验证语句，阿粉也收集了几种常见数据库的validationQuery。

> - hsqldb select 1 from INFORMATION_SCHEMA.SYSTEM_USERS
> - Oracle select 1 from dual
> - DB2 select 1 from sysibm.sysdummy1
> - MySql select 1
> - Microsoft SqlServer select1
> - postgresql select version()
> - ingres select 1
> - derby values 1
> - H2 select 1

而这个参数，一般是否执行，都是靠着 `testOnBorrow` 还有 `testOnReturn`

`testOnBorrow`设置为true后如果要生效,validationQuery参数必须设置为非空字符串。

同样的 `testOnReturn` 设置为true后如果要生效,validationQuery参数必须设置为非空字符串。

但是如果我们设置 `testOnBorrow` 为 false 的时候，也会出现一些些的问题，

> 假如链接池中的链接被数据库关闭了，应用经过链接池getConnection时，均可能获取到这些不可用的链接，且这些链接若是不被其余线程回收的话；它们不会被链接池废除，也不会从新被建立，占用了链接池的名额，项目若是是服务端，数据库连接被关闭，客户端调用服务端就会出现大量的timeout，客户端设置了超时时间，会主动断开，服务端就会出现close_wait。

> 这也是为什么有时候在排查日志的时候，会出现一些 close_wait 的错误，虽然知道并不影响业务，但是日志上看着还是难受。

那么为什么还要设置成 false 呢？

> 因为 `testOnBorrow` 能够确保我们每次都能获取到可用的连接，但如果设置成 true ，则每次获取连接的时候都要到数据库验证连接有效性，这在高并发的时候会造成性能下降，可以将`testOnBorrow`设成false，testWhileIdle设置成true这样能获得比较好的性能。

> 这样也会执行我们上面所说的 `validationQuery` 参数中的 SQL 来验证连接的有效性。这样在每次连接失效之后，都会通过`validationQuery` 来进行验证是否失效。



## 加密

[使用阿里巴巴 Druid 轻松实现加密！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247530381&idx=2&sn=796f15cbbbc09d120c6dc47bbe5b2087&chksm=ebd548a1dca2c1b71f6985417c93a9ace1c993a452835916c3e6f4f60853202e86d8592b1407&mpshare=1&scene=23&srcid=1109BihPdsn56A9xDJYeff1J&sharer_sharetime=1667959528667&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

### 为什么要加密

> 现在的开发习惯，无论是公司的项目还是个人的项目，都会选择将源码上传到 Git 服务器（GitHub、Gitee 或是自建服务器），但只要**将源码提交到公网服务器就会存在源码泄漏的风险**，而数据库配置信息作为源码的一部分，一旦出现源码泄漏，那么数据库中的所有数据都会公之于众，其产生的不良后果无法预期（比如某某酒店的信息）。
>

> 于是**为了避免这种问题的产生，我们至少要对数据库的密码进行加密操作**，这样即使得到了源码，也不会造成数据的泄露，也算保住了最后一块遮羞布。
>

### 加密执行流程

在没有进行密码加密之前，项目的交互流程是这样的：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241640565.png" alt="image-20220824164048475" style="zoom:67%;" />

在使用了密码加密之后，项目的交互流程就变成了这样：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208241641688.png" alt="image-20220824164111593" style="zoom: 67%;" />

### 加密实战

#### 添加Druid依赖

```xml
<dependency>
   <groupId>com.alibaba</groupId>
   <artifactId>druid-spring-boot-starter</artifactId>
   <version>1.2.15</version>
</dependency>
```

获取 Druid 最新版本：https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter

#### 生成密文

Druid 添加完成之后就可以借助 Druid 中提供的 `ConfigTools` 类来加密密码了，实现代码如下：

```java
@Test
public void testWeb() throws Exception {
    // 需要加密的明文命名
    String password = "123456"; // 【注意：这里要改为你自己的密码】
    // 调用 druid 生成私钥、公钥、密文
    ConfigTools.main(new String[]{password});
}
```

以上代码执行的结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301291719247.png" alt="image-20230129171907156" style="zoom:80%;" />

从上述结果可以看出，使用 `ConfigTools` 类会生成 3 部分的内容：

1. privateKey：私钥，暂时不会用到，用于密码的加密；
2. publicKey：公钥，用于密码的解密；
3. password：加密之后的密码。

> PS：要实现数据库的加密，主要使用的是 publicKey（公钥）和 password（密文），这就把明文转换成密文了。

#### 添加配置

完成了以上操作之后，只需要将上一步生成的**公钥**和**密文**添加到项目的配置文件 application.yml（或application.xml）中就实现了加密操作了，具体配置信息如下：

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
      username: root
      # 密码加密配在这
      password: fCbxVBqlrLocIxC3dn3mTl6y8Z...5uQrtLrJP1oiZxPc5ACHA== 
      # Druid数据源配置
      # 初始连接数
      initialSize: 5
      # 最小连接池数量
      minIdle: 10
      # 最大连接池数量
      maxActive: 20
      # 配置获取连接等待超时的时间
      maxWait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      timeBetweenEvictionRunsMillis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      minEvictableIdleTimeMillis: 300000
      # 配置一个连接在池中最大生存的时间，单位是毫秒
      maxEvictableIdleTimeMillis: 900000
      # 配置检测连接是否有效
      validationQuery: SELECT 1
      #申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，
      #执行validationQuery检测连接是否有效。
      testWhileIdle: true
      #配置从连接池获取连接时，是否检查连接有效性，true每次都检查；
      #false不检查。做了这个配置会降低性能。
      testOnBorrow: false
      #配置向连接池归还连接时，是否检查连接有效性，true每次都检查；
      #false不检查。做了这个配置会降低性能。
      testOnReturn: false
      #打开PsCache，并且指定每个连接上PSCache的大小
      poolPreparedStatements: true
      maxPoolPreparedStatementPerConnectionSize: 20
      #配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      #加密要加上config 
      filters: config,stat,wall,log4j2
      #合并多个DruidDatasource的监控数据
      useGlobalDataSourceStat: true
      # 配置监控页面(重点)
      stat-view-servlet:
        login-username: admin
        login-password: 123456
        enabled: true
      filter:
        stat:
          log-slow-sql: true
          slow-sql-millis: 2000
        config: # 加密也要有这一项
          enabled: true
      # 以下是公钥配置
      connection-properties:  druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500;config.decrypt=true;config.decrypt.key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJWSu8Bl+JKAu7dK/eoa/J8SKeEupAJfyzH3fIjwFGbK7HkPp2GJ4FidAJyDaqVn+4EI1RiDW7sOLazlmVysWtcCAwEAAQ==
```

> 其中 password 对应的是上一步生成的 password（密文），而 config.decrypt.key 对应的是上一步生成的 publicKey（公钥），如果能正常启动项目，表示已经配置完成加密



### 注意事项-插着钥匙的锁

> 经过前面 3 步的配置之后，我们的程序就可以正常运行了，但这远没有结束！
>

> 在第 3 步配置时，我们将密文和公钥都写入配置文件，这就会造成**当有人拿到密文和公钥之后，就可以使用 Druid 将加密的密码还原出来了**，这就好比一把插着钥匙的锁是极不安全的。
>

> 因此我们**正确的使用姿势：是将公钥找一个安全的地方保存起来，每次在项目启动时动态的将公钥设置到项目中**，这样就可以有效的保证密码的安全了。
>

##### 正确的配置文件

接下来我们将 Spring Boot 的公钥设置为配置项，在项目运行时再替换为具体的值，最终的安全配置信息如下：

```yml
spring:
  # MySQL 配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      url: jdbc:mysql://localhost:3307/xuexi?serverTimezone=UTC
      username: root
      password: IMgKm27bOHok3/+5aDL4jGBoVVZkpicbbM6...
      # encrypt config
      filters: config
      connect-properties:
        config.decrypt: true
        config.decrypt.key: ${spring.datasource.druid.publickey}
```

可以看出公钥被修改成“${spring.datasource.druid.publickey}”了，这就相当于使用占位符先把坑给占上，等项目启动时再更换上具体的值。

> PS：“spring.datasource.druid.publickey”并非是固定不可变的 key，此 key 值用户可自行定义。

##### 开发环境替换公钥

开发环境只需要在 Idea 的启动参数中配置公钥的值即可，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjf9ibPvo8r6KjSt1dab87nltUeV5rpKibfLw1RtFgE3hR3sv4m17C25R7ZE6dLoG35Audc0Xvrib4OA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)当我们输入正确的公钥值时程序可以正常运行，当输入一个错误的公钥值时就会提示解码失败，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjf9ibPvo8r6KjSt1dab87nlLLdDEWcz9Y09Y5Ue73ib7k7C4S4GUWkmcjzLuNcg97SxWffrU3ovibtA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

##### 生产环境替换公钥

生产环境在启动 jar 包时只需要动态设置公钥的值即可，参考以下命令：

> java -jar xxx.jar --spring.datasource.druid.publickey=你的公钥

### Druid运行原理

经过上述步骤之后，我们就完成 MySQL 密码的加密了，这样当 Spring Boot 项目启动时，**Druid 的拦截器会使用密文和公钥将密码还原成真实的密码以供项目使用**，当然这一切都无需人工干预（无需编写任何代码），Druid 已经帮我封装好了，我们只需要通过以上配置即可。

什么？你想知道 Druid 是如何通过密文和公钥还原出真实的密码的？

没问题，满足你，其实 `ConfigTools` 类中已经提供了相应实现，代码如下：

```java
// 密文
String password = "VwH1mu2IUpqjfKTd+gSikiZgJTi+3Y5z...";
// 公钥
String publicKey = "MFwwDQYJKoZIhvcNAQEBBQADS...";
// 还原成真实的密码
String result = ConfigTools.decrypt(publicKey, password);
System.out.println("最终结果：" + result);
```

# 优雅停机

## 什么叫优雅停机

简单的说，就是向应用进程发出停止指令之后，能保证正在执行的业务操作不受影响，直到操作运行完毕之后再停止服务。应用程序接收到停止指令之后，会进行如下操作：

> - 停止接收新的访问请求
> - 正在处理的请求，等待请求处理完毕；对于内部正在执行的其他任务，比如定时任务、mq 消费等等，也要等当前正在执行的任务执行完毕，并且不再启动新的任务
> - 当应用准备关闭的时候，按需向外发出信号，告知其他应用服务准备接手，以保证服务高可用

> 如果暴力的关闭应用程序，比如通过`kill -9 <pid>`命令强制直接关闭应用程序进程，可能会导致正在执行的任务数据丢失或者错乱，也可能会导致任务所持有的全局资源等不到释放，比如当前任务持有 redis 的锁，并且没有设置过期时间，当任务突然被终止并且没有主动释放锁，会导致其他进程因无法获取锁而不能处理业务。

那么如何在不影响正在执行的业务的情况下，将应用程序安全的进行关闭呢？SpringBoot 官方文档上，已经告诉开发者只需要实现特定接口即可监听到项目启动成功与关闭时的事件，相关接口如下：

- `CommandLineRunner`接口：当应用启动成功后但在开始接受流量之前，会回调此接口的实现类，也可以实现`ApplicationRunner`接口，工作的方式与`CommandLineRunner`与之类似
- `DisposableBean`接口：当应用正要被销毁前，会回调此接口的实现类，也可以使用`@PreDestroy`注解，被标记的方法也会被调用

基于此流程，我们可以创建一个服务监听类，用于监听到项目启动成功与关闭时的回调服务，示例代码如下：

```java
@Component
public class AppListener implements CommandLineRunner, DisposableBean {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("应用启动成功，预加载相关数据");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("应用正在关闭，清理相关数据");
    }

}
```

每一个`SpringApplication`在启用的时候，都会向 JVM 注册一个关闭钩子`shutdown hook`，以确保`ApplicationContext`在退出的时候，通过这个勾子通知 JVM，实现服务正常的关闭，以下介绍的所有关闭服务的方法，都是基于这一原理进行实现的。

#### 通过Actuator的Endpoint机制

使用此方法，需要先添加`spring-boot-starter-actuator`监控服务依赖包，

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

默认配置下，`shutdown`端点是关闭的，需要在`application.properties`里配置里面开启：

```java
management.endpoint.shutdown.enabled=true
```

虽然`Actuator`的端点，支持通过`JMX`或`HTTP`进行远程访问。而`shutdown`默认配置下是不支持`HTTP`进行`Web`访问的，所以使用`HTTP`请求进行关闭时的配置，也需要开启：

```java
management.endpoints.web.exposure.include=shutdown
```

最后将`SpringBoot`服务启动之后，使用`POST`请求类型，调用以下接口，即可实现关闭服务！

```sh
http://127.0.0.1:8080/actuator/shutdown
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/tWOhQMr1wdCD0BIpm1bRzCkicWa8dfjLAWSInshCLibShaxo57ibZXpHh4uUmAFtiaYqJOO8D0xyVf7aPKCVkicibabw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

#### ApplicationContext的close方法

如果你不想添加`spring-boot-starter-actuator`监控服务依赖包来关停服务，也可以使用`ApplicationContext`的`close`方法来关停服务，他会自动销毁`bean`对象并关停服务。

只需要在应用启用的时候，获取`ApplicationContext`对象，然后在相关的位置调用`close`方法，就可以关闭服务。

示例代码如下：

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
      ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);

      try {
         TimeUnit.SECONDS.sleep(10);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
      //启动10秒以后，自动关闭
      context.close();
    }
}
```

当然我们也可以自己写一个`Controller`，获取对应的`ApplicationContext`对象，通过`api`操作调用`close`方法关停服务，示例代码如下：

```java
@RestController
public class ShutdownController implements ApplicationContextAware {

    private ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) 
        throws BeansException {
        this.context = applicationContext;
    }

    /**
     * 关闭服务
     */
    @GetMapping("/shutdown")
    public void shutdownContext() {
        ((ConfigurableApplicationContext) context).close();
    }
}
```

#### 监听服务pid，通过kill方式关闭服务

通过`api`方式来关停服务，在很多人看来并不安全，因为一旦接口泄漏了，意味着用户可以随便请求这个接口来关闭服务，其影响不言而喻，因此很多人建议在服务端，通过其他的方式来关闭服务，比如通过进程命令方式来关停。

在`springboot`启动的时候将应用进程 ID 写入一个`app.pid`文件，生成的路径可以指定，然后通过脚本命令方式来关闭服务。

启动示例代码如下：

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(Application.class);
        application.addListeners(new ApplicationPidFileWriter("/home/app/project1/app.pid"));
        application.run();
    }
}
```

通过如下命令方式，可以安全的关闭服务。

```sh
cat /home/app/project1/app.pid | xargs kill
```

这种方式，也是目前在`linux`操作系统中，使用较为普遍的一种解决方案，区别在于实现的方式可能不同，有的不用写文件，通过其他方式来获取应用进程 ID。

**如果使用`kill -9 <pid>`的方式关闭服务，服务的监听器不会收到任何消息，类似于直接强杀应用进程，此方法不可取**！

## SpringApplication的exit方法

通过调用一个`SpringApplication.exit()`方法也可以安全的退出程序，同时会返回一个退出码，这个退出码可以传递给所有的`context`，最后通过调用`System.exit()`可以将这个错误码也传给`JVM`。

示例代码如下：

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);

        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //5秒后，关闭服务
        exitApplication(context);
    }

    public static void exitApplication(ConfigurableApplicationContext context) {
     //获取退出码
        int exitCode = SpringApplication.exit(context, (ExitCodeGenerator) () -> 0);
        //退出码传递给jvm，安全退出程序
        System.exit(exitCode);
    }

}
```

## 其他监听介绍

#### 3.1、ApplicationListener

如果有些服务，比如定时任务，我们想在`SpringBoot`关闭数据源连接池之前，将其关闭，可以通过实现`ApplicationListener`接口，监听`bean`对象的变化情况，在`bean`对象销毁之前，执行相关的关闭任务。

示例代码如下：

```java
@Component
public class JobTaskListener implements ApplicationListener {

    @Override
    public void onApplicationEvent(ApplicationEvent applicationEvent) {
        // 在spring bean容器销毁之前执行的事件，防止数据库连接池在任务终止前销毁
        if (applicationEvent instanceof ContextClosedEvent) {
            System.out.println("关闭相关的定时任务");
        }
    }
}
```

#### 3.2、PreDestroy

上文中，我们提到了实现`DisposableBean`接口，可以监听应用关闭前的回调处理，其实在自定义的方法上加`@PreDestroy`注解，也可以实现相同的效果。

示例代码如下：

```java
@Component
public class AppDestroyConfig {

    @PreDestroy
    public void PreDestroy(){
        System.out.println("应用程序正在关闭。。。");
    }
}
```



# Jackson的JSON操作

[用好Jackson，操作Json节省一半时间 (qq.com)](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488021&idx=1&sn=75516e4e306340a172d91ff3bd0b0566&chksm=cf21cd3cf856442a4f12e7d308247510802f36c3cd6c3c71c16970ddc174a7c2a08bac73162c&mpshare=1&scene=23&srcid=0718rm5kvUHES1NIQI0VYnMZ&sharer_sharetime=1658105824134&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

[最棒的Json解析工具Jackson，看这一篇就够了 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&mid=2247484429&idx=1&sn=48dc7202189fd48394a4facaee953a87&chksm=c0cceca8f7bb65bef523616dbccea62114225c3d7694555bc64f6c06f0d5a4ffa0a4857ccfc6&mpshare=1&scene=23&srcid=0725ObXEXgA17M52cgh1C8LV&sharer_sharetime=1658761805322&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> 目前解析Json的工具包有，Gson，FastJson，Jackson，Json-lib。综合来看，Jackson的性能较优，稳定性也比较高，而且spring-boot-starter-web默认会引入Jackson包。因此介绍一下Jackson的使用。

## Jackson 依赖

在pom中加入如下依赖即可

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.2</version>
</dependency>

<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.2</version>
</dependency>

<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.2</version>
</dependency>
```

前文说过，当使用spring-boot-starter-web模块时，会默认引入Jackson包，不必在pom中再次引入上面依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

## JSON工具类

> 将常用的方法封装成一个常用的工具类，如下所示，有2个好处。一般的工具类，都是单例的，同时是线程安全的。ObjectMapper也不例外，它也是线程安全的，你可以并发的执行它，不会产生任何问题。
>

```java
@Slf4j
public class JsonUtil {

    private static final ObjectMapper objectMapper = new ObjectMapper();

    static {
        //忽略 在json字符串中存在，但是在java对象中不存在对应属性的情况。防止错误
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    // 将对象转为string
    public static <T> String obj2String(T obj){

        if(obj == null){
            return null;
        }
        try {
            return obj instanceof String ? (String)obj :
                    objectMapper.writeValueAsString(obj);
        } catch (Exception e) {
            log.warn("将对象转为string错误：",e);
            return null;
        }
    }
    
    // 将对象转为string, 并且进行JSON格式化
    public static <T> String obj2StringPretty(T obj){
        if(obj == null){
            return null;
        }
        try {
            return obj instanceof String ? (String)obj : objectMapper
                    .writerWithDefaultPrettyPrinter()
                    .writeValueAsString(obj);
        } catch (Exception e) {
            log.warn("Parse Object to String error",e);
            return null;
        }
    }
    
    // 将json转为java对象
    public static <T> T string2Obj(String str, Class<T> clazz){
        if(StringUtils.isEmpty(str) || clazz == null){
            return null;
        }
        try {
            return clazz.equals(String.class)? (T)str:objectMapper.readValue(str, clazz);
        } catch (Exception e) {
            log.warn("Parse String to Object error",e);
            return null;
        }
    }
}
```



## JSON序列化

### 0. 初始准备

#### 实体类

将java对象序列化成json,@Data注解是用lombok插件来自动生成get和set方法

```java
@Data
public class Student {
    /** 名字 */
    private String name;
    /** 年龄 */
    private Integer age;
    /** 头像 */
    private String profileImageUrl;
}
```



### 1. 将对象转为json

将此方法加入工具类

```java
public static <T> String obj2String(T obj){
    if(obj == null){
        return null;
    }
    try {
        return obj instanceof String ? (String)obj : objectMapper.writeValueAsString(obj);
    } catch (Exception e) {
        log.warn("Parse Object to String error",e);
        return null;
    }
}
```

各种类型均可

```java
@Test
public void obj2String() throws Exception {
    Student student = new Student();
    student.setAge(10);
    student.setName("renshuo");
    student.setProfileImageUrl("link");
    String result = JsonUtil.obj2String(student);
    // {"name":"renshuo","age":10,"profileImageUrl":"link"}
    System.out.println(result);

    Map<String, List<Integer>> map = new HashMap<>();
    map.put("a", Arrays.asList(1, 2, 3));
    map.put("b", Arrays.asList(1, 2, 3));
    String result1 = JsonUtil.obj2String(map);
    // {"a":[1,2,3],"b":[1,2,3]}
    System.out.println(result1);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207191722068.png" alt="image-20220719172240998" style="zoom:67%;" />

### 2. 将对象转为json，并格式化的输出

将此方法加入工具类

```java
public static <T> String obj2StringPretty(T obj){
    if(obj == null){
        return null;
    }
    try {
        return obj instanceof String ? (String)obj : objectMapper
                                                     .writerWithDefaultPrettyPrinter()
                                                     .writeValueAsString(obj);
    } catch (Exception e) {
        log.warn("Parse Object to String error",e);
        return null;
    }
}
```

------

```java
@Test
public void obj2StringPretty() throws Exception {
    Student student = new Student();
    student.setAge(10);
    student.setName("name");
    student.setProfileImageUrl("link");
    String result = JsonUtil.obj2StringPretty(student);
    /*
    {
        "name" : "name",
        "age" : 10,
        "profileImageUrl" : "link"
    }
    */
    System.out.println(result);

    Map<String, List<Integer>> map = new HashMap<>();
    map.put("a", Arrays.asList(1, 2, 3));
    map.put("b", Arrays.asList(1, 2, 3));
    String result1 = JsonUtil.obj2StringPretty(map);

    /*
    {
        "a" : [ 1, 2, 3 ],
        "b" : [ 1, 2, 3 ]
    }
    */
    System.out.println(result1);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207191723255.png" alt="image-20220719172326172" style="zoom:67%;" />

## Jackson反序列化

> 将json转为java对象

### 方式1

```java
public static <T> T string2Obj(String str, Class<T> clazz){
    if(StringUtils.isEmpty(str) || clazz == null){
        return null;
    }

    try {
        return clazz.equals(String.class)? (T)str : objectMapper.readValue(str, clazz);
    } catch (Exception e) {
        log.warn("Parse String to Object error",e);
        return null;
    }
}
```

基本类型的转换

```java
@Test
public void string2Obj() throws Exception {
    String str = "{\"name\":\"name\",\"age\":10,\"profileImageUrl\":\"link\"}";
    Student student = JsonUtil.string2Obj(str, Student.class);
    // Student(name=name, age=10, profileImageUrl=link)
    System.out.println(student);
}
```

各种复杂类型的转换，示例1

```java
@Test
public void string2Obj1() throws Exception {

    Student student1 = new Student();
    student1.setAge(10);
    student1.setName("name1");
    student1.setProfileImageUrl("link1");

    Student student2 = new Student();
    student2.setAge(20);
    student2.setName("name2");
    student2.setProfileImageUrl("link2");

    List<Student> studentList = new ArrayList<>();
    studentList.add(student1);
    studentList.add(student2);
    String result = JsonUtil.obj2String(studentList);
    // [{"name":"name1","age":10,"profileImageUrl":"link1"},  
    //  {"name":"name2","age":20,"profileImageUrl":"link2"}]
    System.out.println(result);

    List<Student> finalList = JsonUtil.string2Obj(result, List.class);
    // [{name=name1, age=10, profileImageUrl=link1}, 
    //  {name=name2, age=20, profileImageUrl=link2}]
    System.out.println(finalList);
}
```

复杂类型的转换，示例2

```java
@Test
public void string2Obj2() throws Exception {

    Map<String, List<Integer>> testMap = new HashMap<>();
    testMap.put("1", Arrays.asList(1, 2, 3));
    testMap.put("2", Arrays.asList(2, 3, 4));

    String result = JsonUtil.obj2String(testMap);
    // {"1":[1,2,3],"2":[2,3,4]}
    System.out.println(result);

    Map<String, List<Integer>> finalMap = JsonUtil.string2Obj(result, Map.class);
    // {1=[1, 2, 3], 2=[2, 3, 4]}
    System.out.println(finalMap);
}
```

到现在为止，你可以用这3个函数进行序列化和反序列化操作

```java
/** 将对象转为json */
public static <T> String obj2String(T obj) 

/** 将对象转为json,并格式化显示 */
public static <T> String obj2StringPretty(T obj)

/** 将json转为对象 */
public static <T> T string2Obj(String str, Class<T> clazz)
```

可能你还看过其他类型的解析方式，如下所示，但是没有必要，上面3个函数完全能满足你的需求，我这里演示一下

### 方式2

```java
public static <T> T string2Obj(String str, TypeReference<T> typeReference){
    if(StringUtils.isEmpty(str) || typeReference == null){
        return null;
    }
    try {
        return (T)(typeReference.getType().equals(String.class)? str : 
                   objectMapper.readValue(str,typeReference));
    } catch (Exception e) {
        log.warn("Parse String to Object error",e);
        return null;
    }
}
```

------

```java
@Test
public void string2Obj3() throws Exception {

    Student student1 = new Student();
    student1.setAge(10);
    student1.setName("name1");
    student1.setProfileImageUrl("link1");

    Student student2 = new Student();
    student2.setAge(20);
    student2.setName("name2");
    student2.setProfileImageUrl("link2");

    List<Student> studentList = new ArrayList<>();
    studentList.add(student1);
    studentList.add(student2);
    String result = JsonUtil.obj2String(studentList);
    // [{"name":"name1","age":10,"profileImageUrl":"link1"},
    //  {"name":"name2","age":20,"profileImageUrl":"link2"}]
    System.out.println(result);

    List<Student> finalList = JsonUtil.string2Obj(result, 
                                                  new TypeReference<List<Student>>(){});
    // [{name=name1, age=10, profileImageUrl=link1}, 
    //  {name=name2, age=20, profileImageUrl=link2}]
    System.out.println(finalList);
}
```

### 方式3

```java
public static <T> T string2Obj(String str, Class<?> collectionClass, Class<?>... elementClasses){
    JavaType javaType = objectMapper.getTypeFactory()
                                    .constructParametricType(collectionClass,elementClasses);
    try {
        return objectMapper.readValue(str,javaType);
    } catch (Exception e) {
        log.warn("Parse String to Object error",e);
        return null;
    }
}
```

------

```java
@Test
public void string2Obj4() throws Exception {

    Student student1 = new Student();
    student1.setAge(10);
    student1.setName("name1");
    student1.setProfileImageUrl("link1");

    Student student2 = new Student();
    student2.setAge(20);
    student2.setName("name2");
    student2.setProfileImageUrl("link2");

    List<Student> studentList = new ArrayList<>();
    studentList.add(student1);
    studentList.add(student2);
    String result = JsonUtil.obj2String(studentList);
    // [{"name":"name1","age":10,"profileImageUrl":"link1"},
    //  {"name":"name2","age":20,"profileImageUrl":"link2"}]
    System.out.println(result);

    List<Student> finalList = JsonUtil.string2Obj(result, List.class, Student.class);
    // [{name=name1, age=10, profileImageUrl=link1}, 
    //  {name=name2, age=20, profileImageUrl=link2}]
    System.out.println(finalList);
}
```

## 常用注解及配置

下面是一些常用的注解：

| 注解               | 用法                                                         |
| :----------------- | :----------------------------------------------------------- |
| @JsonProperty      | 用于属性，把属性的名称序列化时转换为另外一个名称             |
| @JsonFormat        | 用于属性或者方法，把属性的格式序列化时转换成指定的格式       |
| @JsonPropertyOrder | 用于类， 指定属性在序列化时 json 中的顺序                    |
| @JsonCreator       | 用于构造方法，和 @JsonProperty 配合使用，适用有参数的构造方法 |
| @JsonAnySetter     | 用于属性或者方法，设置未反序列化的属性名和值作为键值存储到 map 中 |
| @JsonAnyGetter     | 用于方法 ，获取所有未序列化的属性                            |

下面是一些注解的详细说明。

### @JsonIgnore忽略属性

```java
@Data
public class Student {
    /** 名字 */
    private String name;
    /** 年龄 */
    private Integer age;
    /** 头像 */
    @JsonIgnore
    private String profileImageUrl;
}
```

------

```java
@Test
public void jsonIgnore() throws Exception {
    Student student = new Student();
    student.setAge(10);
    student.setName("name");
    student.setProfileImageUrl("link");
    String result = JsonUtil.obj2String(student);
    // {"name":"name","age":10}
    System.out.println(result);

    String str = "{\"name\":\"name\",\"age\":10,\"profileImageUrl\":\"link\"}";
    Student student1 = JsonUtil.string2Obj(str, Student.class);
    // Student(name=name, age=10, profileImageUrl=null)
    System.out.println(student1);
}
```

### @JsonProperty

当Json的属性值和Java的属性值不一样时，会映射失败，用这个注解指定映射关系，在属性上用这个注解，则序列化和反序列化都会用这个值。如果序列化和反序列化的属性不一致，可以在get方法或者set方法上用这个注解，set方法影响反序列化，get方法影响序列化。

去掉@Data注解

```java
public class Student {

    /** 名字 */
    private String name;
    /** 年龄 */
    private Integer age;
    /** 头像 */
    private String profileImageUrl;

    @JsonProperty("getImage")
    public String getProfileImageUrl() {
        return profileImageUrl;
    }
    @JsonProperty("setImage")
    public void setProfileImageUrl(String profileImageUrl) {
        this.profileImageUrl = profileImageUrl;
    }
}
```

------

```java
@Test
public void jsonProperty() throws Exception {

    String str = "{\"name\":\"name\",\"age\":10,\"setImage\":\"link\"}";
    Student student1 = JsonUtil.string2Obj(str, Student.class);
    // name
    System.out.println(student1.getName());
    // 10
    System.out.println(student1.getAge());
    // link
    System.out.println(student1.getProfileImageUrl());
    // {"name":"name","age":10,"getImage":"link"}
    System.out.println(JsonUtil.obj2String(student1));
}
```

### @JsonFormat

注意事项：`只是获取数据时进行格式化，存储数据时还是正常的该是Date该是LocalTime就是那样，不变`

使用`@JsonFormat`注解格式化时间，应该算是一个基本操作了，大部分开发者都应用此种方式，简单方便。

```java
import java.time.LocalDateTime;
import java.util.Date;

@Data
public class User {
    private Integer id;
    private String name;
    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private Date updateTime;
}
```

进行测试使用

```java
@GetMapping("/hello1")
public User hello1() {
    User u = new User();
    u.setId(1);
    u.setName("张三");
    u.setCreateTime(LocalDateTime.now());
    u.setUpdateTime(new Date());
    return u;
}
```

结果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220416155816160.png" alt="image-20220416155816160" style="zoom: 55%;" />

测试一下结果，发现 `Date` 类型和 `LocalDateTime` 类型都格式化成功，但还是有个问题，这样做仍然比较繁琐，每个实体类的日期字段都要加`@JsonFormat`注解，重复的工作量也不小。接着往下看~



### @JsonIgnoreProperties

@JsonIgnoreProperties(ignoreUnknown = true)

如果json字符串中的属性个数小于java对象中的属性个数，可以顺利转换，java中多的那个属性为null

如果json字符串中出现java对象中没有的属性，则在将json转换为java对象时会报错：Unrecognized field, not marked as ignorable

解决方法1：
在目标对象的类级别上添加注解：@JsonIgnoreProperties(ignoreUnknown = true)

解决方法2：

```java
@Slf4j
public class JsonUtil {

    private static ObjectMapper objectMapper = new ObjectMapper();

    static {
        //忽略 在json字符串中存在，但是在java对象中不存在对应属性的情况。防止错误
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
    
}
```

这样就不用在目标类上加@JsonIgnoreProperties属性了，体现了全局配置的优势，配置项很多，包括格式化显示日期等，不再详细介绍，百度配置即可

## 用Tree Mode方式解析JSON

除了将json转为对象外，还可以用Tree Mode方式解析JSON，全程无脑操作，除了一些特别复杂的JSON，或者只取JSON中的一部分，千万不要用这种二B方式解析JSON。正确的方式是将JSON直接转为对象。我这里演示一下解析的方式

```json
{
    "name": "zhansan", 
    "age": 100, 
    "schools": [
        {
            "name": "tsinghua", 
            "location": "beijing"
        }, 
        {
            "name": "pku", 
            "location": "beijing"
        }
    ]
}
```

------

```java
@Test
public void parseJson() throws Exception {
    String jsonStr = "{\"name\":\"zhansan\",\"age\":100,\"schools\":    [{\"name\":\"tsinghua\",\"location\":\"beijing\"},{\"name\":\"pku\",\"location\":\"beijing\"}]}";

    ObjectMapper objectMapper = new ObjectMapper();
    JsonNode jsonNode = objectMapper.readTree(jsonStr);

    String name = jsonNode.get("name").asText();
    int age = jsonNode.get("age").asInt();
    // name is zhansan age is 100
    System.out.println("name is " + name + " age is " + age);
    // 获取嵌套内容
    JsonNode schoolsNode = jsonNode.get("schools");
    for (int i = 0; i < schoolsNode.size(); i++) {
        String schooleName = schoolsNode.get(i).get("name").asText();
        String schooleLocation = schoolsNode.get(i).get("location").asText();
        // schooleName is tsinghua schooleLocation is beijing
        // schooleName is pku schooleLocation is beijing
        System.out.println("schooleName is " + schooleName + " schooleLocation is " +
                           schooleLocation);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207191746402.png" alt="image-20220719174600339" style="zoom:80%;" />



# 项目实战 ⭐

## 方案 & 功能分析

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261356174.png" alt="image-20230126135639074" style="zoom:67%;" />

## 基础配置

### 添加依赖

```xml
<dependencies>
    <!--spring-web依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--mybatis-plus依赖-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.3</version>
    </dependency>
    <!--druid数据库连接池依赖-->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid-spring-boot-starter</artifactId>
        <version>1.2.15</version>
    </dependency>
    <!--mysql依赖-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <!--lombok实体类依赖-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```

### 数据源连接配置

> 配置数据源与MyBatisPlus对应的基础配置（id生成策略使用数据库自增策略）

```yml
spring:
  datasource:
    druid: # 使用Druid连接池
      driver-class-name: com.mysql.jdbc.Driver
      url: jdbc:mysql://localhost:3306/girls?serverTimezone=UTC
      username: root
      password: 123456
```

### mybatisPlus配置

> 为方便调试可以开启MyBatisPlus的日志

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261550206.png" alt="image-20230126155049113" style="zoom:67%;" />

```yml
mybatis-plus:
  global-config:
    db-config:
      # 使用数据库的自增策略
      id-type: auto
  configuration:
    # 开启日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

## 数据层开发

### 定义实体类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Integer id;
    private String name;
    private String password;
    private String phone;
}
```

### 定义Mapper

```java
@Mapper
@Repository
public interface UserDao extends BaseMapper<User> {
    
}
```

### CURD接口测试

```java
@SpringBootTest
class SsmpApplicationTests {

    @Autowired
    private UserDao userDao;

    @Test
    public void testGetAll() {
        List<User> list = userDao.selectList(null);
        list.forEach(System.out::println);
    }

    @Test
    public void getById() {
        User user = userDao.selectById(1);
        System.out.println(user);
    }
    @Test
    public void testInsert() {
        User user = new User(null,"张三","123","17315118673");
        int insert = userDao.insert(user);
        System.out.println(insert);
    }

    @Test
    public void testUpdate() {
        User user = new User(22,"任硕","123321","17315118673");
        int insert = userDao.updateById(user);
        System.out.println(insert);
    }

    @Test
    public void testDelete() {
        int delete = userDao.deleteById(20);
        System.out.println(delete);
    }
}
```

### 条件查询

#### QueryWrapper

```java
@Test
public void testCon() {
    QueryWrapper<User> wrapper = new QueryWrapper<>();
    wrapper.like("name","任");
    List<User> list = userDao.selectList(wrapper);
    System.out.println(list);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261603830.png" alt="image-20230126160330729" style="zoom:60%;" />

#### LambdaQueryWrapper

```java
@Test
public void testCon1() {
    LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
    // 改进了QueryWrapper的like后数据库字段名容易写错的问题
    wrapper.like(User::getName,"任"); 
    List<User> list = userDao.selectList(wrapper);
    System.out.println(list);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261604571.png" alt="image-20230126160457465" style="zoom:67%;" />

#### 动态条件拼装⭐

##### 传统做法

```java
@Test
public void testCon2() {
    String name = null;
    LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
    // 传统做法
    if (name != null) {
        wrapper.like(User::getName,"任");
    }
    List<User> list = userDao.selectList(wrapper);
    System.out.println(list);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261610379.png" alt="image-20230126161015287" style="zoom: 67%;" />

##### MP 做法⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261613468.png" alt="image-20230126161326361" style="zoom:67%;" />

```java
@Test
public void testCon2() {
    String name = null;
    LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
    // MP做法，条件作为第一个参数
    wrapper.like(name != null, User::getName,"任");
    List<User> list = userDao.selectList(wrapper);
    System.out.println(list);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261612370.png" alt="image-20230126161215274" style="zoom:67%;" />



## 分页功能

> 分页功能：**数据、当前页码值、每页数据总量、最大页码值、数据总量**

### 定义分页拦截器

> 分页操作是在MyBatisPlus的常规操作基础上增强得到，内部是动态的拼写SQL语句，因此需要增强对应的功能，使用MyBatisPlus拦截器实现

```java
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MPConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```

### 分页测试

```java
@Test
public void testSelectPage() {
    //第一步：创建Page对象，第一个参数是当前页，第二个参数是每页显示的记录数
    Page<User> page = new Page<>(1,2);
    //第二步：调用selectPage方法，第一个参数是page对象，第二个参数是传入的条件
    userDao.selectPage(page, null);
    //userService.page(page,null);
    //每页数据的list集合
    page.getRecords().forEach(System.out::println);
    //获取当前页
    System.out.println("当前页:"+page.getCurrent());
    //得到总页数
    System.out.println("总页数:"+page.getPages());
    //得到每页的记录数
    System.out.println("每页的记录数:"+page.getSize());
    //得到总记录数
    System.out.println("总记录数:"+page.getTotal());
    //是否有下页
    System.out.println("是否有下页:"+page.hasNext());
    //是否有上页
    System.out.println("是否有上页:"+page.hasPrevious());
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261558853.png" alt="image-20230126155817761" style="zoom: 67%;" />

### 超出页码处理

```java
//如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值
if(currentPage > page.getPages()){
    page = new Page<>(page.getPages(), pageSize);
    userService.page(page,null);
}
```

### 分页实现

```java
@GetMapping("/page/{currentPage}/{pageSize}")
public Map<String, Object> getPage(@PathVariable Integer currentPage,
                   @PathVariable Integer pageSize){
    Page<User> page = new Page<>(currentPage,pageSize);
    // 第二个参数是条件
    userService.page(page,null);
    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值
    if(currentPage > page.getPages()){
        page = new Page<>(page.getPages(), pageSize);
        userService.page(page,null);
    }
    Map<String, Object> map = new HashMap<>();
    map.put("data", page.getRecords());
    map.put("total",page.getTotal());
    return map;
}
```

### 条件分页

```java
@GetMapping("{currentPage}/{pageSize}")
public Map<String, Object> getPageCon(@PathVariable Integer currentPage, 
                                      @PathVariable Integer pageSize, User user) {
     Page<User> page = new Page<>(currentPage, pageSize);
     LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<>();
     lqw.like(Strings.isNotEmpty(user.getName()), User::getName, user.getName());
     lqw.like(Strings.isNotEmpty(user.getPhone()), User::getPhone, user.getPhone());
     // 第二个参数是条件
     userService.page(page, lqw);
     // 如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值
     if(currentPage > page.getPages()){
         page = new Page<>(page.getPages(), pageSize);
         userService.page(page,lqw);
     }
     Map<String, Object> map = new HashMap<>();
     map.put("data", page.getRecords());
     map.put("total", page.getTotal());
     return map;
}
```



## 业务层开发基础版

### 接口

```java
public interface UserService {
    Boolean save(User user);
    Boolean update(User user);
    Boolean delete(Integer id);
    User getById(Integer id);
    List<User> getAll();
    IPage<User> getPage(int currentPage, int pageSize);
}
```

### 实现类

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Override
    public Boolean save(User user) {
        // 插入删除等操作返回的都是影响行数，即是数字。那么则大于0为真，其他情况为假
        return userDao.insert(user) > 0;
    }

    @Override
    public Boolean update(User user) {
        return userDao.updateById(user) > 0;
    }

    @Override
    public Boolean delete(Integer id) {
        return userDao.deleteById(id) > 0;
    }

    @Override
    public User getById(Integer id) {
        return userDao.selectById(id);
    }

    @Override
    public List<User> getAll() {
        return userDao.selectList(null);
    }

    @Override
    public IPage<User> getPage(int currentPage, int pageSize) {
        IPage<User> page = new Page<>(currentPage,pageSize);
        return userDao.selectPage(page,null);
    }
}
```

### CURD测试

```java
@SpringBootTest
public class serviceTest {
    
    @Autowired
    private UserService userService;

    @Test
    public void testGetAll() {
        List<User> list = userService.getAll();
        list.forEach(System.out::println);
    }

    @Test
    public void getById() {
        User user = userService.getById(1);
        System.out.println(user);
    }

    @Test
    public void testInsert() {
        User user = new User(null,"张三","123123","17315118673");
        Boolean save = userService.save(user);
        System.out.println(save);
    }

    @Test
    public void testUpdate() {
        User user = new User(22,"任硕123","123321","17315118673");
        Boolean update = userService.update(user);
        System.out.println(update);
    }

    @Test
    public void testDelete() {
        Boolean delete = userService.delete(21);
        System.out.println(delete);
    }

    @Test
    public void testSelectPage() {
        IPage<User> page = userService.getPage(1, 2);
        page.getRecords().forEach(System.out::println);
        //获取当前页
        System.out.println("当前页:"+page.getCurrent());
        //得到总页数
        System.out.println("总页数:"+page.getPages());
        //得到每页的记录数
        System.out.println("每页的记录数:"+page.getSize());
        //得到总记录数
        System.out.println("总记录数:"+page.getTotal());
    }
}
```

## 业务层开发进阶版

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261700062.png" alt="image-20230126164656808" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211101192022078.png" alt="image-20211101192022078" style="zoom:67%;" />

### 接口定义

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261700489.png" alt="image-20230126170001490" style="zoom:50%;" />

```java
public interface UserService extends IService<User> {

}
```

### 实现类

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserDao, User>
                             implements UserService {
}
```

### CURD测试

```java
@SpringBootTest
public class serviceTest {
    
    @Autowired
    private UserService userService;

    @Test
    public void testGetAll() {
        List<User> list = userService.list();
        list.forEach(System.out::println);
    }

    @Test
    public void getById() {
        User user = userService.getById(1);
        System.out.println(user);
    }

    @Test
    public void testInsert() {
        User user = new User(null,"毛严123","123123","17315118673");
        Boolean save = userService.save(user);
        System.out.println(save);
    }

    @Test
    public void testUpdate() {
        User user = new User(22,"毛严312","123321","17315118673");
        Boolean update = userService.updateById(user);
        System.out.println(update);
    }

    @Test
    public void testDelete() {
        Boolean delete = userService.removeById(21);
        System.out.println(delete);
    }

    @Test
    public void testSelectPage() {
        Page<User> page = new Page<>(1,2);
        userService.page(page,null);
        page.getRecords().forEach(System.out::println);
        //获取当前页
        System.out.println("当前页:"+page.getCurrent());
        //得到总页数
        System.out.println("总页数:"+page.getPages());
        //得到每页的记录数
        System.out.println("每页的记录数:"+page.getSize());
        //得到总记录数
        System.out.println("总记录数:"+page.getTotal());
    }
}
```

## 表现层开发

> 基于Restful制作表现层接口：新增：POST、删除：DELETE、修改：PUT、查询：GET

> 接收参数：实体数据：@RequestBody、路径变量：@PathVariable

```java
@RestController
@RequestMapping("user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("getAll")
    public List<User> getAll() {
        return userService.list();
    }

    // 保存和更新采用json格式传参，因此使用@RequestBody
    @PostMapping("save")
    public Boolean save(@RequestBody User user) {
        return userService.save(user);
    }

    @PutMapping("update")
    public Boolean update(@RequestBody User user) {
        return userService.updateById(user);
    }
    // 接收路径上的参数，{id}
    @DeleteMapping("delete/{id}")
    public Boolean delete(@PathVariable("id") Integer id) {
        return userService.removeById(id);
    }

    @GetMapping("getById/{id}")
    public User getById(@PathVariable("id") Integer id) {
        return userService.getById(id);
    }
    
    // 分页实现
    @GetMapping("/page/{currentPage}/{pageSize}")
    public Map<String, Object> getPage(@PathVariable Integer currentPage,
                       @PathVariable Integer pageSize){
        Page<User> page = new Page<>(currentPage,pageSize);
        // 第二个参数是条件
        userService.page(page,null);
        Map<String, Object> map = new HashMap<>();
        map.put("records", page.getRecords());
        map.put("total",page.getTotal());
        return map;
    }
    // 条件分页实现
    @GetMapping("{currentPage}/{pageSize}")
    public Map<String, Object> getPageCon(@PathVariable Integer currentPage, 
                                          @PathVariable Integer pageSize, User user) {
            Page<User> page = new Page<>(currentPage, pageSize);
            LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<>();
            lqw.like(Strings.isNotEmpty(user.getName()), User::getName, user.getName());
            lqw.like(Strings.isNotEmpty(user.getPhone()), User::getPhone, user.getPhone());
            // 第二个参数是条件
            userService.page(page, lqw);
            Map<String, Object> map = new HashMap<>();
            map.put("data", page.getRecords());
            map.put("total", page.getTotal());
            return map;
    }
}
```

## 统一返回类型

设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议，要保证返回类型统一

> 1. 设计统一的返回值结果类型便于前端开发读取数据
> 2. 返回值结果类型可以根据需求自行设定，没有固定格式
> 3. 返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议

![image-20211101210516478](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211101210516478.png)

```java
public interface ResultCode {
    public static Integer SUCCESS = 20000;
    public static Integer ERROR = 20001;
}
```

```java
@Data
public class R {
    private Boolean success;
    private Integer code;
    private String message;
    private Map<String, Object> data = new HashMap<String, Object>();

    private R(){}

    public static R ok(){
        R r = new R();
        r.setSuccess(true);
        r.setCode(ResultCode.SUCCESS);
        r.setMessage("成功");
        return r;
    }

    public static R error(){
        R r = new R();
        r.setSuccess(false);
        r.setCode(ResultCode.ERROR);
        r.setMessage("失败");
        return r;
    }

    public R success(Boolean success){
        this.setSuccess(success);
        //可以起到链式变成R.ok().success()这样
        return this; 
    }

    public R message(String message){
        this.setMessage(message);
        return this;
    }

    public R code(Integer code){
        this.setCode(code);
        return this;
    }
    
    public R data(String key, Object value){
        // key为获取数据的数组名
        this.data.put(key, value);
        return this;
    }
    
    public R data(Map<String, Object> map){
        this.setData(map);
        return this;
    }
}
```

## 统一错误处理

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211101210857788.png" alt="image-20211101210857788" style="zoom: 67%;" />

```java
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

//作为SpringMVC的全局异常处理
@RestControllerAdvice
public class ProjectExceptionAdvice {
    //拦截所有的异常信息
    @ExceptionHandler
    public R doException(Exception ex){
        //记录日志
        //通知开发
        //通知运维
        ex.printStackTrace();
        return R.error().data("错误信息","服务器出现异常，请及时联系管理员");
    }
}
```

## 统一返回改进表现层

```java
@RestController
@RequestMapping("user1")
public class User1Controller {

    @Autowired
    private UserService userService;

    @GetMapping("getAll")
    public R getAll() {
        return R.ok().data("records",userService.list());
    }

    // 保存和更新采用json格式传参，因此使用@RequestBody
    @PostMapping("save")
    public R save(@RequestBody User user) {
        return R.ok().data("isSave",userService.save(user));
    }

    @PutMapping("update")
    public R update(@RequestBody User user) {
        return R.ok().data("isUpdate",userService.updateById(user));
    }

    @DeleteMapping("delete/{id}")
    public R delete(@PathVariable("id") Integer id) {
        return R.ok().data("isDelete",userService.removeById(id));
    }

    @GetMapping("getById/{id}")
    public R getById(@PathVariable("id") Integer id) {
        return R.ok().data("records",userService.getById(id));
    }

    @GetMapping("/page/{currentPage}/{pageSize}")
    public R getPage(@PathVariable Integer currentPage,
                                       @PathVariable Integer pageSize){
        Page<User> page = new Page<>(currentPage,pageSize);

        // 第二个参数是条件
        userService.page(page,null);
        //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值
        if(currentPage > page.getPages()){
            page = new Page<>(page.getPages(), pageSize);
            userService.page(page,null);
        }
        Map<String, Object> map = new HashMap<>();
        map.put("data", page.getRecords());
        map.put("total",page.getTotal());
        return R.ok().data("records", map);
    }

    @GetMapping("{currentPage}/{pageSize}")
    public R getPageCon(@PathVariable Integer currentPage, 
                        @PathVariable Integer pageSize, User user) {
        Page<User> page = new Page<>(currentPage, pageSize);
        LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<>();
        lqw.like(Strings.isNotEmpty(user.getName()), User::getName, user.getName());
        lqw.like(Strings.isNotEmpty(user.getPhone()), User::getPhone, user.getPhone());
        // 第二个参数是条件
        userService.page(page, lqw);
        //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值
        if(currentPage > page.getPages()){
            page = new Page<>(page.getPages(), pageSize);
            userService.page(page,lqw);
        }
        Map<String, Object> map = new HashMap<>();
        map.put("data", page.getRecords());
        map.put("total", page.getTotal());
        return R.ok().data("records", map);
    }
}
```

## 跨域问题

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOriginPatterns("*")
                .allowedMethods("POST", "GET", "PUT", "OPTIONS", "DELETE")
                .maxAge(3600)
                .allowCredentials(true);
    }
}
```



# 测试

## 加载测试专用属性

> 在启动测试环境时可以通过properties参数设置测试环境专用的属性
>
> 优势：比多环境开发中的测试环境影响范围更小，仅对当前测试类有效，**应用于小范围测试环境**

### 添加临时变量

```java
@SpringBootTest(properties = {"ren.school=TUT","ren.name=zhangsan"})
class SpringBootDemoApplicationTests {
    @Value("${ren.school}")
    private String school;
    @Value("${ren.name}")
    private String name;

    @Test
    void testProperties(){
        System.out.println("school = " + school);
        System.out.println("name = " + name);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271720924.png" alt="image-20230127172057770" style="zoom:80%;" />

### 添加临时命令行参数

在启动测试环境时可以通过args参数设置测试环境专用的传入参数

```java
@SpringBootTest(args = {"--server.port=8083"})
class SpringBootDemoApplicationTests {
    
    @Value("${server.port}")
    private String port;

    @Test
    void testProperties(){
        System.out.println("port = " + port);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271719289.png" alt="image-20230127171923177" style="zoom:67%;" />

## 加载测试专用配置

> 使用@Import注解加载当前测试类专用的配置

定义配置类

```java
@Configuration
public class MsgConfig {
    @Bean
    public String msg() {
        return "Hello,MSG";
    }
}
```

读取配置类

```java
@SpringBootTest
@Import({MsgConfig.class})
class SpringBootDemoApplicationTests {
    @Autowired
    private String msg;

    @Test
    void testConfiguration(){
        System.out.println("msg = " + msg);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271727657.png" alt="image-20230127172737558" style="zoom:80%;" />

## Web环境模拟测试

### 模拟端口

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271746470.png" alt="image-20230127174616363" style="zoom:67%;" />

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SpringBootDemoApplicationTests {

    @Test
    void testConfiguration(){
        
    }

}
```

### 虚拟请求测试

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//开启虚拟MVC调用
@AutoConfigureMockMvc
class SpringBootDemoApplicationTests {

    @Test
    //注入虚拟MVC调用对象
    public void testWeb(@Autowired MockMvc mvc) throws Exception {
        //创建虚拟请求，当前访问/user1/getAll
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/user1/getAll");
        //执行请求
        ResultActions action = mvc.perform(builder);
    }
}
```

### 虚拟请求状态匹配

> 匹配正常不显示结果，匹配错误就会显示很多内容

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//开启虚拟MVC调用
@AutoConfigureMockMvc
public class springbootTest1 {

    @Test
    //注入虚拟MVC调用对象
    public void testWeb(@Autowired MockMvc mvc) throws Exception {
        // 创建虚拟请求，当前访问/user1/getAll
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/user1/getAll");
        // 执行请求
        ResultActions action = mvc.perform(builder);
        // 匹配执行状态（是否预期值）
        // 定义执行状态匹配器
        StatusResultMatchers status = MockMvcResultMatchers.status();
        //定义预期执行状态
        ResultMatcher ok = status.isOk();
        //使用本次真实执行结果与预期结果进行比对
        action.andExpect(ok);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271908772.png" alt="image-20230127190811663" style="zoom:67%;" />

### 虚拟请求响应体匹配

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//开启虚拟MVC调用
@AutoConfigureMockMvc
public class springbootTest1 {

    @Test
    //注入虚拟MVC调用对象
    public void testWeb(@Autowired MockMvc mvc) throws Exception {
        // 创建虚拟请求，当前访问/user1/getAll
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/user1/getAll");
        // 执行请求
        ResultActions action = mvc.perform(builder);
        //定义执行结果匹配器
        ContentResultMatchers content = MockMvcResultMatchers.content();
        //定义预期执行结果，就是返回结果
        ResultMatcher result = content.string("springboot");
        //使用本次真实执行结果与预期结果进行比对
        action.andExpect(result);
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271911941.png" alt="image-20230127191128830" style="zoom:67%;" />

### 虚拟请求响应体（json）匹配

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//开启虚拟MVC调用
@AutoConfigureMockMvc
public class springbootTest1 {

    @Test
    //注入虚拟MVC调用对象
    public void testWeb(@Autowired MockMvc mvc) throws Exception {
        // 创建虚拟请求，当前访问/user1/getAll
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/user1/getAll");
        // 执行请求
        ResultActions action = mvc.perform(builder);
        //定义执行结果匹配器
        ContentResultMatchers content = MockMvcResultMatchers.content();
        //定义预期执行结果，就是返回结果
        ResultMatcher result = content.json("{\"id\":1,\"name\":\"SpringBoot2\"}");
        //使用本次真实执行结果与预期结果进行比对
        action.andExpect(result);
    }
}
```

### 虚拟请求响应头匹配

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//开启虚拟MVC调用
@AutoConfigureMockMvc
public class springbootTest1 {

    @Test
    //注入虚拟MVC调用对象
    public void testWeb(@Autowired MockMvc mvc) throws Exception {
        // 创建虚拟请求，当前访问/user1/getAll
        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/user1/getAll");
        // 执行请求
        ResultActions action = mvc.perform(builder);
        HeaderResultMatchers header = MockMvcResultMatchers.header();
        ResultMatcher resultHeader = header.string("Content-Type", "application/json");
        action.andExpect(resultHeader);
    }
}
```

## 数据层测试回滚

> 保证数据不提交，避免产生太多脏数据

![](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301271925096.png)

```java
@SpringBootTest
@Transactional // 加上这个注解，虽然插入显示成功，但是数据并没有进入到数据库中
public class serviceTest {
    
    @Autowired
    private UserService userService;

    @Test
    public void testGetAll() {
        List<User> list = userService.list();
        list.forEach(System.out::println);
    }

    @Test
    public void testInsert() {
        User user = new User(null,"毛严321","123123","17315118673");
        Boolean save = userService.save(user);
        System.out.println(save);
    }
}
```

> 加上Rollback注解，就跟以前一样了，没有区别

```java
@SpringBootTest
@Transactional
@Rollback(value = false)
public class serviceTest {
    // 内容通同上
}
```

## 测试用例数据设定

对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301272111039.png" alt="image-20230127211136869" style="zoom:67%;" />

```yml
testcast:
  book:
    id: ${random.int}
    id1: ${random.int(10)}
    id2: ${random.int(10,20)}
    uuid: ${random.uuid}
    md5: ${random.value}
    t1: ${random.long}
```

```java
@Component
@ConfigurationProperties(prefix = "testcast.book")
@Data
public class bookCase {
    private Integer id;
    private Integer id1;
    private Integer id2;
    private String md5;
    private String uuid;
    private String t1;
}
```

```java
@Autowired
private bookCase bookCase;

@Test
public void testGetAll1() {
    System.out.println("bookCase = " + bookCase);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301261148813.png" alt="image-20230126114851754" style="zoom:67%;" />

























