

# 架构理论

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305082055748.png" alt="image-20230508205557616" style="zoom: 67%;" />



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305082103538.png" alt="image-20230508210348414" style="zoom: 67%;" />

## 系统架构演变

> 随着互联网的发展，网站应用的规模也在不断的扩大，进而导致系统架构也在不断的进行变化。从互联网早起到现在，系统架构大体经历了下面几个过程: 单体应用架构--->垂直应用架构--->分布式架构--->SOA架构--->微服务架构，当然还有悄然兴起的Service Mesh(服务网格化)。接下来我们就来了解一下每种系统架构是什么样子的， 以及各有什么优缺点。

### 单体架构

> 互联网早期，**一般的网站应用流量较小，只需一个应用，将所有功能代码都部署在一起就可以，这样可以减少开发、部署和维护的成本**。比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块，我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090852850.png" alt="image-20230509085242788" style="zoom: 67%;" />

优点：

> - **项目架构简单，小型项目的话， 开发成本低**
> - **项目部署在一个节点上， 维护方便**

缺点：

> - **全部功能集成在一个工程中，对于大型项目来讲不易开发和维护**
> - **项目模块之间紧密耦合，单点容错率低**
> - **无法针对不同模块进行针对性优化和水平扩展**

### 垂直架构

> **随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量**。还是以上面的电商为例子， 用户访问量的增加可能影响的只是用户和订单模块， 但是对消息模块的影响就比较小。那么此时我们希望只多增加几个订单模块， 而不增加消息模块. 此时单体应用就做不到了， 垂直应用就应运而生了。**所谓的垂直应用架构，就是将原来的一个应用拆成互不相干的几个应用，以提升效率。比如我们可以将上面电商的单体应用拆分成**:

> - **电商系统(用户管理 商品管理 订单管理)**
> - **后台系统(用户管理 订单管理 客户管理)**
> - **CMS系统(广告管理 营销管理)**

> 这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台和CMS的节点

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091115357.png" alt="image-20230509111524284" style="zoom: 67%;" />

优点：

> - **系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水平扩展**
> - **一个系统的问题不会影响到其他系统，提高容错率**

缺点：

> - **系统之间相互独立， 无法进行相互调用**
> - **系统之间相互独立， 会有重复的开发任务**

### 分布式架构

> **当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务**，然后由前端控制层调用不同的业务层服务呢？这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分，服务层中包含业务逻辑。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090855395.png" alt="image-20230509085532317" style="zoom:67%;" />

> 优点：**抽取公共的功能为服务层，提高代码复用性**
>
> 缺点：**系统间耦合度变高，调用关系错综复杂，难以维护**

### SOA架构

> 在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理。此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090856569.png" alt="image-20230509085641494" style="zoom:67%;" />

> 优点:**使用注册中心解决了服务间调用关系的自动调节**
>
> 缺点:**服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )，服务关心复杂，运维、测试部署困难**

### 微服务架构

> 微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，**它更加强调服务的"彻底拆分"**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090857060.png" alt="image-20230509085737995" style="zoom: 80%;" />

> 优点：服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展
>
> 微服务之间采用Restful等轻量级http协议相互调用
>
> 缺点：分布式系统开发的技术成本高（容错、分布式事务等）

## 微服务架构

> 微服务架构， 简单的说就是将单体应用进一步拆分，拆分成更小的服务，每个服务都是一个可以独立运行的项目

### 常见问题

一旦采用微服务系统架构，就势必会遇到这样几个问题：

> - 这么多小服务，如何管理他们？(服务治理 注册中心[服务注册 发现 剔除])
> - 这么多小服务，他们之间如何通讯？(restful rpc)
> - 这么多小服务，客户端怎么访问他们？(网关)
> - 这么多小服务，一旦出现问题了，应该如何自处理？(容错)
> - 这么多小服务，一旦出现问题了，应该如何排错? (链路追踪)

对于上面的问题，是任何一个微服务设计者都不能绕过去的，因此大部分的微服务产品都针对每一个问题提供了相应的组件来解决它们。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090859263.png" alt="image-20230509085920185" style="zoom:67%;" />

### 微服务特征⭐

微服务的架构特征：

- **单一职责**：`微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责`
- **自治**：`团队独立、技术独立、数据独立，独立部署和交付`
- **面向服务**：`服务提供统一标准的接口，与语言和技术无关`
- **隔离性强**：`服务调用做好隔离、容错、降级，避免出现级联问题`

![image-20210713203753373](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210713203753373.png)

微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302245261.png" alt="image-20220830224553147" style="zoom: 80%;" />

因此，可以认为**微服务**是一种经过良好架构设计的**分布式架构方案** 。

但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。

其中在Java领域最引人注目的就是SpringCloud提供的方案了。

### 微服务技术⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211111221426006.png" alt="image-20211111221426006" style="zoom: 80%;" />

![image-20211111221511942](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211111221511942.png)

### 常见概念

#### 服务治理

> - 服务治理：就是进行服务的自动化管理，其核心是服务的自动注册与发现。
> - 服务注册：服务实例将自身服务信息注册到注册中心。
> - 服务发现：服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过信息去请求它们提供的服务
> - 服务剔除：服务注册中心将出问题的服务自动剔除到可用列表之外，使其不会被调用到。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090900758.png" alt="image-20230509090037688" style="zoom:80%;" />

#### 服务调用

> 在微服务架构中，存在多个服务之间的远程调用的需求。**有基于HTTP的RESTful接口以及基于TCP的RPC协议**

> REST(Representational State Transfer)这是一种HTTP调用的格式，更标准，更通用，都支持http协议

> RPC（Remote Promote Call）一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式、序列化方式和通信细节。开发人员在使
> 用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。

区别与联系

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090902041.png" alt="image-20230509090225979" style="zoom:80%;" />

#### 服务网关

> 随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现：
>
> - 客户端需要调用不同的url地址，增加难度
> - 在一定的场景下，存在跨域请求的问题
> - 每个微服务都需要进行单独的身份认证

针对这些问题，API网关顺势而生。

> API网关直面意思是将所有API调用统一接入到API网关层，由网关层统一接入和输出。一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090910751.png" alt="image-20230509091047691" style="zoom:67%;" />

#### 服务容错

> 在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可用，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。我们没法预防雪崩效应的发生，只能尽可能去做好容错。服务容错的三个核心思想是：

> - 不被外界环境影响
> - 不被上游请求压垮
> - 不被下游响应拖垮

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090911971.png" alt="image-20230509091143912" style="zoom: 80%;" />

#### 链路追踪

> 随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要对一次请求涉及的多个服务链路进行日志记录，性能监控即链路追踪

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090912182.png" alt="image-20230509091239079" style="zoom:67%;" />

### 常见解决方案

SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。其中常见的组件包括：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210713204155887.png" alt="image-20210713204155887" style="zoom:67%;" />

#### ServiceComb

> Apache ServiceComb，前身是华为云的微服务引擎 CSE (Cloud Service Engine) 云服务，是全球首个Apache微服务顶级项目。它提供了一站式的微服务开源解决方案，致力于帮助企业、用户和开发者将企业应用轻松微服务化上云，并实现对微服务应用的高效运维管理。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090913387.png" alt="image-20230509091322300" style="zoom:80%;" />

#### SpringCloud

> Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090914798.png" alt="image-20230509091420731" style="zoom:80%;" />

> Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

#### SpringCloud Alibaba

> Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090915371.png" alt="image-20230509091502307" style="zoom:80%;" />

## Alibaba概述

> Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。

### 主要功能

> - 服务限流降级：默认支持 WebServlet、WebFlux， OpenFeign、RestTemplate、Spring CloudGateway， Zuul， Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，支持限流降级 Metrics 监控
> - 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。
> - 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。
> - 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。
> - 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。
> - 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。
> - 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有
> - Worker（schedulerx-client）上执行。
> - 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，迅速搭建客户触达通道

### 常用组件

> - Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
> - Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
> - RocketMQ：开源的分布式消息系统，基于高可用分布式集群，提供低延时的、高可靠消息发布与订阅服务
> - Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。
> - Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。
> - Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。
> - Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
> - Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。
> - Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助迅速搭建客户触达通道

# 版本选择⭐

## 基本概述

### Spring Cloud

> 提起微服务，不得不提 Spring Cloud 全家桶系列，Spring Cloud 是一个服务治理平台，是若干个框架的集合，提供了全套的分布式系统解决方案。包含了：**服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等等**。

> Spring Cloud 通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。**微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，Spring Cloud 就是这些微服务的大管家**，采用了微服务这种架构之后，项目的数量会非常多，Spring Cloud 做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。

### Spring Boot

> Spring Boot并不是一个新的技术，它是基于spring框架下对于“约定优于配置(Convention Over Configuration)”理念下的产物，主要是帮助开发人员更容易更快速的创建独立运行和产品级别的基于spring框架的应用。为什么说springboot是微框架呢？如果大家玩过springboot，那应该很有体会，我们只需要非常少的配置就可以快速构建一个web项目。

> 而spring boot中并没有新的技术，如果大家对spring框架比较熟悉，那么在学习springboot的时候会更加容易。围绕springboot构建的spring cloud生态下，目前有两类的比较成熟的实现，一个是基于netflix、另一个是基于alibaba。

### Spring Cloud Alibaba

https://github.com/alibaba/spring-cloud-alibaba/blob/2022.x/README-zh.md

### Netflix 工具包

针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius 等。

> - Netflix Eureka：一个基于 Rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的* 实现，实现了云端负载均衡和中间层服务器的故障转移。
> - Netflix Ribbon：客户端负载均衡的服务调用组件。
> - Netflix Hystrix：容错管理工具，实现断路器模式，通过控制服务的节点，对延迟和故障提供更强大的容错能力
> - Netflix Feign：基于 Ribbon 和 Hystrix 的声明式服务调用组件。
> - Netflix Zuul：微服务网关，提供动态路由，访问过滤等服务。
> - Netflix Archaius：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。

### Alibaba 工具包

> **Sentinel**：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定
>
> **Nacos**：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
>
> **RocketMQ**：Apache RocketMQ™ 基于 Java 的高性能、高吞吐量的分布式消息和流计算平台。
>
> **Dubbo**：Apache Dubbo™ 是一款高性能 Java RPC 框架。
>
> **Seata**：一个易于使用的高性能微服务分布式事务解决方案。
>
> **Alibaba Cloud OSS**：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
>
> **Alibaba Cloud SchedulerX**：分布式任务调度产品，支持周期性的任务与固定时间点触发任务
>
> **Alibaba Cloud SMS**：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力

Nacos与Eureka的共同点

- 都支持服务注册和服务拉取
- 都支持服务提供者心跳方式做健康检测

Nacos与Eureka的区别

- Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
- 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
- Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
- Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式

## 命名规则

> Spring Cloud 采用了英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z依次类推的形式来发布迭代版本
> SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。

> 为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。例如Angel是第一个版本, Brixton是第二个版本。当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个"service releases"版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081623649.png" alt="image-20230508162343613" style="zoom:80%;" />

## 版本对应

### 版本选择

SpringBoot版本：https://github.com/spring-projects/spring-boot/releases/

SpringCloud版本：https://spring.io/projects/spring-cloud

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081619679.png" alt="image-20230508161958633" style="zoom:80%;" />

### 粗略版本

https://spring.io/projects/spring-cloud#overview

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081608097.png" alt="image-20230508160850043" style="zoom:80%;" />

### 详细版本⭐

同时用boot和cloud，需要照顾cloud，由cloud决定boot版本

https://spring.io/projects/spring-cloud#learn

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081628066.png" alt="image-20230508162854995" style="zoom:80%;" />

https://docs.spring.io/spring-cloud/docs/2021.0.6/reference/html/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081629124.png" alt="image-20230508162952073" style="zoom: 67%;" />

https://start.spring.io/actuator/info

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081611906.png" alt="image-20230508161140825" style="zoom:67%;" />

https://spring.io/projects/spring-cloud

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081625876.png" alt="image-20230508162519833" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081626484.png" alt="image-20230508162607441" style="zoom:67%;" />

### Alibaba版本对应

https://github.com/alibaba/spring-cloud-alibaba/blob/2022.x/README-zh.md

https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090932906.png" alt="image-20230509093223810" style="zoom: 67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081650537.png" alt="image-20230508165008501" style="zoom:80%;" />

## 版本选择

> cloud：Hoxton.SR1
>
> boot：2.2.2.RELEASE
>
> cloud alibaba：2.1.0.RELEASE
>
> Java：Java8
>
> Maven：3.5及以上
>
> MySQL：5.7及以上

不许捣蛋，上述全部版本必须和阳哥一致



## SpirngCloudAlibaba

https://spring.io/projects/spring-cloud-alibaba

过去两年里,由于SpringCloud Netflix原先的一些组件进入停更维护状态，因此这些组件逐渐被一些新技术所替代

| 名称           | SpringCloud                  | SpirngCloudAlibaba  |
| -------------- | ---------------------------- | ------------------- |
| 注册中心       | Eureka、Consul               | Nacos               |
| 配置中心       | SpringCloud Config           | Nacos               |
| 网关           | SpringCloud Zull             | SpringCloud Gateway |
| 负载均衡       | Ribbon                       | Loadbalabcer        |
| 熔断降级       | Hystrix                      | Sentinel            |
| 服务调用       | Feign                        | OpenFeign、Dubbo    |
| 服务总线       | Bus                          | Nacos               |
| 消息中间件     | 无(第三方替代方案：rabbitmq) | RocketMQ            |
| 分布式解决方案 | 无(第三方替代方案：2pc)      | Seata               |

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305082028118.png" alt="image-20230508202839034" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305081634677.png" alt="image-20230508163430633" style="zoom:80%;" />

# 环境搭建⭐

项目地址：https://gitee.com/sure-s-renshuo/cloud_demo

## 工程结构

cloud-demo：父工程，管理依赖

> - order-service：订单微服务，负责订单相关业务
> - user-service：用户微服务，负责用户相关业务

> - 订单微服务和用户微服务都必须有各自的数据库，相互独立
> - 订单服务和用户服务都对外暴露Restful的接口
> - 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库
>

## 模块搭建⭐

### 数据库表

```sql
drop table if exists `tb_order`;
create table `tb_order`  (
  `id` bigint(20) not null auto_increment comment '订单id',
  `user_id` bigint(20) not null comment '用户id',
  `name` varchar(100) default null comment '商品名称',
  `price` bigint(20) not null comment '商品价格',
  `num` int(10) null default 0 comment '商品数量',
  primary key (`id`) using btree,
  unique index `username`(`name`) using btree
) engine = innodb;
```

```sql
drop table if exists `tb_user`;
create table `tb_user`  (
  `id` bigint(20) not null auto_increment,
  `username` varchar(100) default null comment '收件人',
  `address` varchar(255) default null comment '地址',
  primary key (`id`) using btree,
  unique index `username`(`username`) using btree
) engine = innodb;
```

### 数据准备

cloud-user表中初始数据如下：

```sql
insert into `tb_user` values (1, '柳岩', '湖南省衡阳市');
insert into `tb_user` values (2, '文二狗', '陕西省西安市');
insert into `tb_user` values (3, '华沉鱼', '湖北省十堰市');
insert into `tb_user` values (4, '张必沉', '天津市');
insert into `tb_user` values (5, '郑爽爽', '辽宁省沈阳市大东区');
insert into `tb_user` values (6, '范兵兵', '山东省青岛市');
```

cloud-order表中初始数据如下，cloud-order表中持有cloud-user表中的id字段。

```sql
insert into `tb_order` values (101, 1, 'apple 苹果 iphone 12 ', 699900, 1);
insert into `tb_order` values (102, 2, '雅迪 yadea 新国标电动车', 209900, 1);
insert into `tb_order` values (103, 3, '骆驼（camel）休闲运动鞋女', 43900, 1);
insert into `tb_order` values (104, 4, '小米10 双模5g 骁龙865', 359900, 1);
insert into `tb_order` values (105, 5, 'oppo reno3 pro 双模5g 视频双防抖', 299900, 1);
insert into `tb_order` values (106, 6, '美的（midea) 新能效 冷静星ii ', 544900, 1);
insert into `tb_order` values (107, 2, '西昊/sihoo 人体工学电脑椅子', 79900, 1);
insert into `tb_order` values (108, 3, '梵班（famdbann）休闲男鞋', 31900, 1);
```

配置下项目使用的JDK：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091500928.png" alt="image-20230509150006835" style="zoom:80%;" />

### parent

> 创建maven模块，**定义依赖版本，删除其他不相干文件夹**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305090946300.png" alt="image-20230509094622212" style="zoom:80%;" />

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 。。。.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.it</groupId>
    <artifactId>spring-cloud-alibaba1</artifactId>
    <version>1.0-SNAPSHOT</version>

    <!-- 子模块 -->
    <modules>
        <module>order-service</module>
        <module>user-service</module>
    </modules>
    
    <!-- 打包方式为pom -->
    <packaging>pom</packaging>
    <!-- 设置依赖版本 -->
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <spring-boot.version>2.6.3</spring-boot.version>
        <spring-cloud.version>2021.0.1</spring-cloud.version>
        <spring-cloud-alibaba.version>2021.0.1.0</spring-cloud-alibaba.version>
        <mybatis-plus.version>3.5.2</mybatis-plus.version>
        <mysql.version>8.0.28</mysql.version>
        <lombok.version>1.18.24</lombok.version>
    </properties>
    
    <!-- 定义父工程依赖 -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.3</version>
    </parent>

    <dependencyManagement>
        <dependencies>
            <!--spring-cloud依赖-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--spring-cloud-alibaba依赖-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--mybatis-plus依赖-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.version}</version>
            </dependency>
            <!--lombok-->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```

### order-service

> 创建maven模块

#### pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0。。。4.0.0.xsd">
    
    <parent>
        <artifactId>spring-cloud-alibaba1</artifactId>
        <groupId>com.it</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    
    <modelVersion>4.0.0</modelVersion>
    <artifactId>order-service</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <!--spring-boot依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!--mysql依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <!--mybatis-plus依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### application.yml

```yml
server:
  port: 8080
spring:
  application:
    name: orderService
  datasource:
    url: jdbc:mysql://localhost:3306/heima1?serverTimezone=UTC
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver

logging:
  level:
    com.it: debug
  pattern:
    dateformat: MM-dd HH:mm:ss:SSS
```

#### entity

```java
@TableName("tb_order")
@Data
public class Order {
    private Long id;
    private Long price;
    private String name;
    private Integer num;
    private Long userId;
    @TableField(exist = false)
    private User user;
}
```

```java
@Data
public class User {
    private Long id;
    private String username;
    private String address;
}
```

#### mapper

```java
@Repository
public interface OrderMapper extends BaseMapper<Order> {
    @Select("select * from tb_order where id = #{id}")
    Order findById1(Long id);
}
```

#### service

```java
@Service
public class OrderService {

    @Autowired
    private OrderMapper orderMapper;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.selectById(orderId);
        // 4.返回
        return order;
    }
}
```

#### controller

```java
@RestController
@RequestMapping("order")
public class OrderController {

    @Autowired
    private OrderService orderService;

    @GetMapping("{orderId}")
    public Order queryOrderByUserId(@PathVariable("orderId") Long orderId) {
        // 根据id查询订单并返回
        return orderService.queryOrderById(orderId);
    }
}
```

#### Test

:8080/order/101#

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091547730.png" alt="image-20230509154733666" style="zoom:80%;" />



### user-service

> 创建maven模块

#### pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0。。。.xsd">
    <parent>
        <artifactId>spring-cloud-alibaba1</artifactId>
        <groupId>com.it</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    
    <modelVersion>4.0.0</modelVersion>
    <artifactId>user-service</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>
        <!--spring-boot依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--mysql依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!--mybatis-plus依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### application.yml

```yml
server:
  port: 8081
spring:
  application:
    name: userService
  datasource:
    url: jdbc:mysql://localhost:3306/heima1?serverTimezone=UTC
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver

logging:
  level:
    com.it: debug
  pattern:
    dateformat: MM-dd HH:mm:ss:SSS
```

#### entity

```java
@Data
public class User {
    private Long id;
    private String username;
    private String address;
}
```

#### mapper

```java
@Repository
public interface UserMapper extends BaseMapper<User> {
    
    @Select("select * from tb_user where id = #{id}")
    User findById1(@Param("id") Long id);
}
```

#### service

```java
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    public User queryById(Long id) {
        return userMapper.selectById(id);
    }
}
```

#### controller

```java
@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public User queryById(@PathVariable("id") Long id) {
        return userService.queryById(id);
    }
}
```

#### TEST

:8081/user/1#

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091548983.png" alt="image-20230509154824912" style="zoom:80%;" />

## 远程调用

### 流程描述

修改order-service中的根据id查询订单业务，在查询订单的同时，根据订单中包含userId查询用户信息，一起返回

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113120924636.png" alt="image-20211113120924636" style="zoom:80%;" />



因此，我们需要在order-service中 向user-service发起请求，调用:8081/user/{userId}这个接口。

> - 注册一个RestTemplate的实例到Spring容器
> - 修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User
> - 将查询的User填充到Order对象，一起返回

### RestTemplate注册

首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：

```java
@MapperScan("com.it.mapper")
@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

### 远程调用实现

在order-service里新增User实体类，上面已经写了

```java
@Data
public class User {
    private Long id;
    private String username;
    private String address;
}
```

修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：

```java
@Service
public class OrderService {

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private RestTemplate restTemplate;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.selectById(orderId);
        // 实现远程调用⭐⭐
        String url = ":8081/user/" +  order.getUserId();
        //获取到查找到的值并set到order表中
        User user = restTemplate.getForObject(url, User.class);
        order.setUser(user);
        // 4.返回
        return order;
    }
}
```

微服务调用方式

> - 基于RestTemplate发起的http请求实现远程调用
> - http请求做远程调用是与语言无关的调用，**只要知道对方的ip、端口、接口路径、请求参数即可**。

### 实战测试

:8080/order/101#

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091557431.png" alt="image-20230509155706349" style="zoom:80%;" />



# Eureka注册中心

## 原服务调用问题

> - **服务消费者该如何获取服务提供者的地址信息？**
> - **如果有多个服务提供者，消费者该如何选择？**
> - **消费者如何得知服务提供者的健康状态？**

假如我们的服务提供者user-service部署了多个实例，如图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113121500745.png" alt="image-20211113121500745" style="zoom: 50%;" />

大家思考几个问题：

> - order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？
> - 有多个user-service实例地址，order-service调用时该如何选择？
> - order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？

## Eureka结构和作用

### Eureka作用

这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208310958226.png" alt="image-20220831095803132" style="zoom: 80%;" />

**消费者该如何获取服务提供者具体信息？**

> 服务提供者启动时向eureka注册自己的信息，eureka保存这些信息，消费者根据服务名称向eureka拉取提供者信息

**如果有多个服务提供者，消费者该如何选择？**

> 服务消费者利用负载均衡算法，从服务列表中挑选一个

**消费者如何感知服务提供者健康状态？**

> - 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态
> - eureka会更新记录服务列表信息，心跳不正常会被剔除
> - 消费者就可以拉取到最新的信息

### Eureka解决的问题

**问题1：order-service如何得知user-service实例地址？**

> - user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫**服务注册**
> - eureka-server保存服务名称到服务实例地址列表的映射关系
> - order-service根据服务名称，拉取实例地址列表。这个叫**服务发现或服务拉取**

**问题2：order-service如何从多个user-service实例中选择具体的实例？**

> - order-service从实例列表中**利用负载均衡算法选中一个实例地址**
> - 向该实例地址发起远程调用

**问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？**

> - user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳
> - 当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除
> - order-service拉取服务时，就能将故障实例排除了

注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端

### Eureka角色

> - EurekaServer：服务端，注册中心、记录服务信息、心跳监控
> - EurekaClient：客户端，Provider：服务提供者，例如案例中的 user-service，注册自己的信息到EurekaServer，每隔30秒向EurekaServer发送心跳
> - Consumer：服务消费者，例如案例中的 order-service，根据服务名称从EurekaServer拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用

### Eureka心跳检测原理

> 我们知道 Eureka 注册中心是通过心跳检测机制来判断服务是否可用的，如果不可用，可能会把这个服务摘除。为什么是可能呢？因为 Eureka 有自我保护机制，如果达到自我保护机制的阀值，后续就不会自动摘除。
>

这里我们可以再复习下 Eureka 的自我保护机制和服务摘除机制。

- **Eureka 心跳机制**：每个服务每隔 30s 自动向 Eureka Server 发送一次心跳，Eureka Server 更新这个服务的最后心跳时间。如果 180 s 内（版本1.7.2）未收到心跳，则任务服务故障了。
- **Eureka 自我保护机制**：如果上一分钟实际的心跳次数，比我们期望的心跳次数要小，就会触发自我保护机制，不会摘除任何实例。期望的心跳次数：服务实例数量 * 2 * 0.85。
- **Eureka 服务摘除机制**：不是一次性将服务实例摘除，每次最多随机摘除 15%。如果摘除不完，1 分钟之后再摘除。

说完 Eureka 的心跳机制和服务摘除机制后，我们来看下 Ribbon 的心跳机制。

Ribbon 的心跳检测原理和 Eureka 还不一样，**Ribbon 不是通过每个服务向 Ribbon 发送心跳或者 Ribbon 给每个服务发送心跳来检测服务是否存活的**。

先来一张图看下 Ribbon 的心跳检测机制：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021007819.png" alt="image-20220702100738725" style="zoom:67%;" />

Ribbon 心跳检测原理：对自己本地缓存的 Server List 进行遍历，看下每个服务的状态是不是 UP 的。具体的代码就是 isAlive 方法。

核心代码：

```apl
isAlive = status.equals(InstanceStatus.UP);
```

那么多久检测一次呢？

默认每隔 30s 执行以下 PingTask 调度任务，对每个服务执行 isAlive 方法，判断下状态。

### Eureka总体步骤

1.搭建EurekaServer

- 引入eureka-server依赖
- 添加@EnableEurekaServer注解
- 在application.yml中配置eureka地址

2.服务注册

- 引入eureka-client依赖
- 在application.yml中配置eureka地址

3.服务发现

- 引入eureka-client依赖
- 在application.yml中配置eureka地址
- 给RestTemplate添加@LoadBalanced注解
- 用服务提供者的服务名称远程调用

## 搭建Eureka-server⭐

首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113121642018.png" alt="image-20211113121642018" style="zoom: 50%;" />

### Eureka-server模块

在cloud-demo父工程下，创建一个子模块：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113121718546.png" alt="image-20211113121718546" style="zoom:67%;" />

填写模块信息,然后填写服务信息：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091611898.png" alt="image-20230509161127763" style="zoom:80%;" />

### Eureka依赖

引入SpringCloud为eureka提供的starter依赖：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
</dependencies>
```

### 编写启动类

给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

//这个要加上exclude排除数据库，不然会出错
@SpringBootApplication(exclude= {DataSourceAutoConfiguration.class})
@EnableEurekaServer
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
```

### 配置文件

编写一个application.yml文件，内容如下：

```yaml
server:
  port: 10086
spring:
  application:
    name: eureka-server
eureka:
  client:
    service-url: # Eureka的地址信息。它自己也是微服务，所以自己也要注册
      defaultZone: http://127.0.0.1:10086/eureka
```

### 启动服务

启动微服务，然后在浏览器访问：http://127.0.0.1:10086 ，看到下面结果应该是成功了：

![image-20211113123513827](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113123513827.png)

## 服务注册⭐

下面，我们将user-service注册到eureka-server中去。

### 引入依赖

在user-service的pom文件中，引入下面的eureka-client依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

### 配置文件

在user-service中，修改application.yml文件，添加服务名称、eureka地址：

```yaml
spring:
  application:
    name: userservice # 名称必须要配置
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

### 启动多个实例(可选)

为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。

就是把一个启动类启动两遍，首先，复制原来的user-service启动配置：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113122138649.png" alt="image-20211113122138649" style="zoom:80%;" />

然后，在弹出的窗口中，填写信息：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113122150772.png" alt="image-20211113122150772" style="zoom:67%;" />

现在，SpringBoot窗口会出现两个user-service启动配置：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113122208448.png" alt="image-20211113122208448" style="zoom:67%;" />

不过，第一个是8081端口，第二个是8082端口。启动两个user-service实例：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113122226279.png" alt="image-20211113122226279" style="zoom:67%;" />

查看eureka-server管理页面：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091620809.png" alt="image-20230509162040706" style="zoom:80%;" />

## 服务发现⭐

下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。

### 引入依赖

之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。

在order-service的pom文件中，引入下面的eureka-client依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

### 配置文件

服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：

在order-service中，修改application.yml文件，添加服务名称、eureka地址：

```yaml
spring:
  application:
    name: orderservice
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

### 服务拉取和负载均衡

> 最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。
>

> 不过这些动作不用我们去做，只需要添加一些注解即可。在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：
>

```java
@Bean
//必须加上此注解，不然修改url后不能被识别然后进行访问⭐⭐
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```

修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：

```java
@Service
public class OrderService {

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private RestTemplate restTemplate;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.findById(orderId);
        // TODO 2.查询用户，服务名好像只能小写，大写或驼峰式访问不到
        String url = "http://userservice/user/" +  order.getUserId();
        User user = restTemplate.getForObject(url, User.class);
        // 3.封装user信息
        order.setUser(user);
        // 4.返回
        return order;
    }
}    
```

spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。

访问两次order表的内容，可以看到

![image-20211112102637120](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112102637120.png)

![image-20211112102655853](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112102655853.png)

userservice的8081和8082均被访问一次，实现了负载均衡

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220329105553501.png" alt="image-20220329105553501" style="zoom:80%;" />

# 负载均衡

> 负载均衡通器常有两种实现手段，一种是服务端负载均衡器，另一种是客户端负载均衡器，而我们今天的主角 Ribbon 就属于后者——客户端负载均衡器。
>

> 服务端负载均衡器的问题是，它提供了更强的流量控制权，但无法满足不同的消费者希望使用不同负载均衡策略的需求，而使用不同负载均衡策略的场景确实是存在的，所以客户端负载均衡就提供了这种灵活性然而客户端负载均衡也有其缺点，如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务的情况，所以我们本文就来了解一下这 7 种内置负载均衡策略的具体规则。
>

## Ribbon

> Ribbon 是 Spring Cloud 技术栈中非常重要的基础框架，它为 Spring Cloud 提供了负载均衡的能力，比如 Fegin 和 OpenFegin 都是基于 Ribbon 实现的，就连 Nacos 中的负载均衡也使用了 Ribbon 框架。
>

> Ribbon 框架的强大之处在于，它不仅内置了 7 种负载均衡策略，同时还支持用户自定义负载均衡策略，所以其开放性和便利性也是它得以流行的主要原因。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311027181.png" alt="image-20220831102714085" style="zoom:80%;" />

## 核心组件

> Ribbon 主要有五大功能组件：ServerList、Rule、Ping、ServerListFilter、ServerListUpdater。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021003899.png" alt="image-20220702100350813" style="zoom:67%;" />

### 负载均衡器 LoadBalancer

> 用于管理负载均衡的组件。初始化的时候通过加载 YMAL 配置文件创建出来的。
>

### 服务列表 ServerList

> ServerList 主要用来获取所有服务的地址信息，并存到本地。
>
> 根据获取服务信息的方式不同，又分为静态存储和动态存储。
>
> 静态存储：从配置文件中获取服务节点列表并存储到本地。
>
> 动态存储：从注册中心获取服务节点列表并存储到本地

### 服务列表过滤 ServerListFilter

将获取到的服务列表按照过滤规则过滤。

> - 通过 Eureka 的分区规则对服务实例进行过滤。
> - 比较服务实例的通信失败数和并发连接数来剔除不够健康的实例。
> - 根据所属区域过滤出同区域的服务实例。

### 服务列表更新 ServerListUpdater

> 服务列表更新就是 Ribbon 会从注册中心获取最新的注册表信息。是由这个接口 ServerListUpdater 定义的更新操作。而它有两个实现类，也就是有两种更新方式：
>

- 通过定时任务进行更新。由这个实现类 PollingServerListUpdater 做到的。
- 利用 Eureka 的事件监听器来更新。由这个实现类 EurekaNotificationServerListUpdater 做到的。

### 心跳检测 Ping

> IPing 接口类用来检测哪些服务可用。如果不可用了，就剔除这些服务。
>
> 实现类主要有这几个：PingUrl、PingConstant、NoOpPing、DummyPing、NIWSDiscoveryPing。
>
> 心跳检测策略对象 IPingStrategy，默认实现是轮询检测。

### 负载均衡策略 Rule

Ribbon 的负载均衡策略和之前讲过的负载均衡策略有部分相同，看下 Ribbon 有哪几种负载均衡策略。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021004286.png" alt="image-20220702100447194" style="zoom: 50%;" />

再来看下 Ribbon 源码中关于均衡策略的 UML 类图。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021005002.png" alt="image-20220702100516901" style="zoom:67%;" />

由图可以看到，主要由以下几种均衡策略：

- **线性轮询均衡** （RoundRobinRule）：轮流依次请求不同的服务器。优点是无需记录当前所有连接的状态，无状态调度。
- **可用服务过滤负载均衡**（AvailabilityFilteringRule）：过滤多次访问故障而处于断路器状态的服务，还有过滤并发连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问。默认情况下，如果最近三次连接均失败，则认为该服务实例断路。然后保持 30s 后进入回路关闭状态，如果此时仍然连接失败，那么等待进入关闭状态的时间会随着失败次数的增加呈指数级增长。
- **加权响应时间负载均衡**（WeightedResponseTimeRule）：为每个服务按响应时长自动分配权重，响应时间越长，权重越低，被选中的概率越低。
- **区域感知负载均衡**（ZoneAvoidanceRule）：更倾向于选择发出调用的服务所在的托管区域内的服务，降低延迟，节省成本。Spring Cloud Ribbon 中默认的策略。
- **重试负载均衡**（RetryRule)：通过轮询均衡策略选择一个服务器，如果请求失败或响应超时，可以选择重试当前服务节点，也可以选择其他节点。
- **高可用均衡**（BestAvailableRule)：忽略请求失败的服务器，尽量找并发比较低的服务器。注意：这种会给服务器集群带来成倍的压力。
- **随机负载均衡**（RandomRule）：随机选择服务器。适合并发比较大的场景。

## Ribbon原理

### 拦截请求的原理

本文最开始提出了一个问题：负载均衡器如何将客户端请求进行拦截然后选择服务器进行转发？

结合上面介绍的 Ribbon 核心组件，我们可以画一张原理图来梳理下 Ribbon 拦截请求的原理：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021005754.png" alt="image-20220702100558647" style="zoom:50%;" />

第一步：Ribbon 拦截所有标注`@loadBalance`注解的 RestTemplate。RestTemplate 是用来发送 HTTP 请求的。

第二步：将 Ribbon 默认的拦截器 LoadBalancerInterceptor 添加到 RestTemplate 的执行逻辑中，当 RestTemplate 每次发送 HTTP 请求时，都会被 Ribbon 拦截。

第三步：拦截后，Ribbon 会创建一个 ILoadBalancer 实例。

第四步：ILoadBalancer 实例会使用 RibbonClientConfiguration 完成自动配置。就会配置好 IRule，IPing，ServerList。

第五步：Ribbon 会从服务列表中选择一个服务，将请求转发给这个服务。

### 初始化的原理

当我们去剖析 Ribbon 源码的时候，需要找到一个突破口，而 @LoadBalanced 注解就是一个比较好的入口。

先来一张 Ribbon 初始化的流程图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021006566.png" alt="image-20220702100629469" style="zoom:50%;" />

添加注解的代码如下所示：

```java
@LoadBalanced
@Bean
public RestTemplate getRestTemplate() {
 return new RestTemplate();
}
```

第一步：Ribbon 有一个自动配置类 LoadBalancerAutoConfiguration，SpringBoot 加载自动配置类，就会去初始化 Ribbon。

第二步：当我们给 RestTemplate 或者 AsyncRestTemplate 添加注解后，Ribbon 初始化时会收集加了 @LoadBalanced 注解的 RestTemplate 和 AsyncRestTemplate ，把它们放到一个 List 里面。

第三步：然后 Ribbon 里面的 RestTemplateCustomizer 会给每个 RestTemplate 进行定制化，也就是加上了拦截器：LoadBalancerInterceptor。

第四步：从 Eureka 注册中心获取服务列表，然后存到 Ribbon 中。

第五步：加载 YMAL 配置文件，配置好负载均衡配置，创建一个 ILoadbalancer 实例。

### 同步服务列表原理

Ribbon 首次从 Eureka 获取全量注册表后，就会隔一定时间获取注册表。原理图如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021007773.png" alt="image-20220702100711677" style="zoom:50%;" />

之前我们提到过 Ribbon 的核心组件 ServerListUpdater，用来同步注册表的，它有一个实现类 PollingServerListUpdater ，专门用来做定时同步的。默认1s 后执行一个 Runnable 线程，后面就是每隔 30s 执行 Runnable 线程。这个 Runnable 线程就是去获取 Eureka 注册表的。

## 策略配置方式⭐

通过定义IRule实现可以修改负载均衡规则，有两种方式：

### 全局配置

作用于全局，order服务访问任何服务都会生效

代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：

```java
@Bean
public IRule randomRule(){
    return new RandomRule();
}
```

### 局部配置

作用于局部，只针对某个微服务而言的

配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：

```yaml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 
```

> **注意**，一般用默认的负载均衡规则，不做修改。

## 负载均衡策略⭐

负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：

![image-20211113155847567](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113155847567.png)

不同规则的含义如下：默认的实现就是ZoneAvoidanceRule，是一种轮询方案

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091637313.png" alt="image-20230509163701156" style="zoom:80%;" />

### 轮询策略

原理：如果给服务器从 0 到 N 编号，轮询均衡策略会从 0 开始依次选择一个服务器作为处理本次请求的服务器。

场景：适合所有父亲都有相同的软硬件配置，且请求频率相对平衡。

轮询策略：RoundRobinRule，按照一定的顺序依次调用服务实例。比如一共有 3 个服务，第一次调用服务 1，第二次调用服务 2，第三次调用服务3，依次类推。此策略的配置设置如下：

```yml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule # 设置负载均衡
```

### 权重策略

原理：按照服务器的不同处理能力，给服务器分配不同的权重，然后请求会按照权重分配给不同的服务器。

场景：服务器的性能不同，充分利用高性能的服务器，同时也能照顾到低性能的服务器。

权重策略：WeightedResponseTimeRule，根据每个服务提供者的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性也就越低。它的实现原理是，刚开始使用轮询策略并开启一个计时器，每一段时间收集一次所有服务提供者的平均响应时间，然后再给每个服务提供者附上一个权重，权重越高被选中的概率也越大。此策略的配置设置如下：

```yml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule
```

### 随机策略

原理：将请求随机分配给不同的服务器。

场景：适合客户端请求的频率比较随机的场景。

随机策略：RandomRule，从服务提供者的列表中随机选择一个服务实例。此策略的配置设置如下：

```yml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #设置负载均衡
```

### 最小连接数策略

最小连接数策略：BestAvailableRule，也叫最小并发数策略，它是遍历服务提供者列表，选取连接数最小的⼀个服务实例。如果有相同的最小连接数，那么会调用轮询策略进行选取。此策略的配置设置如下：

```yml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #设置负载均衡
```

### 重试策略

重试策略：RetryRule，按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务，如果超过指定时间依然没获取到服务实例则返回 null。此策略的配置设置如下：

```yml
ribbon:
  ConnectTimeout: 2000 # 请求连接的超时时间
  ReadTimeout: 5000 # 请求处理的超时时间
springcloud-nacos-provider: # nacos 中的服务 id
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #设置负载均衡
```

### 可用性敏感策略

原理：负载均衡设备对每个服务器发送一个探测请求，看看哪台服务器的响应速度更快，

场景：适合服务器的响应性能不断变化的场景。

注意：响应速度是针对负载均衡设备和服务器之间的。

可用敏感性策略：AvailabilityFilteringRule，先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例。此策略的配置设置如下：

```yml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.AvailabilityFilteringRule
```

### 区域敏感策略

区域敏感策略：ZoneAvoidanceRule，根据服务所在区域（zone）的性能和服务的可用性来选择服务实例，在没有区域的环境下，该策略和轮询策略类似。此策略的配置设置如下：

```yml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.ZoneAvoidanceRule
```

## 饥饿加载⭐

Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，第一次访问请求时间会很长

而饥饿加载则会在项目启动时创建，**降低第一次访问的耗时**，通过下面配置开启饥饿加载：

在orderService模块中配置，最后clients对应ApplicationName

```yaml
ribbon:
  eager-load:
    enabled: true
    clients: userservice
```

当然，如果要加载多个服务，则

```yml
ribbon:
  eager-load:
    enabled: true
    clients:
      - userservice
      - xxservice
```



## Loadbalancer⭐

[升级Spring Cloud最新版后，有个重要的组件被弃用了](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247501791&idx=1&sn=c1c89d0e588cb442fbbdedcbd674e8bf&chksm=fc2c7bd7cb5bf2c137673c0741a135430a586c317b21f195fd8f8559dbc37cab9e686e25a361&mpshare=1&scene=23&srcid=0509iZrWA3Tg62DZcDnfIc9z&sharer_sharetime=1683622674807&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> LoadBalancer是Spring Cloud官方提供的负载均衡组件，可用于替代Ribbon。其使用方式与Ribbon基本兼容，可以从Ribbon进行平滑过渡。

# Nacos注册中心

官网：https://nacos.io/

国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。

现在是[SpringCloud](https://spring.io/projects/spring-cloud)中的一个组件。相比[Eureka](https://github.com/Netflix/eureka)功能更加丰富，在国内受欢迎程度较高。

## Nacos 特性

> **服务发现和服务健康监测**：支持基于DNS和基于RPC的服务发现，支持对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。

> **动态配置服务**：动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。
>
> **动态 DNS 服务**：动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单 DNS 解析服务。
>
> **服务及其元数据管理**：支持从微服务平台建设的视角管理数据中心的所有服务及元数据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113160004718.png" alt="image-20211113160004718" style="zoom: 67%;" />

## Nacos安装启动

### Windows安装

开发阶段采用单机安装即可。

#### 下载安装包

在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：

GitHub主页：https://github.com/alibaba/nacos

GitHub的Release下载页：https://github.com/alibaba/nacos/releases

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402161102887.png" alt="image-20210402161102887" style="zoom:80%;" />

#### 解压

将这个包解压到任意非中文目录下，如图：

![image-20210402161843337](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402161843337.png)

#### 启动

启动非常简单，进入bin目录，结构如下：

![image-20210402162350977](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402162350977.png)

然后执行命令即可：windows命令：

standalone：表示单机启动

```apl
startup.cmd -m standalone
```


执行后的效果如图：

![image-20210402162526774](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402162526774.png)

在启动界面上有访问网址

#### 访问

在浏览器输入地址：http://127.0.0.1:8848/nacos即可：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402162630427.png" alt="image-20210402162630427" style="zoom: 67%;" />

默认的账号和密码都是nacos，进入后：

![image-20210402162709515](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402162709515.png)

### Linux安装

Linux或者Mac安装方式与Windows类似。

#### 安装JDK

Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。

上传jdk安装包：

![image-20210402172334810](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402172334810.png)

上传到某个目录，例如：`/usr/local/`

然后解压缩：

```sh
tar -xvf jdk-8u144-linux-x64.tar.gz
```

然后重命名为java

配置环境变量：

```sh
export JAVA_HOME=/usr/local/java
export PATH=$PATH:$JAVA_HOME/bin
```

设置环境变量：

```sh
source /etc/profile
```

#### 上传Nacos安装包

如图：

![image-20210402161102887](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402161102887.png)

也可以直接使用课前资料中的tar.gz：

![image-20210402161130261](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402161130261.png)

上传到Linux服务器的某个目录，例如`/usr/local/src`目录下：

![image-20210402163715580](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402163715580.png)

#### 解压

命令解压缩安装包：

```sh
tar -xvf nacos-server-1.4.1.tar.gz
```

然后删除安装包：

```sh
rm -rf nacos-server-1.4.1.tar.gz
```

目录中最终样式：

![image-20210402163858429](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402163858429.png)

目录内部：

![image-20210402164414827](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402164414827.png)

#### 启动

在nacos/bin目录中，输入命令启动Nacos：

```sh
sh startup.sh -m standalone
```

### 端口配置

Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。

**如果无法关闭占用8848端口的进程**，也可以进入nacos的conf目录，修改配置文件中的端口：

![image-20210402162008280](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402162008280.png)

修改其中的内容：

![image-20210402162251093](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210402162251093.png)

## 服务注册⭐

> Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。**因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别**。
>

### 依赖引入

在cloud-demo父工程的pom文件中的`<dependencyManagement>`中引入SpringCloudAlibaba的依赖，基本配置已引入

```xml
<!--spring-cloud-alibaba依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
    <version>${spring-cloud-alibaba.version}</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
```

然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：

```xml
<!--添加Nacos支持-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

在order-service添加loadbalancer依赖，因为它已经取代了ribbon，所以必须加上它

```xaml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

```java
//必须加上此注解，不然修改url后不能被识别然后进行访问⭐⭐
@Bean
@LoadBalanced
public RestTemplate restTemplate(){
    return new RestTemplate();
}
```

> **注意**：不要忘了注释掉eureka的依赖。

### 配置nacos地址

在user-service和order-service的application.yml中添加nacos地址：

```yml
spring:    
  application:
    name: userservice
    
  cloud:
    nacos:
      discovery:
        # nachos登录用户名
        username: nacos
        # nachos密码
        password: nacos
        # nachos 服务端地址
        server-addr: 127.0.0.1:8848
```

> **注意**：不要忘了注释掉eureka的地址

### 重启发现服务

重启微服务后，登录nacos管理页面，可以看到微服务信息：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091740713.png" alt="image-20230509174027593" style="zoom:80%;" />

### 发送和接收消息

> 看原order-service的service模块，userService即为服务名

```java
public Order queryOrderById(Long orderId) {
    // 1.查询订单
    Order order = orderMapper.selectById(orderId);
    // 实现远程调用⭐⭐
    String url = "http://userService/user/" +  order.getUserId();
    //获取到查找到的值并set到order表中
    User user = restTemplate.getForObject(url, User.class);
    order.setUser(user);
    // 4.返回
    return order;
}
```

在user-service发送端设定

```java
@GetMapping("/call/{name}")
public String call(@PathVariable String name) {
    return "I'm Provider. Received a message from: " + name;
}
```

在order-service接收端设定

```java
@Resource
private RestTemplate restTemplate;

@GetMapping("/consumer")
public String consumer(@RequestParam String name) {
    // 请求并获取结果 为 Nacos 服务id）
    String result = restTemplate.getForObject("http://userService/user/call/" + name,
                                              String.class);
    return result;
}
```

访问测试：:8080/order/consumer?name=ren

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291600126.png" alt="image-20220629160029059" style="zoom:67%;" />

## 服务分级和集群

一个**服务**可以有多个**实例**，例如我们的user-service，可以有:

- 127.0.0.1:8081
- 127.0.0.1:8082
- 127.0.0.1:8083

假如这些实例分布于全国各地的不同机房，例如：

- 127.0.0.1:8081，在上海机房
- 127.0.0.1:8082，在上海机房
- 127.0.0.1:8083，在杭州机房

Nacos就将同一机房内的实例 划分为一个**集群**。

也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210713232522531.png" alt="image-20210713232522531" style="zoom:67%;" />



微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群

![image-20210713232658928](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210713232658928.png)

杭州机房内的order-service应该优先访问同机房的user-service。



### 配置集群

修改user-service的application.yml文件，添加集群配置：

```yaml
spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ # 集群名称
```

重启两个user-service实例后，我们可以在nacos控制台看到下面结果：

![image-20211113161043289](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113161043289.png)

我们再次复制一个user-service启动配置，添加属性：

```sh
-Dserver.port=8083 
-Dspring.cloud.nacos.discovery.cluster-name=SH
```

配置如图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210713233528982.png" alt="image-20210713233528982" style="zoom:67%;" />

启动UserApplication3后再次查看nacos控制台：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113161118881.png" alt="image-20211113161118881" style="zoom:80%;" />

### 集群优先的负载均衡

默认的`ZoneAvoidanceRule`并不能实现根据同集群优先来实现负载均衡。

因此Nacos中提供了一个`NacosRule`的实现，可以优先从同集群中挑选实例。

1）给**order-service**配置集群信息

修改order-service的application.yml文件，添加集群配置：

```yml
spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ # 集群名称
```

2）修改负载均衡规则

修改order-service的application.yml文件，修改负载均衡规则：

```yaml
userservice:
  ribbon:
    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule 
```

NacosRule负载均衡策略

> - 优先选择同集群服务实例列表
> - 本地集群找不到提供者，才去其它集群寻找，并且会报警告
> - 确定了可用实例列表后，再采用随机负载均衡挑选实例

## 集群权重配置

实际部署中会出现这样的场景：

> 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113161212110.png" alt="image-20211113161212110" style="zoom:80%;" />

在弹出的编辑窗口，修改权重：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210713235235219.png" alt="image-20210713235235219" style="zoom:50%;" />



> **注意**：如果权重修改为0，则该实例永远不会被访问，这样可以做到平滑升级，无感知升级系统

## 保护阈值

> 保护阈值（ProtectThreshold）：为了防止因过多实例故障，导致所有流量全部流入剩余健康实例，继而造成流量压力将剩余健康实例被压垮形成雪崩效应。应将健康保护阈值定义为⼀个 0 到 1 之间的浮点数。当域名健康实例数占总服务实例数的比例小于该值时，无论实例是否健康，都会将这个（健康或不健康的）实例返回给客户端。这样做虽然损失了⼀部分流量，但是保证了集群中剩余健康实例能正常工作。

> 也就是说，保护阈值是设置集群中健康实例占比允许的最小值，它需要设置一个 0-1 的浮点值，默认值为 0，当集群中的健康实例占比小于设置的保护阈值时，就会触发阈值保护功能。保护阈值可在服务详情中查询和设置，如下
>

> 保护阈值是为了防止因过多实例故障，导致所有流量全部流入剩余健康实例，继而造成流量压力将剩余健康实例被压垮形成雪崩效应。它的默认值是 0，取值范围应该是 0-1 的浮点数。此值是定义集群中允许健康实例占比的最小值，如果实际健康服务占比小于或等于此值，就会触发保护阈值，那么 Nacos 就会将全部实例：健康实例 + 非健康实例全部返回给调用者，而当保护阈值未触发时，Nacos 只会把健康实例返回给调用者。

![image-20220901091827293](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091604159.png)

### 如何理解保护阈值

> **要理解保护阈值先要明确一个前提条件：对于 Nacos 的注册中心功能来说，Nacos 有一个天然的职责，是将服务消费者（Consumer）的请求转发给某个健康的服务提供者（Provider）。**但在执行的流程中，可能会出现一种极端的情况，比如某个服务有 100 个实例，其中 99 个实例都宕机了，只剩下一个健康的实例，这个时候如果把所有的请求都转发到这一个健康实例上就会造成雪崩效应，最终导致业务系统崩溃。

> 为了防止这种极端情况，于是就有了“保护阈值”，保护阈值一旦被触发，那么 Nacos 将会把请求转发给所有服务实例，也就是健康实例+非健康实例，这样可能会损失了⼀部分流量，但能保证集群中剩余的健康实例能正常工作。

> 保护阈值触发条件：（实际健康实例/总服务实例）≤设置的保护阈值

### 设置保护阈值

我们可以通过“编辑服务”来设置保护阈值，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291652265.png" alt="image-20220629165243156" style="zoom:50%;" />

### 触发保护阈值

接下来我们创建一个服务测试一下保护阈值的功能，在创建的服务中添加两个实例，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291653663.png" alt="image-20220629165304575" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291653413.png" alt="image-20220629165320304" style="zoom:50%;" />

默认情况下服务实例都是健康的，接下来我们将保护阈值设置为 0.8，也就是健康实例的最低要求是 80%，如果健康实例占比小于此值就会触发保护阈值，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291653346.png" alt="image-20220629165338238" style="zoom:50%;" />

当所有节点都健康时，观察服务列表页面，可以看出并未触发保护阈值的功能，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291653164.png" alt="image-20220629165354077" style="zoom:67%;" />

此时我们手动停止一个服务实例，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291654174.png" alt="image-20220629165409070" style="zoom:50%;" />

这是健康实例的占比就从 100%，下降到了 50%，小于了设置的保护阈值 0.8（80%），接下来返回服务列表页面，可以看到保护阈值功能被触发了：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291654020.png" alt="image-20220629165429928" style="zoom:50%;" />

此时，我们再去访问服务就会看到，部分请求会转发到非健康实例，也就是访问会出错，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_gif/HrWw6ZuXCsjv1hSiaoap1G5Wq0RhAjxTjLgrjZy3DeqFkmh9KrLF5rNJibicD2WX5hyMaayKW0uWcQHVjUscxqZnQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

### 未触发保护阈值

接下来我们降低保护阈值，将保护阈值设置为 0.3，也就是健康实例占比最低要求是 30%，否则会触发阈值保护

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291654142.png" alt="image-20220629165446035" style="zoom:50%;" />

而此时因为我们健康实例占比是 50%，大于设置的阈值保护 0.3，所以就不会触发阈值保护，这点可以在服务列表中观察到：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291654756.png" alt="image-20220629165458668" style="zoom:67%;" />

当未触发保护阈值时，Nacos 会把所有请求都转发到健康的实例上，所以每次都能正常的访问服务，执行效果如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_gif/HrWw6ZuXCsjv1hSiaoap1G5Wq0RhAjxTjSH7zZMojMysDcfNqn4RkoTEpJchhCicB91EdhtfXQKz3GDPIYRUMNlw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

## 环境隔离

Nacos提供了namespace来实现环境隔离功能。

> - nacos中可以有多个namespace
> - namespace下可以有group、service等
> - 不同namespace之间相互隔离，例如**不同namespace的服务互相不可见**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714000101516.png" alt="image-20210714000101516" style="zoom:50%;" />

### 创建namespace

默认情况下，所有service、data、group都在同一个namespace，名为public：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714000414781.png" alt="image-20210714000414781" style="zoom:80%;" />

我们可以点击页面新增按钮，添加一个namespace：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714000440143.png" alt="image-20210714000440143" style="zoom:80%;" />

然后，填写表单：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714000505928.png" alt="image-20210714000505928" style="zoom:80%;" />

就能在页面看到一个新的namespace：

![image-20210714000522913](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714000522913.png)

再回到服务列表，可以看到刚配置的命名空间

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112122542651.png" alt="image-20211112122542651" style="zoom:67%;" />

### 配置namespace

给微服务配置namespace只能通过修改配置来实现。

例如，修改order-service的application.yml文件：

```yaml
spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ
        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID
```

重启order-service后，访问控制台，可以看到下面的结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113161307986.png" alt="image-20211113161307986" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305091604161.png" alt="image-20211113161317916"  />

此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：

![image-20211113161343175](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113161343175.png)

因此，要让服务能互相访问，必须把服务放在同一个命名空间下

## 临时 & 非临时实例

Nacos的服务实例分为两种类型：

> - 临时实例：**如果实例宕机超过一定时间，会从服务列表剔除，默认的类型**。
>
> - 非临时实例：**如果实例宕机，不会从服务列表剔除，也可以叫永久实例**。

配置一个服务实例为永久实例：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        ephemeral: false # 设置为非临时实例
```

Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113161412688.png" alt="image-20211113161412688" style="zoom: 67%;" />

> 服务的实例类型一旦确定之后，整个生命周期内不允许被修改，如果试图修改实例类型会提示错误



## 健康检查机制

> Spring Cloud Alibaba Nacos 作为注册中心不止提供了服务注册和服务发现功能，它还提供了服务可用性监测的机制。有了此机制之后，Nacos 才能感知服务的健康状态，从而为服务调用者提供健康的服务实例，最终保证了业务系统能够正常的执行。

### 两种健康检查机制

Nacos 中提供了两种健康检查机制：

1. 客户端主动上报机制。
2. 服务器端反向探测机制。

如何理解这两种机制呢？想象⼀下这么⼀个场景，你所在的地区突然发生地质灾害，你被掩盖在废墟下面，搜救队必须要知道你在废墟里面，那么才能对你进行施救。那有什么方法可以让救援队知道你在废墟下面？

- 第⼀种，你在废墟里面大喊 help! help! I am here! ，让搜救队知道你的位置和健康状态。
- 第二种，搜救队使用了他们的专业检查设备，探测到你正埋在废墟下面。

以上这两种方法和 Nacos 的两种健康检查机制类似，也就是客户端主动上报机制，是客户端每隔一段时间，主动向 Nacos 服务器端上报自己的健康状况，而服务器端反向探测机制是 Nacos 服务器端来检测客户端是否健康

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291603192.png" alt="image-20220629160347075" style="zoom: 33%;" />



### 如何设置健康检查机制？

**Nacos 中的健康检查机制不能主动设置，但健康检查机制是和 Nacos 的服务实例类型强相关的。**也就是说 Nacos 中的两种服务实例分别对应了两种健康检查机制：

1. 临时实例（也可以叫做非持久化实例）：对应的是客户端主动上报机制。
2. 永久实例（也可以叫做持久化实例）：服务端反向探测机制。

> 为什么需要两种服务实例呢？以淘宝为例，双十一大促期间，流量会比平常高出很多，此时服务肯定需要增加更多实例来应对高并发，而这些实例在双十一之后就无需继续使用了，采用临时实例比较合适。而对于服务的一些常备实例，则使用永久实例更合适。

### 客户端主动上报机制

> 临时实例每隔 5 秒会主动上报一次自己的健康状况，发送的数据包叫做心跳包，发送心跳包的机制叫做心跳机制。如果心跳包的间隔时间超过了 15 秒，那么 Nacos 服务器端就会将此服务实例标记为非健康实例，如果心跳包超过了 30s 秒，那么 Nacos 服务器端将会把此服务实例从服务列表中删除掉。运行 Nacos 项目时，可以看到客户端主动上报心跳包的日志，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291605015.png" alt="image-20220629160503893" style="zoom:50%;" />

从上述图片可以看出，Nacos 客户端会以每 5s 一次的频率来上报自己的健康情况，请求信息如下：

> /nacos/v1/ns/instance/beat?app=unknown&namespaceId=public&port=8081&clusterName=DEFAULT&ip=192.168.3.72&serviceName=DEFAULT_GROUP@@spring-cloud-nacos-producer2

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291615566.png" alt="image-20220629161521461" style="zoom:67%;" />

###  服务端反向探测机制

> 永久实例使用的服务器端反向探测的方式实现健康检查的，它的探测周期是 2000 毫秒 + 随机数（5000 毫秒以内），如果检测异常会将此服务实例，标记为非健康实例，但不会把服务实例向临时实例那样进行删除。**Nacos 服务器反向探测目前内置了 3 种探测协议：HTTP 探测、TCP 探测和 MySQL 探测。**⼀般而言 HTTP 和 TCP 探测已经可以涵盖绝大多数的健康检查场景，MySQL 主要用于特殊的业务场景，例如数据库的主备需要通过服务名对外提供访问，需要确定当前访问数据库是否为主库时，那么我们此时的健康检查接口，是⼀个检查数据库是否为主库的 MySQL 命令

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291616665.png" alt="image-20220629161602540" style="zoom:50%;" />

#### TCP 探测

默认情况下，永久实例使用的是 TCP 探测，这点可以在 Nacos 控制台观察到，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291617896.png" alt="image-20220629161752791" style="zoom:50%;" />

默认会使用 IP端口来检查，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291618000.png" alt="image-20220629161808905" style="zoom: 50%;" />

**TCP 探测的大体逻辑是通过与注册实例建立 channel，不断 ping 注册实例的端口，来判断实例是否健康。**

#### HTTP 探测

HTTP 探测需要在 Nacos 控制台手动配置，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291618299.png" alt="image-20220629161827197" style="zoom:50%;" />

我们在服务实例中添加探测接口的实现代码：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291618922.png" alt="image-20220629161847836" style="zoom:50%;" />

此时我们重新启动服务实例，在服务详情中可以看到我们配置的 HTTP 探测已经生效了，可以检查出实例是健康的，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291619180.png" alt="image-20220629161947076" style="zoom:50%;" />

**Nacos 服务器端通过检查 HTTP 的接口是否返回 200 状态码，来判断实例是否为健康状态。**

### 集群下的健康检查机制

集群下的健康检查机制可以用一句话来概括，那就是“各司其职”。每个服务对应了一个主注册中心，当注册中心接收到临时实例的心跳包之后，将健康状态同步给其他注册中心。而永久实例也是类似的，每个服务对应了一个主注册中心，当负责的注册中心探测到服务实例的健康状态发生改变时，再会将实例的健康状况同步到其他注册中心，从而实现了集群下的健康检查机制。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291619378.png" alt="image-20220629161925260" style="zoom:50%;" />

# Nacos配置管理

> Nacos除了可以做注册中心，同样可以做配置管理来使用。Nacos 中通过命名空间 + 分组名 + 服务名可以定位到一个唯一实例，通常推荐使用由运行环境作为命名空间、应用名作为分组，服务功能作为服务名的组合来定义服务。保护阈值是牺牲⼀部分流量，保证集群中剩余健康实例能正常工作的一种手段。服务路由类型和权重都是用来定义 Nacos 路由规则的，而临时实例和持久化实例是 Nacos 中的两种实例类型。
>

## 参数配置⭐

> Nacos 中的参数有很多，如：命名空间、分组名、服务名、保护阈值、服务路由类型、临时实例等，那这些参数都是什么意思？又该如何设置？接下来我们一起来盘它。
>

### 命名空间

在 Nacos 中通过命名空间（Namespace）+ 分组（Group）+服务名（Name）可以定位到一个唯一的服务实例。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291656664.png" alt="image-20220629165649575" style="zoom:67%;" />

> **命名空间（Namespace）：Nacos 服务中最顶层、也是包含范围最广的概念，用于强制隔离类似环境或租户等场景。Nacos 的服务也需要使用命名空间来进行隔离。**命名空间在 Nacos 控制台的一级目录里可以找到，如下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291744770.png" alt="image-20220629174444683" style="zoom:67%;" />

在服务列表中也能看到命名空间的身影，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291745916.png" alt="image-20220629174507830" style="zoom:67%;" />

#### 命名空间用法

> 命名空间默认为 public，在项目开发中，如果不指定命名空间，那么会使用默认值 public。**官方推荐使用运行环境来定义命名空间**，如生产版本可使用 public，开发版可定义为 private。在项目开发中，可通过配置“spring.cloud.nacos.discovery.namespace”来定义命名空间，如下图所示：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291752947.png" alt="image-20220629175238872" style="zoom:67%;" />

#### 注意事项

**命名空间在使用前，必须先在控制台新建命名空间**，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291751916.png" alt="image-20220629175131819" style="zoom:67%;" />

如果在控制台没有新建命名空间，直接在项目中使用的话，是不能将服务成功的注册到 Nacos 中的，如下在项目中配置了一个未新建的 dev 命名空间，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291752318.png" alt="image-20220629175200222" style="zoom:67%;" />

然后启动项目，此时会发现，在 Nacos 控制台的服务列表中一直刷新不到任何服务实例，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291752369.png" alt="image-20220629175212280" style="zoom:67%;" />

### 分组名

> **分组名（Group）：Nacos 中次于命名空间的⼀种隔离概念，区别于命名空间的强制隔离属性，分组属于⼀个弱隔离概念，主要用于逻辑区分⼀些服务使用场景或不同应用的同名服务，最常用的情况主要是同⼀个服务的测试分组和生产分组、或者将应用名作为分组以防止不同应用提供的服务重名。**分组名在 Nacos 控制台的服务列表中可以看到，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291750101.png" alt="image-20220629175031012" style="zoom:67%;" />

> 分组名默认为 DEFAULT_GROUP，在项目中可通过“spring.cloud.nacos.discovery.group”来设置，如下图所示：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291750221.png" alt="image-20220629175043150" style="zoom:67%;" />

> 此项可省略，省略时的默认值为 DEFAULT_GROUP。**分组名可以直接在项目中使用**，无需像命名空间那样，在使用前还要在控制台中新建，设定了分组名之后，刷新服务列表就可以看到新的分组名称了，如下图所示：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291750846.png" alt="image-20220629175056759" style="zoom:67%;" />

### 服务名

> **服务名（Name）：该服务实际的名字，⼀般用于描述该服务提供了某种功能或能力。**通常推荐使用由运行环境作为命名空间、应用名作为分组，服务功能作为服务名的组合来确保该服务的天然唯⼀性，当然使用者可以忽略命名空间和分组，仅使用服务名作为服务唯⼀标示，这就需要使用者在定义服务名时额外增加自己的规则来确保在使用中能够唯⼀定位到该服务而不会发现到错误的服务上。服务名在项目中可以通过“spring.application.name”来指定，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291750547.png" alt="image-20220629175012475" style="zoom:67%;" />

### 服务路由类型

服务路由类型的设置如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291748741.png" alt="image-20220629174819631" style="zoom:67%;" />

> 它是用来设置服务的路由策略的，默认值为 none。如果**设置此值为 label（标签）模式，需要设置相应的标签表达式来匹配实例选择器（Selector），通过实例选择器可以完成自定义负载均衡策略**，比如我们可以自定义实例选择器，实现就近访问的负载均衡策略，这样消费者在调用时，会优先调用离自己比较近的 IP 节点，从而实现更高效的服务调用。
>

### 权重

> **权重（Weight）：实例的级别配置。权重为浮点数，范围为 0-10000。权重越大，分配给该实例的流量越大。**它是针对服务实例进行设置的，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291747005.png" alt="image-20220629174758898" style="zoom:50%;" />



## 统一配置管理⭐

> **当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置**。

将配置交给Nacos管理的步骤

> 1. **在Nacos中添加配置文件**
> 2. **在微服务中引入nacos的config依赖**
> 3. **在微服务中添加bootstrap.yml**，**配置nacos地址、当前环境、服务名称、文件后缀名**。
> 4. 这些决定了程序启动时去nacos读取哪个文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714164426792.png" alt="image-20210714164426792" style="zoom:80%;" />

Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。

### 添加配置文件

如何在nacos中管理配置呢？

![image-20210714164742924](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714164742924.png)

然后在弹出的表单中，填写配置信息：

![image-20210714164856664](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714164856664.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305092057126.png" alt="image-20230509205728947" style="zoom:80%;" />

> 注意：**项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好**。

### 微服务拉取配置

> 微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。但如果尚未读取application.yml，又如何得知nacos地址呢？因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：
>

![img](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/L0iFYNF.png)

#### 1）引入nacos-config依赖

首先，在user-service服务中，引入nacos-config的客户端依赖：

```xml
<!--nacos配置管理依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

spring-cloud-dependencies 2020.0.0 版本不在默认加载bootstrap 文件，如果需要加载bootstrap 文件需手动添加依赖⭐

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
```

#### 2）添加bootstrap.yaml

然后，在user-service中添加一个**bootstrap.yml**文件，这个文件是引导文件，优先级高于application.yml：如下：

```yml
spring:
  application:
    name: userservice # 服务名称
  profiles:
    active: dev #开发环境，这里是dev
  cloud:
    nacos:
      discovery:
        enabled: true
        server-addr: 127.0.0.1:8848
      config:
        file-extension: yaml # 文件后缀名
        server-addr: localhost:8848
```

这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据以下拼接作为文件id，来读取配置。

```sh
${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}
```

本例中，就是去读取`userservice-dev.yaml`：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714170845901.png" alt="image-20210714170845901" style="zoom:80%;" />

#### 3）读取nacos配置

在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：

```java
@RestController
@RequestMapping("/user")
@RefreshScope //属性值热更新注解
public class UserController {

    //判断是否从nacos控制台里得到yaml配置
    @Value("${pattern.dateformat}")
    private String dateformat;

    @GetMapping("now")
    public String now() {
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));
    }

    //判断是否从nacos控制台里得到yaml配置
    @Value("${pattern.list}")
    private String list;

    @GetMapping("/list")
    public String getList(){
        return list;
    }
}
```

在页面访问，可以看到效果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211113163839830.png" alt="image-20211113163839830" style="zoom:80%;" />



### 配置热更新⭐

我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是**配置热更新**。Nacos配置更改后，微服务可以实现热更新，方式有：要实现配置热更新，可以使用两种方式：

> 1. **通过@Value注解注入，结合@RefreshScope来刷新**
> 2. **通过@ConfigurationProperties注入，自动刷新**

注意事项：

> 1. **不是所有的配置都适合放到配置中心，维护起来比较麻烦**
> 2. **建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置**

#### @RefreshScope

> 在@Value注入的变量所在类上添加注解@RefreshScope，然后重启服务

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714171036335.png" alt="image-20210714171036335" style="zoom: 67%;" />

修改配置

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101107164.png" alt="image-20230510110754043" style="zoom:80%;" />

再次查看时间：:8081/user/now

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101108075.png" alt="image-20230510110812988" style="zoom:80%;" />

#### @ConfigurationProperties⭐

> 使用@ConfigurationProperties注解代替@Value注解。不需要加上@RefreshScope也可以实现热更新

在user-service服务中，添加一个类，读取patterrn.dateformat属性：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

```java
@Data
@Component
@ConfigurationProperties(prefix = "pattern")
public class PatternProperties {
    private String dateformat;
    private String username;
}
```

在UserController中使用这个类代替@Value：

```java
@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;
    
    //判断是否从nacos控制台里得到yaml配置
    @Autowired
    private PatternProperties properties;

    @GetMapping("/{id}")
    public User queryById(@PathVariable("id") Long id) {
        return userService.queryById(id);
    }

    @GetMapping("now")
    public String now() {
        return LocalDateTime.now()
                            .format(DateTimeFormatter.ofPattern(properties.getDateformat()));
    }
}
```

> 服务重启完成后，修改配置文件，再次进行发布

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101114806.png" alt="image-20230510111426710" style="zoom:80%;" />

> 访问查询结果，发现已经进行了热更新

:8081/user/now

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101113182.png" alt="image-20230510111330090" style="zoom: 50%;" />

## 配置共享

### 配置共享实现

其实微服务启动时，会去nacos读取多个配置文件，例如：

- `[spring.application.name]-[spring.profiles.active].yaml`，例如：**userservice-dev.yaml**

- `[spring.application.name].yaml`，例如：**userservice.yaml**

**而`[spring.application.name].yaml`不包含环境，因此可以被多个环境共享。**

无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112163823245.png" alt="image-20211112163823245" style="zoom:80%;" />

下面我们通过案例来测试配置共享

### 测试多环境共享

> 创建userservice.yaml配置文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101419100.png" alt="image-20230510141922014" style="zoom:80%;" />

> 修改代码

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

```java
@Data
@Component
@ConfigurationProperties(prefix = "pattern")
public class PatternProperties {
    private String dateformat;
    private String username;
    private String envShardValue;
}
```

```java
@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;
    
    @Autowired
    private PatternProperties properties;

    @GetMapping("prop")
    public PatternProperties properties() {
        return properties;
    }
}
```

> 修改8082端口的配置为test环境，只需要修改下面的配置即可

修改UserApplication2这个启动项，改变其profile值：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714173538538.png" alt="image-20210714173538538" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714173519963.png" alt="image-20210714173519963" style="zoom: 67%;" />

这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。

> 访问测试，发现userservice.yaml的文件内容可以被dev和test环境都能读取到

:8081/user/prop

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101425825.png" alt="image-20230510142517752" style="zoom:80%;" />

:8082/user/prop

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101424514.png" alt="image-20230510142458439" style="zoom:80%;" />

### 配置共享的优先级

当nacos、服务本地同时出现相同属性时，优先级有高低之分：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112164215834.png" alt="image-20211112164215834" style="zoom:80%;" />

> 环境配置 >服务名.yaml > extension-config > extension-configs > shared-configs > 本地配置

# Nacos集群搭建⭐

## 集群结构图

官方给出的Nacos集群图：搭建集群的基本步骤：

> - **搭建数据库，初始化数据库表结构**
> - **下载nacos安装包**
> - **配置nacos**
> - **启动nacos集群**
> - **nginx反向代理**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311446377.png" alt="image-20210409210621117" style="zoom: 80%;" />

其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311446375.png" alt="image-20210409211355037" style="zoom: 67%;" />

三个nacos节点的地址：

| 节点   | ip            | port |
| ------ | ------------- | ---- |
| nacos1 | 192.168.150.1 | 8845 |
| nacos2 | 192.168.150.1 | 8846 |
| nacos3 | 192.168.150.1 | 8847 |

## 初始化数据库

> Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。这里我们以单点的数据库为例来讲解。首先新建一个数据库，命名为nacos，而后导入下面的SQL：
>

> 官网：https://github.com/alibaba/nacos/tree/develop/distribution/conf ，点击mysql-schema.sql，执行即可
>
> 就是下面的哪个，SQL脚本是在nacos源码包下的distribution\conf\nacos-mysql.sql

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311505474.png" alt="image-20220831150547368" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311457951.png" alt="image-20220831145733859" style="zoom: 80%;" />

## 配置nacos

nacos在GitHub上有下载地址：https://github.com/alibaba/nacos/tags，可以选择任意版本下载。将这个包解压到任意非中文目录下，如图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311446378.png" alt="image-20210402161843337" style="zoom:80%;" />

目录说明：

- bin：启动脚本
- conf：配置文件

进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：

![image-20210409212459292](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311446381.png)

然后添加内容：

```apl
127.0.0.1:8845
127.0.0.1.8846
127.0.0.1.8847
```

然后修改application.properties文件，取消注释数据库配置

```properties
spring.datasource.platform=mysql
# MySQL数量
db.num=1
# 连接数据库配置
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
db.user.0=root
db.password.0=123456
```

将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311446393.png" alt="image-20210409213335538" style="zoom:80%;" /> 

### 修改端口

然后分别修改三个文件夹中的application.properties，

nacos1:

```properties
server.port=8845
```

nacos2:

```properties
server.port=8846
```

nacos3:

```properties
server.port=8847
```

### 解决端口被占用

```apl
netstat -ano | findstr 8846
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311547986.png" alt="image-20220831154743889" style="zoom:80%;" />

依次执行该命令杀死再启动

```apl
taskkill  -f -pid  15328 
```

## 启动nacos

然后分别进入bin目录启动三个nacos节点：

```apl
startup.cmd
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101445630.png" alt="image-20230510144553525" style="zoom:80%;" />

## nginx反向代理 

解压到任意非中文目录下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311446908.png" alt="image-20210410103322874" style="zoom:80%;" /> 

修改conf/nginx.conf文件，配置如下：

```nginx
upstream nacos-cluster {
    server 127.0.0.1:8845;
	server 127.0.0.1:8846;
	server 127.0.0.1:8847;
}

server {
    listen       80;
    server_name  localhost;

    location /nacos {
        proxy_pass http://nacos-cluster;
    }
}
```

启动：start nginx.exe，而后在浏览器访问：/nacos即可。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311551231.png" alt="image-20220831155147109" style="zoom:80%;" />

代码中application.yml文件配置如下：将端口改成80即可

```yaml
spring:
  cloud:
    nacos:
      server-addr: localhost:80 # Nacos地址
```

## 优化部署

> **实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置。Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离**

# 服务调用

> Nacos 支持两种 HTTP 服务请求，一个是 REST Template，另一个是 Feign Client。之前的文章咱们介绍过 Rest Template 的调用方式，主要是通过 Ribbon（负载均衡） + RestTemplate 实现 HTTP 服务调用的，请求的核心代码是这样的：

```java
// 拼接地址
String url = "http://userservice/user/" +  order.getUserId();
// 通过restTemplate发送请求
User user = restTemplate.getForObject(url, User.class);
```

存在下面的问题：

- 代码可读性差，编程体验不统一


- 参数复杂URL难以维护


Feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign

其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。

![image-20210714174918088](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714174918088.png)

## 基础使用

### 1）引入依赖

在父模块dependencyManagement需要有这个spring-cloud-dependencies依赖，不然会失效

我们在order-service服务的pom文件中引入feign的依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

### 2）添加注解

在order-service的启动类添加注解开启Feign的功能：

```java
@EnableFeignClients //Feign注解
@MapperScan("com.it.mapper")
@SpringBootApplication
public class OrderApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }
}
```

### 3）编写Feign客户端

在order-service中新建一个接口client/UserClient，内容如下：

```java
// nacos服务 id
@FeignClient("userservice") 
public interface UserClient {
    
    @GetMapping("/user/{id}")
    User findById(@PathVariable("id") Long id);
}
```

这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：

- 服务名称：userservice
- 请求方式：GET
- 请求路径：/user/{id}
- 请求参数：Long id
- 返回值类型：User

这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。

### 4）使用Feign客户端

修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：

```java
@Service
public class OrderService {

    @Resource
    private OrderMapper orderMapper;

    @Autowired
    private UserClient userClient;

    public Order queryOrderById(Long orderId) {
        // 1.查询订单
        Order order = orderMapper.selectById(orderId);
		// 2.普通访问方式
        // String url = "http://userservice/user/" +  order.getUserId();
        // User user = restTemplate.getForObject(url, User.class);
	
        // 2.利用Feign发起http请求，查询用户
        User user = userClient.findById(order.getUserId());
        // 3.封装user到Order
        order.setUser(user);
        // 4.返回
        return order;
    }
}
```

访问测试：:8080/order/101

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101456081.png" alt="image-20230510145642995" style="zoom:80%;" />

是不是看起来优雅多了。

## 自定义配置

Feign运行自定义配置来覆盖默认配置，可以修改的配置如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311601512.png" alt="image-20220831160113405" style="zoom:80%;" />

一般我们需要配置的就是日志级别

### 配置文件方式

基于配置文件修改feign的日志级别可以针对单个服务：

```yaml
feign:  
  client:
    config: 
      userservice: # 针对某个微服务的配置
        loggerLevel: FULL #  日志级别 
```

也可以针对所有服务：

```yaml
feign:  
  client:
    config: 
      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置
        loggerLevel: FULL #  日志级别 
```

> 访问order：生成日志

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101502427.png" alt="image-20230510150257310" style="zoom:80%;" />

而日志的级别分为四种：

> - NONE：不记录任何日志信息，这是默认值。
> - BASIC：仅记录请求的方法，URL以及响应状态码和执行时间
> - HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息
> - FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。

### Java代码方式

也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：

```java
// 注意：此时类上无需加上@Component注解
public class DefaultFeignConfiguration {
    @Bean
    public Logger.Level feignLogLevel(){
        return Logger.Level.BASIC; // 日志级别为BASIC
    }
}
```

如果要**全局生效**，将其放到启动类的@EnableFeignClients这个注解中：

```java
@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration.class) 
```

如果是**局部生效**，则把它放到对应的@FeignClient这个注解中：

```java
@FeignClient(value = "userservice", configuration = DefaultFeignConfiguration .class) 
```

## 最佳实践⭐

> 所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：
>

feign客户端：

```java
@FeignClient("userservice")
public interface UserClient {
    
    @GetMapping("/user/{id}")
    User findById(@PathVariable("id") Long id);
    
}
```

UserController：进行用户查询

```java
@GetMapping("/{id}")
public User queryById(@PathVariable("id") Long id) {
    return userService.queryById(id);
}
```

有没有一种办法简化这种重复的代码编写呢？

### 继承方式

一样的代码可以通过继承来共享：

> 1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。
>
> 2）Feign客户端和Controller都集成改接口



![image-20210714190640857](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714190640857.png)



> - 服务提供方、服务消费方紧耦合。官方不推荐这么写，但企业用的挺多
> - 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解
> - 优点：简单，实现了代码共享

### 抽取方式

> 将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。
>

![image-20210714214041796](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714214041796.png)



### 基于抽取的最佳实践⭐

#### 1）抽取

首先创建一个module，命名为feign-api：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714204557771.png" alt="image-20210714204557771" style="zoom:67%;" />

项目结构：

![image-20210714204656214](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714204656214.png)

在feign-api中然后引入feign的starter依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714205221970.png" alt="image-20210714205221970" style="zoom:67%;" />

#### 2）在order-service中使用feign-api

> 首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。在order-service的pom文件中中引入feign-api的依赖：
>

```xml
<dependency>
    <groupId>cn.itcast.demo</groupId>
    <artifactId>feign-api</artifactId>
    <version>1.0</version>
</dependency>
```

> **然后修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包**

#### 3）重启测试

重启后，发现服务报错了：

![image-20210714205623048](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714205623048.png)

> 这是因为UserClient现在在cn.itcast.feign.clients包下，而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。
>

#### 4）解决扫描包问题(重要)

方式一：指定Feign应该扫描的包：

```java
@EnableFeignClients(basePackages = "cn.itcast.feign.clients")
```

方式二：指定需要加载的Client接口：

```java
@EnableFeignClients(clients = {UserClient.class})
```

## 如何传参

开发中接口传参的方式有很多，但是在openFeign中的传参是有一定规则的，下面详细介绍。

### 1、传递JSON数据

这个也是接口开发中常用的传参规则，在Spring Boot 中通过`@RequestBody`标识入参。provider接口中JSON传参方法

```java
@RestController
@RequestMapping("/openfeign/provider")
public class OpenFeignProviderController {
    
    @PostMapping("/order2")
    public Order createOrder2(@RequestBody Order order){
        return order;
    }
    
}
```

consumer中openFeign接口中传参代码如下：

```java
@FeignClient(value = "openFeign-provider")
public interface OpenFeignService {
    /**
     * 参数默认是@RequestBody标注的，这里的@RequestBody可以不填
     * 方法名称任意
     */
    @PostMapping("/openfeign/provider/order2")
    Order createOrder2(@RequestBody Order order);
}
```

注意：`openFeign`默认的传参方式就是JSON传参（`@RequestBody`），因此定义接口的时候可以不用`@RequestBody`注解标注，不过为了规范，一般都填上。

### 2、POJO表单传参

这种传参方式也是比较常用，参数使用POJO对象接收。

provider服务提供者代码如下：

```java
@RestController
@RequestMapping("/openfeign/provider")
public class OpenFeignProviderController {
    @PostMapping("/order1")
    public Order createOrder1(Order order){
        return order;
    }
}
```

consumer消费者openFeign代码如下：

```java
@FeignClient(value = "openFeign-provider")
public interface OpenFeignService {
    /**
     * 参数默认是@RequestBody标注的，如果通过POJO表单传参的，使用@SpringQueryMap标注
     */
    @PostMapping("/openfeign/provider/order1")
    Order createOrder1(@SpringQueryMap Order order);
}
```

网上很多人疑惑POJO表单方式如何传参，官方文档明确给出了解决方案

OpenFeign提供了一个注解`@SpringQueryMap`完美解决POJO表单传参。

### 3、URL中携带参数

此种方式针对restful方式中的GET请求，也是比较常用请求方式。

provider服务提供者代码如下：

```java
@RestController
@RequestMapping("/openfeign/provider")
public class OpenFeignProviderController {

    @GetMapping("/test/{id}")
    public String test(@PathVariable("id")Integer id){
        return "accept one msg id="+id;
}
```

consumer消费者openFeign接口如下：

```java
@FeignClient(value = "openFeign-provider")
public interface OpenFeignService {

    @GetMapping("/openfeign/provider/test/{id}")
    String get(@PathVariable("id")Integer id);
}
```

使用注解`@PathVariable`接收url中的占位符，这种方式很好理解。

### 4、普通表单参数

此种方式传参不建议使用，但是也有很多开发在用。

provider服务提供者代码如下：

```java
@RestController
@RequestMapping("/openfeign/provider")
public class OpenFeignProviderController {
    @PostMapping("/test2")
    public String test2(String id,String name){
        return MessageFormat.format("accept on msg id={0}，name={1}",id,name);
    }
}
```

consumer消费者openFeign接口传参如下：

```java
@FeignClient(value = "openFeign-provider")
public interface OpenFeignService {
    /**
     * 必须要@RequestParam注解标注，且value属性必须填上参数名
     * 方法参数名可以任意，但是@RequestParam注解中的value属性必须和provider中的参数名相同
     */
    @PostMapping("/openfeign/provider/test2")
    String test(@RequestParam("id") String arg1,@RequestParam("name") String arg2);
}
```

## 日志打印

> Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。说白了就是**对Feign接口的调用情况进行监控和输出**

### 日志级别

> NONE：默认的，不显示任何日志；
>
> BASIC：仅记录请求方法、URL、响应状态码及执行时间；
>
> HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；
>
> FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。

### 日志配置

```java
@Configuration
public class FeignConfig {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
```

```yml
server:
  port: 80

eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/

#设置feign客户端超时时间
#springCloud默认开启支持ribbon
ribbon:
  # 指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间
  ReadTimeout: 5000
  # 指的是建立连接后从服务器读取到可用资源所用的时间
  ConnectTimeout: 5000

logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.atguigu.springcloud.service.PaymentFeignService: debug
```

后台日志查看

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305082041235.png" alt="image-20230508204131181" style="zoom:80%;" />

## 超时时间

### 全局超时时间

OpenFeign可以设置超时时间，简单粗暴，设置一个全局的超时时间，如下：

```yml
feign:
  client:
    config:
      default:
        connectTimeout: 3000
        readTimeout: 4000
```

> 如果不配置超时时间，默认是连接超时10s，读超时60s，在源码feign.Request的内部类Options中定义。

> 这个接口设置了最大的readTimeout是60s，这个时间必须大于调用的所有外部接口的readTimeout，否则处理时间大于readTimeout的接口就会调用失败。

> 如下图，在一个系统中使用OpenFeign调用外部三个服务，每个服务提供两个接口，其中serviceC的一个接口需要60才能返回，那上面的readTimeout必须设置成60s。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302191305522.png" alt="image-20230219130545443" style="zoom:80%;" />

> 但是如果serviceA出故障了，表现是接口1超过60s才能返回，这样OpenFeign只能等到读超时，如果调用这个接口的并发量很高，会大量占用连接资源直到资源耗尽系统奔溃。要防止这样的故障发生，就必须保证接口1能fail-fast。最好的做法就是给serviceC单独设置超时时间。

### 单服务超时时间

从上一节的讲解我们看到，需要对serviceC单独设置一个超时时间，代码如下：

```yml
feign:
  client:
    config:
      userservice:
        connectTimeout: 3000
        readTimeout: 4000
```

> 这个时间会覆盖第一节中默认的超时时间。但是问题又来了，serviceC中又掉了serviceD，因为serviceD的故障导致接口6发生了读超时的情况，为了不让系统奔溃，不得不对serviceC的接口5单独设置超时时间。如下图：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302191306429.png" alt="image-20230219130614352" style="zoom:80%;" />



## 重试机制

在order-service创建，进行重试

```java
@Configuration
public class FeignConfigure {
    @Bean
    public Retryer feignRetryer(){
        // period=100 发起当前请求的时间间隔,单位毫秒
        // maxPeriod=1000 发起当前请求的最大时间间隔,单位毫秒
        // maxAttempts=2 重试次数是1，因为包括第一次，所以我们如果想要重试2次，就需要设置为3
        return new Retryer.Default(100, 1000, 2);
    }
}
```

## 性能优化⭐

> 1. 修改 OpenFeign 的超时时间，让 OpenFeign 能够正确的处理业务；
> 2. 配置专用的通信组件 Apache HttpClient 或 OKHttp，让 OpenFeign 可以更好地对 HTTP 连接对象进行重用和管理
> 3. 开启数据压缩功能，可以提高宽带利用率和加速数据传输速度；
> 4. 使用合适的负载均衡策略来替换默认的轮询负载均衡策略，已获得更好的执行效率；
> 5. 检查生成环境中 OpenFeign 的日志级别，选择合适的日志输出级别，防止无效的日志输出。

### 超时优化

OpenFeign 底层内置了 Ribbon 框架，并且使用了 Ribbon 的请求连接超时时间和请求处理超时时间作为其超时时间，而 Ribbon 默认的请求连接超时时间和请求处理超时时间都是 1s，如下源码所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291144294.png" alt="image-20220629114457209" style="zoom:67%;" />

所有当我们使用 OpenFeign 调用了服务接口超过 1s，就会出现以下错误：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291145923.png" alt="image-20220629114516840" style="zoom:67%;" />

因为 1s 确实太短了，因此我们需要手动设置 OpenFeign 的超时时间以保证它能正确的处理业务。OpenFeign 的超时时间有以下两种更改方法：

1. 通过修改 Ribbon 的超时时间，被动的修改 OpenFeign 的超时时间。
2. 直接修改 OpenFeign 的超时时间（推荐使用）。

#### 设置超时时间

在项目配置文件 application.yml 中添加以下配置：

```yml
feign:
  client:
    config:
      # default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间
      default: 
        connectTimeout: 2000 # 请求连接的超时时间
        readTimeout: 5000 # 请求处理的超时时间
```

推荐使用此方式来设置 OpenFeign 的超时时间，因为这样的（配置）语义更明确。

#### 可能出现的问题

> openFeign设置超时时间非常简单，只需要在配置文件中配置，如下：default设置的是全局超时时间，对所有的openFeign接口服务都生效。但是正常的业务逻辑中可能涉及到多个openFeign接口的调用，如下图：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021020027.png" alt="image-20220702102054940" style="zoom: 50%;" />

上图中的伪代码如下：

```java
public T invoke(){
    //1. 调用serviceA
    serviceA();
    
    //2. 调用serviceA
    serviceB();
    
    //3. 调用serviceA
    serviceC();
}
```

那么上面配置的全局超时时间能不能通过呢？很显然是`serviceA`、`serviceB`能够成功调用，但是`serviceC`并不能成功执行，肯定报超时。

此时我们可以给`serviceC`这个服务单独配置一个超时时间，配置如下：

```yml
feign:
  client:
    config:
      ## default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间
      default:
        connectTimeout: 5000
        readTimeout: 5000
      ## 为serviceC这个服务单独配置超时时间
      serviceC:
        connectTimeout: 30000
        readTimeout: 30000
```

> **注意**：单个配置的超时时间将会覆盖全局配置。

### 请求连接优化⭐

如果不做特殊配置，OpenFeign默认使用jdk自带的HttpURLConnection，我们知道HttpURLConnection没有连接池、性能和效率比较低，如果采用默认，很可能会遇到性能问题导致系统故障。Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：

> - URLConnection：默认实现，不支持连接池
>
>
> - Apache HttpClient ：支持连接池
>
>
> - OKHttp：支持连接池


因此提高Feign的性能主要手段就是使用**连接池**代替默认的URLConnection。

这里我们用Apache的HttpClient来演示。

#### 1）引入依赖

在order-service的pom文件中引入Apache的HttpClient依赖：

```xml
<!--httpClient的依赖 -->
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-httpclient</artifactId>
</dependency>
```

#### 2）配置连接池

在order-service的application.yml中添加配置：

```yaml
feign:
  client:
    config:
      default: # default全局的配置
        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息
  httpclient:
    enabled: true # 开启feign对HttpClient的支持
    max-connections: 200 # 最大的连接数
    max-connections-per-route: 50 # 每个路径的最大连接数
```

接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714185925910.png" alt="image-20210714185925910" style="zoom:67%;" />

Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714190041542.png" alt="image-20210714190041542" style="zoom:67%;" />

也可以采用OkHttpClient，properties文件中增加下面配置：

```properties
feign.okhttp.enabled=true
```

pom文件中增加依赖：

```xml
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-okhttp</artifactId>
    <version>10.2.0</version>
</dependency>
```

### 数据压缩

#### gzip压缩

> OpenFeign 默认不会开启数据压缩功能，但我们可以手动的开启它的 Gzip 压缩功能，这样可以极大的提高宽带利用率和加速数据的传输速度。gzip是一种数据格式，采用用deflate算法压缩数据；**当GZIP压缩到一个纯文本数据时，效果是非常明显的，大约可以减少70％以上的数据大小。**
>

> 网络数据经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。网页加载速度加快的好处不言而喻，除了节省流量，改善用户的浏览体验外，另一个潜在的好处是GZIP与搜索引擎的抓取工具有着更好的关系。例如 Google就可以通过直接读取GZIP文件来比普通手工抓取更快地检索网页。
>

#### 压缩流程

GZIP压缩传输的原理如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021015977.png" alt="image-20220702101559904" style="zoom:67%;" />

按照上图拆解出的步骤如下：

> - 客户端向服务器请求头中带有：**`Accept-Encoding:gzip,deflate`** 字段，向服务器表示，客户端支持的压缩格式（gzip或者deflate)，如果不发送该消息头，服务器是不会压缩的。
> - 服务端在收到请求之后，如果发现请求头中含有**`Accept-Encoding`**字段，并且支持该类型的压缩，就对响应报文压缩之后返回给客户端，并且携带**`Content-Encoding:gzip`**消息头，表示响应报文是压缩过。
> - 客户端接收到响应之后，先判断是否有Content-Encoding消息头，如果有，按该格式解压报文。否则按正常处理

#### 配置文件⭐

在项目配置文件 application.yml 中添加以下配置：

> PS：如果服务消费端的 CPU 资源比较紧张的话，建议不要开启数据的压缩功能，因为数据压缩和解压都需要消耗 CPU 的资源，这样反而会给 CPU 增加了额外的负担，也会导致系统性能降低。openFeign开启GZIP步骤也是很简单，只需要在配置文件中开启如下配置：

```yml
feign:
  ## 开启压缩
  compression:
    request:
      enabled: true
      # 最小压缩值标准，当数据大于1024字节才会进行压缩，默认2k，这里为了演示效果设置成10字节
      min-request-size: 10
      mime-types: text/xml,application/xml,application/json
    response:
    # 开启响应数据压缩功能
      enabled: true
```

上述配置完成之后，发出请求，可以清楚看到请求头中已经携带了GZIP压缩，如下图：

:8080/order/102

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102121913.png" alt="image-20230510212132783" style="zoom:80%;" />

### 日志级别优化

OpenFeign 提供了日志增强功能，它的日志级别有以下几个：

- **NONE**：默认的，不显示任何日志。
- **BASIC**：仅记录请求方法、URL、响应状态码及执行时间。(推荐)
- **HEADERS**：除了 BASIC 中定义的信息之外，还有请求和响应的头信息。
- **FULL**：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。

#### 配置文件方式⭐⭐

基于配置文件修改feign的日志级别可以针对单个服务：

```yaml
# 这个日志必须配置成debug，不然不显示效果
logging:
  level:
    cn.itcast: debug
feign:  
  client:
    config: 
      userservice: # 针对某个微服务的配置
        loggerLevel: FULL #  日志级别 
```

也可以针对所有服务：

```yaml
feign:  
  client:
    config: 
      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置
        loggerLevel: FULL #  日志级别 
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208312208674.png" alt="image-20220831220810481" style="zoom:67%;" />

#### Java代码方式

也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：

```java
@Bean
public Logger.Level feignLogLevel(){
      return Logger.Level.BASIC; // 日志级别为BASIC
}
```

> 其中 cn.myjszl.service 为 OpenFeign 接口所在的包名。虽然 **OpenFeign 默认是不输出任何日志，但在开发阶段可能会被修改，因此在生产环境中，我们应仔细检查并设置合理的日志级别，以提高 OpenFeign 的运行效率**。
>

# 服务网关

Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。

[Spring Cloud Gateway](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)

## 网关概述

### 为什么需要网关

Gateway网关是我们服务的守门神，所有微服务的统一入口。网关的**核心功能特性**：请求路由、权限控制、限流

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714210131152.png" alt="image-20210714210131152" style="zoom: 67%;" />

> 传统的单体架构中只有一个服务开放给客户端调用，但是微服务架构中是将一个系统拆分成多个微服务，那么作为客户端如何去调用这些微服务呢？如果没有网关的存在，只能在本地记录每个微服务的调用地址。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303100912770.png" alt="image-20230310091247650" style="zoom:80%;" />

无网关的微服务架构往往存在以下问题：

> - 客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性。
> - 认证复杂，每个服务都需要独立认证。
> - 存在跨域请求，在一定场景下处理相对复杂。 

### 网关基本功能

> 网关是所有微服务的门户，路由转发仅仅是最基本的功能，除此之外还有其他的一些功能，比如：**认证**、**鉴权**、**熔断**、**限流**、**日志监控**等等.........

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303100938709.png" alt="image-20230310093859592" style="zoom:67%;" />

> 以上这些应用场景会在后续的文章详细介绍，不是今天的重点。



### 网关工作流程

> 客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。

> ① **路由判断**；客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。
>

> ② **请求过滤**：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。
>

> ③ **服务处理**：后端服务会对请求进行处理。
>

> ④ **响应过滤**：后端处理结果后，返回 过滤器再次做处理，可以称作 Post-Filters，Post 可以理解为“在...之后”
>

> ⑤ **响应返回**：响应经过过滤处理后，返回给客户端。
>

## 网关快速入门⭐

下面，我们就演示下网关的基本路由功能。基本步骤如下：

> 1. 创建SpringBoot工程gateway，引入网关依赖
> 2. 编写启动类
> 3. 编写基础配置和路由规则
> 4. 启动网关服务进行测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714211742956.png" alt="image-20210714211742956" style="zoom:67%;" />

### 1）创建gateway模块

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714210919458.png" alt="image-20210714210919458" style="zoom:67%;" />

```xml
<dependencies>
    <!--网关-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <!--nacos服务发现依赖-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!-- 因为SpringCloud2020.1及以上已弃用ribbon，所以要加上loadbalancer -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    </dependency>
    <!-- 加上缓存依赖，不然会进行警告  -->
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
    </dependency>
</dependencies>
```

### 2）编写启动类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101525229.png" alt="image-20230510152513130" style="zoom:80%;" />

```java
@SpringBootApplication
public class GatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(GatewayApplication.class, args);
	}
}
```

### 3）编写基础配置和路由规则

创建application.yml文件，内容如下：路由配置包括：

> 1. 路由id：路由的唯一标示
>
> 2. 路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡
>
> 3. 路由断言（predicates）：判断路由的规则，
>
> 4. 路由过滤器（filters）：对请求或响应做处理

```yml
server:
  port: 10010 # 网关端口
spring:
  application:
    name: gateway # 服务名称
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos地址
    gateway:
      routes: # 网关路由配置
        - id: user-service # 路由id，自定义，只要唯一即可
          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称
          predicates: # 路由断言工厂，也就是判断请求是否符合路由规则的条件
            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
        - id: order-service
          uri: lb://orderservice
          predicates:
            - Path=/order/**
        - id: route_qq
          # 断言为 Query=url,qq，表示当请求路径中包含 url=qq，则跳转到http://www.qq.com
          uri: http://www.qq.com
          predicates:
            - Query=url,qq
        - id: route_baidu
          # 当请求路径中参数包含 url=baidu，则跳转到http://www.baidu.com
          uri: http://www.baidu.com
          predicates:
            - Query=url,baidu
```

> 我们将符合**`Path`** 规则的一切请求，都代理到 **`uri`**参数指定的地址。本例中，我们将 **`/user/**`**开头的请求，代理到**`lb://userservice`**，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。
>

### 4）重启测试

访问：:10010/user/1时，符合`/user/**`规则

访问：:10010/order/102时，符合`/order/**`规则

访问：:10010?url=qq，符合Query=url,qq，规则

访问：:10010?url=baidu，符合Query=url,baidu，规则

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101715921.png" alt="image-20230510171506807" style="zoom:80%;" />

## 断言工厂

[Spring Cloud Gateway，可以在这里查看断言示例](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)

我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件

```yml
gateway:
  routes: # 网关路由配置
     .....
    predicates: # 路由断言工厂，也就是判断请求是否符合路由规则的条件
      - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
```

### 常用断言⭐

例如Path=/user/**是按照路径匹配

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311647934.png" alt="image-20220831164717816" style="zoom:80%;" />

我们只需要掌握Path这种路由工程就可以了。

### 设置权重

下面就以最后一种权重断言为例介绍一下如何配置。配置如下：既然配置配置了权重并且相同的分组，则按照权重比例进行分配流量。

```yml
spring:
  application:
    name: gateway # 服务名称
  cloud:
    nacos:
      server-addr: localhost:8848 # nacos地址
    gateway:
      routes: # 网关路由配置
        - id: user-service1 # 路由id，自定义，只要唯一即可
          uri: :8081 # 路由的目标地址 lb就是负载均衡，后面跟服务名称
          predicates: # 路由断言工厂，也就是判断请求是否符合路由规则的条件
            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求
            # Weight Route Predicate Factory，同一分组按照权重进行分配流量，这里分配了80%
            # 第一个group1是分组名，第二个参数是权重
            - Weight=group1, 8
            
        - id: user-service2 # 路由id，自定义，只要唯一即可
          uri: :8082 # 路由的目标地址 lb就是负载均衡，后面跟服务名称
          predicates: # 路由断言工厂，也就是判断请求是否符合路由规则的条件
            # 这个是按照路径匹配，只要以/user/开头就符合要求
            - Path=/user/**
            # Weight Route Predicate Factory，同一分组按照权重进行分配流量，这里分配了20%
            # 第一个group1是分组名，第二个参数是权重
            - Weight=group1, 2
```

访问：:10010/user/1

此时查看日志打印，发现日志基本在8081上打印



## 过滤器

GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714212312871.png" alt="image-20210714212312871" style="zoom:80%;" />

过滤器的作用是什么？

> ① 对路由的请求或响应做加工处理，比如添加请求头
>
> ② 配置在路由下的过滤器只对当前路由的请求生效

### 路由过滤器分类

过滤器 Filter 按照请求和响应可以分为两种：`Pre` 类型和 `Post` 类型。

**Pre 类型**：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。

**Post 类型**：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。

另外一种分类是按照过滤器 Filter 作用的范围进行划分：

**GlobalFilter**：全局过滤器，应用在所有路由上的过滤器。

Spring提供了31种不同的路由过滤器工厂。例如：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101943195.png" alt="image-20230510194359040" style="zoom:80%;" />

### 请求头过滤器

下面我们以AddRequestHeader 为例来讲解。

> **需求**：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!

只需要修改gateway服务的application.yml文件，添加路由过滤即可：

```yaml
spring:
  cloud:
    gateway:
      routes:
      - id: user-service 
        uri: lb://userservice 
        predicates: 
        - Path=/user/** 
        filters: # 过滤器
        # 下面分别是key和value
        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头
        - AddResponseHeader=X-Response-Foo, Bar # 添加响应头
```

当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。

```java
@GetMapping("/head/{id}")
public String getHeader(@PathVariable("id") Long id,
                        @RequestHeader(value = "Truth",required = false) String truth) {
    System.out.println("打印请求头"+truth);
    return truth;
}
```

访问：:10010/user/head/1

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305101953369.png" alt="image-20230510195313243" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303100950353.png" alt="image-20230310095032265" style="zoom:80%;" />

### 默认过滤器

如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：

```yaml
spring:
  cloud:
    gateway:
      routes:
      - id: user-service 
        uri: lb://userservice 
        predicates: 
        - Path=/user/**
      default-filters: # 默认过滤项
      - AddRequestHeader=Truth, Itcast is freaking awesome! 
```

### 全局过滤器⭐

上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。

官方文档：https://cloud.spring.io/spring-cloud-static/Greenwich.SR2/single/spring-cloud.html#_global_filters

#### 全局过滤器作用

> 全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于Filter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。在filter中编写自定义逻辑，可以实现下列功能：**登录状态判断、权限校验、请求限流**等
>

```java
// 定义方式是实现GlobalFilter接口
public interface GlobalFilter {
    /**
     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
     * @param exchange 请求上下文，里面可以获取Request、Response等信息
     * @param chain 用来把请求委托给下一个过滤器 
     * @return {@code Mono<Void>} 返回标示当前过滤器业务结束
     */
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}
```

#### 自定义全局过滤器⭐

需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：

> - 参数中是否有authorization，
>
> - authorization参数值是否为admin

如果同时满足则放行，否则拦截，在gateway中定义一个过滤器：

```java
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

// 顺序注解，值越小，优先级越高，多个过滤器优先执行优先级高的
@Order(-1)
@Component
public class AuthorizeFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1.获取请求参数
        MultiValueMap<String, String> params = exchange.getRequest().getQueryParams();
        // 2.获取authorization参数
        String auth = params.getFirst("authorization");
        // 3.校验
        if ("admin".equals(auth)) {
            // 放行
            return chain.filter(exchange);
        }
        // 4.拦截
        // 4.1.禁止访问，设置状态码401
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        // 4.2.结束处理，拦截
        return exchange.getResponse().setComplete();
    }
}
```

访问：:10010/user/1

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102011265.png" alt="image-20230510201109130" style="zoom: 50%;" />

访问：:10010/user/1?authorization=admin

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102011051.png" alt="image-20230510201150936" style="zoom:80%;" />

#### 模拟Nginx的Access Log 功能

场景：模拟Nginx的Access Log 功能，记录每次请求的相关信息。代码如下：

```java
@Slf4j
@Component
@Order(value = Integer.MIN_VALUE)
public class AccessLogGlobalFilter implements GlobalFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        //filter的前置处理
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().pathWithinApplication().value();
        InetSocketAddress remoteAddress = request.getRemoteAddress();
        return chain
                // 继续调用filter
                .filter(exchange)
                // filter的后置处理
                .then(Mono.fromRunnable(() -> {
                    ServerHttpResponse response = exchange.getResponse();
                    HttpStatus statusCode = response.getStatusCode();
                    log.info("请求路径:{},远程IP地址:{},响应码:{}", path, 
                             remoteAddress, statusCode);
                }));
    }
}
```

好了，全局过滤器不必在路由上配置，注入到IOC容器中即可全局生效。此时发出一个请求，控制台打印信息如下：

:10010/user/1

:10010/user/2

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305110853766.png" alt="image-20230511085349667" style="zoom:80%;" />

### 局部过滤器

#### 判断响应头是否有token

**注意**：过滤器的名称只需要写前缀，过滤器命名必须是`xxxGatewayFilterFactory`（包括自定义）。

> 更多过滤器的配置可以看官方文档：[官方文档](https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gatewayfilter-factories)

虽说内置的过滤器能够解决很多场景，但是难免还是有些特殊需求需要定制一个过滤器，下面就来介绍一下如何自定义局部过滤器。

**场景**：模拟一个授权验证的过程，如果请求头或者请求参数中携带`token`则放行，否则直接拦截返回**401**，代码如下：

```java
/**
 * 名称必须是xxxGatewayFilterFactory形式
 * todo：模拟授权的验证，具体逻辑根据业务完善
 */
@Component
@Slf4j
public class AuthorizeGatewayFilterFactory extends AbstractGatewayFilterFactory<AuthorizeGatewayFilterFactory.Config> {

    private static final String AUTHORIZE_TOKEN = "token";

    //构造函数，加载Config
    public AuthorizeGatewayFilterFactory() {
        //固定写法
        super(AuthorizeGatewayFilterFactory.Config.class);
        log.info("Loaded GatewayFilterFactory [Authorize]");
    }

    //读取配置文件中的参数 赋值到 配置类中
    @Override
    public List<String> shortcutFieldOrder() {
        //Config.enabled
        return Arrays.asList("enabled");
    }

    @Override
    public GatewayFilter apply(AuthorizeGatewayFilterFactory.Config config) {
        return (exchange, chain) -> {
            //判断是否开启授权验证
            if (!config.isEnabled()) {
                return chain.filter(exchange);
            }
            ServerHttpRequest request = exchange.getRequest();
            HttpHeaders headers = request.getHeaders();
            //从请求头中获取token
            String token = headers.getFirst(AUTHORIZE_TOKEN);
            if (token == null) {
                //从请求头参数中获取token
                token = request.getQueryParams().getFirst(AUTHORIZE_TOKEN);
            }

            ServerHttpResponse response = exchange.getResponse();
            //如果token为空，直接返回401，未授权
            if (StringUtils.isEmpty(token)) {
                response.setStatusCode(HttpStatus.UNAUTHORIZED);
                //处理完成，直接拦截，不再进行下去
                return response.setComplete();
            }
            //授权正常，继续下一个过滤器链的调用
            return chain.filter(exchange);
        };
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class Config {
        // 控制是否开启认证
        private boolean enabled;
    }
}
```

局部过滤器需要在路由中配置才能生效，配置如下：

```yml
spring:
  cloud:
    gateway:
      ## 路由
      routes:
        ## id只要唯一即可，名称任意
        - id: gateway-provider_1
          uri: :9024
          ## 配置断言
          predicates:
            # Path Route Predicate Factory断言，
            # 满足/gateway/provider/**这个请求路径的都会被路由到:9024这个uri中
            - Path=/gateway/provider/**
          # 配置过滤器（局部）
          filters:
            - AddResponseHeader=X-Response-Foo, Bar
            ## AuthorizeGatewayFilterFactory自定义过滤器配置，值为true需要验证授权，false不需要
            - Authorize=true
```

此时直接访问：:9023/gateway/provider/port，不携带token，返回如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303100951558.png" alt="image-20230310095140460" style="zoom:80%;" />

请求参数带上token：:9023/gateway/provider/port?token=abcdcdecd-ddcdeicd12，成功返回，如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303100951054.png" alt="image-20230310095152963" style="zoom:80%;" />

上述的`AuthorizeGatewayFilterFactory`只是涉及到了过滤器的前置处理，后置处理是在`chain.filter().then()`中的`then()`方法中完成的，具体可以看下项目源码中的`TimeGatewayFilterFactory`，代码就不再贴出来了，如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303100952018.png" alt="image-20230310095205907" style="zoom:80%;" />

### 过滤器执行顺序

请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter

请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714214228409.png" alt="image-20210714214228409" style="zoom:67%;" />

排序的规则是什么呢？

> - 每一个过滤器都必须指定一个int类型的order值，**order值越小，优先级越高，执行顺序越靠前**。
> - GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定
> - 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。
> - 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行。

## 限流算法

限流：对应用服务器的请求做限制，避免因过多请求而导致服务器过载甚至宕机。限流算法常见的包括两种：

1. 计数器算法，又包括窗口计数器算法、滑动窗口计数器算法
2. 漏桶算法(Leaky Bucket)
3. 令牌桶算法（Token Bucket）

### 计数器算法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112172830301.png" alt="image-20211112172830301" style="zoom:80%;" />

### 漏桶算法

![image-20211112172859172](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112172859172.png)



### 令牌桶算法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112172926727.png" alt="image-20211112172926727" style="zoom:80%;" />

## 跨域配置

### 什么是跨域问题

跨域：域名不一致就是跨域，主要包括：

> - 域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com
> - 域名相同，端口不同：localhost:8080和localhost8081
> - 跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题

### 模拟跨域问题

找到课前资料的页面文件：

![image-20210714215713563](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210714215713563.png)

放入tomcat或者nginx这样的web服务器中，访问：:8090/

```apl
server {
    listen       8090;
    location / {
        root   html;
        index  index.html index.htm;
    }
}
```

```sh
start nginx.exe
```

启动并访问。可以在浏览器控制台看到下面的错误：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102029196.png" alt="image-20230510202959074" style="zoom:80%;" />

从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。

### 解决跨域问题

在gateway服务的application.yml文件中，添加下面的配置：

```yaml
spring:
  cloud:
    gateway:
      # 。。。
      globalcors: # 全局的跨域处理
        add-to-simple-url-handler-mapping: true # 网关特有，解决options请求被拦截问题
        corsConfigurations:
          '[/**]':
            allowedOrigins: # 允许哪些网站的跨域请求 
              - ":8090"
            allowedMethods: # 允许的跨域ajax的请求方式
              - "GET"
              - "POST"
              - "DELETE"
              - "PUT"
              - "OPTIONS"
            allowedHeaders: "*" # 允许在请求中携带的头信息
            allowCredentials: true # 是否允许携带cookie
            maxAge: 360000 # 网关特有这次跨域检测的有效期
```

再次访问：:8090/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102033689.png" alt="image-20230510203330549" style="zoom:67%;" />



## 全局异常处理

> 通过前面的测试可以看到一个现象：一旦路由的微服务下线或者失联了，Spring Cloud Gateway直接返回了一个错误页面，显然这种异常信息不友好，前后端分离架构中必须定制返回的异常信息。传统的Spring Boot 服务中都是使用**`@ControllerAdvice`**来包装全局异常处理的，但是由于服务下线，请求并没有到达。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102146142.png" alt="image-20230510214655030" style="zoom:80%;" />

> 因此必须在网关中也要定制一层全局异常处理，这样才能更加友好的和客户端交互。Spring Cloud Gateway提供了多种全局处理的方式，今天陈某只介绍其中一种方式，实现还算比较优雅。直接创建一个类`GlobalErrorExceptionHandler`，实现`ErrorWebExceptionHandler`，重写其中的`handle`方法，代码如下：
>

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class CommonResponse {
    private String code;
    private String message;
}
```

```java
@Slf4j
@Order(-1)
@Component
@RequiredArgsConstructor
public class GlobalErrorExceptionHandler implements ErrorWebExceptionHandler {

    private final ObjectMapper objectMapper;

    @SuppressWarnings({"rawtypes", "unchecked", "NullableProblems"})
    @Override
    public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
        ServerHttpResponse response = exchange.getResponse();
        if (response.isCommitted()) {
            return Mono.error(ex);
        }

        // JOSN格式返回
        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
        if (ex instanceof ResponseStatusException) {
            response.setStatusCode(((ResponseStatusException) ex).getStatus());
        }

        return response.writeWith(Mono.fromSupplier(() -> {
            DataBufferFactory bufferFactory = response.bufferFactory();
            try {
                //todo 返回响应结果，根据业务需求，自己定制
                CommonResponse resultMsg = new CommonResponse("500",ex.getMessage());
                return bufferFactory.wrap(objectMapper.writeValueAsBytes(resultMsg));
            }
            catch (JsonProcessingException e) {
                log.error("Error writing response", ex);
                return bufferFactory.wrap(new byte[0]);
            }
        }));
    }
}
```

好了，全局异常处理已经定制完成了，在测试一下，此时正常返回JSON数据了，如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305102145142.png" alt="image-20230510214517028" style="zoom:80%;" />

## 动态路由

### 1）引入nacos-config依赖

首先，在user-service服务中，引入nacos-config的客户端依赖：

```xml
<!--nacos配置管理依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

spring-cloud-dependencies 2020.0.0 版本不在默认加载bootstrap 文件，如果需要加载bootstrap 文件需手动添加依赖⭐

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
```

### 2）添加bootstrap.yaml

然后，在user-service中添加一个**bootstrap.yml**文件，这个文件是引导文件，优先级高于application.yml：如下：

```yml
spring:
  application:
    name: userservice # 服务名称
  profiles:
    active: dev #开发环境，这里是dev
  cloud:
    nacos:
      discovery:
        enabled: true
        server-addr: 127.0.0.1:8848
      config:
        file-extension: yaml # 文件后缀名
        server-addr: localhost:8848
```

application.yml对应的内容要删除，当然都可以放到bootstrap.yml

```yml
server:
  port: 10010 # 网关端口
```

这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据以下拼接作为文件id，来读取配置。

```sh
${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}
```

本例中，就是去读取`userservice-dev.yaml`：

### 3）nacos配置

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305110902273.png" alt="image-20230511090235134" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305110903519.png" alt="image-20230511090319408" style="zoom:80%;" />

到这里已经配置完成了。至于效果自己动动小手试试吧...............

访问配置：:10010/user/2

访问配置：:10010/user/1

成功访问，说明配置成功

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305110905070.png" alt="image-20230511090508951" style="zoom:80%;" />

#  链路追踪

对一次请求进行追踪，追踪其涉及的模块，数据中心，服务器。进行性能分析，异常处理等等等。



# 打包部署

## 父模块

> 无需添加maven模块

```xml
<!-- 打包方式为pom -->
<packaging>pom</packaging>
```

## 子模块

```xml
<build>
    <finalName>${project.artifactId}-${project.version}</finalName>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

## 打包部署

> 打包完成后，每一个子模块都会生成target/xxxx.jar，去把它执行了即可

```sh
java -Dfile.encoding=utf-8 -jar  xxx.jar
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305110915122.png" alt="image-20230511091547031" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305110914461.png" alt="image-20230511091458353" style="zoom:80%;" />



# 微服务技术总结

## 整体框架

![image-20211112170817974](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112170817974.png)

## 框架图

![image-20230310143552054](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303101435234.png)

## 学习路径

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208311741424.png" alt="image-20220831174139274" style="zoom:80%;" />

![image-20211112172645414](https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20211112172645414.png)



























