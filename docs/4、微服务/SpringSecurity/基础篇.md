



# 密码泄漏，不可小视⭐

> 今天，跟大家聊聊**注册和登录的原理**，主要讨论安全问题。安全是一个公司生死存亡的关键，华为和腾讯都有大量的技术人员，来保障业务的安全。
>

> 在工作中，一旦遇到了安全问题，必须立即处理，谁都担不起安全责任。安全攻防是一个动态博弈，没有攻不破的防守，也没有防不住的进攻。
>

> 而且，在面试中，安全问题也是必然会涉及到的，比如最基本的AES、RSA、TLS、HTTPS、注册登录、密码存储等知识，我们必须熟悉。
>

> 注册APP时，你填写用户名和密码，点击提交后，APP后台肯定需要“存储你的用户名和密码”，为后面的登录验证做准备。登录APP时，你输入用户名和密码，APP后台就能验证你输入的用户名和密码，与当时注册APP时的用户名和密码是否匹配。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082139797.png" alt="image-20220808213916702" style="zoom:50%;" />

那么，有没有思考过这个问题：APP后台开发的程序员GG们，能偷窥到你的密码吗？他们会盗用你的账号和密码进行登录吗？黑客攻击APP后台后，能盗用你的账号和密码吗？

显然，这是不允许的。没有办法在道德和法律的规范下严格禁止这样的行为，那就要从技术机制上禁止，要确保即使在数据库和程序代码被盗走的情况下，坏人也无法破解密码。

## 一. 密码直接明文存储

如果在APP后台数据库中直接存储用户名和密码，那么黑客可就要在睡梦中笑醒了，比如：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082142705.png" alt="image-20220808214213623" style="zoom: 67%;" />

那么，有没有网站中招呢？当然有！当年CSDN博客首当其冲，当时的声明如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082142239.png" alt="image-20220808214239143" style="zoom:67%;" />

## 二. 密码加密存储

自然地，我们想到对密码进行加密存储。不过，这种方式也挺业余的，既然能加密，就有办法解密，同样存在密码被盗的风险，如果APP后台能以某种方式还原密码，那就是流氓系统哈。

我们有这样一个常识：当用户忘记密码后，正确做法不是APP后台告诉用户密码是多少(因为APP后台压根就不应该知道用户的密码)，而应该让用户重新设置密码。回想一下，是不是如此？

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082144010.png" alt="image-20220808214404910" style="zoom:50%;" />

## 三. 密码哈希存储

哈希函数，单向散列，且几乎不冲突，故可以考虑对密码进行哈希变换后存储。

从理论上讲，即使哈希值yyyyyy被盗走，别人也难以还原成原来的abcd123了，因为哈希函数不可逆。这样貌似就实现了密码的安全存储，不过，有点太天真了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082144144.png" alt="image-20220808214459053" style="zoom:67%;" />

如果数据库和程序代码被盗，从理论上讲，难以用yyyyyy反推出密码abcd123, 但黑客可以用彩虹表攻击，分分钟就能破解出密码abcd123,  彩虹表攻击的图示如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082145585.png" alt="image-20220808214512500" style="zoom:67%;" />

我来简单解释一下：

黑客对一些常用密码进行哈希，形成一张很大的资料表，一旦黑客盗走数据库中的密码哈希值yyyyyy, 就可以在资料表中进行查找，很快能知道密码是abcd123.

这个资料表，就是所谓的彩虹表。理论上不可反解的哈希函数，被狡猾的黑客给“破解”了，并且得到了密码。所以，直接用哈希的方式存储密码，是肯定不行的。

## 四. 密码多次哈希存储

有的朋友可能觉得彩虹表能实现攻击，主要是因为只用一次哈希，那么多加几次哈希，是不是就解决问题了呢？

显然不是。多次哈希后，一旦黑客拿到你多次哈希的程序代码和数据库，便可构造多重彩虹表，分分钟破解密码:

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082146910.png" alt="image-20220808214616845" style="zoom:67%;" />

## 五. 固定盐值哈希存储

思考一下，现在的问题是，要抗彩虹表攻击，可以考虑这么做：

```apl
P = hash(user + hash(password)) 
```

此处的user就是用户名，用作盐值，增加了黑客的破解难度，因为黑客需要针对每个user做一张特定的二重彩虹表，才有可能破解。

即便如此，在攻击一些重要user时，黑客可能感觉值得尝试一下，也是能分分钟进行破解的。所以，用固定盐还是存在较大风险。

## 六. 随机盐值哈希存储

既然固定盐值不好，那就用随机盐吧，于是可以考虑这么做：

```apl
P = hash(salt + hash(password)) 
```

这个随机盐salt，需要存储在APP后台数据库中。可问题是，APP和APP后台需要使用相同的随机盐，那么APP是怎样获取APP后台的随机盐呢？

这又涉及到一系列的加密算法和秘钥管理问题，在实际系统中，有些公司就是这么做的。随机盐的引入，可以让彩虹表失效，黑客只能“望盐兴叹”。

## 七. BCrypt存储

有没有更简洁且安全的做法呢？

有！用BCrypt吧。我觉得，BCrypt这个名字不太好，应该叫bSHA，**BCrypt是一个带随机盐的哈希函数，在哈希值中，又携带了盐的信息，而且也是一种单向 Hash 加密算法，因此它不可被反向破解生成明文**。

由于计算中使用了随机盐值，并且在密文中包含了 salt 值，默认情况下每次生成的密文都是不同的。随机密文带来的好处是：避免了如果两个人或多个人的密码相同，密码加密后保存到数据库会得到相同的结果，以防破解一个就可以知道其他人的密码。

BCrypt加密后的密文结构如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082148638.png" alt="image-20220808214828573" style="zoom:67%;" />

其中密文结构为：$是分割符， 2y是BCrypt加密版本号，10 是 cost 的值（*代价因子，值越高，耗时就越长，值为10代表进行，10 轮运算的盐值，10 轮的意思是 2 的 10 次方哈希*），紧随其后的前 22 位是盐值（salt），最后的字符串就是密码的密文了。

因为 BCrypt 密文中包含盐值（salt），所以在服务端就能从客户端发送过来的哈希值中解析出 APP 端使用的随机盐值，该随机盐不需要被 APP 后台数据库存储，减少了盐值泄露的风险。

使用 BCrypt 后，注册登录的逻辑图如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082148876.png" alt="image-20220808214842773" style="zoom:67%;" />

而且，BCrypt 是一个相对较慢的哈希函数，我们可以通过调整 BCrypt 函数中的代价因子（cost）来控制函数的执行时间，比如针对 8 位密码，在代价因子为 14 的情况，执行 BCrypt 需要 1 秒左右，而 MD5 只需要 0.8 毫秒。

因为 BCrypt 很慢，所以如果黑客想要通过穷举的方式破解密码，那么那些计算机在使用大量的 BCrypt 时性能就会很差，破解的时间成本就很高了。

参考《凤凰架构》里的一个计算方式：如果我们控制 BCrypt 的执行时间大概是 0.1 秒完成一次哈希计算的话，按照 1 秒生成 10 个哈希值的速度，算完所有的 10 位大小写字母（）和数字组成的弱密码大概需要 P(62,10)/(3600×24×365)/0.1=1,237,204,169 年时间。

- P(62,10)是62取10的排列，这么多种密码，62=26*2的大小写字母+10个数字
- 3600×24×365，即 3600秒 x 24小时 x 365天

请注意，是 APP 端的 BCrypt 慢，但 APP 后台的校验并不慢，所以不会影响后台服务性能。

最后，我们需要注意的是，虽然黑客已经很难通过彩虹表来破解密码了，但是仍然有可能暴力破解密码，也就是对于同一个用户名使用常见的密码逐一尝试登录。因此，除了做好密码哈希保存的工作外，我们还要建设一套完善的安全防御机制，在感知到暴力破解危害的时候，开启短信验证、图形验证码、账号暂时锁定等防御机制来抵御暴力破解。

## 八. 扫码登录原理

在本文的最后一部分，我们来聊一下扫码登录的原理。回想一下，扫码登录是不是到处可见呢？那么，扫码登录的逻辑和流程是怎样的呢？别着急，我们一起来看看这个有趣有用的问题。

用户登录APP后，会获取登录态票据(session key, 简写为skey)，在后续操作中，不必再输入密码，APP自动携带登录态票据，此时APP后台进行登录态票据校验即可，提升了便利性。

用户登录APP后，获取到了登录态票据skey,  然后用户利用APP对网页上的二维码进行扫描，获取隐藏在二维码中的token，并把token提交到后台，下图一目了然，无需具体解释每一步。

值得注意的是，步骤6执行完后，步骤3中的轮询才会知道网页token和APP端的userID/skey在后台建立了关联，此时扫码登录成功。我曾经也设计了一个扫码登录方案，思路上大同小异。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208082149140.png" alt="image-20220808214942045" style="zoom:67%;" />

好的，本文先聊到这里了，相信大家对注册登录中的安全问题有了更深入的理解。愿工作顺利，面试也顺利。今天先这样，咱们明天见。



# 常见摘要和加密算法

> 大家都知道在支付中常常要和一些加签、验签，加密、解密打交道，今天，就给大家来盘点一下最常见的 5 种摘要和加密算法。大家平时的工作中，可能也在很多地方用到了加密、解密，比如：

> - 用户的密码不能明文存储，要存储加密后的密文
> - 用户的银行卡号、身份证号之类的敏感数据，需要加密传输
> - 还有一些重要接口，比如支付，客户端要对请求生成一个签名，服务端要对签名进行验证
> - ……

那么上面提到的这些能力，我们都可以利用哪些加密算法来实现呢？咱们接着往下看。

## 常见加密算法

> 算法整体上可以分为**不可逆加密**，以及**可逆加密**，可逆加密又可以分为**对称加密**和**非对称加密**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230625194134536.png" alt="image-20230625194134536" style="zoom:80%;" />

## 不可逆算法

> 不可逆加密的算法的加密是不可逆的，密文无法被还原成原文。散列算法，就是一种不可逆算法。散列算法中，明文通过散列算法生成散列值，散列值是长度固定的数据，和明文长度无关。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWe7PicKT63OJic1voNw9VViadVQEPk2BufYm4c4K50hwRTkU38pibJnIB5q6iaVvO5M03SX1H8lAPjPJOg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)散列算法

> 散列算法的具体实现有很多种，常见的包括MD5、SHA1、SHA-224、SHA-256等等。

> 散列算法常用于数字签名、消息认证、密码存储等场景。

> 散列算法是不需要密钥的，当然也有一些不可逆算法，需要密钥，例如HMAC算法。

### MD5

MD5，全称为“Message-Digest Algorithm 5”，翻译过来叫“信息摘要算法”。它可以将任意长度的数据通过散列算法，生成一个固定长度的散列值。MD5算法的输出长度为128位，通常用32个16进制数表示。

我们来看下MD5算法的Java代码实现：

```java
public class MD5 {
    private static final String MD5_ALGORITHM = "MD5";
    public static String encrypt(String data) throws Exception {
        // 获取MD5算法实例
        MessageDigest messageDigest = MessageDigest.getInstance(MD5_ALGORITHM);
        // 计算散列值
        byte[] digest = messageDigest.digest(data.getBytes());
        Formatter formatter = new Formatter();
        // 补齐前导0，并格式化
        for (byte b : digest) {
            formatter.format("%02x", b);
        }
        return formatter.toString();
    }

    public static void main(String[] args) throws Exception {
        String data = "Hello World";
        String encryptedData = encrypt(data);
        // 加密后的数据：b10a8db164e0754105b7a99be72e3fe5
        System.out.println("加密后的数据：" + encryptedData);
    }
}
```

> MD5有一些优点，比如计算速度快、输出长度固定、应用广泛等等。但是作为一个加密算法，它有一个天大的缺点，那就是`不安全`。MD5算法已经被攻破，而且MD5算法的输出长度有限，攻击者可以通过暴力破解或彩虹表攻击等方式，找到与原始数据相同的散列值，从而破解数据。虽然可以通过加盐，也就是对在原文里再加上一些不固定的字符串来缓解，但是完全可以用更安全的SHA系列算法替代。

### SHA-256

> SHA（Secure Hash Algorithm）系列算法是一组密码散列函数，用于将任意长度的数据映射为固定长度的散列值。SHA系列算法由美国国家安全局（NSA）于1993年设计，目前共有SHA-1、SHA-2、SHA-3三种版本。其中SHA-1系列存在缺陷，已经不再被推荐使用。

> SHA-2算法包括`SHA-224`、`SHA-256`、`SHA-384`和`SHA-512`四种散列函数，分别将任意长度的数据映射为224位、256位、384位和512位的散列值。

> 我们来看一下最常用的`SHA-256`的Java代码实现：

```java
public class SHA256 {
    private static final String SHA_256_ALGORITHM = "SHA-256";
    public static String encrypt(String data) throws Exception {
        //获取SHA-256算法实例
        MessageDigest messageDigest = MessageDigest.getInstance(SHA_256_ALGORITHM);
        //计算散列值
        byte[] digest = messageDigest.digest(data.getBytes());
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转换为15进制字符串
        for (byte b : digest) {
            stringBuilder.append(Integer.toHexString((b & 0xFF) | 0x100), 1, 3);
        }
        return stringBuilder.toString();
    }

    public static void main(String[] args) throws Exception {
        String data = "Hello World";
        String encryptedData = encrypt(data);
        System.out.println("加密后的数据：" + encryptedData);
    }
}
```

> SHA-2算法之所以比MD5强，主要有两个原因：

> - 散列值长度更长：例如SHA-256算法的散列值长度为256位，而MD5算法的散列值长度为128位，这就提高了攻击者暴力破解或者彩虹表攻击的难度。
> - 更强的碰撞抗性：SHA算法采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。

> 当然，SHA-2也不是绝对安全的，散列算法都有被暴力破解或者彩虹表攻击的风险，所以，在实际的应用中，加盐还是必不可少的。

## 对称加密算法

> 对称加密算法，使用同一个密钥进行加密和解密。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWe7PicKT63OJic1voNw9VViadVSU8CSaKmntbAyNx3XbJGk0wyWhGXibIYGv0K8YYzzjMr7RzovBicghyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)对称加密算法

> 加密和解密过程使用的是相同的密钥，因此密钥的安全性至关重要。如果密钥泄露，攻击者可以轻易地破解加密数据。常见的对称加密算法包括DES、3DES、AES等。其中，AES算法是目前使用最广泛的对称加密算法之一，具有比较高的安全性和加密效率。

### DES

> DES（Data Encryption Standard）算法是一种对称加密算法，由IBM公司于1975年研发，是最早的一种广泛应用的对称加密算法之一。DES算法使用56位密钥对数据进行加密，加密过程中使用了置换、替换、异或等运算，具有较高的安全性。我们来看下DES算法的Java代码实现：

```java
public class DES {
    private static final String DES_ALGORITHM = "DES";

    /**
     * DES加密
     * @param data 待加密的数据
     * @param key  密钥，长度必须为8位
     * @return 加密后的数据，使用Base64编码
     */
    public static String encrypt(String data, String key) throws Exception {
        // 根据密钥生成密钥规范
        KeySpec keySpec = new DESKeySpec(key.getBytes());
        // 根据密钥规范生成密钥工厂
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(DES_ALGORITHM);
        // 根据密钥工厂和密钥规范生成密钥
        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);

        // 根据加密算法获取加密器
        Cipher cipher = Cipher.getInstance(DES_ALGORITHM);
        // 初始化加密器，设置加密模式和密钥
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        // 加密数据
        byte[] encryptedData = cipher.doFinal(data.getBytes());
        // 对加密后的数据进行Base64编码
        return Base64.getEncoder().encodeToString(encryptedData);
    }

    /**
     * DES解密
     * @param encryptedData 加密后的数据，使用Base64编码
     * @param key           密钥，长度必须为8位
     * @return 解密后的数据
     */
    public static String decrypt(String encryptedData, String key) throws Exception {
        // 根据密钥生成密钥规范
        KeySpec keySpec = new DESKeySpec(key.getBytes());
        // 根据密钥规范生成密钥工厂
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(DES_ALGORITHM);
        // 根据密钥工厂和密钥规范生成密钥
        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);

        // 对加密后的数据进行Base64解码
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);
        // 根据加密算法获取解密器
        Cipher cipher = Cipher.getInstance(DES_ALGORITHM);
        // 初始化解密器，设置解密模式和密钥
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        // 解密数据
        byte[] decryptedData = cipher.doFinal(decodedData);
        // 将解密后的数据转换为字符串
        return new String(decryptedData);
    }

    public static void main(String[] args) throws Exception {
        String data = "Hello World";
        String key = "12345678"; 

        String encryptedData = encrypt(data, key);
        System.out.println("加密后的数据：" + encryptedData);

        String decryptedData = decrypt(encryptedData, key);
        System.out.println("解密后的数据：" + decryptedData);
    }
}
```

> DES的算法速度较快，但是在安全性上面并不是最优选择，因为DES算法的密钥长度比较短，被暴力破解和差分攻击的风险比较高，一般推荐用一些更安全的对称加密算法，比如3DES、AES。

### AES

> AES（Advanced Encryption Standard）即高级加密标准，是一种对称加密算法，被广泛应用于数据加密和保护领域。AES算法使用的密钥长度为128位、192位或256位，比DES算法的密钥长度更长，安全性更高。我们来看下AES算法的Java代码实现：

```java
public class AES {
    private static final String AES_ALGORITHM = "AES";
    // AES加密模式为CBC，填充方式为PKCS5Padding
    private static final String AES_TRANSFORMATION = "AES/CBC/PKCS5Padding";
    // AES密钥为16位
    private static final String AES_KEY = "1234567890123456";
    // AES初始化向量为16位
    private static final String AES_IV = "abcdefghijklmnop";

    /**
     * AES加密
     *
     * @param data 待加密的数据
     * @return 加密后的数据，使用Base64编码
     */
    public static String encrypt(String data) throws Exception {
        // 将AES密钥转换为SecretKeySpec对象
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(), AES_ALGORITHM);
        // 将AES初始化向量转换为IvParameterSpec对象
        IvParameterSpec ivParameterSpec = new IvParameterSpec(AES_IV.getBytes());
        // 根据加密算法获取加密器
        Cipher cipher = Cipher.getInstance(AES_TRANSFORMATION);
        // 初始化加密器，设置加密模式、密钥和初始化向量
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        // 加密数据
        byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
        // 对加密后的数据使用Base64编码
        return Base64.getEncoder().encodeToString(encryptedData);
    }

    /**
     * AES解密
     *
     * @param encryptedData 加密后的数据，使用Base64编码
     * @return 解密后的数据
     */
    public static String decrypt(String encryptedData) throws Exception {
        // 将AES密钥转换为SecretKeySpec对象
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(), AES_ALGORITHM);
        // 将AES初始化向量转换为IvParameterSpec对象
        IvParameterSpec ivParameterSpec = new IvParameterSpec(AES_IV.getBytes());
        // 根据加密算法获取解密器
        Cipher cipher = Cipher.getInstance(AES_TRANSFORMATION);
        // 初始化解密器，设置解密模式、密钥和初始化向量
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
        // 对加密后的数据使用Base64解码
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);
        // 解密数据
        byte[] decryptedData = cipher.doFinal(decodedData);
        // 返回解密后的数据
        return new String(decryptedData, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) throws Exception {
        String data = "Hello World";

        String encryptedData = encrypt(data);
        System.out.println("加密后的数据：" + encryptedData);

        String decryptedData = decrypt(encryptedData);
        System.out.println("解密后的数据：" + decryptedData);
    }
}
```

> AES算法采用的密钥长度更长，密钥空间更大，安全性更高，能够有效地抵抗暴力破解攻击。当然，因为密钥长度较长，需要的存储也更多。对于对称加密算法而言，最大的痛点就在于密钥管理困难，相比而言，非对称加密就没有这个担忧。

## 非对称加密算法

> 非对称加密算法需要两个密钥，这两个密钥互不相同，但是相互匹配，一个称为**公钥**，另一个称为**私钥**。使用其中的一个加密，则使用另一个进行解密。例如使用公钥加密，则需要使用私钥解密。

> ![图片](https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWe7PicKT63OJic1voNw9VViadV1JeLsCnAFseuLU0gA0A58tNZOKMUBZQsEaYFk6iaERjPMdzyo7HLicsw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)公钥加密，私钥解密

### RSA

> RSA算法是是目前应用最广泛的非对称加密算法，由Ron Rivest、Adi Shamir和Leonard Adleman三人在1978年发明，名字来源三人的姓氏首字母。我们看下RSA算法的Java实现：

```java
public class RSA {
    private static final String RSA_ALGORITHM = "RSA";

    /**
     * 生成RSA密钥对
     *
     * @return RSA密钥对
     */
    public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(RSA_ALGORITHM);
        keyPairGenerator.initialize(2048); // 密钥大小为2048位
        return keyPairGenerator.generateKeyPair();
    }

    /**
     * 使用公钥加密数据
     *
     * @param data      待加密的数据
     * @param publicKey 公钥
     * @return 加密后的数据
     */
    public static String encrypt(String data, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encryptedData);
    }

    /**
     * 使用私钥解密数据
     *
     * @param encryptedData 加密后的数据
     * @param privateKey    私钥
     * @return 解密后的数据
     */
    public static String decrypt(String encryptedData, PrivateKey privateKey) throws 
    Exception {
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] decryptedData = cipher.doFinal(decodedData);
        return new String(decryptedData, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) throws Exception {
        KeyPair keyPair = generateKeyPair();
        PublicKey publicKey = keyPair.getPublic();
        PrivateKey privateKey = keyPair.getPrivate();

        String data = "Hello World";

        String encryptedData = encrypt(data, publicKey);
        System.out.println("加密后的数据：" + encryptedData);

        String decryptedData = decrypt(encryptedData, privateKey);
        System.out.println("解密后的数据：" + decryptedData);
    }
}
```

> RSA算法的优点是安全性高，公钥可以公开，私钥必须保密，保证了数据的安全性；可用于数字签名、密钥协商等多种应用场景。缺点是加密、解密速度较慢，密钥长度越长，加密、解密时间越长；密钥长度过短容易被暴力破解，密钥长度过长则会增加计算量和存储空间的开销。

> 这一期就给大家简单盘点了一下最常用的5种加密算法。其实，论到加密解密算法的应用，有一个东西，可以说是应用到了极致，它是什么呢？

—— **HTTPS**

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWe7PicKT63OJic1voNw9VViadVjszAvRmtQSibgN1F7X43WYsu64zZvEMIgKx0fxDeWEicJIQ9z2iaqAlog/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)https工作流程详图

我们简单回忆一下HTTPS的工作流程，和用到的加密算法：

1. 客户端发起HTTPS请求：用户使用浏览器输入网址访问HTTPS站点，准备发起HTTPS请求

2. 服务端提供证书：服务器返回公钥证书，证书包含了服务器的公钥、颁发者（证书颁发机构）等信息

3. 客户端验证证书：浏览器验证证书的有效性、合法性、来源等，校验证书的过程用到了**非对称加密**和**散列算法**

4. - 客户端使用证书颁发机构的**公钥**对证书进行验证，保证证书的真实性和合法性
   - 客户端使用证书中的**公钥**对服务端的数字签名进行验证，保证服务器的身份和数据的完整性。
   - 客户端使用**散列算法**计算出散列值，和证书中的散列值进行对比，保证证书的完整性

5. 客户端生成对称密钥：客户端生成一个随机数，作为对称密钥

6. 对称密钥加密传输：客户端使用服务器的**公钥**对随机数进行加密，然后将加密后的信息传输给服务器

7. 服务端获取对称密钥：服务端使用**私钥**解密客户端发送的对称密钥，得到对称密钥

8. 客户端与服务器使用**对称密钥**进行通信：服务器与浏览器都使用对称密钥对数据进行加密和解密，以此确保数据传输的安全性。

在数据传输的过程中，也用到了散列算法：

- 消息摘要：在数据传输过程中，客户端和服务器都使用**散列算法**计算消息的散列值，对方收到消息后，会对散列值进行比较，确保传输数据的完整性。

> 总之，HTTPS使用了对称加密算法、非对称加密算法、散列算法来保证数据的安全性和完整性，从而确保了通信双方的身份和数据的安全。

> 至于具体使用哪些加密算法，取决于SSL/TLS协议的版本以及协商过程中选定的加密套件。在实际的网络环境中，很多加密算法可能会被淘汰，以适应更高安全性的需要。在我们的日常开发中，也可以借鉴相应的思路，灵活运用各种加密算法，让我们的应用更加安全、更加健壮。

# SpringSecurity框架

[Spring Security 最佳实践，看了必懂！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&mid=2247510150&idx=1&sn=6e4eb215e43d8c903e63a0cc4554b705&chksm=fd577800ca20f116b9bc68ccc0742f5d70a6e61260cc59b11f988b2e96a996fbc13ac95c1299&mpshare=1&scene=23&srcid=1114IivNZfIeRfr7cIqwz411&sharer_sharetime=1668356767605&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 认证&授权 

Spring 是非常流行和成功的 Java 应用开发框架，Spring Security 正是 Spring 家族中的 成员。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。 

> 关于安全方面的两个主要区域是“认证”和“授权”（或者访问控制），一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权 （Authorization）两个部分，这也是 Spring Security 重要核心功能
>

> 用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问 该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认 证过程。通俗点说就是系统认为用户是否能登录

> 用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户 所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以 进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的 权限。通俗点讲就是系统判断用户是否有权限去做某些事情

## 历史

“Spring Security 开始于 2003 年年底,““spring 的 acegi 安全系统”。 起因是 Spring 开发者邮件列表中的一个问题,有人提问是否考虑提供一个基于 spring 的安全实现。

> Spring Security 以“The Acegi Secutity System for Spring” 的名字始于 2013 年晚些 时候。一个问题提交到 Spring 开发者的邮件列表，询问是否已经有考虑一个机遇 Spring  的安全性社区实现。那时候 Spring 的社区相对较小（相对现在）。实际上 Spring 自己在 2013 年只是一个存在于 ScourseForge 的项目，这个问题的回答是一个值得研究的领 域，虽然目前时间的缺乏组织了我们对它的探索。 
>

> 考虑到这一点，一个简单的安全实现建成但是并没有发布。几周后，Spring 社区的其他成员询问了安全性，这次这个代码被发送给他们。其他几个请求也跟随而来。到 2014 年一 月大约有 20 万人使用了这个代码。这些创业者的人提出一个 SourceForge 项目加入是为 了，这是在 2004 三月正式成立。 
>

> 在早些时候，这个项目没有任何自己的验证模块，身份验证过程依赖于容器管理的安全性 和 Acegi 安全性。而不是专注于授权。开始的时候这很适合，但是越来越多的用户请求额 外的容器支持。容器特定的认证领域接口的基本限制变得清晰。还有一个相关的问题增加 新的容器的路径，这是最终用户的困惑和错误配置的常见问题。 
>

Acegi 安全特定的认证服务介绍。大约一年后，Acegi 安全正式成为了 Spring 框架的子项 目。1.0.0 最终版本是出版于 2006 -在超过两年半的大量生产的软件项目和数以百计的改 进和积极利用社区的贡献。 

Acegi 安全 2007 年底正式成为了 Spring 组合项目，更名为"Spring Security"。

## 同款产品对比 

Spring Security Spring 技术栈的组成部分

通过提供完整可扩展的认证和授权支持保护你的应用程序。 https://spring.io/projects/spring-security 

SpringSecurity 本质是一个过滤器链： 从启动是可以获取到过滤器链：super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。 ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常UsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码

SpringSecurity 特点： 

- 和 Spring 无缝整合。 
- 全面的权限控制。 
- 专门为 Web 开发而设计。 
- 旧版本不能脱离 Web 环境使用。 
- 新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境。 
- 重量级

## SpringSecurity拦截器

SpringSecurity有很多很多的拦截器，在执行流程里面主要有两个核心的拦截器

> 1，登陆验证拦截器**AuthenticationProcessingFilter**
>
> 2，资源管理拦截器**AbstractSecurityInterceptor**

但拦截器里面的实现需要一些组件来实现，所以就有了**AuthenticationManager**认证管理器accessDecisionManager决策管理器等组件来支撑。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305231055120.png" alt="image-20230523105554016" style="zoom:80%;" />

> FilterChainProxy是一个代理，真正起作用的是各个Filter，这些Filter作为Bean被Spring管理，是Spring Security核心，各有各的职责，不直接处理认证和授权，交由认证管理器和决策管理器处理！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305231056289.png" alt="image-20230523105647184" style="zoom:80%;" />

> 1、用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到， 封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。

> 2、然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证 。

> 3、认证成功后， AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息， 身份信息，细节信息，但密码通常会被移除） Authentication 实例。

> 4、SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。 可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它 的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个List 列表，存放多种认证方式，最终实际的认证工作是由 AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为 DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终 AuthenticationProvider将UserDetails填充至Authentication。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305231057391.png" alt="image-20230523105759293" style="zoom:80%;" />

> 访问资源（即授权管理），访问url时，会通过FilterSecurityInterceptor拦截器拦截，其中会调用SecurityMetadataSource的方法来获取被拦截url所需的全部权限，再调用授权管理器AccessDecisionManager，这个授权管理器会通过spring的全局缓存SecurityContextHolder获取用户的权限信息，还会获取被拦截的url和被拦截url所需的全部权限，然后根据所配的投票策略（有：一票决定，一票否定，少数服从多数等），如果权限足够，则决策通过，返回访问资源，请求放行，否则跳转到403页面、自定义页面。

转载自：https://blog.csdn.net/weixin_51542566/article/details/119705963

# 初体验

[Spring Security 最佳实践，看了必懂](https://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&mid=2247510150&idx=1&sn=6e4eb215e43d8c903e63a0cc4554b705&chksm=fd577800ca20f116b9bc68ccc0742f5d70a6e61260cc59b11f988b2e96a996fbc13ac95c1299&mpshare=1&scene=23&srcid=1114IivNZfIeRfr7cIqwz411&sharer_sharetime=1668356767605&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 项目搭建

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305201653013.png" alt="image-20230520165325900" style="zoom:80%;" />

## 坐标依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

## 配置接口

```java
@RestController
public class HelloController {

    @GetMapping("say")
    public String say() {
        return "你好，世界";
    }
}
```

## 访问测试

导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。在浏览器输入：:8080/say 进入Spring Security内置登录页面

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208290919260.png" alt="image-20220829091945032" style="zoom:67%;" />

> 默认的用户名：user 
>
> 密码在项目启动的时候在控制台会打印，注意每次启动的时候密码都回发生变化！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212130934327.png" alt="image-20221213093425197" style="zoom:80%;" />

输入用户名，密码，这样表示可以访问了，404 表示我们没有这个控制器，但是我们可以访问了

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305201703793.png" alt="image-20230520170320540" style="zoom:80%;" />



# 基本原理

![image-20221213094605791](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212130946945.png)

> **SpringSecurity 本质是一个过滤器链：从启动是可以获取到过滤器链：**

```sh
org.....web.context.request.async.WebAsyncManagerIntegrationFilter
org.springframework.security.web.context.SecurityContextPersistenceFilter 
org.springframework.security.web.header.HeaderWriterFilter
org.springframework.security.web.csrf.CsrfFilter
org.springframework.security.web.authentication.logout.LogoutFilter 
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter 
org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter 
org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter
org.springframework.security.web.savedrequest.RequestCacheAwareFilter
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter
org.springframework.security.web.authentication.AnonymousAuthenticationFilter 
org.springframework.security.web.session.SessionManagementFilter 
org.springframework.security.web.access.ExceptionTranslationFilter 
org.springframework.security.web.access.intercept.FilterSecurityInterceptor
```

代码底层流程：重点看三个过滤器：

> **FilterSecurityInterceptor**：是一个方法级的权限过滤器, 基本位于过滤链的最底部。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212130942969.png" alt="image-20221213094232897" style="zoom:80%;" />

> super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。
>
> fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。
>
> ExceptionTranslationFilter：是个异常过滤器，用来处理在认证授权过程中抛出的异常

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212130942676.png" alt="image-20221213094259599" style="zoom:80%;" />

UsernamePasswordAuthenticationFilter ：对/login 的 POST 请求做拦截，校验表单中用户名，密码。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212130943358.png" alt="image-20221213094325273" style="zoom:80%;" />



# 两个重要接口⭐

> **UserDetailsService**：**查询数据库用户名和密码过程**
>
> **创建类继承UsernamePasswordAuthenticationFilter，重写三个方法。创建类实现UserDetailService，编写查询数据过程，返回User对象，这个User对象是安全框架提供对象**

> **PasswordEncoder**：数据加密接口，用于返回User对象里面的密码加密

## UserDetailsService 接口

### 接口概述

> **当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的**。而**在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑**。 

如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：

> **方法参数 username 表示用户名，此值是客户端表单传递过来的数据**。
>
> **表单传递过来的数据默认情况下必须叫 username，否则无法接收**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208292221674.png" alt="image-20220829222125585" style="zoom:80%;" />

```java
@Component
public class UserSecurity implements UserDetailsService {

    @Autowired
    private UserService userService;

    @Override
    public UserDetails loadUserByUsername(String userName) throws 
        UsernameNotFoundException {
        User user = userService.login(userName);
        System.out.println(user);
        if (null==user){
            throw new UsernameNotFoundException("用户名错误");
        }
        org.springframework.security.core.userdetails.User result =
                new org.springframework.security.core.userdetails.User(
                        userName,user.getPassword(), AuthorityUtils.createAuthorityList()
                );
        return result;
    }
}
```

### 返回值 UserDetails  

这个类是系统默认的用户“主体”

```java
// 表示获取登录用户所有权限
Collection<? extends GrantedAuthority> getAuthorities();
// 表示获取密码
String getPassword();
// 表示获取用户名
String getUsername();
// 表示判断账户是否过期
boolean isAccountNonExpired();
// 表示判断账户是否被锁定
boolean isAccountNonLocked();
// 表示凭证{密码}是否过期
boolean isCredentialsNonExpired();
// 表示当前用户是否可用
boolean isEnabled();
```

以下是 UserDetails 实现类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208292257651.png" alt="image-20220829225701561" style="zoom:80%;" />

以后我们只需要使用 User 这个实体类即可！



## PasswordEncoder 接口

> 在Spring Security中，我们现在是用一种自适应单向函数（Adaptive One-way Functions）来处理密码问题，这种自适应单向函数在进行密码匹配时，会有意占用大量系统资源（例如CPU、内存等），这样可以增加恶意用户攻击系统的难度。在Spring Security中，开发者可以通过bcrypt、PBKDF2、scrypt以及argon2来体验这种自适应单向函数加密。

> **PasswordEncoder** 是SpringSecurity 的密码解析器，用户密码校验、加密 。自定义登录逻辑时要求必须给容器注入PaswordEncoder的bean对象。SpringSecurity 定义了很多实现接口**PasswordEncoder** 满足我们密码加密、密码校验 使用需求。

> 由于自适应单向函数有意占用大量系统资源，因此每个登录认证请求都会大大降低应用程序的性能，但是Spring Security不会采取任何措施来提高密码验证速度，因为它正是通过这种方式来增强系统的安全性。当然，开发者也可以将用户名/密码这种长期凭证兑换为短期凭证，如会话、OAuth2令牌等，这样既可以快速验证用户凭证信息，又不会损失系统的安全性。
>

### 接口概述

> **「PasswordEncoder」** 是SpringSecurity 的密码解析器，用户密码校验、加密 。自定义登录逻辑时要求必须给容器注入PaswordEncoder的bean对象。SpringSecurity 定义了很多实现接口**「PasswordEncoder」** 满足我们密码加密、密码校验 使用需求。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208290950404.png" alt="image-20220829095032348" style="zoom: 80%;" />

**方法描述**

```java
// 表示把参数按照特定的解析规则进行解析
String encode(CharSequence rawPassword);
// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹  配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。
boolean matches(CharSequence rawPassword, String encodedPassword);
// 是否还要进行再次加密，这个一般来说就不用了
default boolean upgradeEncoding(String encodedPassword)
```

**在配置类中指定自定义密码凭证匹配器**

```java
/**
  * 加密
  * @return 加密对象
  * 如需使用自定义密码凭证匹配器 返回自定义加密对象
  * 例如: return new MD5PasswordEncoder(); 
  */
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(); //Spring Security 自带
}
```

### PasswordEncoder常见实现类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305202007375.png" alt="image-20230520200706106" style="zoom:80%;" />

> Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，它使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。
>

> 不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。

> idea按ctrl+h查看所有实现类

#### BCryptPasswordEncoder

> BCryptPasswordEncoder使用bcrypt算法对密码进行加密，为了提高密码的安全性，bcrypt算法故意降低运行速度，以增强密码破解的难度。同时BCryptPasswordEncoder “为自己带盐”，开发者不需要额外维护一个“盐”字段，使用BCryptPasswordEncoder加密后的字符串就已经“带盐”了，即使相同的明文每次生成的加密字符串都不相同。

> BCryptPasswordEncoder的默认强度为10，开发者可以根据自己的服务器性能进行调整，以确保密码验证时间约为1秒钟（官方建议密码验证时间为1秒钟，这样既可以提高系统安全性，又不会过多影响系统运行性能）。

#### Argon2PasswordEncoder

> Argon2PasswordEncoder使用Argon2算法对密码进行加密，Argon2曾在Password Hashing Competition竞赛中获胜。为了解决在定制硬件上密码容易被破解的问题，Argon2也是故意降低运算速度，同时需要大量内存，以确保系统的安全性。

#### Pbkdf2PasswordEncoder

> Pbkdf2PasswordEncoder使用PBKDF2算法对密码进行加密，和前面几种类似，PBKDF2算法也是一种故意降低运算速度的算法，当需要FIPS（Federal Information Processing Standard，美国联邦信息处理标准）认证时，PBKDF2算法是一个很好的选择。

#### SCryptPasswordEncoder

> SCryptPasswordEncoder使用scrypt算法对密码进行加密，和前面的几种类似，scrypt也是一种故意降低运算速度的算法，而且需要大量内存。

> 这四种就是我们前面所说的自适应单向函数加密。除了这几种，还有一些基于消息摘要算法的加密方案，这些方案都已经不再安全，但是出于兼容性考虑，Spring Security并未移除相关类，主要有LdapShaPasswordEncoder、MessageDigestPasswordEncoder、Md4Password Encoder、StandardPasswordEncoder以及NoOpPasswordEncoder（密码明文存储），这五种皆已废弃，这里对这些类也不做过多介绍。

除了上面介绍的这几种之外，还有一个非常重要的密码加密工具类，那就是DelegatingPasswordEncoder。

#### DelegatingPasswordEncoder

> 根据前文的介绍，读者可能会认为Spring Security中默认的密码加密方案应该是四种自适应单向加密函数中的一种，其实不然，在Spring Security 5.0之后，默认的密码加密方案其实是这个。
>

从名字上来看，DelegatingPasswordEncoder是一个代理类，而并非一种全新的密码加密方案。

> DelegatingPasswordEncoder主要用来代理上面介绍的不同的密码加密方案。为什么采用它而不是某一个具体加密方式作为默认的密码加密方案呢？主要考虑了如下三方面的因素：

> 1. 兼容性：使用DelegatingPasswordEncoder可以帮助许多使用旧密码加密方式的系统顺利迁移到Spring Security中，它允许在同一个系统中同时存在多种不同的密码加密方案。
> 2. 便捷性：密码存储的最佳方案不可能一直不变，如果使用DelegatingPasswordEncoder作为默认的密码加密方案，当需要修改加密方案时，只需要修改很小一部分代码就可以实现。
> 3. 稳定性：作为一个框架，Spring Security不能经常进行重大更改，而使用Delegating PasswordEncoder可以方便地对密码进行升级（自动从一个加密方案升级到另外一个加密方案）

### 加密演示

```java
@Test
public void test01(){
    // 创建密码解析器
    BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
    // 对密码进行加密
    String atguigu = bCryptPasswordEncoder.encode("atguigu");
    // 打印加密之后的数据
    System.out.println("加密之后数据："+atguigu);
    //判断原字符加密后和加密之前是否匹配
    boolean result = bCryptPasswordEncoder.matches("atguigu", atguigu);
    // 打印比较结果
    System.out.println("比较结果："+result);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208290940288.png" alt="image-20220829094009227" style="zoom:80%;" />

### 自定义密码解析器

1. 编写类，实现PasswordEncoder 接口

```java
/**
 * 凭证匹配器，用于做认证流程的凭证校验使用的类型
 * 其中有2个核心方法
 * 1. encode - 把明文密码，加密成密文密码
 * 2. matches - 校验明文和密文是否匹配
 * */
public class MyMD5PasswordEncoder implements PasswordEncoder {

    /**
     * 加密
     * @param charSequence  明文字符串
     * @return
     */
    @Override
    public String encode(CharSequence charSequence) {
        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            return toHexString(digest.digest(charSequence.toString().getBytes()));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return "";
        }
    }

    /**
     * 密码校验
     * @param charSequence 明文，页面收集密码
     * @param s 密文 ，数据库中存放密码
     * @return
     */
    @Override
    public boolean matches(CharSequence charSequence, String s) {
        return s.equals(encode(charSequence));
    }

     /**
     * @param tmp 转16进制字节数组
     * @return 饭回16进制字符串
     */
    private String toHexString(byte [] tmp){
        StringBuilder builder = new StringBuilder();
        for (byte b :tmp){
            String s = Integer.toHexString(b & 0xFF);
            if (s.length()==1){
                builder.append("0");
            }
            builder.append(s);
        }

        return builder.toString();
    }
}
```





# 用户认证⭐

## 自定义登录账号、密码⭐

> 三种方式

### 配置文件

静态用户，一般只在内部网络认证中使用，如：内部服务器1，访问服务器2

```properties
# 设置静态用户名
spring.security.user.name=atguigu
# 设置静态登录密码
spring.security.user.password=atguigu
```

### 配置类

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        String password = passwordEncoder.encode("123");
        // 在内存中设置用户名，加密后的密码，角色
        auth.inMemoryAuthentication().withUser("renshuo")
            .password(password).roles("admin");
    }
	// PasswordEncoder需要注入bean
    @Bean
    PasswordEncoder password() {
        return new BCryptPasswordEncoder();
    }
}
```

### 数据库⭐

> 什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过**「自定义逻辑控制认证逻辑」**。如果需要自定义逻辑时，只需要实现UserDetailsService接口
>

> 创建配置类，设置使用哪个userDetailsService实现类
>
> 编写实现类，返回User对象，User对象有用户名密码和操作权限

#### 数据库表

```sql
create database security1;
use security1;
create table user (
	id int primary key auto_increment,
	name varchar(100),
	password varchar(100)
)

insert into user values(null,'zhangsan','123');
```

#### 依赖配置

```xml
<!--lombok依赖-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
<!--mysql依赖-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
<!--mybatis-plus依赖-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.2</version>
</dependency>
```

> application-a.yml

```yml
# mysql数据库连接
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 如果出问题再加时区：&serverTimezone=GMT%2B8
    url: jdbc:mysql://localhost:3306/security1?characterEncoding=UTF-8
    username: root
    password: 123456
#mybatisPlus日志，可以在控制台查看具体的sql执行语句
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
server:
  port: 8800
```

```properties
spring.profiles.active=a
```

#### 实体类

```java
@Data
public class user {
    private int id;
    private String name;
    private String password;
}
```

```java
@Mapper
public interface userMapper extends BaseMapper<user> {
}
```

#### SecurityConfig

> 将 UserDetailsService 查询到的用户名和密码和传入得值进行比对，返回验证结果
>
> 这个类是固定内容，无需做出改变

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // 1 注入UserDetailsService
    @Resource
    private UserDetailsService userDetailsService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 2 使用 UserDetailsService 和 使用密码 password()验证
        auth.userDetailsService(userDetailsService).passwordEncoder(password());
    }

    @Bean
    PasswordEncoder password() {
        return new BCryptPasswordEncoder();
    }
}
```

#### MyUserDetailService

> 通过UserDetailsService 获取数据库中查询得用户名和密码

```java
@Service
public class MyUserDetailService implements UserDetailsService {
    // 注入mybatisPlus mapper
    @Resource
    private userMapper userMapper;

    // 传入的参数表示用户名，它是根据用户名进行查询用户是否存在
    @Override
    public UserDetails loadUserByUsername(String username) throws 
        UsernameNotFoundException {
        // 根据用户名查询,注意，用户名要求唯一不重复，因此只查一条
        user users = userMapper.selectOne(new LambdaQueryWrapper<user>().
                                              eq(user::getName, username));
        // 判断，数据库没有查到用户名，认证失败
        if (users == null) {
            throw new UsernameNotFoundException("用户名不存在！");
        }
        // 这里是设置角色，目前没用到，但还是得写，因为不能为空
        List<GrantedAuthority> auths = AuthorityUtils
                                       .commaSeparatedStringToAuthorityList("role");
        // 从查询数据库返回users对象，得到数据库查询得用户名和密码，返回
        return new User(users.getName(),new BCryptPasswordEncoder()
                             .encode(users.getPassword()),auths);
    }
}
```

#### 访问测试

```java
@RestController
public class HelloController {

    @GetMapping("say")
    public String say() {
        return "你好，世界";
    }
}
```

访问：:8080/say 输入用户名 zhangsan ， 密码 123

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131040775.png" alt="image-20221213104003708" style="zoom:80%;" />



## 密码保存⭐

> 前面的用户密码都是手动添加的，所以数据库中是明文显示，在实际开发中，都是需要加密保存的。
>
> 在上面基于数据库的登录基础上，进行密码保存和密码修改等操作

```java
//插入数据时密码加密
//如果各种导包都没有问题，还有一种可能的错误是，BCryptPasswordEncoder被注入了两次，
//在前面加上注解@Lazy
@Lazy
@Resource
private PasswordEncoder passwordEncoder;
// 注入mapper用来保存数据
@Resource
private userMapper userMapper;

@PostMapping("insertOne")
public void insertOne(@RequestBody user u) {
    // 加密密码
    // 方式一：u.setPassword(new BCryptPasswordEncoder().encode(u.getPassword()));
    // 方式二
    u.setPassword(passwordEncoder.encode(u.getPassword()));
    userMapper.insert(u);
}
```

> 为了方便测试，这里放开插入时要登录的权限，在SecurityConfig类中
>

```java
// 这些路径不用认证可以直接访问
.antMatchers("/","/user/login","/user/insertOne").permitAll()
```

这样进行保存的时候，密码就进行加密了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211415988.png" alt="image-20230521141522899" style="zoom:80%;" />

> 使用加密密码登录，需要修改MyUserDetailsService类，之前从数据库拿到明文密码后需要加密，现在数据库里面的密码已经加密了，就不用加密了。前面已经配置过了，如下：
>

```java
// 这里将获取到的用户名密码进行校验
// 因为之前数据库是明文，所以这里需加密密码
// new BCryptPasswordEncoder().encode(users.getPassword())
// 现在已经配置了密码加密了，所以要将参数二变成正常获取密码
return new User(users.getName(),users.getPassword(),auths);
```

进行登录测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211417497.png" alt="image-20230521141714441" style="zoom:80%;" />

## 密码修改⭐

```java
@Data
public class userVo {
    private Integer id;
    private String oldPwd;
    private String newPwd;
}
```

```java
@PutMapping("updateOne")
public String updateOne(@RequestBody userVo u) {
    // 从数据库中获取用户信息
    user user = userMapper.selectById(u.getId());
    // 判断输入的旧密码是正确，u.getOldPwd()是输入的旧密码
    if (passwordEncoder.matches(u.getOldPwd(), user.getPassword())) {
        // 密码加密
        user.setPassword(passwordEncoder.encode(u.getNewPwd()));
        // 不要忘记加密新密码
        int i = userMapper.updateById(user);
        if (i == 1) {
            return "更新成功";
        } else {
            return "更新失败";
        }
    }
    return "旧密码和新密码不匹配";
}
```

> 别忘了将/user/updateOne添加到不拦截路径

```java
.antMatchers("/","/user/hello","/user/login","/user/insertOne","/user/updateOne")
.permitAll()
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211442202.png" alt="image-20230521144250133" style="zoom:80%;" />

启动后，进行登录，发现密码已经修改



## 配置参数详解⭐

> 在SecurityConfig类中进行配置

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
        // 配置登录请求相关内容。
        http.formLogin()
            .loginPage("/toLogin") // 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login
            .usernameParameter("name") // 设置请求参数中，用户名参数名称。 默认username
            .passwordParameter("pswd") // 设置请求参数中，密码参数名称。 默认password
            .loginProcessingUrl("/login") //设置登录 提交表单数据访问请求地址
            .defaultSuccessUrl("/toMain")   
            .failureUrl("/toLogin");
            //.successForwardUrl("/toMain")
            // 登录失败后，请求转发的位置。转发使用Post请求。默认转发到：loginPage?error
            .failureForwardUrl("/toLogin");
            //.successHandler(new LoginSuccessHandler("/toMain", true))//自定义登录成功处理
            //.failureHandler(new LoginErrorHandler("/toLogin", true));

        http.authorizeRequests()
            //.antMatchers("/toLogin").anonymous() //只能匿名用户访问
            // /toLogin请求地址，可以随便访问。
            .antMatchers("/toLogin", "/register", "/login", "/favicon.ico").permitAll() 
            .antMatchers("/**/*.js").permitAll() // 授予所有目录下的所有.js文件可访问权限
            .regexMatchers(".*[.]css").permitAll() // 授予所有目录下的所有.css文件可访问权限
            .anyRequest().authenticated(); // 任意的请求，都必须认证后才能访问。


        // 配置退出登录
        http.logout()
            // 回收HttpSession对象。退出之前调用HttpSession.invalidate() 默认 true
            .invalidateHttpSession(true) 
            .clearAuthentication(true) // 退出之前，清空Security记录的用户登录标记。 默认 true
            // .addLogoutHandler() // 增加退出处理器。
            .logoutSuccessUrl("/") // 配置退出后，进入的请求地址。 默认是loginPage?logout
            .logoutUrl("/logout"); // 配置退出登录的路径地址。和页面请求地址一致即可。
        // 关闭CSRF安全协议。
        // 关闭是为了保证完整流程的可用。
        http.csrf().disable();
}
```

> 下面我们进行实战测试

## 实战演练

### 依赖坐标

```xml
<dependencies>
    <!--web依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--security依赖-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!--lombok依赖-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    <!--mysql依赖-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <!--mybatis-plus依赖-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.2</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

```yml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/security1?characterEncoding=UTF-8
    username: root
    password: 123456
#mybatisPlus日志，可以在控制台查看具体的sql执行语句
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
server:
  port: 8800
```

### 实体类

```java
@Data
public class user {
    private int id;
    private String name;
    private String password;
}
```

```java
@Mapper
public interface userMapper extends BaseMapper<user> {
}
```

### UserDetailService⭐

```java
@Service
public class MyUserDetailService implements UserDetailsService {
    // 注入mybatisPlus mapper
    @Resource
    private userMapper userMapper;

    // 传入的参数表示用户名，它是根据用户名进行查询用户是否存在
    @Override
    public UserDetails loadUserByUsername(String username) throws
            UsernameNotFoundException {
        // 根据用户名查询
        user users = userMapper.selectOne(new LambdaQueryWrapper<user>().
                eq(user::getName, username));
        // 判断，数据库没有用户名，认证失败
        if (users == null) {
            throw new UsernameNotFoundException("用户名不存在！");
        }
        // 这里是设置角色，目前没用到，但还是得写，因为不能为空
        List<GrantedAuthority> auths = AuthorityUtils
                .commaSeparatedStringToAuthorityList("role");
        // 从查询数据库返回users对象，得到数据库查询得用户名和密码，返回
        return new User(users.getName(),new BCryptPasswordEncoder()
                .encode(users.getPassword()),auths);
    }
}
```

### SecurityConfig⭐

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // 注入UserDetailsService
    @Resource
    private UserDetailsService userDetailsService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(password());
    }
    
    @Bean
    PasswordEncoder password() {
        return new BCryptPasswordEncoder();
    }
    
    // 自定义登录页面配置项
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //自定义自己编写的登录页面
            // 登陆页面地址，可以是前端vue页面地址，直接写前端登录地址就行：如
            .loginPage("/login.html") 
            // 登录页面点击登录后访问路径，表单提交处理等操作。这个操作无需自己写， 
            // 是Spring Security自己执行的，只需把form的action设置成该路径即可
            .loginProcessingUrl("/user/login")
            // 登录成功之后跳转路径
            .defaultSuccessUrl("/user/index").permitAll() 
            // 定义哪些路径拦截还是不拦截
            .and().authorizeRequests() 
                // antMatchers哪些路径可直接访问，不用认证
                .antMatchers("/","/user/hello","/user/login").permitAll() 
                .anyRequest().authenticated() // 所有请求都要被认证
                .and().csrf().disable(); // 关闭csrf防护
    }
}
```



### login.html

> 在resource/static目录下新建login.html,页面提交方式必须为 post 请求
>

> 原因： 在执行登录的时候会走一个过滤器 UsernamePasswordAuthenticationFilter
>
> **用户名，密码必须为 username,password，不然Spring Seurity获取不到用户名和密码**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!-- 路径必须和配置的loginProcessingUrl相同 -->
<form action="/user/login" method="post">
  <!-- name必须是username和password，不然无法生效 -->
  用户名：<input type="text" name="username">
  <br/>
  密码：<input type="password" name="password">
  <br/>
  <input type="submit" value="登录">
</form>
</body>
</html>
```

### 请求接口

```java
@RestController
@RequestMapping("user")
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello World";
    }
    // 登录成功跳转到/user/index
    @GetMapping("/index")
    public String index() {
        return "登录成功";
    }
}    
```

### 访问测试

访问其他需要认证的接口时会自动跳转到该页面

直接访问：:8800/user/hello

进入登录页面：:8800/user/index

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131204262.png" alt="image-20221213120449198" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211323359.png" alt="image-20230521132324294" style="zoom:80%;" />

# 用户授权⭐

## 基于角色进行访问控制

### hasAuthority

> **hasAuthority(String)** 判断角色是否具有特定权限，有则返回 true,否则返回 false

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131446824.png" alt="image-20221213144630697" style="zoom:80%;" />

> 在SecurityConfig进行配置
>

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.formLogin() //自定义自己编写的登录页面
        .loginPage("/login.html") // 登陆页面设置
        .loginProcessingUrl("/user/login") // 登录页面点击登录后访问路径
        .defaultSuccessUrl("/user/index").permitAll() // 登录成功之后跳转路径
        .and().authorizeRequests()
            // 这些路径不用认证可以直接访问
            .antMatchers("/","/user/login").permitAll()
            // 当前登录用户，只有具有admins权限才可以访问这个路径⭐
            .antMatchers("/user/hello").hasAuthority("admins")
            .anyRequest().authenticated()
            .and().csrf().disable(); // 关闭csrf防护
}
```

> 在MyUserDetailService进行配置
>

```java
@Service
public class MyUserDetailService implements UserDetailsService {
    // 注入mybatisPlus mapper
    @Resource
    private userMapper userMapper;

    // 传入的参数表示用户名，它是根据用户名进行查询用户是否存在
    @Override
    public UserDetails loadUserByUsername(String username) throws 
        UsernameNotFoundException {
        // 根据用户名查询
        user users = userMapper.selectOne(new LambdaQueryWrapper<user>()
                                          .eq(user::getName, username));
        // 判断，数据库没有用户名，认证失败
        if (users == null) {
            throw new UsernameNotFoundException("用户名不存在！");
        }
        // 这里是设置角色，目前没用到，但还是得写，因为不能为空，这里加了admins⭐
        // 多个权限逗号分隔
        List<GrantedAuthority> auths = AuthorityUtils
                                      .commaSeparatedStringToAuthorityList("admins");
        // 这里将获取到的用户名密码进行校验
        return new User(users.getName(),new BCryptPasswordEncoder()
                         .encode(users.getPassword()),auths);
    }
}
```

> 如果上面没有写成admins，会显示403，没有权限访问
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208291519222.png" alt="image-20220829151937153" style="zoom:67%;" />

> 否则能正常访问
>



### hasAnyAuthority

> 如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回 true. 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131447740.png" alt="image-20221213144746623" style="zoom:80%;" />

```java
// 当前登录用户，只有具有admins,manager权限才可以访问这个路径，可以设置多个权限
.antMatchers("/user/hello").hasAnyAuthority("admins","manager")
```



## 基于权限进行访问控制

写法同上

### hasRole

> 如果用户具备给定角色就允许访问,否则出现 403。 如果当前主体具有指定的角色，则返回 true。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131450849.png" alt="image-20221213145036749" style="zoom:80%;" />

```java
// 设置角色时需要加上前缀ROLE_,成ROLE_sale，sale销售人员
.antMatchers("/user/hello").hasRole("sale")
```

```java
// 这里是设置角色，目前没用到，但还是得写，因为不能为空
List<GrantedAuthority> auths = AuthorityUtils
                              .commaSeparatedStringToAuthorityList("admins,ROLE_sale");
```

### hasAnyRole

 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131451892.png" alt="image-20221213145146809" style="zoom:80%;" />

> 表示用户具备任何一个条件都可以访问。 给用户添加角色
>

```java
// 需要加上前缀ROLE_,成ROLE_sale
.antMatchers("/user/hello").hasAnyRole("sale","pole")
```

### hasIpAddress

> **「hasIpAddress(String)」** 请求是指定的IP就运行访问

```
//ip 是127.0.0.1 的请求 可以访问/ip
http.authorizeRequests().antMatchers("/ip").hasIpAddress("127.0.0.1")
```



## 自定义403页面(无权限页面)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131455218.png" alt="image-20221213145532079" style="zoom:80%;" />

> 在static目录下新建unauth.html
>

```html
<h1>没有访问权限！</h1>
```

> 在SecurityConfig配置类里修改即可
>

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    // 配置没有权限访问跳转的自定义页面⭐⭐
    http.exceptionHandling().accessDeniedPage("/unauth.html");
    // 这边是配置登录页面的，和上面没关系
    http.formLogin() //自定义自己编写的登录页面
        .loginPage("/login.html") // 登陆页面设置
        .loginProcessingUrl("/user/login") // 登录页面点击登录后访问路径
        .defaultSuccessUrl("/user/index").permitAll() // 登录成功之后跳转路径
        .and().authorizeRequests()
            // 这些路径不用认证可以直接访问
            .antMatchers("/","/user/login").permitAll()
            // 需要加上前缀ROLE_,成ROLE_sale
            .antMatchers("/user/hello").hasAnyRole("sale","pole")
            .anyRequest().authenticated()
            .and().csrf().disable(); // 关闭csrf防护
}
```

修改MyUserDetailService，让他没有权限

```java
// 这里是设置角色，目前没用到，但还是得写，因为不能为空
List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList("abc");
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208291536658.png" alt="image-20220829153601595" style="zoom:80%;" />

## 注解使用⭐⭐

> 作用同上面权限配置

### 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131504626.png" alt="image-20221213150405487" style="zoom:80%;" />

> 1、使用注解先要Application中开启注解功能！ 

```java
@EnableGlobalMethodSecurity(securedEnabled=true)
```

> 2、在控制器方法上添加注解

```java
@Secured({"ROLE_sale","ROLE_manager"})
@GetMapping("update")
public String helloUpdate() {
    return "Hello Update";
}
```

> 3、在MyUserDetailService设置用户角色

```java
List<GrantedAuthority> auths = AuthorityUtils
        .commaSeparatedStringToAuthorityList("admins.ROLE_sale");
```

> 4、启动并访问，成功访问

:8800/user/update

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211353498.png" alt="image-20230521135337431" style="zoom:80%;" />

### @Secured

> @Secured 判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“。 
>

> 角色校验 ,请求到来访问控制单元方法时必须包含XX角色才能访问
>

> 角色必须添加ROLE_前缀 配置类中正常配置
>

```java
// 需要加上前缀ROLE_,成ROLE_sale
.antMatchers("/user/hello").hasAnyRole("sale","manager")
```

```java
// 这里是设置角色，目前没用到，但还是得写，因为不能为空
List<GrantedAuthority> auths = AuthorityUtils
                              .commaSeparatedStringToAuthorityList("admins,ROLE_sale");
```

### @PreAuthorize 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131504605.png" alt="image-20221213150433493" style="zoom:80%;" />

> 权限检验,请求到来访问控制单元之前必须包含xx权限才能访问，控制单元方法执行前进行角色校验
>

> 使用`@PreAuthorize`和`@PostAuthorize` 需要在配置类中配置注解@EnableGlobalMethodSecurity 才能生效先开启注解功能： 
>

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
// 在上面已经开启注解的情况下，这样写
@EnableGlobalMethodSecurity(securedEnabled=true,prePostEnabled = true)
```

>  @PreAuthorize：注解适合进入方法前的权限验证 @PreAuthorize 可以将登录用户的 roles/permissions 参数传到方法
>

```java
@PreAuthorize("hasAnyAuthority('admins')")
@GetMapping("/hello")
public String hello() {
    return "Hello World";
}
```



### @PostAuthorize 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131505898.png" alt="image-20221213150500812" style="zoom:80%;" />

> 权限检验,请求到来访问控制单元之后必须包含xx权限才能访问 ，控制单元方法执行完后进行角色校验
>

先开启注解功能 

```java
@EnableGlobalMethodSecurity(prePostEnabled = true) 
```

@PostAuthorize 注解使用并不多，在方法执行后再进行权限验证，适合验证带有返回值 的权限

```java
// 方法之后执行
@PostAuthorize("hasAnyAuthority('admins')")
@GetMapping("/hello")
public String hello() {
    return "Hello World";
}
```

### @PostFilter 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131505922.png" alt="image-20221213150529836" style="zoom:67%;" />

> @PostFilter ：权限验证之后对数据进行过滤 留下用户名是 admin1 的数据 表达式中的 filterObject 引用的是方法返回值 List 中的某一个元素
>

```java
@GetMapping("getAll")
@PreAuthorize("hasRole('ROLE_sale')")
// 对返回数据做过滤，只有用户名是admin1才返回
@PostFilter("filterObject.name == 'admin1'")
public List<user> getAllUser(){
    ArrayList<user> list = new ArrayList<>();
    list.add(new user(1,"admin1","6666"));
    list.add(new user(2,"admin2","888"));
    System.out.println(list);
    return list;
}
```

进行访问：/user/getAll

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208291605127.png" alt="image-20220829160553039" style="zoom:80%;" />

### @PreFilter 

@PreFilter: 进入控制器之前对数据进行过滤

```java
@GetMapping("getTestPreFilter")
@PreAuthorize("hasRole('ROLE_sale')")
@PreFilter(value = "filterObject.id%2==0")
public List<UserInfo> getTestPreFilter(@RequestBody List<UserInfo> list){
	 list.forEach(t-> {
	 	System.out.println(t.getId()+"\t"+t.getUsername());
	});
	return list;
}
```



# 退出注销

## 添加退出链接

在登录页面添加一个退出连接

创建success.html

```java
登录成功!<br>
<a href="/logout">退出</a>
```

## 添加退出映射地址

在SecurityConfig进行配置

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    // 退出，第一个设置退出注销路径(就是html退出按钮路径)，第二个表示退出之后前往哪个页面⭐⭐
    http.logout().logoutUrl("/logout").logoutSuccessUrl("/user/hello").permitAll();

    // 配置没有权限访问跳转的自定义页面
    http.exceptionHandling().accessDeniedPage("/unauth.html");

    http.formLogin() //自定义自己编写的登录页面
        .loginPage("/login.html") // 登陆页面设置
        .loginProcessingUrl("/user/login") // 登录页面点击登录后访问路径
        .defaultSuccessUrl("/success.html").permitAll() // 登录成功之后跳转路径
        .and().authorizeRequests()
            // 这些路径不用认证可以直接访问
            .antMatchers("/","/user/login").permitAll()
            // 需要加上前缀ROLE_,成ROLE_sale
            .antMatchers("/user/hello").hasAnyRole("sale","manager")
            .anyRequest().authenticated()
            .and().csrf().disable(); // 关闭csrf防护
}
```

> 测试即可：/login.html ，退出之后，是无法访问需要登录时才能访问的控制器！
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211450509.png" alt="image-20230521145054434" style="zoom:80%;" />



# 自动登录/记住我⭐

> 实现原理

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131513376.png" alt="image-20221213151317184" style="zoom:80%;" />

> 认证过程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131514163.png" alt="image-20221213151450016" style="zoom:80%;" />

## 数据库配置

可以不配置，在启动时自动创建就行

```sql
CREATE TABLE `persistent_logins` (
 `username` varchar(64) NOT NULL,
 `series` varchar(64) NOT NULL,
 `token` varchar(64) NOT NULL,
 `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`series`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

添加数据库连接的配置文件

```properties
# mysql数据库连接
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/security1?serverTimezone=GMT%2B8
spring.datasource.username=root
spring.datasource.password=123456
```

## 配置文件

### SecurityConfig配置

配置在SecurityConfig中即可

```java
// 注入数据源
@Resource
private DataSource dataSource;

// 配置对象
@Bean
public PersistentTokenRepository persistentTokenRepository() {
    JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
    jdbcTokenRepository.setDataSource(dataSource);
    // 启动时自动创建数据库表persistent_logins，第一次执行完成就要注释，不然再次启动就会报错
    jdbcTokenRepository.setCreateTableOnStartup(true);
    return jdbcTokenRepository;
}
```

### 自动登录配置⭐⭐

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    // 退出，第一个设置退出/注销路径，第二个表示退出之后前往哪个页面
    http.logout().logoutUrl("/logout").logoutSuccessUrl("/user/hello").permitAll();
    // 配置没有权限访问跳转的自定义页面
    http.exceptionHandling().accessDeniedPage("/unauth.html");
    //自定义自己编写的登录页面
    http.formLogin()
        .loginPage("/login.html") // 登陆页面设置
        .loginProcessingUrl("/user/login") // 登录页面点击登录后访问路径
        .defaultSuccessUrl("/success.html").permitAll() // 登录成功之后跳转路径
        .and().authorizeRequests()
            // 这些路径不用认证可以直接访问
            .antMatchers("/","/user/login").permitAll()
            // 需要加上前缀ROLE_,成ROLE_sale
            .antMatchers("/user/hello").hasAnyRole("sale","manager")
            .anyRequest().authenticated()
            // 自动登录配置⭐⭐
            // 1、记住我，刚配置的对象
            .and().rememberMe().tokenRepository(persistentTokenRepository())
            // 2、设置有效时长，单位秒
            // 默认 2 周时间。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。
            .tokenValiditySeconds(60*60)
            // 3、设置userDetailsService来操作
            .userDetailsService(userDetailsService)
            .and().csrf().disable(); // 关闭csrf防护
}
```

### 完整配置文件

> SecurityConfig.java

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // 注入UserDetailsService
    @Resource
    private UserDetailsService userDetailsService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(password());
    }

    @Bean
    PasswordEncoder password() {
        return new BCryptPasswordEncoder();
    }

    @Resource
    DataSource dataSource;

    @Bean
    public PersistentTokenRepository persistentTokenRepository(){
        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();
        jdbcTokenRepository.setDataSource(dataSource);
        // 启动创建数据库表
        //jdbcTokenRepository.setCreateTableOnStartup(true);
        return jdbcTokenRepository;
    }

    // 自定义登录页面配置项
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //自定义自己编写的登录页面
                .loginPage("/login.html") // 登陆页面地址
                .loginProcessingUrl("/user/login") // 登录页面点击登录后访问路径
                .defaultSuccessUrl("/user/index").permitAll() // 登录成功之后跳转路径
                .and().authorizeRequests()
                // 哪些路径可直接访问，不用认证
                .antMatchers("/","/user/hello","/user/login").permitAll()
                .anyRequest().authenticated()
                // 自动登录配置⭐⭐
                // 1、记住我，刚配置的对象
                .and()
                .rememberMe() 
                 // 刚刚注入的PersistentTokenRepository
                .tokenRepository(persistentTokenRepository()) 
                .tokenValiditySeconds(10*24*60*60) // 设置记住我有效时间。单位是秒。默认是14天
                .rememberMeParameter("remember-me") // 修改请求参数名。 默认是remember-me
                // 修改remember me的cookie名称。默认是remember-me
                .rememberMeCookieName("remember-me") 
                // 设置userDetailsService来操作数据库
                .userDetailsService(userDetailsService) 
                .and().csrf().disable(); // 关闭csrf防护
    }

}
```

## 登录页面

> static/login.html 页面添加记住我复选框，此处：name 属性值必须位 remember-me.不能改为其他值
>

```html
<!-- 路径必须和配置的loginProcessingUrl相同 -->
<form action="/user/login" method="post">
  <!--name必须为username，不然找不到-->
  用户名：<input type="text" name="username">
  <br/>
  <!--name必须为password，不然找不到-->
  密码：<input type="password" name="password">
  <br/>
  <!--name必须为remember-me，不然找不到-->
  <input type="checkbox" name="remember-me"/>自动登录
  <input type="submit" value="登录">
</form>
```

## 访问控制

```java
@RestController
@RequestMapping("user")
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello World";
    }
    @GetMapping("/index")
    public String index() {
        return "登录成功";
    }

    @GetMapping("say")
    public String say() {
        return "你好，世界";
    }
}
```



## 接口测试

> 进行访问：:8080/user/say  这是任意的一个接口，此时跳转到登录页

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131536671.png" alt="image-20221213153650549" style="zoom:80%;" />

> 点击登录，成功进入访问页面

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211503003.png" alt="image-20230521150357929" style="zoom:80%;" />

> 发现数据库中已经有内容了，而且浏览器登录成功页面也有Cookie

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211504414.png" alt="image-20230521150423337" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211515830.png" alt="image-20230521151529738" style="zoom:80%;" />

> 此时关掉浏览器，打开浏览器再次进行访问，此时发现无需登录，能够成功访问

:8080/user/say

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212131543650.png" alt="image-20221213154309164" style="zoom:80%;" />



# CSRF跨站请求伪造

> 大家看到，csrf 攻击主要是借助了浏览器默认发送 Cookie 的这一机制，所以如果你的前端是 App、小程序之类的应用，不涉及浏览器应用的话，其实可以忽略这个问题，如果你的前端包含浏览器应用的话，这个问题就要认真考虑了。
>

> 案例已经上传到 GitHub https://github.com/lenve/spring-security-samples
>

## CSRF 原理

> 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click  attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已 登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 
>

> 跨站请求攻击，简单地说，是**攻击者通过一些技术手段欺骗用户的浏览器去访问一个 自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买 商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行**。 这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的 浏览器，却不能保证请求本身是用户自愿发出的。 
>

> 想要防御 CSRF 攻击，那我们得先搞清楚什么是 CSRF 攻击，松哥通过下面一张图，来和大家梳理 CSRF 攻击流程：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208300942786.png" alt="image-20220830094212708" style="zoom:80%;" />

其实这个流程很简单：

> 1. 假设用户打开了招商银行网上银行网站，并且登录。
> 2. 登录成功后，网上银行会返回 Cookie 给前端，浏览器将 Cookie 保存下来。
> 3. 用户在没有登出网上银行的情况下，在浏览器里边打开了一个新的选项卡，然后又去访问了一个危险网站。
> 4. 这个危险网站上有一个超链接，超链接的地址指向了招商银行网上银行。
> 5. **用户点击了这个超链接，由于这个超链接会自动携带上浏览器中保存的 Cookie，所以用户不知不觉中就访问了网上银行，进而可能给自己造成了损失。**

CSRF 的流程大致就是这样，接下来松哥用一个简单的例子和小伙伴们展示一下 CSRF 到底是怎么回事。

> 通俗解释：**CSRF就是别的网站非法获取我们网站Cookie值，我们项目服务器是无法区分到底是不是我们的客户端，只有请求中有Cookie，认为是自己的客户端，所以这个时候就出现了CSRF。**
>

## CSRF 问题还原

> 接下来，我创建一个名为 csrf-1 的 Spring Boot 项目，这个项目相当于我们上面所说的网上银行网站，创建项目时引入 Web 和 Spring Security 依赖，如下：
>

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```

创建成功后，方便起见，我们直接将 Spring Security 用户名/密码 配置在 application.properties 文件中：

```properties
spring.security.user.name=renshuo
spring.security.user.password=123
```

然后我们提供两个测试接口：

```java
@RestController
public class HelloController {
    @PostMapping("/transfer")
    public void transferMoney(String name, Integer money) {
        System.out.println("name = " + name);
        System.out.println("money = " + money);
    }
    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```

> 假设 `/transfer` 是一个转账接口（这里是假设，主要是给大家演示 CSRF 攻击，真实的转账接口比这复杂）。最后我们还需要配置一下 Spring Security，因为 Spring Security 中默认是可以自动防御 CSRF 攻击的，所以我们要把这个关闭掉：
>

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest().authenticated()
                .and()
                .formLogin()
                .and()
                .csrf()
                .disable();
    }
}
```

> 配置完成后，我们启动 csrf-1 项目。接下来，我们再创建一个 csrf-2 项目，这个项目相当于是一个危险网站，为了方便，这里创建时我们只需要引入 web 依赖即可。项目创建成功后，首先修改项目端口：
>

```properties
server.port=8081
```

然后我们在 resources/static 目录下创建一个 hello.html ，内容如下：

```html
<body>
<form action=":8080/transfer" method="post">
    <input type="hidden" value="javaboy" name="name">
    <input type="hidden" value="10000" name="money">
    <input type="submit" value="点击查看美女图片">
</form>
</body>
```

> 这里有一个超链接，超链接的文本是**点击查看美女图片**，当你点击了超链接之后，会自动请求 `:8080/transfer` 接口，同时隐藏域还携带了两个参数。
>

配置完成后，就可以启动 csrf-2 项目了。

> 接下来，用户首先访问 csrf-1 项目中的接口，在访问的时候需要登录，用户就执行了登录操作，访问完整后，用户并没有执行登出操作，然后用户访问 csrf-2 中的页面，看到了超链接，好奇这美女到底长啥样，一点击，结果钱就被人转走
>

## CSRF防御策略

> 先来说说防御思路。**CSRF 防御，一个核心思路就是在前端请求中，添加一个随机数。**
>

> 因为在 CSRF 攻击中，黑客网站其实是不知道用户的 Cookie 具体是什么的，他是让用户自己发送请求到网上银行这个网站的，因为这个过程会自动携带上 Cookie 中的信息。
>

> 所以我们的防御思路是这样：用户在访问网上银行时，除了携带 Cookie 中的信息之外，还需要携带一个随机数，如果用户没有携带这个随机数，则网上银行网站会拒绝该请求。黑客网站诱导用户点击超链接时，会自动携带上 Cookie 中的信息，但是却不会自动携带随机数，这样就成功的避免掉 CSRF 攻击
>

Spring Security 中对此提供了很好的支持，我们一起来看下。

### 默认方案

> Spring Security 中默认实际上就提供了 csrf 防御，但是需要开发者做的事情比较多。首先我们来创建一个新的 Spring Boot 工程，创建时引入 Spring Security、Thymeleaf 和 web 依赖。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208300948538.png" alt="image-20220830094828451" style="zoom:80%;" />

项目创建成功后，我们还是在 application.properties 中配置用户名/密码：

```properties
spring.security.user.name=javaboy
spring.security.user.password=123
```

接下来，我们提供一个测试接口：

```java
@Controller
public class HelloController {
    @PostMapping("/hello")
    @ResponseBody
    public String hello() {
        return "hello";
    }
}
```

注意，这个测试接口是一个 POST 请求，因为默认情况下，GET、HEAD、TRACE 以及 OPTIONS 是不需要验证 CSRF 攻击的。然后，我们在 resources/templates 目录下，新建一个 thymeleaf 模版，如下：

```html
<body>
<form action="/hello" method="post">
    <input type="hidden" th:value="${_csrf.token}" th:name="${_csrf.parameterName}">
    <input type="submit" value="hello">
</form>
</body>
```

> 注意，在发送 POST 请求的时候，还额外携带了一个隐藏域，隐藏域的 key 是 `${_csrf.parameterName}`，value 则是 `${_csrf.token}`。这两个值服务端会自动带过来，我们只需要在前端渲染出来即可。
>

接下来给前端 hello.html 页面添加一个控制器，如下：

```java
@GetMapping("/hello")
public String hello2() {
    return "hello";
}
```

> 添加完成后，启动项目，我们访问 hello 页面，在访问时候，需要先登录，登录成功之后，我们可以看到登录请求中也多了一个参数，如下：
>

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnLmrFzicO9dUKeYSH4UWpAotXXHoSdRn3IpRv2xs0pNPzQfD6MKc7aroqE2fYAqMlrbmDc62tmQfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> 可以看到，这里也多了 `_csrf` 参数。这里我们用了 Spring Security 的默认登录页面，如果大家使用自定义登录页面，可以参考上面 hello.html 的写法，通过一个隐藏域传递 `_csrf` 参数。
>

访问到 hello 页面之后，再去点击按钮，就可以访问到 hello 接口了。

> 小伙伴们可以自行尝试在 hello.html 页面中，去掉 `_csrf` 参数，看看访问 hello 接口的效果。

> 这是 Spring Security 中默认的方案，通过 Model 将相关的数据带到前端来。如果你的项目是前后端不分项目，这种方案就可以了，如果你的项目是前后端分离项目，这种方案很明显不够用。
>

### 前后端分离方案

> 如果是前后端分离项目，Spring Security 也提供了解决方案。这次不是将 `_csrf` 放在 Model 中返回前端了，而是放在 Cookie 中返回前端，配置方式如下：
>

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest().authenticated()
                .and()
                .formLogin()
                .and()
                .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository
                                     .withHttpOnlyFalse());
    }
}
```

有小伙伴可能会说放在 Cookie 中不是又被黑客网站盗用了吗？其实不会的，大家注意如下两个问题：

> 1. 黑客网站根本不知道你的 Cookie 里边存的啥，他也不需要知道，因为 CSRF 攻击是浏览器自动携带上 Cookie 中的数据的。
> 2. 我们将服务端生成的随机数放在 Cookie 中，前端需要从 Cookie 中自己提取出来 `_csrf` 参数，然后拼接成参数传递给后端，单纯的将 Cookie 中的数据传到服务端是没用的。

> 理解透了上面两点，你就会发现 `_csrf` 放在 Cookie 中是没有问题的，但是大家注意，配置的时候我们通过 withHttpOnlyFalse 方法获取了 CookieCsrfTokenRepository 的实例，该方法会设置 Cookie 中的 HttpOnly 属性为 false，也就是允许前端通过 js 操作 Cookie（否则你就没有办法获取到 `_csrf`）。
>

> 配置完成后，重启项目，此时我们就发现返回的 Cookie 中多了一项：
>

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnLmrFzicO9dUKeYSH4UWpAoaBUXVZpjYonEqKCLECibbjvdE1w73MR2mQWpeEicleZCLvaqw5AJAF4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

接下来，我们通过自定义登录页面，来看看前端要如何操作。

首先我们在 resources/static 目录下新建一个 html 页面叫做 login.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/jquery.min.js"></script>
    <script src="js/jquery.cookie.js"></script>
</head>
<body>
<div>
    <input type="text" id="username">
    <input type="password" id="password">
    <input type="button" value="登录" id="loginBtn">
</div>
<script>
    $("#loginBtn").click(function () {
        let _csrf = $.cookie('XSRF-TOKEN');
        $.post('/login.html',{username:$("#username").val(),
                              password:$("#password").val(),_csrf:_csrf},
               function (data) {
            alert(data);
        })
    })
</script>
</body>
</html>
```

这段 html 我给大家解释下：

1. 首先引入 jquery 和 jquery.cookie ，方便我们一会操作 Cookie。
2. 定义三个 input，前两个是用户名和密码，第三个是登录按钮。
3. 点击登录按钮之后，我们先从 Cookie 中提取出 XSRF-TOKEN，这也就是我们要上传的 csrf 参数。
4. 通过一个 POST 请求执行登录操作，注意携带上 `_csrf` 参数。

服务端我们也稍作修改，如下：

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/js/**");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage("/login.html")
                .successHandler((req,resp,authentication)->{
                    resp.getWriter().write("success");
                })
                .permitAll()
                .and()
                .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
    }
}
```

一方面这里给 js 文件放行。

另一方面配置一下登录页面，以及登录成功的回调，这里简单期间，登录成功的回调我就给一个字符串就可以了。大家感兴趣的话，可以查看[本系列](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1319828555819286528&__biz=MzI1NDY0MTkzNQ==#wechat_redirect)前面文章，有登录成功后回调的详细解释。

OK，所有事情做完之后，我们访问 login.html 页面，输入用户名密码进行登录，结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnLmrFzicO9dUKeYSH4UWpAonpNrib0FDRejyHeG7ia4FCB1Mjia3OYiaT12Aew0894mEDXBIyC5yvlJSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，我们的 `_csrf` 配置已经生效了。

> 小伙伴们可以自行尝试从登录参数中去掉 `_csrf`，然后再看看效果。



# 新版 Spring Security 配置变化

## 配置变化

进入到 SpringBoot2.7 时代，有小伙伴发现有一个常用的类忽然过期了：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304111419149.png" alt="image-20230411141923978" style="zoom:80%;" />

在 Spring Security 时代，这个类可太重要了。过期的类当然可以继续使用，但是你要是决定别扭，只需要稍微看一下注释，基本上就明白该怎么玩了。我们来看下 WebSecurityConfigurerAdapter 的注释：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304111419504.png" alt="image-20230411141934335" style="zoom:80%;" />

从这段注释中我们大概就明白了咋回事了。以前我们自定义类继承自 WebSecurityConfigurerAdapter 来配置我们的 Spring Security，我们主要是配置两个东西：

- configure(HttpSecurity)
- configure(WebSecurity)

前者主要是配置 Spring Security 中的过滤器链，后者则主要是配置一些路径放行规则。

现在在 WebSecurityConfigurerAdapter 的注释中，人家已经把意思说的很明白了：

1. 以后如果想要配置过滤器链，可以通过自定义 SecurityFilterChain Bean 来实现。
2. 以后如果想要配置 WebSecurity，可以通过 WebSecurityCustomizer Bean 来实现。

## 实战演练

那么接下来我们就通过一个简单的例子来看下。

首先我们新建一个 Spring Boot 工程，引入 Web 和 Spring Security 依赖，注意 Spring Boot 选择最新的 2.7。

![图片](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYm3yVddbCLaWPW4KGB8aDxIg2gJOiaooGPgg86nxBWrEEazfoohpiaetatdly3uyurRZ7bbUKsayiccA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

接下来我们提供一个简单的测试接口，如下：

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello 江南一点雨!";
    }
}
```

小伙伴们知道，在 Spring Security 中，默认情况下，只要添加了依赖，我们项目的所有接口就已经被统统保护起来了，现在启动项目，访问 `/hello` 接口，就需要登录之后才可以访问，登录的用户名是 user，密码则是随机生成的，在项目的启动日志中。

现在我们的第一个需求是使用自定义的用户，而不是系统默认提供的，这个简单，我们只需要向 Spring 容器中注册一个 UserDetailsService 的实例即可，像下面这样：

```java
@Configuration
public class SecurityConfig {

    @Bean
    UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager users = new InMemoryUserDetailsManager();
        users.createUser(User.withUsername("javaboy")
                         .password("{noop}123").roles("admin").build());
        users.createUser(User.withUsername("江南一点雨")
                         .password("{noop}123").roles("admin").build());
        return users;
    }

}
```

这就可以了。

当然我现在的用户是存在内存中的，如果你的用户是存在数据库中，那么只需要提供 UserDetailsService 接口的实现类并注入 Spring 容器即可，这个之前在 vhr 视频中讲过多次了（公号后台回复 666 有视频介绍），这里就不再赘述了。

但是假如说我希望 `/hello` 这个接口能够匿名访问，并且我希望这个匿名访问还不经过 Spring Security 过滤器链，要是在以前，我们可以重写 `configure(WebSecurity)` 方法进行配置，但是现在，得换一种玩法：

```java
@Configuration
public class SecurityConfig {

    @Bean
    UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager users = new InMemoryUserDetailsManager();
        users.createUser(User.withUsername("javaboy")
                         .password("{noop}123").roles("admin").build());
        users.createUser(User.withUsername("江南一点雨")
                         .password("{noop}123").roles("admin").build());
        return users;
    }

    @Bean
    WebSecurityCustomizer webSecurityCustomizer() {
        return new WebSecurityCustomizer() {
            @Override
            public void customize(WebSecurity web) {
                web.ignoring().antMatchers("/hello");
            }
        };
    }

}
```

以前位于 `configure(WebSecurity)` 方法中的内容，现在位于 WebSecurityCustomizer Bean 中，该配置的东西写在这里就可以了。

那如果我还希望对登录页面，参数等，进行定制呢？继续往下看：

```java
@Configuration
public class SecurityConfig {

    @Bean
    UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager users = new InMemoryUserDetailsManager();
        users.createUser(User.withUsername("javaboy")
                         .password("{noop}123").roles("admin").build());
        users.createUser(User.withUsername("江南一点雨")
                         .password("{noop}123").roles("admin").build());
        return users;
    }

    @Bean
    SecurityFilterChain securityFilterChain() {
        List<Filter> filters = new ArrayList<>();
        return new DefaultSecurityFilterChain(new AntPathRequestMatcher("/**"), filters);
    }

}
```

Spring Security 的底层实际上就是一堆过滤器，所以我们之前在 configure(HttpSecurity) 方法中的配置，实际上就是配置过滤器链。现在过滤器链的配置，我们通过提供一个 SecurityFilterChain Bean 来配置过滤器链，SecurityFilterChain 是一个接口，这个接口只有一个实现类 DefaultSecurityFilterChain，构建 DefaultSecurityFilterChain 的第一个参数是拦截规则，也就是哪些路径需要拦截，第二个参数则是过滤器链，这里我给了一个空集合，也就是我们的 Spring Security 会拦截下所有的请求，然后在一个空集合中走一圈就结束了，相当于不拦截任何请求。

此时重启项目，你会发现 `/hello` 也是可以直接访问的，就是因为这个路径不经过任何过滤器。

其实我觉得目前这中新写法比以前老的写法更直观，更容易让大家理解到 Spring Security 底层的过滤器链工作机制。

有小伙伴会说，这写法跟我以前写的也不一样呀！这么配置，我也不知道 Spring Security 中有哪些过滤器，其实，换一个写法，我们就可以将这个配置成以前那种样子：

```java
@Configuration
public class SecurityConfig {

    @Bean
    UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager users = new InMemoryUserDetailsManager();
        users.createUser(User.withUsername("javaboy")
                         .password("{noop}123").roles("admin").build());
        users.createUser(User.withUsername("江南一点雨")
                         .password("{noop}123").roles("admin").build());
        return users;
    }

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .permitAll()
                .and()
                .csrf().disable();
        return http.build();
    }

}
```

这么写，就跟以前的写法其实没啥大的差别了。

好啦，多余的废话我就不多说了，小伙伴们可以去试试最新玩法啦～



# Sa-Token⭐

Sa-Token框架是一个轻量级的登录、鉴权框架，有利于我们开发。

> - Sa-Token框架的官方文档：https://sa-token.cc/doc.html#/

> 今天最近在做登录、授权的功能，一开始考虑到的是spring boot + spring security，但spring security太重，而我们是轻量级的项目，所以，spring security不适合我们。而后考虑spring boot + shiro，但shiro自带的aop会影响spring boot的aop，所以，shiro也不适合我们。

## 功能一览

上述只提供了登录认证和权限认证的两个功能，Sa-Token还有如下诸多功能：

- **登录认证** —— 单端登录、多端登录、同端互斥登录、七天内免登录
- **权限认证** —— 权限认证、角色认证、会话二级认证
- **Session会话** —— 全端共享Session、单端独享Session、自定义Session
- **踢人下线** —— 根据账号id踢人下线、根据Token值踢人下线
- **账号封禁** —— 指定天数封禁、永久封禁、设定解封时间
- **持久层扩展** —— 可集成Redis、Memcached等专业缓存中间件，重启数据不丢失
- **分布式会话** —— 提供jwt集成、共享数据中心两种分布式会话方案
- **微服务网关鉴权** —— 适配Gateway、ShenYu、Zuul等常见网关的路由拦截认证
- **单点登录** —— 内置三种单点登录模式：无论是否跨域、是否共享Redis，都可以搞定
- **OAuth2.0认证** —— 基于RFC-6749标准编写，OAuth2.0标准流程的授权认证，支持openid模式
- **二级认证** —— 在已登录的基础上再次认证，保证安全性
- **Basic认证** —— 一行代码接入Http Basic认证
- **独立Redis** —— 将权限缓存与业务缓存分离
- **临时Token验证** —— 解决短时间的Token授权问题
- **模拟他人账号** —— 实时操作任意用户状态数据
- **临时身份切换** —— 将会话身份临时切换为其它账号
- **前后台分离** —— APP、小程序等不支持Cookie的终端
- **同端互斥登录** —— 像QQ一样手机电脑同时在线，但是两个手机上互斥登录
- **多账号认证体系** —— 比如一个商城项目的user表和admin表分开鉴权
- **花式token生成** —— 内置六种Token风格，还可：自定义Token生成策略、自定义Token前缀
- **注解式鉴权** —— 优雅的将鉴权与业务代码分离
- **路由拦截式鉴权** —— 根据路由拦截鉴权，可适配restful模式
- **自动续签** —— 提供两种Token过期策略，灵活搭配使用，还可自动续签
- **会话治理** —— 提供方便灵活的会话查询接口
- **记住我模式** —— 适配[记住我]模式，重启浏览器免验证
- **密码加密** —— 提供密码加密模块，可快速MD5、SHA1、SHA256、AES、RSA加密
- **全局侦听器** —— 在用户登陆、注销、被踢下线等关键性操作时进行一些AOP操作
- **开箱即用** —— 提供SpringMVC、WebFlux等常见web框架starter集成包，真正的开箱即用

## 基础使用

### 依赖坐标

在pom.xml中添加依赖：

```xml
<!-- Sa-Token 权限认证, 在线文档：http://sa-token.dev33.cn/ -->
<dependency>
    <groupId>cn.dev33</groupId>
    <artifactId>sa-token-spring-boot-starter</artifactId>
    <version>1.34.0</version>
</dependency>
```

### 设置配置文件

你可以零配置启动项目 ，但同时你也可以在 application.yml 中增加如下配置，定制性使用框架：

```yml
server:
    # 端口
    port: 8081

# Sa-Token配置
sa-token: 
    # token 名称 (同时也是cookie名称)
    token-name: satoken
    # token 有效期，单位s 默认30天, -1代表永不过期 
    timeout: 2592000
    # token 临时有效期 (指定时间内无操作就视为token过期) 单位: 秒
    activity-timeout: -1
    # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) 
    is-concurrent: true
    # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 
    # 为false时每次登录新建一个token) 
    is-share: false
    # token风格
    token-style: uuid
    # 是否输出操作日志 
    is-log: true
```

### 创建启动类

在项目中新建包com.pj，在此包内新建主类 SaTokenDemoApplication.java，复制以下代码：

```java
@SpringBootApplication
public class SaTokenDemoApplication {
    public static void main(String[] args) throws JsonProcessingException {
        SpringApplication.run(SaTokenDemoApplication.class, args);
        System.out.println("启动成功：Sa-Token配置如下：" + SaManager.getConfig());
    }
}
```

### Controller

```java
@RestController
@RequestMapping("/user/")
public class UserController {

    // 测试登录，浏览器访问： :8081/user/doLogin?
    //                    username=zhang&password=123456
    @PostMapping("doLogin")
    public String doLogin(String username, String password) {
        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对
        if("zhang".equals(username) && "123456".equals(password)) {
            StpUtil.login(10001);
            return "登录成功";
        }
        return "登录失败";
    }

    // 查询登录状态，浏览器访问： :8081/user/isLogin
    @GetMapping("isLogin")
    public String isLogin() {
        return "当前会话是否登录：" + StpUtil.isLogin();
    }

}
```

### 运行测试

启动代码，从浏览器依次访问上述测试接口：

:8081/user/doLogin?username=zhang&password=123456

:8081/user/isLogin



## 登录认证

### 设计思路

对于一些登录之后才能访问的接口（例如：查询我的账号资料），我们通常的做法是增加一层接口校验：

- 如果校验通过，则：正常返回数据。
- 如果校验未通过，则：抛出异常，告知其需要先进行登录。

那么，判断会话是否登录的依据是什么？我们先来简单分析一下登录访问流程：

1. 用户提交 `name` + `password` 参数，调用登录接口。
2. 登录成功，返回这个用户的 Token 会话凭证。
3. 用户后续的每次请求，都携带上这个 Token。
4. 服务器根据 Token 判断此会话是否登录成功。

所谓登录认证，指的就是服务器校验账号密码，为用户颁发 Token 会话凭证的过程，这个 Token 也是我们后续判断会话是否登录的关键所在。

<img src="https://oss.dev33.cn/sa-token/doc/g/g3--login-auth.gif" alt="img" style="zoom:80%;" />

### [登录与注销](https://sa-token.cc/doc.html#/use/login-auth?id=登录与注销)

根据以上思路，我们需要一个会话登录的函数：

```java
// 会话登录：参数填写要登录的账号id，建议的数据类型：long | int | String， 不可以传入复杂类型，如：User、Admin 等等
StpUtil.login(Object id);     复制到剪贴板错误复制成功12
```

只此一句代码，便可以使会话登录成功，实际上，Sa-Token 在背后做了大量的工作，包括但不限于：

1. 检查此账号是否之前已有登录
2. 为账号生成 `Token` 凭证与 `Session` 会话
3. 通知全局侦听器，xx 账号登录成功
4. 将 `Token` 注入到请求上下文
5. 等等其它工作……

你暂时不需要完整的了解整个登录过程，你只需要记住关键一点：`Sa-Token 为这个账号创建了一个Token凭证，且通过 Cookie 上下文返回给了前端`。

所以一般情况下，我们的登录接口代码，会大致类似如下：

```java
// 会话登录接口 
@RequestMapping("doLogin")
public SaResult doLogin(String name, String pwd) {
    // 第一步：比对前端提交的账号名称、密码
    if("zhang".equals(name) && "123456".equals(pwd)) {
        // 第二步：根据账号id，进行登录 
        StpUtil.login(10001);
        return SaResult.ok("登录成功");
    }
    return SaResult.error("登录失败");
}
```

如果你对以上代码阅读没有压力，你可能会注意到略显奇怪的一点：此处仅仅做了会话登录，但并没有主动向前端返回 Token 信息。 是因为不需要吗？严格来讲是需要的，只不过 `StpUtil.login(id)` 方法利用了 Cookie 自动注入的特性，省略了你手写返回 Token 的代码。

如果你对 Cookie 功能还不太了解，也不用担心，我们会在之后的 [ 前后端分离 ] 章节中详细的阐述 Cookie 功能，现在你只需要了解最基本的两点：

- Cookie 可以从后端控制往浏览器中写入 Token 值。
- Cookie 会在前端每次发起请求时自动提交 Token 值。

因此，在 Cookie 功能的加持下，我们可以仅靠 `StpUtil.login(id)` 一句代码就完成登录认证。

除了登录方法，我们还需要：

```java
// 当前会话注销登录
StpUtil.logout();

// 获取当前会话是否已经登录，返回true=已登录，false=未登录
StpUtil.isLogin();

// 检验当前会话是否已经登录, 如果未登录，则抛出异常：`NotLoginException`
StpUtil.checkLogin();复制到剪贴板错误复制成功12345678
```

异常 `NotLoginException` 代表当前会话暂未登录，可能的原因有很多： 前端没有提交 Token、前端提交的 Token 是无效的、前端提交的 Token 已经过期 …… 等等，可参照此篇：[未登录场景值](https://sa-token.cc/doc.html#/fun/not-login-scene)，了解如何获取未登录的场景值。

### [会话查询](https://sa-token.cc/doc.html#/use/login-auth?id=会话查询)

```java
// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`
StpUtil.getLoginId();

// 类似查询API还有：
StpUtil.getLoginIdAsString();    // 获取当前会话账号id, 并转化为`String`类型
StpUtil.getLoginIdAsInt();       // 获取当前会话账号id, 并转化为`int`类型
StpUtil.getLoginIdAsLong();      // 获取当前会话账号id, 并转化为`long`类型

// ---------- 指定未登录情形下返回的默认值 ----------

// 获取当前会话账号id, 如果未登录，则返回null 
StpUtil.getLoginIdDefaultNull();

// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）
StpUtil.getLoginId(T defaultValue);复制到剪贴板错误复制成功123456789101112131415
```

### [Token 查询](https://sa-token.cc/doc.html#/use/login-auth?id=token-查询)

```java
// 获取当前会话的token值
StpUtil.getTokenValue();

// 获取当前`StpLogic`的token名称
StpUtil.getTokenName();

// 获取指定token对应的账号id，如果未登录，则返回 null
StpUtil.getLoginIdByToken(String tokenValue);

// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）
StpUtil.getTokenTimeout();

// 获取当前会话的token信息参数
StpUtil.getTokenInfo();复制到剪贴板错误复制成功1234567891011121314
```

有关`TokenInfo`参数详解，请参考：[TokenInfo参数详解](https://sa-token.cc/doc.html#/fun/token-info)

### 实战演练

新建 `LoginController`，复制以下代码

```java
// 登录测试 
@RestController
@RequestMapping("/acc/")
public class LoginController {

    // 测试登录  ---- :8081/acc/doLogin?name=zhang&pwd=123456
    @PostMapping("doLogin")
    public SaResult doLogin(String name, String pwd) {
        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 
        if("zhang".equals(name) && "123456".equals(pwd)) {
            StpUtil.login(10001);
            return SaResult.ok("登录成功");
        }
        return SaResult.error("登录失败");
    }

    // 查询登录状态  ---- :8081/acc/isLogin
    @GetMapping("isLogin")
    public SaResult isLogin() {
        return SaResult.ok("是否登录：" + StpUtil.isLogin());
    }
    
    // 查询 Token 信息  ---- :8081/acc/tokenInfo
    @GetMapping("tokenInfo")
    public SaResult tokenInfo() {
        return SaResult.data(StpUtil.getTokenInfo());
    }
    
    // 测试注销  ---- :8081/acc/logout
    @PostMapping("logout")
    public SaResult logout() {
        StpUtil.logout();
        return SaResult.ok();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211630176.png" alt="image-20230521163038109" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211631587.png" alt="image-20230521163110528" style="zoom:80%;" /><img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211631617.png" alt="image-20230521163144530" style="zoom:80%;" />

## 权限认证

所谓权限认证，核心逻辑就是判断一个账号是否拥有指定权限：

- 有，就让你通过。
- 没有？那么禁止访问！

> 深入到底层数据中，就是每个账号都会拥有一个权限码集合，框架来校验这个集合中是否包含指定的权限码。例如：当前账号拥有权限码集合 `["user-add", "user-delete", "user-get"]`，这时候我来校验权限 `"user-update"`，则其结果就是：**验证失败，禁止访问**。

所以现在问题的核心就是：

1. 如何获取一个账号所拥有的的权限码集合？
2. 本次操作需要验证的权限码是哪个？

### 获取当前账号权限码集合

因为每个项目的需求不同，其权限设计也千变万化，因此 [ 获取当前账号权限码集合 ] 这一操作不可能内置到框架中， 所以 Sa-Token 将此操作以接口的方式暴露给你，以方便你根据自己的业务逻辑进行重写。

你需要做的就是新建一个类，实现 `StpInterface`接口，例如以下代码：

```java
// 自定义权限验证接口扩展
// 保证此类被SpringBoot扫描，完成Sa-Token的自定义权限验证扩展 
@Component    
public class StpInterfaceImpl implements StpInterface {

    // 返回一个账号所拥有的权限码集合 
    @Override
    public List<String> getPermissionList(Object loginId, String loginType) {
        // 本list仅做模拟，实际项目中要根据具体业务逻辑来查询权限
        List<String> list = new ArrayList<String>();    
        list.add("101");
        list.add("user.add");
        list.add("user.update");
        list.add("user.get");
        // list.add("user.delete");
        list.add("art.*");
        return list;
    }

    // 返回一个账号所拥有的角色标识集合 (权限与角色可分开校验)
    @Override
    public List<String> getRoleList(Object loginId, String loginType) {
        // 本list仅做模拟，实际项目中要根据具体业务逻辑来查询角色
        List<String> list = new ArrayList<String>();    
        list.add("admin");
        list.add("super-admin");
        return list;
    }

}
```

**参数解释：**

- loginId：账号id，即你在调用 `StpUtil.login(id)` 时写入的标识值。
- loginType：账号体系标识，此处可以暂时忽略，在 [ 多账户认证 ] 章节下会对这个概念做详细的解释。

可参考代码：[码云：StpInterfaceImpl.java](https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/satoken/StpInterfaceImpl.java)

> 注意: StpInterface 接口在需要鉴权时由框架自动调用，开发者只需要配置好就可以使用下面的鉴权方法或后面的注解鉴权

### 权限校验

然后就可以用以下api来鉴权了

```java
// 获取：当前账号所拥有的权限集合
StpUtil.getPermissionList();

// 判断：当前账号是否含有指定权限, 返回 true 或 false
StpUtil.hasPermission("user.add");        

// 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException 
StpUtil.checkPermission("user.add");        

// 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]
StpUtil.checkPermissionAnd("user.add", "user.delete", "user.get");        

// 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]
StpUtil.checkPermissionOr("user.add", "user.delete", "user.get");    复制到剪贴板错误复制成功1234567891011121314
```

扩展：`NotPermissionException` 对象可通过 `getLoginType()` 方法获取具体是哪个 `StpLogic` 抛出的异常

### 角色校验

在Sa-Token中，角色和权限可以独立验证

```java
// 获取：当前账号所拥有的角色集合
StpUtil.getRoleList();

// 判断：当前账号是否拥有指定角色, 返回 true 或 false
StpUtil.hasRole("super-admin");        

// 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException
StpUtil.checkRole("super-admin");        

// 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]
StpUtil.checkRoleAnd("super-admin", "shop-admin");        

// 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] 
StpUtil.checkRoleOr("super-admin", "shop-admin");        复制到剪贴板错误复制成功1234567891011121314
```

扩展：`NotRoleException` 对象可通过 `getLoginType()` 方法获取具体是哪个 `StpLogic` 抛出的异常

### 拦截全局异常

> 有同学要问，鉴权失败，抛出异常，然后呢？要把异常显示给用户看吗？**当然不可以！**

> 你可以创建一个全局异常拦截器，统一返回给前端的格式，参考：

```java
@RestControllerAdvice
public class GlobalException {

	// 拦截：未登录异常
	@ExceptionHandler(NotLoginException.class)
	public SaResult handlerException(NotLoginException e) {

		// 打印堆栈，以供调试
		e.printStackTrace(); 

		// 返回给前端
		return SaResult.error(e.getMessage());
	}

	// 拦截：缺少权限异常
	@ExceptionHandler(NotPermissionException.class)
	public SaResult handlerException(NotPermissionException e) {
		e.printStackTrace(); 
		return SaResult.error("缺少权限：" + e.getPermission());
	}

	// 拦截：缺少角色异常
	@ExceptionHandler(NotRoleException.class)
	public SaResult handlerException(NotRoleException e) {
		e.printStackTrace(); 
		return SaResult.error("缺少角色：" + e.getRole());
	}

	// 拦截：二级认证校验失败异常
	@ExceptionHandler(NotSafeException.class)
	public SaResult handlerException(NotSafeException e) {
		e.printStackTrace(); 
		return SaResult.error("二级认证校验失败：" + e.getService());
	}

	// 拦截：服务封禁异常 
	@ExceptionHandler(DisableServiceException.class)
	public SaResult handlerException(DisableServiceException e) {
		e.printStackTrace(); 
		return SaResult.error("当前账号 " + e.getService() + 
                              " 服务已被封禁 (level=" + e.getLevel() + ")：" + 
                              e.getDisableTime() + "秒后解封");
	}

	// 拦截：Http Basic 校验失败异常 
	@ExceptionHandler(NotBasicAuthException.class)
	public SaResult handlerException(NotBasicAuthException e) {
		e.printStackTrace(); 
		return SaResult.error(e.getMessage());
	}

	// 拦截：其它所有异常
	@ExceptionHandler(Exception.class)
	public SaResult handlerException(Exception e) {
		e.printStackTrace(); 
		return SaResult.error(e.getMessage());
	}
	
}
```

可参考：[码云：GlobalException.java](https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/current/GlobalException.java)

### [权限通配符](https://sa-token.cc/doc.html#/use/jur-auth?id=权限通配符)

Sa-Token允许你根据通配符指定**泛权限**，例如当一个账号拥有`art.*`的权限时，`art.add`、`art.delete`、`art.update`都将匹配通过

```java
// 当拥有 art.* 权限时
StpUtil.hasPermission("art.add");        // true
StpUtil.hasPermission("art.update");     // true
StpUtil.hasPermission("goods.add");      // false

// 当拥有 *.delete 权限时
StpUtil.hasPermission("art.delete");      // true
StpUtil.hasPermission("user.delete");     // true
StpUtil.hasPermission("user.update");     // false

// 当拥有 *.js 权限时
StpUtil.hasPermission("index.js");        // true
StpUtil.hasPermission("index.css");       // false
StpUtil.hasPermission("index.html");      // false
```

上帝权限：当一个账号拥有 `"*"` 权限时，他可以验证通过任何权限码 （角色认证同理）

> **前端有了鉴权后端还需要鉴权吗**？**需要！**前端的鉴权只是一个辅助功能，对于专业人员这些限制都是可以轻松绕过的，为保证服务器安全，无论前端是否进行了权限校验，后端接口都需要对会话请求再次进行权限校验！

## 踢人下线

所谓踢人下线，核心操作就是找到指定 `loginId` 对应的 `Token`，并设置其失效。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211640153.png" alt="image-20230521164017080" style="zoom:80%;" />

### 强制注销

```java
StpUtil.logout(10001);                  // 强制指定账号注销下线 
StpUtil.logout(10001, "PC");            // 强制指定账号指定端注销下线 
StpUtil.logoutByTokenValue("token");    // 强制指定 Token 注销下线
```

### 踢人下线

```java
StpUtil.kickout(10001);                    // 将指定账号踢下线 
StpUtil.kickout(10001, "PC");              // 将指定账号指定端踢下线
StpUtil.kickoutByTokenValue("token");      // 将指定 Token 踢下线
```

强制注销 和 踢人下线 的区别在于：

- 强制注销等价于对方主动调用了注销方法，再次访问会提示：Token无效。
- 踢人下线不会清除Token信息，而是将其打上特定标记，再次访问会提示：Token已被踢下线。

### 实战案例

```java
@RestController
@RequestMapping("/kickout/")
public class KickoutController {
    
    // 前提：首先调用登录接口进行登录  
    // :8081/kickout/doLogin?name=zhang&pwd=123456
    @PostMapping("doLogin")
    public SaResult doLogin(String name, String pwd) {
        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对
        if("zhang".equals(name) && "123456".equals(pwd)) {
            StpUtil.login(10001);
            return SaResult.ok("登录成功");
        }
        return SaResult.error("登录失败");
    }
    
	// 将指定账号强制注销  ---- :8081/kickout/logout?userId=10001
	@RequestMapping("logout")
	public SaResult logout(long userId) {	
		// 强制注销等价于对方主动调用了注销方法，再次访问会提示：Token无效。
		StpUtil.logout(userId);	
		// 返回
		return SaResult.ok();
	}

	// 将指定账号踢下线   ---- :8081/kickout/kickout?userId=10001
	@RequestMapping("kickout")
	public SaResult kickout(long userId) {
		// 踢人下线不会清除Token信息，而是将其打上特定标记，再次访问会提示：Token已被踢下线。
		StpUtil.kickout(userId);
		// 返回
		return SaResult.ok();
	}

	// 根据 Token 值踢人,已登录账号的token值
    // :8081/kickout/kickoutByTokenValue?tokenValue=xxx-xxx-xx-xx
	@RequestMapping("kickoutByTokenValue")
	public SaResult kickoutByTokenValue(String tokenValue) {
		StpUtil.kickoutByTokenValue(tokenValue);
		// 返回
		return SaResult.ok();
	}
	
}
```



## 登录页面

> 你马上就会发现，写个监控页你一下午就可以搞定，然而这个登录页你却可能需要花上两三天的时间，这是一笔非常不划算的时间浪费

### 坐标依赖

```xml
<dependencies>
    <!-- web支持 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- Sa-Token 权限认证 -->
    <dependency>
        <groupId>cn.dev33</groupId>
        <artifactId>sa-token-spring-boot-starter</artifactId>
        <version>1.34.0</version>
    </dependency>
    <!-- Sa-Token-Quick-Login 插件 -->
    <dependency>
        <groupId>cn.dev33</groupId>
        <artifactId>sa-token-quick-login</artifactId>
        <version>1.34.0</version>
    </dependency>
</dependencies>
```

### 配置文件

```yml
server:
  port: 8080

# Sa-Token-Quick-Login 配置
sa:
  # 登录账号
  name: admin
  # 登录密码
  pwd: 123456
  # 是否自动随机生成账号密码 (此项为true时, name与pwd失效)
  auto: false
  # 是否开启全局认证(关闭后将不再强行拦截)
  auth: true
  # 登录页标题
  title: Asurplus 登录
  # 是否显示底部版权信息
  copr: true
  # 指定拦截路径
  include: /**
  # 指定排除路径
  exclude: /test
```

```properties
spring.profiles.active=a
```

### 访问接口

```java
@RestController
public class TestController {

    // 不需要认证
    @GetMapping("test")
    public String test() {
        return "test";
    }

    // 需要认证
    @GetMapping("test1")
    public String test1() {
        return "test1";
    }
}
```

### 访问测试

**:8080/test**

 **:8080/test1**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211609499.png" alt="image-20230521160945416" style="zoom: 67%;" />

## 记住我

> 如图所示，一般网站的登录界面都会有一个 **`[记住我]`** 按钮，当你勾选它登录后，即使你关闭浏览器再次打开网站，也依然会处于登录状态，无须重复验证密码：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211657689.png" alt="image-20230521165728623" style="zoom:80%;" />

那么在Sa-Token中，如何做到 [ 记住我 ] 功能呢？

### 在 Sa-Token 中实现记住我功能

> Sa-Token的登录授权，**默认就是`[记住我]`模式**，为了实现`[非记住我]`模式，需要在登录时如下设置

```java
// 设置登录账号id为10001，第二个参数指定是否为[记住我]
// 当此值为false后，关闭浏览器后再次打开需要重新登录
StpUtil.login(10001, false);
```

### 实现原理

Cookie作为浏览器提供的默认会话跟踪机制，其生命周期有两种形式，分别是：

- 临时Cookie：有效期为本次会话，只要关闭浏览器窗口，Cookie就会消失。
- 持久Cookie：有效期为一个具体的时间，在时间未到期之前，即使用户关闭了浏览器Cookie也不消失

利用Cookie的此特性，我们便可以轻松实现 [记住我] 模式：

- 勾选 [记住我] 按钮时：调用`StpUtil.login(10001, true)`，在浏览器写入一个`持久Cookie`储存 Token，此时用户即使重启浏览器 Token 依然有效。
- 不勾选 [记住我] 按钮时：调用`StpUtil.login(10001, false)`，在浏览器写入一个`临时Cookie`储存 Token，此时用户在重启浏览器后 Token 便会消失，导致会话失效。

### 前后端分离模式下如何实现[记住我\]

> 此时机智的你😏很快发现一个问题，Cookie虽好，却无法在前后端分离环境下使用，那是不是代表上述方案在APP、小程序等环境中无效？

> 准确的讲，答案是肯定的，任何基于Cookie的认证方案在前后端分离环境下都会失效（原因在于这些客户端默认没有实现Cookie功能），不过好在，这些客户端一般都提供了替代方案， 唯一遗憾的是，此场景中token的生命周期需要我们在前端手动控制：

以经典跨端框架 [uni-app](https://uniapp.dcloud.io/) 为例，我们可以使用如下方式达到同样的效果：

```js
// 使用本地存储保存token，达到 [持久Cookie] 的效果
uni.setStorageSync("satoken", "xxxx-xxxx-xxxx-xxxx-xxx");

// 使用globalData保存token，达到 [临时Cookie] 的效果
getApp().globalData.satoken = "xxxx-xxxx-xxxx-xxxx-xxx";
```

> 如果你决定在PC浏览器环境下进行前后端分离模式开发，那么更加简单：

```js
// 使用 localStorage 保存token，达到 [持久Cookie] 的效果
localStorage.setItem("satoken", "xxxx-xxxx-xxxx-xxxx-xxx");

// 使用 sessionStorage 保存token，达到 [临时Cookie] 的效果
sessionStorage.setItem("satoken", "xxxx-xxxx-xxxx-xxxx-xxx");
```

Remember me, it's too easy!

### 登录时指定 Token 有效期

登录时不仅可以指定是否为`[记住我]`模式，还可以指定一个特定的时间作为 Token 有效时长，如下示例：

```java
// 示例1：
// 指定token有效期(单位: 秒)，如下所示token七天有效
StpUtil.login(10001, new SaLoginModel().setTimeout(60 * 60 * 24 * 7));

// ----------------------- 示例2：所有参数
// `SaLoginModel`为登录参数Model，其有诸多参数决定登录时的各种逻辑，例如：
StpUtil.login(10001, new SaLoginModel()
            // 此次登录的客户端设备类型, 用于[同端互斥登录]时指定此次登录的设备类型
            .setDevice("PC")
            // 是否为持久Cookie（临时Cookie在浏览器关闭时会自动删除，
            // 持久Cookie在重新打开后依然存在）
            .setIsLastingCookie(true)   
            // 指定此次登录token的有效期, 单位:秒 （如未指定，自动取全局配置的 timeout 值）
            .setTimeout(60 * 60 * 24 * 7)    
            // 预定此次登录的生成的Token 
            .setToken("xxxx-xxxx-xxxx-xxxx") 
            // 是否在登录后将 Token 写入到响应头
            .setIsWriteHeader(false));
```

### 实战案例

```java
@RestController
@RequestMapping("/RememberMe/")
public class RememberMeController {

	// 记住我登录  ---- :8081/RememberMe/doLogin?name=zhang&pwd=123456
	@PostMapping("doLogin")
	public SaResult doLogin(String name, String pwd) {
		if("zhang".equals(name) && "123456".equals(pwd)) {
			StpUtil.login(10001, true);
			return SaResult.ok("登录成功");
		}
		return SaResult.error("登录失败");
	}
	
	// 不记住我登录 ---- :8081/RememberMe/doLogin2?name=zhang&pwd=123456
	@PostMapping("doLogin2")
	public SaResult doLogin2(String name, String pwd) {
		if("zhang".equals(name) && "123456".equals(pwd)) {
			StpUtil.login(10001, false);
			return SaResult.ok("登录成功");
		}
		return SaResult.error("登录失败");
	}

	// 七天免登录  ---- :8081/RememberMe/doLogin3?name=zhang&pwd=123456
	@PostMapping("doLogin3")
	public SaResult doLogin3(String name, String pwd) {
		if("zhang".equals(name) && "123456".equals(pwd)) {
			StpUtil.login(10001, 60 * 60 * 24 * 7);
			return SaResult.ok("登录成功");
		}
		return SaResult.error("登录失败");
	}
	
}
```

## 密码加密

严格来讲，密码加密不属于 [权限认证] 的范畴，但是对于大多数系统来讲，密码加密又是安全认证不可或缺的部分， 所以，应大家要求，`Sa-Token`在 v1.14 版本添加密码加密模块，该模块非常简单，仅仅封装了一些常见的加密算法。

### 摘要加密

md5、sha1、sha256

```java
// md5加密 
SaSecureUtil.md5("123456");

// sha1加密 
SaSecureUtil.sha1("123456");

// sha256加密 
SaSecureUtil.sha256("123456");复制到剪贴板错误复制成功12345678
```

### 对称加密

AES加密

```java
// 定义秘钥和明文
String key = "123456";
String text = "Sa-Token 一个轻量级java权限认证框架";

// 加密 
String ciphertext = SaSecureUtil.aesEncrypt(key, text);
System.out.println("AES加密后：" + ciphertext);

// 解密 
String text2 = SaSecureUtil.aesDecrypt(key, ciphertext);
System.out.println("AES解密后：" + text2);复制到剪贴板错误复制成功1234567891011
```

### 非对称加密

RSA加密

```java
// 定义私钥和公钥 
String privateKey = "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAO+wmt01pwm9lHMdq7A8gkEigk0XKMfjv+4IjAFhWCSiTeP7dtlnceFJbkWxvbc7Qo3fCOpwmfcskwUc3VSgyiJkNJDs9ivPbvlt8IU2bZ+PBDxYxSCJFrgouVOpAr8ar/b6gNuYTi1vt3FkGtSjACFb002/68RKUTye8/tdcVilAgMBAAECgYA1COmrSqTUJeuD8Su9ChZ0HROhxR8T45PjMmbwIz7ilDsR1+E7R4VOKPZKW4Kz2VvnklMhtJqMs4MwXWunvxAaUFzQTTg2Fu/WU8Y9ha14OaWZABfChMZlpkmpJW9arKmI22ZuxCEsFGxghTiJQ3tK8npj5IZq5vk+6mFHQ6aJAQJBAPghz91Dpuj+0bOUfOUmzi22obWCBncAD/0CqCLnJlpfOoa9bOcXSusGuSPuKy5KiGyblHMgKI6bq7gcM2DWrGUCQQD3SkOcmia2s/6i7DUEzMKaB0bkkX4Ela/xrfV+A3GzTPv9bIBamu0VIHznuiZbeNeyw7sVo4/GTItq/zn2QJdBAkEA8xHsVoyXTVeShaDIWJKTFyT5dJ1TR++/udKIcuiNIap34tZdgGPI+EM1yoTduBM7YWlnGwA9urW0mj7F9e9WIQJAFjxqSfmeg40512KP/ed/lCQVXtYqU7U2BfBTg8pBfhLtEcOg4wTNTroGITwe2NjL5HovJ2n2sqkNXEio6Ji0QQJAFLW1Kt80qypMqot+mHhS+0KfdOpaKeMWMSR4Ij5VfE63WzETEeWAMQESxzhavN1WOTb3/p6icgcVbgPQBaWhGg==";
String publicKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDvsJrdNacJvZRzHauwPIJBIoJNFyjH47/uCIwBYVgkok3j+3bZZ3HhSW5Fsb23O0KN3wjqcJn3LJMFHN1UoMoiZDSQ7PYrz275bfCFNm2fjwQ8WMUgiRa4KLlTqQK/Gq/2+oDbmE4tb7dxZBrUowAhW9NNv+vESlE8nvP7XXFYpQIDAQAB";

// 文本
String text = "Sa-Token 一个轻量级java权限认证框架";

// 使用公钥加密
String ciphertext = SaSecureUtil.rsaEncryptByPublic(publicKey, text);
System.out.println("公钥加密后：" + ciphertext);

// 使用私钥解密
String text2 = SaSecureUtil.rsaDecryptByPrivate(privateKey, ciphertext);
System.out.println("私钥解密后：" + text2); 复制到剪贴板错误复制成功1234567891011121314
```

你可能会有疑问，私钥和公钥这么长的一大串，我怎么弄出来，手写吗？当然不是，调用以下方法生成即可

```java
// 生成一对公钥和私钥，其中Map对象 (private=私钥, public=公钥)
System.out.println(SaSecureUtil.rsaGenerateKeyPair());复制到剪贴板错误复制成功12
```

### Base64编码与解码

```java
// 文本
String text = "Sa-Token 一个轻量级java权限认证框架";

// 使用Base64编码
String base64Text = SaBase64Util.encode(text);
System.out.println("Base64编码后：" + base64Text);

// 使用Base64解码
String text2 = SaBase64Util.decode(base64Text);
System.out.println("Base64解码后：" + text2); 
```

### BCrypt加密

由它加密的文件可在所有支持的操作系统和处理器上进行转移

它的口令必须是8至56个字符，并将在内部被转化为448位的密钥

```java
// 使用方法
String pw_hash = BCrypt.hashpw(plain_password, BCrypt.gensalt()); 

// 使用checkpw方法检查被加密的字符串是否与原始字符串匹配：
BCrypt.checkpw(candidate_password, stored_hash); 

// gensalt方法提供了可选参数 (log_rounds) 来定义加盐多少，也决定了加密的复杂度:
String strong_salt = BCrypt.gensalt(10);
String stronger_salt = BCrypt.gensalt(12); 
```



## 集成Redis

### 依赖坐标

```xml
<dependencies>
    <!-- web支持 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- Sa-Token 权限认证 -->
    <dependency>
        <groupId>cn.dev33</groupId>
        <artifactId>sa-token-spring-boot-starter</artifactId>
        <version>1.34.0</version>
    </dependency>
    <!-- Sa-Token 整合 Redis （使用 jdk 默认序列化方式） -->
    <dependency>
        <groupId>cn.dev33</groupId>
        <artifactId>sa-token-dao-redis</artifactId>
        <version>1.34.0</version>
    </dependency>
    <!-- 提供Redis连接池 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
</dependencies>
```

### 配置文件

```yml
# Sa-Token配置
sa-token:
  # token 名称 (同时也是cookie名称)
  token-name: satoken
  # token 有效期，单位s 默认30天, -1代表永不过期
  timeout: 2592000
  # token 临时有效期 (指定时间内无操作就视为token过期) 单位: 秒
  activity-timeout: -1
  # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录)
  is-concurrent: true
  # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token,
  # 为false时每次登录新建一个token)
  is-share: false
  # token风格
  token-style: uuid
  # 是否输出操作日志
  is-log: true

spring:
  # redis配置
  redis:
    # Redis数据库索引（默认为0）
    database: 1
    # Redis服务器地址
    host: 127.0.0.1
    # Redis服务器连接端口
    port: 6379
    # Redis服务器连接密码（默认为空）
    # password:
    # 连接超时时间
    timeout: 10s
    lettuce:
      pool:
        # 连接池最大连接数
        max-active: 200
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1ms
        # 连接池中的最大空闲连接
        max-idle: 10
        # 连接池中的最小空闲连接
        min-idle: 0
```

### 登录接口

```java
// 登录测试
@RestController
@RequestMapping("/acc/")
public class LoginController {

    // 测试登录  ---- :8081/acc/doLogin?name=zhang&pwd=123456
    @PostMapping("doLogin")
    public SaResult doLogin(String name, String pwd) {
        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对
        if("zhang".equals(name) && "123456".equals(pwd)) {
            StpUtil.login(10001);
            return SaResult.ok("登录成功");
        }
        return SaResult.error("登录失败");
    }

    // 查询登录状态  ---- :8081/acc/isLogin
    @GetMapping("isLogin")
    public SaResult isLogin() {
        return SaResult.ok("是否登录：" + StpUtil.isLogin());
    }

    // 查询 Token 信息  ---- :8081/acc/tokenInfo
    @GetMapping("tokenInfo")
    public SaResult tokenInfo() {
        return SaResult.data(StpUtil.getTokenInfo());
    }

    // 测试注销  ---- :8081/acc/logout
    @PostMapping("logout")
    public SaResult logout() {
        StpUtil.logout();
        return SaResult.ok();
    }

}
```

> **集成 Redis 后，是我额外手动保存数据，还是框架自动保存？**
> 框架自动保存。集成 `Redis` 只需要引入对应的 `pom依赖` 即可，**框架所有上层 API 保持不变**。

> **集成包版本问题**
> Sa-Token-Redis 集成包的版本尽量与 Sa-Token-Starter 集成包的版本一致，否则可能出现兼容性问题。

### 运行测试

:8081/acc/doLogin?name=zhang&pwd=123456

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305211652215.png" alt="image-20230521165241157" style="zoom:80%;" />







# 第三方登录⭐

https://github.com/justauth/JustAuth

https://www.justauth.cn/guide/



# 分布式Session

我们之前实现Java的会话管理功能，主要是使用Cookie或Session。

> - Cookie是客户端技术，服务器把数据以cookie的形式保存在用户的浏览器中
> - Session是服务器端技术，服务器把数据以session的形式保存在服务器中

> 在分布式情况下，session会失效，比如项目部署在多台服务器中，服务器之间无法共享session，用户在A服务器上已经登录了，但当负载均衡跳转到服务器B时，由于B服务器并没有用户的登录信息，session就失效了，用户就退出了登录。一旦服务器关闭或重启也会导致session会话失效，因此如果项目部署在多台服务器中，就需要解决session共享的问题。

> 这个时候我们可以使用Spring Session技术，Spring Session 就是使用Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据同步到Redis 中，或者自动的从 Redis 中读取数据。

## 依赖配置

```xml
<!--session-redis-->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

```yml
spring:
  redis:
    port: 6379
    host: localhost
```

## 配置类

```java
@Configuration
//设置session过期时间,默认是1800秒
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 31 * 60)
public class HttpSessionConfig {

    @Bean
    public static ConfigureRedisAction configureRedisAction(){
        return ConfigureRedisAction.NO_OP;
    }
    // 序列化，避免存入redis时出现乱码
    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
}
```

## 实体类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User implements Serializable {
    private Integer id;
    private String username;
    private String password;
}
```

## 登录接口

> spring-session会自动帮我们把session存入redis中，我们只需要对session进行简单操作即可，登陆成功后，可以看到session已经保存到了redis中。
>

```java
@PostMapping("/login")
public String login(HttpServletRequest request,
                    @RequestParam("username") String username,
                    @RequestParam("password") String password){
    // 从数据库中查询，这里不查了，直接用
    // User user = userService.checkUser(username, password);
    User user = new User(1,username,password);
    HttpSession session = request.getSession();
    if (user != null){
        session.setAttribute("userLogin", user);
        return "登录成功";
    }else {
        return "登录失败";
    }
}
```

:8080/login

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206232302917.png" alt="image-20220623230229833" style="zoom:67%;" />

## Redis查询测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206232303829.png" alt="image-20220623230348731" style="zoom:80%;" />



## 查询用户测试

> 测试从redis中获取session，然后从session中获取用户信息。spring-session会自动帮我们从redis取出session

```java
@GetMapping("/getUser")
public User getSession(HttpServletRequest request){
    HttpSession session = request.getSession();
    return (User) session.getAttribute("userLogin");
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206232302174.png" alt="image-20220623230257100" style="zoom:67%;" />































