



# Cookie Session Token⭐

## cookie

> Cookie 总是保存在客户端中，按在客户端中的存储位置，可分为内存 Cookie 和硬盘 Cookie。内存 Cookie 由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的；硬盘 Cookie 保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘 Cookie 不会被删除，其存在时间是长期的。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211025424.png" alt="image-20220821102531322" style="zoom:67%;" />

### cookie 定义和作用

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

通常 Cookie 用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车等其它需要记录的信息）；
- 个性化设置（如用户自定义设置、主题等）；
- 浏览器行为跟踪（如跟踪分析用户行为等）。

- `cookie` 最开始被设计出来是为了弥补HTTP在状态管理上的不足。
- `cookie 存储在客户端`：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- `cookie 是不可跨域的`：每个 cookie 都会绑定单一的域名（包括子域），无法在别的域名下获取使用。

### 服务端创建 cookie

当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。

浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求都通过  Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

服务器向客户端发送 Cookie 是通过 HTTP 响应报文实现的，在 Set-Cookie 中设置需要向客户端发送的cookie，cookie格式如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211027110.png" alt="image-20220821102758971" style="zoom:67%;" />

服务器使用 Set-Cookie 响应头部向用户浏览器发送 Cookie 信息。

一个简单的 Cookie 可能像这样：

```
Set-Cookie: <cookie名>=<cookie值>

HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
```

客户端对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

我来访问下淘宝网，抓个包看看这个真实的过程：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211031214.png" alt="image-20220821103140075" style="zoom:67%;" />

### cookie 工作流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207212313196.png" alt="image-20220721231310105" style="zoom:67%;" />

（1）浏览器向服务器发送请求；

（2）服务器响应请求，向浏览器设置 cookie；

（3）浏览器将 cookie 存在本地，下一次请求带上该 cookie；

（4）服务器响应请求。

### 存在问题

Cookie 常用来标记用户或授权会话，被浏览器发出之后可能被劫持，被用于非法行为，可能导致授权用户的会话受到攻击，因此存在安全问题。

还有一种情况就是跨站请求伪造 CSRF，简单来说，比如你在登录银行网站的同时，登录了一个钓鱼网站，在钓鱼网站进行某些操作时可能会获取银行网站相关的 Cookie 信息，向银行网站发起转账等非法行为。

> 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。
>
> 跨站请求攻击（XSS），简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件、发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。
>
> 与跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

不过这种情况有很多解决方法，特别对于银行这类金融性质的站点，用户的任何敏感操作都需要确认，并且敏感信息的 Cookie 只能拥有较短的生命周期。

同时 Cookie 有容量和数量的限制，每次都要发送很多信息带来额外的流量消耗、复杂的行为 Cookie 无法满足要求。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211033978.png" alt="image-20220821103333873" style="zoom:67%;" />

特别注意：以上存在的问题只是 Cookie 被用于实现交互状态时存在的问题，但并不是说 Cookie 本身的问题。试想一下：菜刀可以用来做菜，也可以被用来从事某些暴力行为，你能说菜刀应该被废除吗？



## Session

### session机制概念

> 如果说 Cookie 是客户端行为，那么 Session 就是服务端行为。session 翻译过来就是『会话』。用户打开一个浏览器, 点击多个超链接, 访问服务器多个web资源, 然后关闭浏览器, 整个过程称之为一个会话。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211035682.png" alt="image-20220821103544551" style="zoom: 67%;" />

> Cookie 机制在最初和服务端完成交互后，保持状态所需的信息都将存储在客户端，后续直接读取发送给服务端进行交互。
>

> Session 代表服务器与浏览器的一次会话过程，并且完全由服务端掌控，实现分配 ID、会话信息存储、会话检索等功能。Session 机制将用户的所有活动信息、上下文信息、登录信息等都存储在服务端，只是生成一个唯一标识 ID 发送给客户端，后续的交互将没有重复的用户信息传输，取而代之的是唯一标识 ID，暂且称之为 Session-ID 吧。
>

### 简单的交互流程

> 当客户端第一次请求 session 对象时候，服务器会为客户端创建一个 session，并将通过特殊算法算出一个 session 的 ID，用来标识该 session 对象。

> 当浏览器下次请求别的资源的时候，浏览器会将 sessionID 放置到请求头中，服务器接收到请求后解析得到 sessionID，服务器找到该 id 的 session 来确定请求方的身份和一些上下文信息。

### Session实现方式

> 首先明确一点，Session 和 Cookie 没有直接的关系，可以认为 Cookie 只是实现 Session 机制的一种方法途径而已，没有 Cookie 还可以用别的方法。
>

> Session 和 Cookie 的关系就像加班和加班费的关系，看似关系很密切，实际上没啥关系。

> session 的实现主要两种方式：cookie 与 url 重写，而 cookie 是首选方式，因为各种现代浏览器都默认开通 cookie 功能，但是每种浏览器也都有允许 cookie 失效的设置，因此对于 Session 机制来说还需要一个备胎
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211041900.png" alt="image-20220821104106779" style="zoom:67%;" />

将会话标识号以参数形式附加在超链接 URL 地址后面的技术称为 URL 重写。

```c
//原始的 URL：
http://taobao.com/getitem?name=baymax&action=buy
//重写后的 URL:
http://taobao.com/getitem?sessionid=1wui87htentg&?name=baymax&action=buy
```

### 存在的问题

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211054636.png" alt="image-20220821105451523" style="zoom:67%;" />

> 由于 Session 信息是存储在服务端的，因此如果用户量很大的场景，Session 信息占用的空间就不容忽视。对于大型网站必然是集群化&分布式的服务器配置，如果 Session 信息是存储在本地的，那么由于负载均衡的作用，原来请求机器 A 并且存储了 Session 信息，下一次请求可能到了机器 B，此时机器 B 上并没有 Session 信息。
>

> 这种情况下要么在 B 机器重复创建造成浪费，要么引入高可用的 Session 集群方案，引入 Session 代理实现信息共享，要么实现定制化哈希到集群 A，这样做其实就有些复杂了。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211055534.png" alt="image-20220821105541412" style="zoom:67%;" />



## token 

> Token 是令牌的意思，由服务端生成并发放给客户端，是一种具有时效性的验证身份的手段。Token 避免了 Session 机制带来的海量信息存储问题，也避免了 Cookie 机制的一些安全性问题，在现代移动互联网、跨域访问等场景有广泛的用途。
>

### 交互流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211057174.png" alt="image-20220821105733052" style="zoom:67%;" />

> - 客户端将用户的账号和密码提交给服务器
> - 服务器对其进行校验，通过则生成一个 token 值返回给客户端，作为后续的请求交互身份令牌
> - 客户端拿到服务端返回的 token 值后，可将其保存在本地，以后每次请求服务器时都携带该 token，提交给服务器进行身份校验；
> - 服务器接收到请求后，解析关键信息，再根据相同的加密算法、密钥、用户参数生成 sign 与客户端的 sign 进行对比，一致则通过，否则拒绝服务；
> - 验证通过之后，服务端就可以根据该 Token 中的 uid 获取对应的用户信息，进行业务请求的响应

### Token 设计思想

以 JSON Web Token（JWT）为例，Token 主要由 3 部分组成：

- Header 头部信息
  记录了使用的加密算法信息；
- Payload 净荷信息
  记录了用户信息和过期时间等；
- Signature 签名信息
  根据 header 中的加密算法和 payload 中的用户信息以及密钥 key 来生成，是验证服务端的重要依据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208211144131.png" alt="image-20220821114449004" style="zoom:67%;" />

header 和 payload 的信息不做加密，只做一般的 base64 编码，服务端收到 token 后，剥离出 header 和 payload 获取算法、用户、过期时间等信息，然后根据自己的加密密钥来生成 sign，并与客户端传来的 sign 进行一致性对比，来确定客户端的身份合法性。

这样就实现了用 CPU 加解密的时间换取存储空间，同时服务端密钥的重要性就显而易见，一旦泄露整个机制就崩塌了，这个时候就需要考虑 HTTPS 了。

### Token 方案的特点

- Token 可以跨站共享，实现单点登录；
- Token 机制无需太多存储空间，Token 包含了用户的信息，只需在客户端存储状态信息即可，对于服务端的扩展性很好；
- Token 机制的安全性依赖于服务端加密算法和密钥的安全性；
- Token 机制也不是万金油。



在分布式微服务技术日趋流行的今天，大型网站的设计都尽量避免使用 session 实现 HTTP 状态化。

> session简单粗暴，在服务端维护会话信息，在客户端保存session id，服务端能够轻易地把会话控制在自己的手中，但服务集群化产生了session共享的负担；

> jwt（token）只在客户端保存会话信息，服务端通过密钥校验会话，（相比session）拿时间换空间，卸下了服务端集群共享会话信息的负担，同时也加大了服务端控制会话的难度。

> Cookie、Session、Token 这三者是不同发展阶段的产物，并且各有优缺点，三者也没有明显的对立关系，反而常常结伴出现，这也是容易被混淆的原因。

> Cookie 侧重于信息的存储，主要是客户端行为，Session 和 Token 侧重于身份验证，主要是服务端行为。三者方案在很多场景都还有生命力，了解场景才能选择合适的方案，没有银弹。





##  Session和Cookie的区别

**我们先来看Session和Cookie的概念吧：**

Cookie是保存在`客户端`的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务器就是根据这个Cookie来确认身份的。

Session指的就是`服务器和客户端一次会话的过程`。Session利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。

**Session 和Cookie的区别主要有这些：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206301021500.png" alt="image-20220630102127439" style="zoom:80%;" />

来看个图吧：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206301021584.png" alt="image-20220630102156512" style="zoom: 67%;" />

> - 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入Cookie中，同时Cookie记录此SessionID是属于哪个域名。
> - 当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据 SessionID查找对应的 Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。



## Cookie Session Token详解

[熬夜彻底搞懂Cookie Session Token JWT ](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247496583&idx=1&sn=d2de2aaf82aa4e96107f9653d9ec3aca&chksm=cf222caef855a5b8f6a6fbed93ae8cb6fdc127e5664703d2db44da7870a5af1040cb413ed800&mpshare=1&scene=23&srcid=07206xvYjBz0dNuEgejopy6o&sharer_sharetime=1658329065447&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

[聊聊Cookie、Session、Token背后的故事](https://mp.weixin.qq.com/s?__biz=MzI1MzYzMTI2Ng==&mid=2247486329&idx=1&sn=d20114c694a65069002769a70792d73d&chksm=e9d0c534dea74c223234c68022afdd30189baaa498204522d45ed971ae38a78cf390949bc42b&mpshare=1&scene=23&srcid=1208oaQ6uBX8r6jmSyScAtkO&sharer_sharetime=1670430263727&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> **一切的根源就是因为 HTTP 是一个无状态的协议。**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212101139045.png" alt="image-20221210113932884" style="zoom:50%;" />

网站交互体验升级

作为网友的我们，每天都会使用浏览器来逛各种网站，来满足日常的工作生活需求。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212101141578.png" alt="image-20221210114158414" style="zoom:50%;" />

现在的交互体验还是很丝滑的，但早期并非如此，而是一锤子买卖。

#### HTTP 是一个无状态的协议

无状态的http协议是什么鬼？

HTTP无状态协议，是指协议对于业务处理没有记忆能力，之前做了啥完全记不住，每次请求都是完全独立互不影响的，没有任何上下文信息。

缺少状态意味着如果后续处理需要前面的信息，则它必须重传关键信息，这样可能导致每次连接传送的数据量增大。

如果大家没明白，可以想一下《夏洛特烦恼》里面的桥段：

> 夏洛：大爷，楼上322住的是马冬梅家吗？
> 大爷：马冬什么？
> 夏洛：马冬梅。
> 大爷：什么冬梅啊？
> 夏洛：马冬梅啊。
> 大爷：马什么梅啊？
> 夏洛：……行，大爷，您先凉快吧。

「打岔」大爷记不住马冬梅，就如同 HTTP 协议记不住上一次请求。说得通俗一点：HTTP 的记忆力不太好，需要借助『助听器』。

记忆力不好的优点就是一个字「快」；缺点也很明显，需要借靠 `cookie`、`session` 、`token`等机制将客户端多次请求关联起来。

大概明白了吧，假如一直用这种原生无状态的 http 协议，我们每换一个页面可能就得重新登录一次，那还玩个球。

所以必须要解决 http 协议的无状态，提升网站的交互体验，否则星辰大海是去不了的。

在讲解`cookie`、`session` 、`token`前我们先简单讲解两个概念：`认证`、`授权`。

#### 解决之道

整个事情交互的双方只有客户端和服务端，所以必然要在这两个当事者身上下手。

**客户端来买单**

> 客户端每次请求时把自己必要的信息封装发送给服务端，服务端查收处理一下就行。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212101146445.png" alt="image-20221210114646299" style="zoom:67%;" />

**服务端来买单**

> 客户端第一次请求之后，服务端就开始做记录，然后客户端在后续请求中只需要将最基本最少的信息发过来就行，不需要太多信息了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaeduHjZ3hQO8VLRdhqqNIPGprPjMan9JGLHFJclbVuuGXMcQC2icDEycBnH3d4zd8r0eMhsOxtb5w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



#### 认证和授权

##### 什么是认证

认证（Authentication）简单来讲就是**验证当前者的身份**，证明`你是你自己`。

最常见的认证方式是通过`用户名`和`密码`，除此之外还有：

- 通过用户手机：手机短信、手机二维码扫描、手势密码
- 用户的电子邮箱
- 身份证号码
- 基于时间序列和用户相关的一次性口令
- 用户的生物学特征：指纹、语音、眼睛虹膜等

为了确认用户的身份，防止请求伪造，在安全要求高的场合，经常会使用组合认证（也叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。

##### 什么是授权

授权（Authorization）简单来讲就是`授予第三方访问用户资源的权限`。

在互联网应用开发中，主要通过下面几种方式实现授权：

- 通过 session 机制，`一个访问会话保持着用户的授权信息`
- 通过 cookie 机制，`一个网站的 cookie 保持着用户的授权信息`
- 颁发授权令牌（token），`一个合法有效的令牌中保持着用户的授权信息`





## 分布式session

### 问题分析

这种机制在单体应用时代应用非常广泛，但是，随着分布式时代的到来，Session 的缺点也逐渐暴露出来。

举个例子，比如我们有多个服务器，客户端 1 向服务器发送了一个请求，由于负载均衡的存在，该请求被转发给了服务器 A，于是服务器 A 创建并存储了这个 Session

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206281541856.png" alt="image-20220628154112778" style="zoom:67%;" />

紧接着，客户端 1 又向服务器发送了一个请求，但是这一次请求被负载均衡给了服务器 B，而服务器 B 这时候是没有存储服务器 A 的 Session 的，这就导致 Session 的失效。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206281541882.png" alt="image-20220628154138811" style="zoom:67%;" />

明明用户在上一个界面还是登录的，跳到下一个界面就退出登录了，这显然不合理。

当然了，对此的解决方法其实也有很多种，其实就是如何解决 Session 在多个服务器之间的共享问题：

### Session Replication

这个是最容易想到的，既然服务器 B 没有服务器 A 存储的 Session，那各个服务器之间同步一下 Session 数据不就完了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206281542247.png" alt="image-20220628154208178" style="zoom:67%;" />

这种方案存在的问题也是显而易见的：

1. 同步 Session 数据带来了额外的网络带宽开销。只要 Session 数据有变化，就需要将数据同步到所有其他机器上，机器越多，同步带来的网络带宽开销就越大。
2. 每台Web服务器都要保存所有 Session 数据，如果整个集群的 Session 数据很多（比如很多人同时访问网站的情况），每台服务器用于保存 Session 数据的内存占用会非常严重。

### Session Sticky

从名称也能看出来，Sticky，`即让负载均衡器能够根据每次的请求的会话标识来进行请求的转发，保证一个会话中的每次请求都能落到同一台服务器上面。`

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206281542723.png" alt="image-20220628154235645" style="zoom: 67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206281542591.png" alt="image-20220628154255520" style="zoom:67%;" />

存在问题的：

1. `如果某台服务器宕机或者重启了，那么它上面存储的 Session 数据就丢失了，用户就需要重新进行登陆。`
2. `负载均衡器变为一个有状态的节点，因为他需要保存 Session 到具体服务器的映射，和之前无状态的节点相比，内存消耗会更大，容灾方面会更麻烦。`

### Session 数据集中存储

借助外部存储（Redis、MySQL 等），将 Session 数据进行集中存储，然后所有的服务器都从这个外部存储中拿 Session

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208102243833.png" alt="image-20220628162224868" style="zoom:67%;" />

存在的问题也很显然：

- 过度依赖外部存储，如果集中存储 Session 的外部存储机器出问题了，就会直接影响到我们的应用

### ThreadLocal(推荐)

事实上，无论采用何种方案，使用 Session 机制，会使得服务器集群很难扩展，因此，Session 适用于中小型 Web 应用程序。对于大型 Web 应用程序来说，通常需要避免使用 Session 机制。

So，在 Echo 项目中，我们决定摒弃 Session，一个 ThreadLocal 解决所有问题（狗头）！

ThreadLocal 线程本地内存，很好理解，就是每个访问 ThreadLocal 变量的线程都有自己的一个 “本地” 实例副本，每个线程之间互相隔离，互不干涉。

这里我就不详细解释底层原理了，ThreadLocal 适用于如下两种场景：

> - 每个线程需要有自己单独的实例（数据）
> - 实例（数据）需要在多个方法中共享，但不希望被多线程共享

来看如何用 ThreadLocal 实现我们的需求：显示登录信息，在本次请求中持有当前用户数据。

首先我们需要明白的是，ThreadLocal 只跟其归属的线程有关，线程死亡了，那么它对应的 ThreadLocal 中存储的信息也就被清除了（线程死亡前一定要释放掉绑定的用户数据，不然会出现 OOM 问题），也就是说，ThreadLocal 只用于在本次请求中持有数据。

简单来说，我们把用户数据存入 `ThreadLocal` 里，这样，只要本次请求未处理完，这个线程就一直还在，当前用户数据就一直被持有，当服务器对本次请求做出响应后，这个线程就会被销毁。

`那同一个用户发出的两次请求可能被不同的两个线程进行处理，如何使得这个两个线程的 ThreadLocal 持有相同的用户信息呢？`

答案：过滤器。

> 具体来说，我们定义一个过滤器，在每次请求前都对用户进行判断（为了避免每次请求都经过过滤器，可以将登录成功的用户信息暂时存储到 Redis 中），然后将已经登录成功的用户信息存到 ThreadLocal 里，从而使得该线程在本次请求中持有该用户信息。



# token

## 生成token

### 实体类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User implements Serializable {
    private Integer id;
    private String username;
    private String password;
}
```

### java-jwt

```xml
<!-- https://mvnrepository.com/artifact/com.auth0/java-jwt -->
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.4.0</version>
</dependency>
```

```java
@Slf4j
public class JWTUtil {

    // 设置有效时间和签名密钥
    private static long tokenExpiration = 365 * 24 * 60 * 60 * 1000;
    private static final String TOKEN_SECRET = "123456";

    // 生成token，自定义过期时间 毫秒
    public static String generateToken(User user) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            // 私钥和加密算法
            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);
            // 设置头部信息
            Map<String, Object> header = new HashMap<>(2);
            header.put("Type", "Jwt");
            header.put("alg", "HS256");
            return JWT.create()
                    .withHeader(header)
                    .withClaim("token", mapper.writeValueAsString(user))
                    .withExpiresAt(new Date(System.currentTimeMillis() + 
                                            tokenExpiration))
                    .sign(algorithm);
        } catch (Exception e) {
            log.error("生成token失败，失败的原因是:{}", e);
            return null;
        }
    }

    // 检验token是否正确
    public static User parseToken(String token) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);
            JWTVerifier verifier = JWT.require(algorithm).build();
            DecodedJWT jwt = verifier.verify(token);
            String tokenInfo = jwt.getClaim("token").asString();
            return mapper.readValue(tokenInfo, User.class);
        } catch (JsonProcessingException e) {
            log.error("token已经过期");
        }
        return null;
    }

    public static void main(String[] args) {
        // 生成token
        String token = generateToken(new User(1,"renshuo","123456"));
        System.out.println(token);
        // 验证token
        User user = parseToken(token);
        System.out.println(user);
    }

}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305212159176.png" alt="image-20230521215933124" style="zoom:80%;" />

### jjwt

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

```java
public class JwtHelper {
    // 设置有效时间和签名密钥
    private static long tokenExpiration = 365 * 24 * 60 * 60 * 1000;
    private static String tokenSignKey = "123456";
    
    // 根据用户ID和用户名称生成token字符串
    public static String createToken(Long userId, String username) {
        String token = Jwts.builder()
                .setSubject("AUTH-USER") // 分类
                // 设置token有效时长
                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))
                // 设置主体
                .claim("userId", userId)
                .claim("username", username)
                .signWith(SignatureAlgorithm.HS512, tokenSignKey)
                .compressWith(CompressionCodecs.GZIP)
                .compact();
        return token;
    }

    // 从生成的token中获取用户ID
    public static Long getUserId(String token) {
        try {
            if (StringUtils.isEmpty(token)) return null;
            Jws<Claims> claimsJws = Jwts.parser().setSigningKey(tokenSignKey)
                                        .parseClaimsJws(token);
            Claims claims = claimsJws.getBody();
            Integer userId = (Integer) claims.get("userId");
            return userId.longValue();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    
    // 从生成的token中获取用户名称
    public static String getUsername(String token) {
        try {
            if (StringUtils.isEmpty(token)) return "";

            Jws<Claims> claimsJws = Jwts.parser().setSigningKey(tokenSignKey)
                    .parseClaimsJws(token);
            Claims claims = claimsJws.getBody();
            return (String) claims.get("username");
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    // 测试
    public static void main(String[] args) {
        String token = JwtHelper.createToken(1L, "admin");
        System.out.println(token);
        System.out.println(JwtHelper.getUserId(token));
        System.out.println(JwtHelper.getUsername(token));
    }
}
```



# 登录实战⭐

## 基础准备

### 数据库表

```sql
create database xue;
use xue;
drop table if exists `tb_user`;
create table `tb_user`  (
  `id` bigint(20) unsigned not null auto_increment comment '主键',
  `phone` varchar(11) not null comment '手机号码',
  `password` varchar(128) null default '' comment '密码，加密存储',
  `nick_name` varchar(32) null default '' comment '昵称，默认是用户id',
  `icon` varchar(255) null default '' comment '人物头像',
  `create_time` timestamp not null default current_timestamp comment '创建时间',
  `update_time` timestamp not null default current_timestamp on update 
    current_timestamp comment '更新时间',
  primary key (`id`) using btree,
  unique index `unique_key_phone`(`phone`) using btree
) engine = innodb auto_increment = 1 ;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221421870.png" alt="image-20230522142141816" style="zoom:80%;" />

```sql
insert into `tb_user`(id,phone,password,nick_name,icon) values
(1, '13686869696', '', '小鱼同学', '/imgs/blogs/blog1.jpg'),
(2, '13838411438', '', '可可今天不吃肉','/imgs/icons/kkjtbcr.jpg'),
(4, '13456789011', '', '人生大事', '/imgs/icons/kkjtbcr1.jpg'),
(5, '13456789001', '', '毛遂自建', '/imgs/icons/kkjtbcr2.jpg');
```

### 坐标依赖

```xml
<dependencies>
    <!--spring-data-redis-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <!--commons-pool2连接池-->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    <!--spring-boot-starter-web-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--mysql-connector-java-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!--lombok-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <!--spring-boot-starter-test-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <!--mybatis-plus-->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.4.3</version>
    </dependency>
    <!--hutool-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.7.17</version>
    </dependency>
</dependencies>
```

### 连接配置

```yml
server:
  port: 8081
spring:
  application:
    name: hmdp
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/xue?useSSL=false&serverTimezone=UTC
    username: root
    password: 123456
  redis:
    host: 127.0.0.1
    port: 6379
    # password: 123321
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段
mybatis-plus:
  type-aliases-package: com.hmdp.entity # 别名扫描包，在xml中写SQL有效
logging:
  level:
    com.hmdp: debug
```

### 统一返回结果

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Boolean success;
    private String errorMsg;
    private Object data;
    private Long total;

    public static Result ok(){
        return new Result(true, null, null, null);
    }
    public static Result ok(Object data){
        return new Result(true, null, data, null);
    }
    public static Result ok(List<?> data, Long total){
        return new Result(true, null, data, total);
    }
    public static Result fail(String errorMsg){
        return new Result(false, errorMsg, null, null);
    }
}
```

### 正则工具类

```java
public abstract class RegexPatterns {
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = 
                  "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = 
                  "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";

}
```

```java
public class RegexUtils {
    /**
     * 是否是无效手机格式
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, RegexPatterns.PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, RegexPatterns.EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, RegexPatterns.VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}
```

### User实体类和工具类

登录完成返回实体类

```java
@Data
public class UserDTO {
    private Long id;
    private String nickName;
    private String icon;
}
```

```java
@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("tb_user")
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    //主键
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    //手机号码
    private String phone;
    //密码，加密存储
    private String password;
    //昵称，默认是随机字符
    private String nickName;
    //用户头像
    private String icon;
    //创建时间
    private LocalDateTime createTime;
    //更新时间
    private LocalDateTime updateTime;
}
```

登录实体类

```java
@Data
public class LoginFormDTO {
    private String phone;
    private String code;
    private String password;
}
```

### controller

```java
@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    @Resource
    private IUserService userService;

    @Resource
    private IUserInfoService userInfoService;

    // 发送手机验证码
    @PostMapping("code")
    public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {
        // TODO 发送短信验证码并保存验证码
        return Result.fail("功能未完成");
    }

    // 登录功能：loginForm 登录参数，包含手机号、验证码；或者手机号、密码
    @PostMapping("/login")
    public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){
        // TODO 实现登录功能
        return Result.fail("功能未完成");
    }

    // 登出功能
    @PostMapping("/logout")
    public Result logout(){
        // TODO 实现登出功能
        return Result.fail("功能未完成");
    }

    @GetMapping("/me")
    public Result me(){
        // TODO 获取当前登录的用户并返回
        return Result.fail("功能未完成");
    }

    @GetMapping("/info/{id}")
    public Result info(@PathVariable("id") Long userId){
        // 查询详情
        UserInfo info = userInfoService.getById(userId);
        if (info == null) {
            // 没有详情，应该是第一次查看详情
            return Result.ok();
        }
        info.setCreateTime(null);
        info.setUpdateTime(null);
        // 返回
        return Result.ok(info);
    }
}
```

## Session登录

### 登录流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314144723213.png" alt="image-20220314144723213" style="zoom:80%;" />

### 发送验证码

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171026832.png" alt="image-20220717102638699" style="zoom:80%;" />

```java
@PostMapping("code")
public Result sendCode(@RequestParam("phone") String phone, 
                       HttpSession session) {
    // TODO 发送短信验证码并保存验证码
    return userService.sendCode(phone,session);
}
```

```java
public interface IUserService extends IService<User> {
   Result sendCode(String phone, HttpSession session);
}
```

```java
// UserServiceImpl
@Override
public Result sendCode(String phone, HttpSession session) {
    //1、校验手机号：正则"^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$"
    //   该正则是自己定义的工具类
    if (RegexUtils.isPhoneInvalid(phone)) {
        //2、如果不符合，返回错误信息
        return Result.fail("手机号格式错误");
    }
    //3、符合，生成验证码,RandomUtil是hutool工具包
    String code = RandomUtil.randomNumbers(6);
    
    //4、保存验证码用session
    session.setAttribute("code",code);

    //5、发送验证码
    log.debug("发送验证码成功，验证码：{}",code);
    
    //返回ok，发送成功
    return Result.ok();
}
```

> 功能测试：http://127.0.0.1:8081/user/code

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221510334.png" alt="image-20230522151012267" style="zoom:80%;" />

### 登录功能实现

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171033024.png" alt="image-20220717103326930" style="zoom:67%;" />

#### entity

> LoginFormDTO：登录的表单信息

```java
@Data
public class LoginFormDTO {
    private String phone;
    private String code;
    private String password;
}
```

> UserDTO：返回的数据信息，不能带密码

```java
@Data
public class UserDTO {
    private Long id;
    private String nickName;
    private String icon;
}
```

#### UserController

```java
@PostMapping("login")
public Result login(@RequestBody LoginFormDTO loginForm,
                    HttpSession session){
    // TODO 实现登录功能
    return userService.login(loginForm,session);
}
```

#### IUserService

```java
public interface IUserService extends IService<User> {
	// 发送验证码
    Result sendCode(String phone, HttpSession session);
  	// 登录功能
    Result login(LoginFormDTO loginForm, HttpSession session);
}
```

#### UserServiceImpl

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
    //1、先校验手机号
    String phone = loginForm.getPhone();
    if (RegexUtils.isPhoneInvalid(phone)) {
        //2、如果不符合，返回错误信息
        return Result.fail("手机号格式错误");
    }
    //2、再校验验证码，从session取出验证码，再和输入的验证码进行比较
    Object cacheCode = session.getAttribute("code");   
    String code = loginForm.getCode();
    if (cacheCode == null || !cacheCode.equals(code)) {
        //3、不一致，报错
        return Result.fail("验证码错误");
    }
    //4、一致，根据手机号查询用户select * from tb_user where phone = ?
    User user = query().eq("phone", phone).one();
    //5、判断用户是否存在
    if (user == null) {
        //6、不存在，创建新用户保存
        user = createUserWithPhone(phone);
    }
    //7、保存用户信息到session中，
    //注意：这边要隐藏用户敏感信息,将user当中的属性拷贝到UserDTO(user的部分属性)中
    session.setAttribute("user", 
                         BeanUtil.copyProperties(user, UserDTO.class)); 
    //session保存不需要返回保存内容
    return Result.ok();
}
```

> UserServiceImpl：注册目前无需写接口，登陆时用户不存在直接创建，因此只写实现即可

```java
private User createUserWithPhone(String phone) {
    //1、创建用户
    User user = new User();
    user.setPhone(phone);
    // 随机生成昵称
    user.setNickName("user_"+RandomUtil.randomString(10));
    //2、保存用户，save是MybatisPlus的方法
    save(user);
    return user;
}
```

#### 功能测试

> 发送验证码

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221532478.png" alt="image-20230522153231424" style="zoom:80%;" />

> 进行登录

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221532171.png" alt="image-20230522153259119" style="zoom:80%;" />

### 登录校验拦截器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171034824.png" alt="image-20220717103431751" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314154403399.png" alt="image-20220314154403399" style="zoom:67%;" />

#### ThreadLocal

用来保存用户信息

```java
public class UserHolder {
    // 创建ThreadLocal对象
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();
	// 创建存、取、删、静态方法
    public static void saveUser(UserDTO userId){
        tl.set(userId);
    }
    
    public static UserDTO getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

#### LoginInterceptor

```java
public class LoginInterceptor implements HandlerInterceptor{
    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        //1、获取session
        HttpSession session = request.getSession();
        //2、获取session中的用户
        Object user = session.getAttribute("user");
        //3、判断用户是否存在
        if (user == null) {
            //不存在，拦截，返回401状态码
            response.setStatus(401);
            return false;
        }  
        //5、存在，保存信息到ThreadLocal
        UserHolder.saveUser((UserDTO)user);
        //6、放行
        return true;
    }

    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response, 
                                Object handler, @Nullable Exception ex)
        throws Exception {
        //移除用户，避免内存泄露
        UserHolder.removeUser();
    }
}
```

#### MvcConfig

> 拦截器写好后还需要配置，不然不会生效

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截器注册，添加排除不需要拦截的路径
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/shop/**",
                        "/voucher/**",
                        "/shop-type/**",
                        "/upload/**",
                        "/blog/hot",
                        "/user/code",
                        "/user/login",
                        "/swagger-resources/**",
                        "/webjars/**", "/v2/**",
                        "/swagger-ui.html/**"
                );
    }
}
```

#### UserController

> 登录成功获取用户

```java
@GetMapping("me")
public Result me(){
    // TODO 获取当前登录的用户并返回，在拦截器中已经把用户信息放到UserHolder里面了
    UserDTO user = UserHolder.getUser();
    return Result.ok(user);
}
```

#### 访问测试

> 前面获取验证码和登录流程和上面一样，接下来只需要调用me方法获取信息即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221551375.png" alt="image-20230522155113319" style="zoom:80%;" />



### 集群共享问题

> **Session共享问题**：**多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题**。session的替代方案应该满足：

> - 数据共享
>
> - 内存存储
> - key、value结构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314154521491.png" alt="image-20220314154521491" style="zoom:67%;" />



## Redis登录

### 流程图解

#### 登录注册

> 每一个用户都是唯一的，因此redis的key是唯一的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314160722513.png" alt="image-20220314160722513" style="zoom:67%;" />



#### 校验状态

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314160757368.png" alt="image-20220314160757368" style="zoom:67%;" />



### 信息保存格式

> 保存登录的用户信息，可以使用String结构，以JSON字符串来保存，比较直观
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314160840149.png" alt="image-20220314160840149" style="zoom:67%;" />

> Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220314160905860.png" alt="image-20220314160905860" style="zoom:67%;" />

Redis代替session需要考虑的问题：

- 选择合适的数据结构
- 选择合适的key
- 选择合适的存储粒度

### 前端逻辑⭐

> 就是请求头添加一个authorization，把token保存在里面

> login.vue

```js
login() {
    if(!this.radio){
        this.$message.error("请先确认阅读用户协议");
        return
    }
    if(!this.form.phone || !this.form.code){
        this.$message.error("手机号和验证码不能为空");
        return
    }
    axios.post("/user/login",this.form).then(({data}) => {
        // 保存用户信息到session
        sessionStorage.setItem("token",data)
    })
    // 跳转到首页
    location.href = "/info.html"
}
```

> axios请求工具类

```js
// request拦截器，将用户token放入头中
let token = sessionStorage.getItem("token");
axios.interceptors.request.use(
  config => {
    if(token) config.headers['authorization'] = token
    return config
  },
  error => {
    console.log(error)
    return Promise.reject(error)
  }
)
```

### Redis常量类

```java
public class RedisConstants {
    // 验证码，时间
    public static final String LOGIN_CODE_KEY = "login:code:";
    public static final Long LOGIN_CODE_TTL = 200L;
    public static final TimeUnit LOGIN_CODE_TIME = TimeUnit.SECONDS;
    
    // 登录用户信息
    public static final String LOGIN_USER_KEY = "login:token:";
    public static final Long LOGIN_USER_TTL = 250L;
    public static final TimeUnit LOGIN_USER_TIME = TimeUnit.SECONDS;
}
```

### 发送验证码

> 修改上面的session登录即可

```java
@PostMapping("code")
public Result sendCode(@RequestParam("phone") String phone) {
    // TODO 发送短信验证码并保存验证码
    return userService.sendCode(phone);
}
```

```java
Result sendCode(String phone);
```

```java
@Resource
private StringRedisTemplate stringRedisTemplate;

@Override
public Result sendCode(String phone) {
    //1、校验手机号
    if (RegexUtils.isPhoneInvalid(phone)) {
        //2、如果不符合，返回错误信息
        return Result.fail("手机号格式错误");
    }
    //3、符合，生成验证码
    String code = RandomUtil.randomNumbers(6);

    //改用redis,设置有效期,设置常量
    stringRedisTemplate.opsForValue()
            .set(RedisConstants.LOGIN_CODE_KEY +phone,code,
                 RedisConstants.LOGIN_CODE_TTL, RedisConstants.LOGIN_CODE_TIME);

    //5、发送验证码
    log.debug("发送验证码成功，验证码：{}",code);
    //返回ok
    return Result.ok();
}
```

### 登录功能实现

```java
//登录参数，包含手机号、验证码；或者手机号、密码
@PostMapping("login")
public Result login(@RequestBody LoginFormDTO loginForm){
    // TODO 实现登录功能
    return userService.login(loginForm);
}
```

```java
Result login(LoginFormDTO loginForm);
```

```java
@Override
public Result login(LoginFormDTO loginForm) {
    //1、校验手机号
    String phone = loginForm.getPhone();
    if (RegexUtils.isPhoneInvalid(phone)) {
        //2、如果不符合，返回错误信息
        return Result.fail("手机号格式错误");
    }
    //2、校验验证码，从redis获取验证码并校验
    String cacheCode = stringRedisTemplate.opsForValue()
                       .get(RedisConstants.LOGIN_CODE_KEY + phone);
    String code = loginForm.getCode();
    //打印一下，看看两个是否相同
    log.info("code:{},cacheCode:{}",code,cacheCode);
    //3、验证码不一致或不存在，报错
    if (cacheCode == null || !cacheCode.equals(code)) {
        return Result.fail("验证码错误");
    }
    //4、一致，根据手机号查询用户select * from tb_user where phone = ?
    User user = query().eq("phone", phone).one();
    //5、判断用户是否存在
    if (user == null) {
        //6、不存在，创建新用户保存(下面的方法)
        user = createUserWithPhone(phone);
    }
    //7、将信息保存到redis中，随机生成token，作为登录令牌，这不是标准的token，只是UUID
    String token = UUID.randomUUID().toString();
    //8、将user对象里的部分信息复制到userDTO中(保护隐私)
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
    //9、将UserDTO对象转为HashMap存储，下面这种情况是普通用法
    //Map<String, Object> userMap = BeanUtil.beanToMap(userDTO);
    //因为stringRedisTemplate要求对象内部全是string才行，因此里面用到string转换
    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO,new HashMap<>(),
            CopyOptions.create()
                    .setIgnoreNullValue(true)
                     // 将字段值全部转换成String类型                                
                    .setFieldValueEditor((fieldName,fieldValue) ->
                            fieldValue.toString()));
    //存储,这个是为了存储在redis中，返回给前端的只需要token
    String tokenKey = RedisConstants.LOGIN_USER_KEY+token;
    log.info("tokenKey:"+tokenKey);
    //将信息保存到hash
    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);
    //获取存储的hash信息
    Map<Object, Object> userMap1 = stringRedisTemplate.opsForHash().entries(tokenKey);
    //设置token有效期
    stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL,
                               RedisConstants.LOGIN_USER_TIME);
    //注意把token返回
    return Result.ok(token);
}
```

> 用户不存在创建用户(和session中一样)

```java
private User createUserWithPhone(String phone) {
    //1、创建用户
    User user = new User();
    user.setPhone(phone);
    user.setNickName("user_"+RandomUtil.randomString(10));
    //2、保存用户
    save(user);
    return user;
}
```



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205052107563.png" alt="image-20220505210738458" style="zoom:80%;" />





### 拦截器⭐

> **因为目前拦截器只拦截需要登录校验的路径，而一些如首页等路径是不会去拦截的，如果用户不去访问这些路径，拦截器的token有效期就不会刷新，这样token有效期到了登录就会失效**。我们想让拦截器只要用户访问任何路径都会触发，这样就能一直刷新token有效期了。**即token必须是自动续期的**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171132072.png" alt="image-20220717113218979" style="zoom:67%;" />





拦截器优化

> 第一个拦截器拦截所有路径，这样能一直刷新登录有效期，第二个拦截器拦截登录请求

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205052118051.png" alt="image-20220505211817932" style="zoom:80%;" />

#### UserHolder

```java
public class UserHolder {
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();

    public static void saveUser(UserDTO user){
        tl.set(user);
    }

    public static UserDTO getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

#### RefreshTokenInterceptor

> 第一个拦截器，拦截所有请求，但目标只是为了刷新token，无论token是否存在，路径都能访问通过
>
> 注意：拦截所有请求是在配置类中设置

```java
public class RefreshTokenInterceptor implements HandlerInterceptor{
	// 注入stringRedisTemplate
    private  StringRedisTemplate stringRedisTemplate;

    //因为不是Spring的类，不能@Resource注入，所以要使用构造函数来注入
    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }
	// 前置拦截器
    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        //获取请求头的token，前端传过来的
        String token = request.getHeader("authorization");
        //判断token是否为空，为空也放行，感觉没必要判断，StrUtil是hutool工具包
        if (StrUtil.isBlank(token)) {
            return true;
        }
        //2、获取Redis中的用户，从Hash类型中取到
        String key = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
        //判断用户是否存在，这里同样不要拦截，直接放行，感觉没必要判断
        if (userMap.isEmpty()) {
            return true;
        }
        //5、将查询到的Hash数据转换为userDTO对象，第三个参数表示是否忽略错误，false不忽略
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, 
                                                   new UserDTO(), false);
        //6、存在，保存用户信息到ThreadLocal
        UserHolder.saveUser(userDTO);
        //6、放行
        //7、刷新token有效期
        stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL,
                                       RedisConstants.LOGIN_USER_TIME);
        return true;
    }

    public void afterCompletion(HttpServletRequest request, 
                                HttpServletResponse response, 
                                Object handler, @Nullable Exception ex) 
        throws Exception {
        //移除用户
        UserHolder.removeUser();
    }
}
```

#### LoginInterceptor

> 第二个拦截器，负责真正的拦截动作

```java
public class LoginInterceptor implements HandlerInterceptor {

    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        //判读是否需要拦截(ThreadLocal中是否有用户)
        if (UserHolder.getUser() == null) {
            //没有用户，需要拦截，并设置状态码
            response.setStatus(401);
            return false;
        }
        //有用户，放行
        return true;
    }
}
```

#### MvcConfig

> 注册拦截器

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //order表示执行先后顺序，order越大越晚执行，确保第一个拦截器一定在第二个前面执行
        registry.addInterceptor(new 
                                RefreshTokenInterceptor(stringRedisTemplate))
                // 拦截一切路径
                .addPathPatterns("/**").order(0);
        registry.addInterceptor(new LoginInterceptor())
                // 只拦截需要登录的路径，即放行不需要登录的路径
                .excludePathPatterns(
                        "/shop/**",
                        "/voucher/**",
                        "/shop-type/**",
                        "/upload/**",
                        "/blog/hot",
                        "/user/code",
                        "/user/login",
                        "/swagger-resources/**",
                        "/webjars/**", "/v2/**",
                        "/swagger-ui.html/**"
                ).order(1);
    }
}
```

#### UserController

```java
@GetMapping("me")
public Result me(){
    // TODO 获取当前登录的用户并返回
    //在拦截器中已经把用户信息放到UserHolder里面了
    UserDTO user = UserHolder.getUser();
    return Result.ok(user);
}
```

### 验证测试

#### 发送验证码

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221639599.png" alt="image-20230522163905539" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221639664.png" alt="image-20230522163926614" style="zoom:80%;" />

#### 登录测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221640981.png" alt="image-20230522164013921" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221640129.png" alt="image-20230522164049073" style="zoom:80%;" />

#### 获取个人信息

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305221643466.png" alt="image-20230522164325409" style="zoom:80%;" />



# 实战演练

## 后端搭建

### 依赖坐标

```xml
<dependencies>
     <!-- spring-web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- spring-boot-starter-security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!-- 热更新 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <!-- mysql -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!-- 连接池 -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.10</version>
    </dependency>
    <!-- mybatis-plus -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.3.2</version>
    </dependency>
    <!-- fastjson -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
        <version>1.2.40</version>
    </dependency>
    <!-- JWT -->
    <dependency>
        <groupId>com.auth0</groupId>
        <artifactId>java-jwt</artifactId>
        <version>3.2.0</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
        <version>0.9.1</version>
    </dependency>
    <!-- commons-io -->
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.5</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <!-- spring boot redis 缓存引入 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <!-- lettuce pool 缓存连接池 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
    <!-- hutool工具类-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.3.3</version>
    </dependency>
</dependencies>
```

### 配置文件

```yml
server:
  port: 8888
  # 不配置时，默认为 / ，如：localhost:8080/xxxxxx
  # 有配置时，比如 /demo，此时的访问方式为localhost:8080/demo/xxxxxx
  servlet:
    context-path: /

spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/xue?serverTimezone=Asia/Shanghai
    username: root
    password: 123456
  redis: # redis配置
    host: 127.0.0.1 # IP
    port: 6379  # 端口
    # password:  # 密码
    connect-timeout: 10s  # 连接超时时间
    lettuce: # lettuce redis客户端配置
      pool: # 连接池配置
        max-active: 8  # 连接池最大连接数（使用负值表示没有限制） 默认 8
        max-wait: 200s  # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1
        max-idle: 8 # 连接池中的最大空闲连接 默认 8
        min-idle: 0 # 连接池中的最小空闲连接 默认 0

mybatis-plus:
  global-config:
    db-config:
      id-type: auto
  configuration:
    map-underscore-to-camel-case: true
    auto-mapping-behavior: full
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  mapper-locations: classpath:mapper/*.xml

avatarImagesFilePath: H://java1234-vue3-admin3//pic
```



### MybatisX

> 使用MybatisX进行代码生成

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222010014.png" alt="image-20230522201046953" style="zoom:80%;" />

> 先连接数据库

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222011075.png" alt="image-20230522201139015" style="zoom:80%;" />

> 再进行代码生成

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222012240.png" alt="image-20230522201212172" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222013790.png" alt="image-20230522201315715" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222013706.png" alt="image-20230522201356616" style="zoom:80%;" />

### 启动类

> 要加上@MapperScan，进行包扫描

```java
@SpringBootApplication
@MapperScan("com.java1234.mapper")
public class Java1234Admin3Application {

    public static void main(String[] args) {
        SpringApplication.run(Java1234Admin3Application.class, args);
    }

}
```

### 统一返回结果

> 项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容

#### 返回格式

> 包含信息：状态码、信息、数据

例如，我们的系统要求返回的基本数据格式如下：

**列表：**

```json
{
  "code": 200,
  "message": "成功",
  "data": [
    {
      "id": 2,
      "roleName": "系统管理员"
    }
  ],
  "ok": true
}
```

**分页：**

```json
{
  "code": 200,
  "message": "成功",
  "data": {
    "records": [
      {
        "id": 2,
        "roleName": "系统管理员"
      },
      {
        "id": 3,
        "name": "普通管理员"
      }
    ],
    "total": 10,
    "size": 3,
    "current": 1,
    "orders": [],
    "hitCount": false,
    "searchCount": true,
    "pages": 2
  },
  "ok": true
}
```

**没有返回数据：**

```json
{
  "code": 200,
  "message": "成功",
  "data": null,
  "ok": true
}
```

**失败：**

```json
{
  "code": 201,
  "message": "失败",
  "data": null,
  "ok": false
}
```

#### 枚举类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305161109709.png" alt="image-20230516110911643" style="zoom:80%;" />

> 操作模块：common-util，后续其他模块也会用到，故抽取到common-util模块
>
> 创建文件：com.atguigu.common.result.ResultCodeEnum

```java
package com.atguigu.common.result;

import lombok.Getter;

// 统一返回结果状态信息类
@Getter
public enum ResultCodeEnum {
    // 定义枚举
    SUCCESS(200,"成功"),
    FAIL(201, "失败"),
    SERVICE_ERROR(2012, "服务异常"),
    DATA_ERROR(204, "数据异常"),
    LOGIN_AUTH(208, "未登陆"),
    PERMISSION(209, "没有权限")
    ;
    // 设置code和message
    private Integer code;
    private String message;
    // 设置有参构造，目的是传递参数
    private ResultCodeEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

#### 统一返回结果⭐

> 创建文件：com.atguigu.common.result.Result

```java
// 全局统一返回结果类
@Data
public class Result<T> {

    //返回码
    private Integer code;

    //返回消息
    private String message;

    //返回数据
    private T data;

    private Result(){}

    public static <T> Result<T> build(T body, ResultCodeEnum resultCodeEnum) {
        Result<T> result =  new Result<T>();
        // 封装数据
        if (body != null) {
            result.setData(body);
        }
        // 状态码
        result.setCode(resultCodeEnum.getCode());
        // 返回信息
        result.setMessage(resultCodeEnum.getMessage());
        return result;
    }

    public static<T> Result<T> ok(){
        return build(null,ResultCodeEnum.SUCCESS);
    }

    // 操作成功
    public static<T> Result<T> ok(T data){
        return build(data, ResultCodeEnum.SUCCESS);
    }

    public static<T> Result<T> fail(){
        return build(null,ResultCodeEnum.FAIL);
    }

    // 操作失败
    public static<T> Result<T> fail(T data){
        return build(data, ResultCodeEnum.FAIL);
    }

    public Result<T> message(String msg){
        this.setMessage(msg);
        return this;
    }

    public Result<T> code(Integer code){
        this.setCode(code);
        return this;
    }
}
```

统一返回结果状态信息类下面的状态后续都会用到，所以直接引入了

### SysUserController

> 进行查询测试

```java
@RestController
@RequestMapping("/sys/user")
public class SysUserController {

    @Autowired
    private SysUserService sysUserService;
    
    @GetMapping("list1")
    public Result getList(){
        List<SysUser> list = sysUserService.list();
        return Result.ok(list);
    }
}
```

## 前端搭建

> 我们用vue ui来搭建vue项目；vue ui是一个可视化图形界面，方便你去创建、更新和管理vue项目，包括下载router，vuex，axios，elementui等插件，配置好一些属性以及依赖关系，方便我们使用，我个人第一次接触它就感觉非常非常非常智能和强大。

### 安装Vue-cli

> vue-cli 是一个官方发布 vue.js 项目脚手架，使用 vue-cli 可以快速创建 vue 项目。因为vue ui是在Vue CLI基础上封装的

```sh
npm install -g @vue/cli
vue ui
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222035275.png" alt="image-20230522203500188" style="zoom:80%;" />

### 搭建项目

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222041374.png" alt="image-20230522204123298" style="zoom:80%;" />

> 创建、导入、或管理项目

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222042973.png" alt="image-20230522204236879" style="zoom:80%;" />

### 自定义仪表盘

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222045689.png" alt="image-20230522204528580" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222045151.png" alt="image-20230522204550084" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222046425.png" alt="image-20230522204616296" style="zoom:80%;" />

### 安装axios element-plus

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222035361.png" alt="image-20230522203539269" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222036679.png" alt="image-20230522203636602" style="zoom:80%;" />

> Element-plus官网：https://element-plus.gitee.io/

### 项目测试

> 导入elementplus以及样式

```js
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
createApp(App).use(store).use(router).use(ElementPlus).mount('#app')
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222038987.png" alt="image-20230522203841909" style="zoom:80%;" />

# JWT前后端交互

> Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准；JWT就是一段字符串，用来进行用户身份认证的凭证，该字符串分成三段【头部、载荷、签证】

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222048446.png" alt="image-20230522204800349" style="zoom:80%;" />

## 后端实现

### JWT工具类

> constant/JwtConstant

```java
public class JwtConstant {
    // token
    public static final int JWT_ERRCODE_NULL = 4000;         //Token不存在
    public static final int JWT_ERRCODE_EXPIRE = 4001;       //Token过期
    public static final int JWT_ERRCODE_FAIL = 4002;         //验证不通过
    //JWT密匙，可以任意设置
    public static final String JWT_SECERT = "8677df7fc3a34e26a61c034d5ec8245d";  
    //JWT有效时间：24小时
    public static final long JWT_TTL = 24*60 * 60 * 1000;                          
}
```

> result/CheckResult

```java
@Data
public class CheckResult {
    // 映射运行结果：jwt验证信息
    private int errCode;
    private boolean success;
    private Claims claims;
}
```

> utils/JwtUtils

```java
public class JwtUtils {

    // 签发JWT，可以是JSON数据 尽可能少
    public static String createJWT(String id, String subject, long ttlMillis) {
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        SecretKey secretKey = generalKey();
        JwtBuilder builder = Jwts.builder()
                .setId(id)
                .setSubject(subject)   // 主题
                .setIssuer("Java1234")     // 签发者
                .setIssuedAt(now)      // 签发时间
                .signWith(signatureAlgorithm, secretKey); // 签名算法以及密匙
        if (ttlMillis >= 0) {
            long expMillis = nowMillis + ttlMillis;
            Date expDate = new Date(expMillis);
            builder.setExpiration(expDate); // 过期时间
        }
        return builder.compact();
    }

    // 生成jwt token
    public static String genJwtToken(String username){
        return createJWT(username,username,60*60*1000);
    }

    // 验证JWT
    public static CheckResult validateJWT(String jwtStr) {
        CheckResult checkResult = new CheckResult();
        Claims claims = null;
        try {
            claims = parseJWT(jwtStr);
            checkResult.setSuccess(true);
            checkResult.setClaims(claims);
        } catch (ExpiredJwtException e) {
            checkResult.setErrCode(JwtConstant.JWT_ERRCODE_EXPIRE);
            checkResult.setSuccess(false);
        } catch (SignatureException e) {
            checkResult.setErrCode(JwtConstant.JWT_ERRCODE_FAIL);
            checkResult.setSuccess(false);
        } catch (Exception e) {
            checkResult.setErrCode(JwtConstant.JWT_ERRCODE_FAIL);
            checkResult.setSuccess(false);
        }
        return checkResult;
    }

    // 生成加密Key
    public static SecretKey generalKey() {
        byte[] encodedKey = Base64.decode(JwtConstant.JWT_SECERT);
        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES");
        return key;
    }


    // 解析JWT字符串
    public static Claims parseJWT(String jwt) {
        SecretKey secretKey = generalKey();
        return Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(jwt)
                .getBody();
    }

    public static void main(String[] args) throws InterruptedException {
        //小明失效 10s
        String sc = createJWT("1","小明", 60 * 60 * 1000);
        System.out.println(sc);
        System.out.println(validateJWT(sc).getErrCode());
        System.out.println(validateJWT(sc).getClaims().getId());
        System.out.println(validateJWT(sc).getClaims().getSubject());
        //Thread.sleep(3000);
        System.out.println(validateJWT(sc).getClaims());
        Claims claims = validateJWT(sc).getClaims();
        String sc2 = createJWT(claims.getId(),claims.getSubject(), JwtConstant.JWT_TTL);
        System.out.println(sc2);
    }

}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222052932.png" alt="image-20230522205214855" style="zoom:80%;" />

### TestController

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @Autowired
    private SysUserService sysUserService;

    @GetMapping("/user/list")
    public Result userList(@RequestHeader(required = false) String token){
        if(!StringUtils.isEmpty(token)){
            List<SysUser> userList = sysUserService.list();
            return Result.ok(userList);
        }else{
            return Result.fail("没有权限访问");
        }
    }

    @GetMapping("/login")
    public Result login(){
        String token = JwtUtils.genJwtToken("java1234");
        return Result.ok(token);
    }
}
```

### 跨域访问

```java
@Configuration
public class WebAppConfigurer implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "HEAD", "POST", "PUT", "DELETE","OPTIONS")
                .maxAge(3600);
    }
}
```



### 访问测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222107129.png" alt="image-20230522210717060" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222115742.png" alt="image-20230522211551681" style="zoom:80%;" />

## 前端实现

### utils/request.js

> utils/request.js

```js
// 引入axios
import axios from 'axios';
import store from '@/store'

let baseUrl=":8888/";
// 创建axios实例
const httpService = axios.create({
    // url前缀-'http:xxx.xxx'
    // baseURL: process.env.BASE_API, // 需自定义
    baseURL:baseUrl,
    // 请求超时时间
    timeout: 3000 // 需自定义
});

//添加请求和响应拦截器
// 添加请求拦截器
httpService.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么，保存token
    //config.headers.token=window.sessionStorage.getItem('token');
    console.log("store="+store.getters.GET_TOKEN)
    config.headers.token=store.getters.GET_TOKEN
    return config;
}, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
});

// 添加响应拦截器
httpService.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
}, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
});

/*网络请求部分*/

// get请求、url:请求地址、params:参数
export function get(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'get',
            params: params
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

// post请求、url:请求地址、params:参数
export function post(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params
        }).then(response => {
            console.log(response)
            resolve(response);
        }).catch(error => {
            console.log(error)
            reject(error);
        });
    });
}

// 文件上传
export function fileUpload(url, params = {}) {
    return new Promise((resolve, reject) => {
        httpService({
            url: url,
            method: 'post',
            data: params,
            headers: { 'Content-Type': 'multipart/form-data' }
        }).then(response => {
            resolve(response);
        }).catch(error => {
            reject(error);
        });
    });
}

export function getServerUrl(){
    return baseUrl;
}

export default {
    get,
    post,
    fileUpload,
    getServerUrl
}
```

### store/index.js

> vuex

```js
import { createStore } from 'vuex'
import router from '@/router'

export default createStore({
  state: {
  },
  getters: {
    GET_TOKEN:state => {
      return sessionStorage.getItem("token")
    }
  },
  mutations: {
    SET_TOKEN:(state,token)=>{
      sessionStorage.setItem("token",token);
    }
  },
  actions: {
  },
  modules: {
  }
})
```



### App.vue

```vue
<template>
    <el-button type="primary" @click="handleLogin">测试登录</el-button>
    <el-button type="danger" @click="handleUserList">测试获取用户请求</el-button>
</template>
```

```js
<script setup>
    
import requestUtil from '@/util/request'
import store from '@/store'

const handleLogin = async ()=>{
  let result = await requestUtil.get("/test/login");
  let data = result.data;
  if(data.code === 200){
    const token = data.data;
    console.log("登录成功：token="+token);
    store.commit('SET_TOKEN',token);
  }else{
    console.log("登录出错！");
  }
}

const handleUserList=async ()=>{
  let result = await requestUtil.get("test/user/list");
  let data = result.data;
  if(data.code === 200){
     const userList = data.data;
     console.log("用户列表信息：userList="+userList);
  }
}
</script>
```

### 访问测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222203295.png" alt="image-20230522220304233" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222202746.png" alt="image-20230522220229657" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305222206678.png" alt="image-20230522220612590" style="zoom:80%;" />



# 登录功能

## 前端样式

### normalize.css

> 重置默认样式：http://necolas.github.io/normalize.css/

> 下载完成后，复制到styles/normalize.css，然后在main.js中导入即可

```js
import '@/assets/styles/normalize.css'
```

### App.vue

```vue
<template>
    <router-view/>
</template>
```

```css
<style>
html,body,#app{
  height: 100%;
}

.app-container{
  padding:20px
}
</style>
```

### router/index.js

```js
import { createRouter, createWebHashHistory } from 'vue-router'


const routes = [
  {
    path: '/',
    name: '首页',
    component: () => import('../layout'),
    redirect:'/index',
    children:[
      {
        path: '/index',
        name: '首页',
        component: () => import('../views/index/index')
      },
      {
        path: '/userCenter',
        name: '个人中心',
        component: () => import('../views/userCenter/index')
      },
    ]
  },
  {
    path: '/login',
    name: 'login',
    component: () => import('../views/Login.vue')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router
```

### sass

```sh
npm install sass-loader --save-dev
npm install sass --save-dev
```

### Login.vue

#### 静态页面结构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305231048919.png" alt="image-20230523104801658" style="zoom:80%;" />

```vue
<template>
<div class="login">
    <!-- 登录表单 -->
    <el-form ref="loginRef" :model="loginForm" :rules="loginRules" class="login-form">
      <h3 class="title">Java1234 Vue3 后台管理系统</h3>
      <!-- 账号输入框 -->
      <el-form-item prop="username">
        <el-input
            v-model="loginForm.username"
            type="text"
            size="large"
            auto-complete="off"
            placeholder="账号">
          <!-- iconfont图标 -->
          <template #prefix><span class="iconfont icon-denglu"></span></template>
        </el-input>
      </el-form-item>
      <!-- 密码输入框 -->
      <el-form-item prop="password">
        <el-input
             v-model="loginForm.password"
            type="password"
            size="large"
            auto-complete="off"
            placeholder="密码"
            @keyup.enter="handleLogin">
          <template #prefix><span class="iconfont icon-denglu-mima"></span></template>
        </el-input>
      </el-form-item>
	  <!-- 记住密码，即记住我 -->
      <el-checkbox v-model="loginForm.rememberMe" 
                   style="margin:0px 0px 25px 0px;">记住密码</el-checkbox>
      <!-- 登录按钮 -->
      <el-form-item style="width:100%;">
        <el-button
            size="large"
            type="primary"
            style="width:100%;"
            @click.prevent="handleLogin">
          <span>登 录</span>
        </el-button>
      </el-form-item>
    </el-form>
    <!--  底部  -->
    <div class="el-login-footer">
      <span>Copyright © 2013-2022 <a href="http://www.java1234.vip" 
                                     target="_blank">java1234.vip</a> 版权所有.</span>
    </div>
  </div>
</template>
```

#### 样式

```css
<style lang="scss" scoped>
a {
  color:white
}
.login {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  background-image: url("../assets/images/login-background.jpg");
  background-size: cover;
}
.title {
  margin: 0px auto 30px auto;
  text-align: center;
  color: #707070;
}

.login-form {
  border-radius: 6px;
  background: #ffffff;
  width: 400px;
  padding: 25px 25px 5px 25px;

  .el-input {
    height: 40px;
    input {
      display: inline-block;
      height: 40px;
    }
  }
  .input-icon {
    height: 39px;
    width: 14px;
    margin-left: 0px;
  }

}
.login-tip {
  font-size: 13px;
  text-align: center;
  color: #bfbfbf;
}
.login-code {
  width: 33%;
  height: 40px;
  float: right;
  img {
    cursor: pointer;
    vertical-align: middle;
  }
}
.el-login-footer {
  height: 40px;
  line-height: 40px;
  position: fixed;
  bottom: 0;
  width: 100%;
  text-align: center;
  color: #fff;
  font-family: Arial;
  font-size: 12px;
  letter-spacing: 1px;
}
.login-code-img {
  height: 40px;
  padding-left: 12px;
}
</style>
```



## 后端配置⭐

### 坐标依赖

> 前面已经加入了该依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

### SecurityConfig

> config/SecurityConfig

```java
@Configuration
@EnableWebSecurity // 开启Security
@EnableGlobalMethodSecurity(prePostEnabled = true) // 注解使用
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private LoginSuccessHandler loginSuccessHandler;

    @Autowired
    private LoginFailureHandler loginFailureHandler;

    @Autowired
    private JwtLogoutSuccessHandler jwtLogoutSuccessHandler;

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    private MyUserDetailsServiceImpl myUserDetailsService;
	// 白名单放行数组
    private static final String URL_WHITELIST[] ={
            "/login",
            "/logout",
            "/captcha",
            "/password",
            "/image/**",
            "/test/**"
    } ;

    @Bean
    JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {
        JwtAuthenticationFilter jwtAuthenticationFilter=new 
            JwtAuthenticationFilter(authenticationManager());
        return jwtAuthenticationFilter;
    }

    @Bean
    BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(myUserDetailsService);
    }
	// 核心配置
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 开启跨域 以及csrf攻击 关闭
        http
            .cors()
            .and()
            .csrf()
            .disable()
        // 登录登出配置，登录页面和登出页面，失败页面
        .formLogin()
              .successHandler(loginSuccessHandler)
              .failureHandler(loginFailureHandler)
        .and()
            .logout()
            .logoutSuccessHandler(jwtLogoutSuccessHandler)

        // session禁用配置（前后端分离配置）
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)  // 无状态

        // 拦截规则配置(对不需要拦截的路径进行放行)
        .and()
        .authorizeRequests()
        .antMatchers(URL_WHITELIST).permitAll()  // 白名单 放行
        .anyRequest().authenticated()


        // 异常处理配置
                .and()
                .exceptionHandling()
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)

        // 自定义过滤器配置
        .and()
        .addFilter(jwtAuthenticationFilter());

    }
}
```

### 登录成功处理器

> 目前先不从数据库查找，先自己写，将其注入到上面的SecurityConfig中

```java
@Component
public class LoginSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, 
                                        HttpServletResponse httpServletResponse, 
                                        Authentication authentication) throws 
        IOException, ServletException {
        // 设定返回结果格式
        httpServletResponse.setContentType("application/json;charset=UTF-8");
        ServletOutputStream outputStream = httpServletResponse.getOutputStream();
		// 根据用户名生成token
        String username="user";
        String token = JwtUtils.genJwtToken(username);
		// 使用hutool工具转JSON
        outputStream.write(JSONUtil.toJsonStr(R.ok("登录成功")
                                              .put("authorization",token)).getBytes());
        outputStream.flush();
        outputStream.close();
    }
}
```

### 登录失败处理器

> 和上面的一样，此处已经完整，后面无需修改

```java
@Component
public class LoginFailureHandler implements AuthenticationFailureHandler {


    @Override
    public void onAuthenticationFailure(HttpServletRequest httpServletRequest, 
                                        HttpServletResponse httpServletResponse, 
                                        AuthenticationException e) throws IOException,
    ServletException {
        httpServletResponse.setContentType("application/json;charset=UTF-8");
        ServletOutputStream outputStream = httpServletResponse.getOutputStream();

        String message=e.getMessage();
        if(e instanceof BadCredentialsException){
            message="用户名或者密码错误！";
        }

        outputStream.write(JSONUtil.toJsonStr(R.error(message)).getBytes("UTF-8"));
        outputStream.flush();
        outputStream.close();
    }
}
```

### 登录处理器

> 需要重写UserDetailService进行查询数据库

```java
public interface SysUserService extends IService<SysUser> {
    SysUser getByUsername(String username);
}
```

```java
@Service
public class SysUserServiceImpl extends ServiceImpl<SysUserMapper, SysUser>
    implements SysUserService{

    @Override
    public SysUser getByUsername(String username) {
        return getOne(new QueryWrapper<SysUser>().eq("username",username));
    }
}
```

```java
@Service
public class MyUserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    SysUserService sysUserService;

    @Override
    public UserDetails loadUserByUsername(String username) throws 
        UsernameNotFoundException {
        // 通过数据库查询
        SysUser sysUser=sysUserService.getByUsername(username);
        if(sysUser==null){
            throw new UsernameNotFoundException("用户名或者密码错误！");
        }else if("1".equals(sysUser.getStatus())){
            throw new UserCountLockException("该用户账号被封禁，具体请联系管理员！");
        }
        // 返回结果
        return new User(sysUser.getUsername(),
                        sysUser.getPassword(),
                        getUserAuthority(sysUser.getId()));
    }
}
```

```java
@Configuration
@EnableWebSecurity // 开启Security
@EnableGlobalMethodSecurity(prePostEnabled = true) // 注解使用
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private LoginSuccessHandler loginSuccessHandler;

    @Autowired
    private LoginFailureHandler loginFailureHandler;

    @Autowired
    private JwtLogoutSuccessHandler jwtLogoutSuccessHandler;

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    private MyUserDetailsServiceImpl myUserDetailsService;

    private static final String URL_WHITELIST[] ={
            "/login",
            "/logout",
            "/captcha",
            "/password",
            "/image/**",
            "/test/**"
    } ;

    @Bean
    JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {
        return new JwtAuthenticationFilter(authenticationManager());
    }

    @Bean
    BCryptPasswordEncoder bCryptPasswordEncoder(){
        return new BCryptPasswordEncoder();
    }
	// 将自己写的userDetailService注册
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(myUserDetailsService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 开启跨域 以及csrf攻击 关闭
        http
            .cors()
            .and()
            .csrf()
            .disable()

        // 登录登出配置
        .formLogin()
              .successHandler(loginSuccessHandler)
              .failureHandler(loginFailureHandler)
        .and()
            .logout()
            .logoutSuccessHandler(jwtLogoutSuccessHandler)

        // session禁用配置
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)  // 无状态

        // 拦截规则配置
        .and()
        .authorizeRequests()
        .antMatchers(URL_WHITELIST).permitAll()  // 白名单 放行
        .anyRequest().authenticated()


        // 异常处理配置
                .and()
                .exceptionHandling()
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)

        // 自定义过滤器配置
        .and()
        .addFilter(jwtAuthenticationFilter());

    }
}
```



### JWT认证过滤器

```java
public class JwtAuthenticationFilter extends BasicAuthenticationFilter {

    @Autowired
    private SysUserService sysUserService;

    @Autowired
    private MyUserDetailsServiceImpl myUserDetailsService;

    private static final String URL_WHITELIST[] ={
            "/login",
            "/logout",
            "/captcha",
            "/password",
            "/image/**",
            "/test/**"
    } ;

    public JwtAuthenticationFilter(AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain chain) throws IOException, 
    ServletException {
        String token = request.getHeader("token");
        System.out.println("请求url:"+request.getRequestURI());
        // 如果token是空 或者 url在白名单里，则放行
        // 这边是为了测试
        if(StringUtil.isEmpty(token) || new ArrayList<>(Arrays.asList(URL_WHITELIST))
                     .contains(request.getRequestURI())){
            // chain.doFilter表示放行
            chain.doFilter(request,response);
            return;
        }
        CheckResult checkResult = JwtUtils.validateJWT(token);
        if(!checkResult.isSuccess()){
            switch (checkResult.getErrCode()){
              case JwtConstant.JWT_ERRCODE_NULL:throw new JwtException("Token不存在");
              case JwtConstant.JWT_ERRCODE_FAIL:throw new JwtException("Token验证不通过");
              case JwtConstant.JWT_ERRCODE_EXPIRE:throw new JwtException("Token过期");
            }
        }
        // 获取token信息
        Claims claims = JwtUtils.parseJWT(token);
        String username = claims.getSubject();
        // 查询数据库
        SysUser sysUser = sysUserService.getByUsername(username);
		// 将获取到的信息放到security上下文中
        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken=
            new UsernamePasswordAuthenticationToken(username,
                                                    null,                                                         myUserDetailsService.getUserAuthority(sysUser.getId()));
        SecurityContextHolder.getContext()
                             .setAuthentication(usernamePasswordAuthenticationToken);
        chain.doFilter(request,response);
    }
}
```

### JWT认证失败处理

```java
@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest httpServletRequest, 
                         HttpServletResponse httpServletResponse, 
                         AuthenticationException e) throws IOException, 
    ServletException {
        httpServletResponse.setContentType("application/json;charset=UTF-8");
        ServletOutputStream outputStream = httpServletResponse.getOutputStream();
        outputStream.write(JSONUtil.
                           toJsonStr(R.error(HttpServletResponse.SC_UNAUTHORIZED,
                                                      "认证失败，请登录！")).getBytes());
        outputStream.flush();
        outputStream.close();
    }
}
```

### 退出登录处理

```java
@Component
public class JwtLogoutSuccessHandler implements LogoutSuccessHandler {
    @Override
    public void onLogoutSuccess(HttpServletRequest httpServletRequest, 
                                HttpServletResponse httpServletResponse, 
                                Authentication authentication) throws IOException, 
    ServletException {
        httpServletResponse.setContentType("application/json;charset=UTF-8");
        ServletOutputStream outputStream = httpServletResponse.getOutputStream();
        outputStream.write(JSONUtil.toJsonStr(R.ok("登出成功")).getBytes());
        outputStream.flush();
        outputStream.close();
    }
}
```





## 实体类

### 基础实体类

```java
@Data
public class BaseEntity implements Serializable {

    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    // 创建日期
    @JsonFormat(pattern ="yyyy-MM-dd HH:mm:ss")
    private Date createTime;

    // 更新日期
    @JsonFormat(pattern ="yyyy-MM-dd HH:mm:ss")
    private Date updateTime;

    // 备注
    private String remark;
}
```



































