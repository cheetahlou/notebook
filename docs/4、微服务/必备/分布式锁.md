

上次修改时间：2022.9.7

# 分布式锁概述

在应用开发中，特别是web工程开发，通常都是并发编程，不是多进程就是多线程。这种场景下极易出现线程并发性安全问题，此时不得不使用锁来解决问题。在多线程高并发场景下，为了保证资源的线程安全问题，jdk为我们提供了synchronized关键字和ReentrantLock可重入锁，但是它们`只能保证一个工程内的线程安全`。在分布式集群、微服务、云原生横行的当下，`如何保证不同进程、不同服务、不同机器的线程安全问题`，jdk并没有给我们提供既有的解决方案。此时，我们就必须借助于相关技术手动实现了。目前主流的实现有以下方式：

1. 基于mysql关系型实现
2. 基于redis非关系型数据实现
3. 基于zookeeper/etcd实现

本课程将会全面深入、全程手撸代码式的讲解这三种分布式锁的实现。并深入源码讲解第三方分布式锁框架。

基础知识储备及技术要求： 

- 开发工具：idea + jdk1.8

- 工程构建工具：maven 
- 相关框架基础：SpringBoot SpringMVC Spring Mybatis（mybatis-plus） SpringData-Redis
- 数据库：mysql（InnoDB引擎 事务 锁机制） redis
- 负载均衡工具：nginx 
- 压力测试工具：jmeter 
- 其他：zookeeper lua脚本语言 JUC(java.util.concurrent相关背景知识) 微服务相关背景知识

## 什么是分布式锁

### 通俗例子

> 诊所只有一个医生，很多患者前来就诊。医生在同一时刻只能给一个患者提供就诊服务。
>

> 如果不是这样的话，就会出现医生在就诊肾亏的「肖菜鸡」准备开药时候患者切换成了脚臭的「谢霸哥」，这时候药就被谢霸哥取走了。治肾亏的药被有脚臭的拿去了。
>

> 当并发去读写一个【共享资源】的时候，我们为了保证数据的正确，需要控制同一时刻只有一个线程访问。**`分布式锁就是用来控制同一时刻，只有一个 JVM 进程中的一个线程可以访问被保护的资源`**。
>

> 应用场景：**缓存击穿、库存超卖、防重复提交**

### 分布式锁特性

> 1. **互斥：在任何给定时刻，只有一个客户端可以持有锁**；
> 2. **无死锁：任何时刻都有可能获得锁，即使获取锁的客户端崩溃**；
> 3. **容错：只要大多数 `Redis`的节点都已经启动，客户端就可以获取和释放锁**。

### 完美方案

> 我们可以让获得锁的线程开启一个**守护线程**，用来给快要过期的锁「续航」。加锁的时候设置一个过期时间，同时客户端开启一个「守护线程」，定时去检测这个锁的失效时间。
>

> 别慌，已经有一个库把这些工作都封装好了他叫 **Redisson**。在使用分布式锁时，它就采用了**「自动续期」**的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。一路优化下来，方案似乎比较「严谨」了
>

## 分布式锁特点⭐

**分布式锁：**满足分布式系统或集群模式下多进程可见并且互斥的锁

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206111610026.png" alt="image-20220611161045915" style="zoom: 67%;" />

> 1. 互斥性：同一时刻只能有一个进程或者机器获取到锁，并且其他进程或机器无法获取该锁。
> 2. 可重入性：同一个进程或者机器可以多次获取同一个锁，而且每次获取锁都必须对应一个释放锁的操作，这样才能保证锁被正确地释放。
> 3. 防止死锁：分布式锁需要设计一套有效的机制来避免死锁问题，例如设置锁的超时时间，当锁超时时自动释放锁，避免死锁的发生。
> 4. 高可用性：分布式锁需要保证在任何时候都可以获取到锁，即使某个进程或者机器发生故障，也需要能够及时切换到其他健康的进程或机器上。
> 5. 性能高：分布式锁需要尽可能地减少锁的获取和释放的时间，以提高整个系统的性能。

1.独占排他：znode节点不可重复、自旋锁

2.阻塞锁：临时序列化节点 

​       1.所有请求要求获取锁时，给每一个请求创建临时序列化节点
​	   2.获取当前节点的前置节点，如果前置节点为空，则获取锁成功，否则监听前置节点
​	   3.获取锁成功之后执行业务操作，然后释放当前节点的锁

3.可重入：同一线程已经获取过该锁的情况下，可重入
	  1.在节点的内容中记录服务器、线程以及重入信息
	  2.ThreadLocal：线程的局部变量，线程私有

4.公平锁：有序列
      1.独占排他互斥使用 节点不重复

​	  2.防死锁： 客户端程序获取到锁之后服务器立马宕机。可自动释放锁（临时节点） ：获得锁之后客户端所在机器宕机了，客户端没有主动删除子节点；如果创建的是永久的节点，那么这个锁永远不会释放，导致死锁；由于创建的是临时节点，客户端宕机后，过了一定时间zookeeper没有收到客户端的心跳包判断会话失效，将临时节点删除从而释放锁。临时节点：一旦客户端服务器宕机，链接就会关闭，此时zk心  跳检测不到客户端程序，删除对应的临时节点。不可重入：可重入锁 

5.防误删：给每一个请求线程创建一个唯一的序列化节点。宕机自动释放临时节点，不需要设置过期时间，也就不存在 误删问题。

6.原子性：创建节点 删除节点 查询及监听，加锁/解锁要具备原子性

7.可重入：ThreadLocal实现 节点数据 ConcurrentHashMap

8.自动续期：没有过期时间 也就不需要自动续期

9.单点故障：zk一般都是集群部署，使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。

10.zk集群：偏向于一致性集群，zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，可以对外提供务。

关于性能不太高的一种说法

> 因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同步到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。由于ZooKeeper的高可用特性，在并发量不是太高的场景，也推荐使用ZK的分布式锁。
>

## 超卖现象

> **多线程并发安全问题最典型的代表就是超卖现象。库存在并发量较大情况下很容易发生超卖现象，一旦发生超卖现象，就会出现多成交了订单而发不了货的情况**。

场景：商品S库存余量为5时，用户A和B同时来购买一个商品，此时查询库存数都为5，库存充足则开始减库存

用户A：update db_stock set stock = stock - 1 where id = 1

用户B：update db_stock set stock = stock - 1 where id = 1

并发情况下，更新后的结果可能是4，而实际的最终库存量应该是3才对

## 分布式锁对比⭐

分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206111612961.png" alt="image-20220611161234851" style="zoom:80%;" />

> - 简易程度：MySQL > Redis(lua脚本) > zk
> - 性能：Redis > Zookeeper > MySQL
> - 可靠性：Zookeeper > redis = MySQL

这三种方式都不是尽善尽美，我们可以根据实际业务情况选择最适合的方案：

> 如果追求**`极致性能`**可以选择：Redis方案
>
> 如果追求**`可靠性`**可以选择：zk

简单玩一下，实现独占排他，对性能 对可靠性要求都不高的情况下，选择mysql分布式锁。

## 压力测试工具

接下来咱们使用jmeter压力测试工具，高并发下压测一下，添加线程组：并发100循环50次，即5000次请求。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225681.png" alt="1606442946203" style="zoom:80%;" />

> 线程数：这里就是指虚拟用户数，默认的输入是“1”，则表明模拟一个虚拟用户访问被测系统，如果想模拟100个用户，则此处输入100。

> Ramp-Up Period (in seconds): 虚拟用户增长时长。不明白别着急，xmeter君给你举个栗子：比如你测试的是一个考勤系统，那么实际用户登录使用考勤系统的时候并不是大家喊1、2、3 - 走起，然后一起登录。实际使用场景可能是9点钟上班，那么从8:30开始，考勤系统会陆陆续续有人开始登录，直到9:10左右，那么如果完全按照用户的使用场景，设计该测试的时候此处应输入40（分钟）* 60（秒）= 2400。

> 但是实际测试一般不会设置如此长的Ramp-Up时间，原因嘛，难道你做一次测试要先等上40分钟做登录操作？一般情况下，可以估计出登录频率最高的时间长度，比如此处可能从8:55到9:00登录的人最多，那这里设置成300秒，如果“线程数”输入为100，则意味着在5分钟内100用户登录完毕。Ramp-Up Period=0：代表同时并发
>

> 循环次数：该处设置一个虚拟用户做多少次的测试。默认为1，意味着一个虚拟用户做完一遍事情之后，该虚拟用户停止运行。如果选中“永远”，则意味着测试运行起来之后就根本停不下来了，除非你把它强制咔嚓。

> **总并发=线程数×循环次数**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225699.png" alt="1606443124589" style="zoom:80%;" />

> **给线程组添加HTTP Request请求**

![1606443172072](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225717.png)

> **填写测试接口路径如下**

![1606443276322](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225732.png)

> **再选择你想要的测试报表，例如这里选择聚合报告**

![1606443541407](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225746.png)

> **启动测试，查看压力测试报告**

![image-20220313204754310](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225037.png)

> - Label          取样器别名，如果勾选**Include group name** ，则会添加线程组的名称作为前缀
> - Samples      取样器运行次数
> - Average       请求（事务）的平均响应时间
> - Median        中位数
> - 90% Line       90%用户响应时间
> - 95% Line       90%用户响应时间
> - 99% Line       90%用户响应时间
> - Min           最小响应时间
> - Max           最大响应时间
> - Error          错误率
> - Throughput     吞吐率
> - Received KB/sec  每秒收到的千字节
> - Sent KB/sec      每秒收到的千字节

> 测试结果：请求总数5000次，平均请求时间37ms，中位数（50%）请求是在36ms内完成的，错误率0%，每秒钟平均吞吐量2568.1次。查看mysql数据库剩余库存数：还有4870。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225065.png" alt="1606445079298" style="zoom:80%;" />

此时如果还有人来下单，就会出现超卖现象（别人购买成功，而无货可发）。

# 传统锁

> 项目路径：https://gitee.com/sure-s-renshuo/distributed-lock

## JVM锁原理

> JVM：ReentrantLock + synchronized，添加synchronized关键字之后，StockService就具备了对象锁，由于添加了**独占的排他锁**，**同一时刻只有一个请求能够获取到锁，并减库存**。**此时，所有请求只会one-by-one执行下去，也就不会发生超卖现象**。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225348.png" alt="1606448189738" style="zoom:80%;" />

> 单个jvm实例单机，必须单例，与事务并存问题，总之，不适合于保证数据库数据可靠性

## 简化版本

### 基本搭建

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051536248.png" alt="image-20230505153629186" style="zoom:80%;" />

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```

```java
@Data
public class Stock {
    private Integer stock = 5000;
}
```

```java
@Service
public class StockService {
    private Stock stock = new Stock();

    public void deduct() {
        stock.setStock(stock.getStock() - 1);
        System.out.println("库存余量: " + stock.getStock());
    }
}
```

```java
@RestController
public class StockController {

    @Autowired
    private StockService stockService;

    @GetMapping("stock/deduct")
    public String deduct() {
        this.stockService.deduct();
        return "hello stock deduct";
    }
}
```

### 访问测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051539270.png" alt="image-20230505153925202" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051539119.png" alt="image-20230505153940051" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051540862.png" alt="image-20230505154045770" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051541655.png" alt="image-20230505154121601" style="zoom:80%;" />

### JVM锁解决超卖

> synchronized方式：在上述代码中，只需要加上synchronized，其他地方不用动，重启项目即可

```java
public synchronized void deduct() {
    stock.setStock(stock.getStock() - 1);
    System.out.println("库存余量: " + stock.getStock());
}
```

> ReentrantLock方式：在上述代码中，只需要修改如下，其他地方不用动，重启项目即可

```java
private ReentrantLock lock = new ReentrantLock();

public void deduct() {
    lock.lock();
    try {
        stock.setStock(stock.getStock() - 1);
        System.out.println("库存余量: " + stock.getStock());
    } finally {
        // 必须在这里解锁，确保锁一定会被释放
        lock.unlock();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051544634.png" alt="image-20230505154419554" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051543055.png" alt="image-20230505154358993" style="zoom:80%;" />

## 升级版本

### 数据库

```mysql
create database heima1;
use heima1;
create table `db_stock` (
  `id` bigint(20) not null auto_increment,
  `product_code` varchar(255) default null comment '商品编号',
  `warehouse` varchar(255) default null comment '仓库编号',
  `count` int(11) default null comment '库存量',
  primary key (`id`)
) engine=innodb auto_increment=1 default charset=utf8;

insert into db_stock(id,product_code,warehouse,count)values (null,'1001','北京仓',5000);
```

表中数据如下：1001商品在北京仓有5000件库存。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051612837.png" alt="image-20230505161231781" style="zoom:80%;" />

### 项目实践

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051618491.png" alt="image-20230505161858417" style="zoom: 80%;" />

**配置文件**

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.4.3</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```

**application-a.yml配置文件**

```yml
server:
  port: 10010
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/heima1?serverTimezone=GMT%2B8
    username: root
    password: 123456
```

```properties
spring.profiles.active=a
```

**stock实体类**

```java
@Data
@TableName("db_stock")
public class Stock {
    @TableId
    private Long id;
    private String productCode;
    private String warehouse;
    private Integer count;
}
```

**stockMapper接口**

```java
@Mapper
public interface StockMapper extends BaseMapper<Stock> {
}
```

**StockService**

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    private ReentrantLock lock = new ReentrantLock();

    public void deduct() {
        //lock.lock();
        try {
            // 先查询库存是否充足
            Stock stock = new LambdaQueryChainWrapper<>(stockMapper)
                              .eq(Stock::getProductCode,"1001").one();
            if (stock != null && stock.getCount() > 0){
                stock.setCount(stock.getCount() - 1);
                this.stockMapper.updateById(stock);
            }
        } finally {
            // 必须在这里解锁，确保锁一定会被释放
            //lock.unlock();
        }
    }
}
```

**StockController**

```java
@RestController
public class StockController {

    @Autowired
    private StockService stockService;

    @GetMapping("stock/deduct")
    public String deduct() {
        this.stockService.deduct();
        return "hello stock deduct";
    }
}
```

### 访问测试

在浏览器中一个一个访问时，每访问一次，库存量减1，没有任何问题，现在测试并发

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051620808.png" alt="image-20230505162050733" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051620995.png" alt="image-20230505162035903" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051701956.png" alt="image-20230505170126881" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051701191.png" alt="image-20230505170153111" style="zoom:80%;" />

### JVM锁解决超卖

> ReentrantLock + synchronized

#### synchronized锁

> 只需要修改StockService即可

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    public synchronized void deduct() {
        // 先查询库存是否充足
        Stock stock = new LambdaQueryChainWrapper<>(stockMapper)
                          .eq(Stock::getProductCode,"1001").one();
        if (stock != null && stock.getCount() > 0){
            stock.setCount(stock.getCount() - 1);
            this.stockMapper.updateById(stock);
        }
    }
}
```

重启tomcat服务，再次使用jmeter压力测试，效果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051716534.png" alt="image-20230505171618446" style="zoom:80%;" />

查看mysql数据库：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051713461.png" alt="image-20230505171319408" style="zoom:80%;" />

并没有发生超卖现象，完美解决。

#### ReetrantLock锁

> 只需要修改StockService即可

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    private ReentrantLock lock = new ReentrantLock();

    public void deduct() {
        lock.lock();
        try {
            // 先查询库存是否充足
            Stock stock = new LambdaQueryChainWrapper<>(stockMapper)
                              .eq(Stock::getProductCode,"1001").one();
            if (stock != null && stock.getCount() > 0){
                stock.setCount(stock.getCount() - 1);
                this.stockMapper.updateById(stock);
            }
        } finally {
            // 必须在这里解锁，确保锁一定会被释放
            lock.unlock();
        }
    }
}
```

效果同上，也是能完美解决

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051713904.png" alt="image-20230505171306824" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305051713461.png" alt="image-20230505171319408" style="zoom:80%;" />

## JVM锁失效⭐

1.单个jvm实例单机
2.必须单例
3.与事务并存问题

总之，不适合于保证数据库数据可靠性

### 多例模式

```java
@Service
// 变成多例模式
@Scope(value = "prototype",proxyMode = ScopedProxyMode.TARGET_CLASS)
public class stockService {
    // 正常加上JVM锁方法
    // ...
}
```

### 事务

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void checkAndLock() {
    lock.lock();
    try {
        // 先查询库存是否充足
        stock stock = this.stockMapper.selectOne(new QueryWrapper<stock>()
                .eq("product_code","1001"));
        // 再减库存
        if (stock != null && stock.getCount() > 0){
            stock.setCount(stock.getCount() - 1);
            this.stockMapper.updateById(stock);
        }
    } finally {
        lock.unlock();
    }
}
```

## 集群搭建

使用jvm锁在单工程单服务情况下确实没有问题，但是在集群情况下会怎样？

接下启动多个服务并使用nginx负载均衡，结构如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225501.png" alt="1606453095867" style="zoom:80%;" />

### IDEA启动多个实例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051306914.png" alt="image-20220905130647864" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051305202.png" alt="image-20220905130502147" style="zoom: 70%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051305643.png" alt="image-20220905130547595" style="zoom:80%;" />

启动三个服务（端口号分别8080 8081 8082），如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051307784.png" alt="image-20220905130737730" style="zoom:80%;" />

### 配置Nginx⭐

**Linux版安装**

> 因为使用的是windows版本，这步可以省略了

```shell
# 拉取镜像
docker pull nginx:latest
# 创建nginx对应资源、日志及配置目录
mkdir -p /opt/nginx/logs /opt/nginx/conf /opt/nginx/html
# 先在conf目录下创建nginx.conf文件，配置内容参照下方
# 再运行容器
docker run -d -p 80:80 --name nginx -v /opt/nginx/html:/usr/share/nginx/html -v /opt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/logs:/var/log/nginx nginx
```

**nginx.conf⭐⭐**

```nginx
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;
    #gzip  on;

    #include /etc/nginx/conf.d/*.conf;
	# 配置负载均衡
	upstream distributed {
		server 127.0.0.1:10011;
		server 127.0.0.1:10012;
		server 127.0.0.1:10013;
	}
	
	server {
	   listen       80;
       server_name  127.0.0.1;
		location / {
			proxy_pass http://distributed;
		}
	}
}
```

### 启动nginx测试⭐

双击nginx.exe启动即可，或者进入CMD执行

```apl
start nginx #启动 
nginx -s stop #快速停止 
nginx -s quit #优雅关闭，在退出前完成已经接受的连接请求 
nginx -s reload #重新加载配置
```

在浏览器中测试：127.0.0.1是我的nginx服务器地址

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051316589.png" alt="image-20220905131639538" style="zoom:80%;" />

经过测试，通过nginx访问服务一切正常。

### Jmeter压力测试

注意：先把数据库库存量还原到5000。

参照之前的测试用例，再创建一个新的测试组：参数给之前一样

![1606467848874](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225553.png)

配置nginx的地址及 服务的访问路径如下：

![1606467953589](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225722.png)

测试结果：性能只是略有提升。

![image-20220313215233371](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225808.png)

数据库库存剩余量如下：

![1606469161544](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225825.png)

又出现了并发问题，即出现了超卖现象。

## MySQL锁

### 更新前判断⭐

> 直接更新时判断：**直接更新时判断，在更新中判断库存是否大于0** 。解决jvm锁多例模式锁失效问题及事务共存问题，锁范围控制：**条件字段必须创建索引；查询条件必须具体的值，同一个商品有多个库存时，无法解决。无法记录库存变化前后的状态**。**条件字段必须为索引，且是具体值，不然变成表级锁，效率很低**

创建联合索引

```sql
create index idx_pcc on db_stock(product_code,count);
```

Mapper

```java
@Mapper
public interface StockMapper extends BaseMapper<Stock> {

    @Update("update db_stock set count=count-#{count} " +
            "where product_code = #{productCode} and count >= #{count}")
    int updateStock(@Param("productCode") String productCode, @Param("count") Integer count);
}
```

Service

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    public void deduct() {
        this.stockMapper.updateStock("1001",1);
    }
}
```

测试，集群情况能正常成功，但仍然存在如下问题

> 1. 锁范围问题 表级锁 行级锁
>
> 2. 同一个商品有多条库存记录
>
> 3. 无法记录库存变化前后的状态

### 悲观锁

#### 悲观锁概述

> 在MySQL的InnoDB中，预设的Tansaction isolation level 为REPEATABLE READ（可重复读）
>

> **在select的时候就会加锁，采用先加锁后处理的模式**，虽然保证了数据处理的安全性，但也会阻塞其他线程的写操作。**悲观锁适用于写多读少的场景，因为拿不到锁的线程，会将线程挂起，交出CPU资源**，可以把CPU给其他线程使用，来提高CPU的利用率。

> 悲观锁：在读取数据时锁住那几行，其他对这几行的更新需要等到悲观锁结束时才能继续。库存操作要统一：不能有的操作是select ... for update 而有的操作是普通的select
>
> 死锁风险：多条记录时，加锁顺序要一致，阻塞及性能问题

**在SELECT 的读取锁定主要分为两种方式：**

> - SELECT ... LOCK IN SHARE MODE　（共享锁）
> - SELECT ... FOR UPDATE                       （悲观锁）

> 这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT ... FOR UPDATE。
>

> mysql悲观锁中使用行级锁：
>
> 1.锁的查询或者更新条件**`必须是索引字段`**
>
> 2.查询或者更新条件**`必须是具体值`**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305060938049.png" alt="image-20230506093821981" style="zoom:80%;" />

#### 代码实现⭐

MySQL悲观锁中使用行级锁条件：

> - **锁的查询或者更新条件必须是索引字段**
> - **查询或者更新条件必须是具体值**

**为条件字段创建索引**

```sql
create index idx_pcc on db_stock(product_code,count);
```

**在StockeMapper中定义selectStockForUpdate方法：**

```java
@Mapper
public interface StockMapper extends BaseMapper<Stock> {

    // 进行库存查询
    @Select("select * from db_stock where product_code=#{productCode} for update")
    List<Stock> queryStock(String productCode);
}
```

**改造StockService：**

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Transactional
    public void deduct() {
        // 1. 查询库存信息并锁定库存信息，调用mapper的悲观锁方法
        // 这里使用List是因为可能有多个仓库代码为1001，比如北京上海
        List<Stock> stocks = this.stockMapper.queryStock("1001");
        // 这里取第一个仓库的库存
        Stock stock = stocks.get(0);
        // 2. 判断库存是否充足
        if (stock !=null && stock.getCount() > 0){
            // 3. 扣减库存
            stock.setCount(stock.getCount()-1);
            this.stockMapper.updateById(stock);
        }
    }
}
```

#### 压力测试

> 注意：测试之前，需要把库存量改成5000。压测数据如下：比jvm性能高很多，比无锁要低将近1倍

```sql
# 更新库存
update db_stock set count = 5000 where product_code = '1001';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225994.png" alt="1606487362848" style="zoom:80%;" />

mysql数据库存：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225012.png" alt="1606487554822" style="zoom:80%;" />

> 1. **性能问题**
>
> 2. **死锁问题：对多条数据加锁时，加锁顺序要一致**
>
> 3. **库存操作要统一：select ... for update 普通select**

### 乐观锁

#### 乐观锁概述

> **时间戳、version版本号、CAS机制**。乐观锁：**读取数据时不上锁，更新时检查是否数据已经被更新过，如果是则取消当前更新进行重试**。**CAS：Compare And Swap(Set)，比较并交换，变量X 旧值A 新值B**

> 乐观锁相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则重试。那么我们如何实现乐观锁呢
>

> 使用数据版本Version记录机制实现，这是乐观锁最常用的实现 方式。一般是通过为数据库表增加一个数字类型的 version字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新。
>

> 在select的时候不会加锁，是基于程序实现的，所以不会存在死锁的情况。适用于**`读多写少`**的场景（写的并发量相对不高），可以**`提高系统的吞吐量`**。因为如果写多的话，乐观锁会有很大机率更新失败，需要不断的自旋执行查找和更新操作。自旋的时候会一直占用CPU，会耗费大量的CPU资源。

> 1. **高并发情况下，性能极低**
>
>    2.**ABA问题--当一个值从A被更新为B，然后又改回来，普通 CAS 机制发现不了**
>
> 3. **读写分离情况下导致乐观锁不可靠**

#### 代码实现

给db_stock表添加version字段：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051824756.png" alt="image-20220905182405692" style="zoom:80%;" />

```sql
# SQL实现
alter table db_stock add column version int default 0;

# 更新version版本要和查询时版本相同
SELECT * FROM tb_stock WHERE product_code="1001";
UPDATE tb_stock set count=count-1,version=version+1 WHERE id=1 and version=0;
```

对应也需要给Stock实体类添加version属性。此处略。。。。

```java
// 实体类加上version字段
private Integer version;
```

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;
    
    // 不能加事务注解，避免连接超时错误，此时事务粒度过大，是整个方法，会超时
    //@Transactional
    public void deduct() {
        // 1. 查询库存信息并锁定库存信息
        List<Stock> stocks = this.stockMapper.selectList(new QueryWrapper<Stock>()
                .eq("product_code","1001"));
        // 这里取第一个仓库的库存
        Stock stock = stocks.get(0);
        // 2. 判断库存是否充足
        if (stock !=null && stock.getCount() > 0){
            // 3. 扣减库存
            stock.setCount(stock.getCount()-1);
            // 获取原版本号
            Integer version = stock.getVersion();
            stock.setVersion(version+1);
            // 最后的==0，是判断影响行数，如果影响行数为0自然就更新失败了
            if(this.stockMapper.update(stock,new UpdateWrapper<Stock>().eq("id",stock.getId())
                    .eq("version",version))==0){
                // 如果更新失败，则进行重试！递归调用会报栈溢出错误
                // 加个睡眠避免栈溢出错误
                try {
                    Thread.sleep(20);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 如果更新失败，则进行重试
                this.deduct();
            }
        }
    }
}
```

重启后使用jmeter压力测试工具结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305060931761.png" alt="image-20230506093144692" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305060932881.png" alt="image-20230506093210788" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305060931605.png" alt="image-20230506093111454" style="zoom:80%;" />

> 说明乐观锁在并发量越大的情况下，性能越低（因为需要大量的重试）；并发量越小，性能越高。
>

#### 乐观锁问题

> 1. 高并发情况下，性能极低
>
> 2. ABA问题
>
> 3. 读写分离情况下导致乐观锁不可靠

## 传统锁对比

> **性能：更新前判断> 悲观锁 > jvm锁 > 乐观锁**

> **如果追求极致性能、业务场景简单并且不需要记录数据前后变化的情况下。优先选择：更新前判断**

> **如果写并发量较低（多读），争抢不是很激烈的情况下优先选择：乐观锁**

> **如果写并发量较高，一般会经常冲突，此时选择乐观锁的话，会导致业务代码不间断的重试。**

> **优先选择：mysql悲观锁，不推荐jvm本地锁**

# 基于Redis的分布式锁

## Redis乐观锁(不推荐)

### 本地代码

利用redis监听 + 事务

> - watch：**可以监控一个或多个key的值，如果在事务(exec)执行之前,key的值发生变化则取消事务执行**
> - multi：开启事务
> - exec：执行事务

```shell
watch stock
multi
set stock 5000
exec
```

如果执行过程中stock的值没有被其他链接改变，则执行成功

 ![image-20220428200109930](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225270.png)

如果执行过程中stock的值被改变，则执行失败效果如下：

 ![image-20220428200244567](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225483.png)

### 代码实现

```sh
# 先在redis中设置库存
set stock 5000
get stock
```

具体代码实现，只需要改造对应的service方法：

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private StringRedisTemplate redisTemplate;

    // 不能加事务注解，避免连接超时错误，此时事务粒度过大，是整个方法
    //@Transactional
    public void deduct() {
        // Redis事务必须放在execute方法中才能执行
        this.redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations operations) throws DataAccessException {
                // watch：观察stock值的变化
                operations.watch("stock");
                // 1. 查询库存信息
                Object stock = operations.opsForValue().get("stock");
                // 2. 判断库存是否充足
                int st = 0;
                if (stock != null && (st = Integer.parseInt(stock.toString())) > 0) {
                    // multi：开启事务
                    operations.multi();
                    // 3. 扣减库存，可以直接使用decriment方法，更简单一点
                    operations.opsForValue().set("stock", String.valueOf(--st));
                    // exec 执行事务
                    List exec = operations.exec();
                    // 如果执行事务的返回结果集为空，则代表减库存失败，重试
                    if (exec == null || exec.size() == 0) {
                        try {
                            Thread.sleep(40);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        // 再次扣减库存
                        deduct();
                    }
                    return exec;
                }
                return null;
            }
        });
    }
}
```

> 压力测试后发现确实解决了并发问题，**但是性能严重下降，不推荐使用**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061000376.png" alt="image-20230506100020293" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061000291.png" alt="image-20230506100002183" style="zoom:80%;" />

## Redis简单分布式锁

> 分布式锁：**跨进程、跨服务、跨服务器**，场景：**超卖现象(NoSQL)、缓存击穿**

### 原理概述

> - **独占排他使用  setnx** 
> - **防死锁发生，如果Redis客户端程序从redis服务中获取到锁之后立马宕机**
> - **解决上面死锁：给锁设置过期时间。expire不可重入：可重入性**
> - **原子性：获取锁和过期时间之间：set key value ex 3 nx，判断和释放锁之间：lua脚本**
> - **防误删：解铃还需系铃人，先判断再删除**
> - **可重入性、自动续期**

> 借助于redis中的命令setnx(key, value)，**key不存在就新增，存在就什么都不做**。**同时有多个客户端发送setnx命令，只有一个客户端可以成功**，返回1（true）；其他的客户端返回0（false）。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061011217.png" alt="image-20230506101116104" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225499.png" alt="1606626611922" style="zoom:80%;" />

> 1. **多个客户端同时获取锁（setnx）**
> 2. **获取成功，执行业务逻辑，执行完成释放锁（del）**
> 3. **其他客户端等待重试：递归 循环**

### 基本配置

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
</dependency>

<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

```yml
server:
  port: 10011
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/heima1?serverTimezone=GMT%2B8
    username: root
    password: 123456
  redis:
    host: 192.168.88.101
    port: 6379
    password: 315217
```

### 基础版：递归上锁

改造StockService方法：

```apl
# 提前设置库存5000
set stock 5000
# 删除前面设置的锁
del lock
```

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private StringRedisTemplate redisTemplate;
    public void deduct() {
        // 加锁setnx，锁的名称任意，setIfAbsent来表示setnx
        Boolean lock = this.redisTemplate.opsForValue().setIfAbsent("lock", "111");

        // 重试：递归调用，是否获取到锁，获取失败，进行重试
        if (!lock){
            try {
                Thread.sleep(50);
                this.deduct();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            // 获取锁成功，开始业务操作
            try {
                // 1. 查询库存信息
                String stock = redisTemplate.opsForValue().get("stock").toString();
                // 2. 判断库存是否充足
                if (stock != null && stock.length() != 0) {
                    Integer st = Integer.valueOf(stock);
                    if (st > 0) {
                        // 3.扣减库存
                        redisTemplate.opsForValue().set("stock", String.valueOf(--st));
                    }
                }
            } finally {
                // 解锁
                this.redisTemplate.delete("lock");
            }
        }
    }
}
```

测试成功，如果出现加载不出来的情况，进入redis看看lock，删除lock，del lock

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051624744.png" alt="image-20220905162449678" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061017713.png" alt="image-20230506101755618" style="zoom:80%;" />

### 进阶版：循环重试

其中，加锁也可以使用循环：

```apl
set stock 5000
```

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private StringRedisTemplate redisTemplate;
    
    public void deduct() {
        // 加锁，获取锁失败重试
        while (!this.redisTemplate.opsForValue().setIfAbsent("lock", "111")){
            // 重试，循环
            try {
                // 减少锁竞争压力，防止死锁发生
                Thread.sleep(40);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            // 1. 查询库存信息
            String stock = redisTemplate.opsForValue().get("stock").toString();
            // 2. 判断库存是否充足
            if (stock != null && stock.length() != 0) {
                Integer st = Integer.valueOf(stock);
                if (st > 0) {
                    // 3.扣减库存
                    redisTemplate.opsForValue().set("stock", String.valueOf(--st));
                }
            }
        } finally {
            // 解锁
            this.redisTemplate.delete("lock");
        }
    }
}
```

使用Jmeter压力测试如下：

```sh
get lock
get stock
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061021963.png" alt="image-20230506102129873" style="zoom:80%;" />

### 高级版：防死锁、误删⭐

#### 防死锁：过期时间

> 问题：setnx刚刚获取到锁，当前服务器宕机，导致del释放锁无法执行，进而导致锁无法锁无法释放（死锁）
>
> 解决：给锁设置过期时间，自动释放锁。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225532.png" alt="1606702476465" style="zoom:80%;" />

设置过期时间两种方式：

> 1. 通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）
> 2. 使用set指令设置过期时间：set key value ex 3 nx（既达到setnx的效果，又设置了过期时间）

```sh
# ex设置过期时间，单位是秒
set lock 111 ex 3 nx
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225664.png" alt="image-20220504102416597" style="zoom:80%;" />

压力测试肯定也没有问题。

#### 防误删：uuid

> **问题：可能会释放其他服务器的锁**。
>
> **场景：如果业务逻辑的执行时间是7s**。执行流程如下

> 1. index1业务逻辑没执行完，3秒后锁被自动释放。
> 2. index2获取到锁，执行业务逻辑，3秒后锁被自动释放。
> 3. index3获取到锁，执行业务逻辑
> 4. index1业务逻辑执行完成，开始调用del释放锁，
> 5. 这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。最终等于没锁的情况。

>
> 解决：**setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁**
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225679.png" alt="1606707959639" style="zoom:80%;" />

实现如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225771.png" alt="image-20220504102714512" style="zoom:80%;" />

问题：删除操作缺乏原子性。场景：

> 1. index1执行删除时，查询到的lock值确实和uuid相等
> 2. index1执行删除前，lock刚好过期时间已到，被redis自动释放
> 3. index2获取了lock
> 4. index1执行删除，此时会把index2的lock删除

> 解决方案：**没有一个命令可以同时做到判断 + 删除**，所有只能通过其他方式实现（**LUA脚本**）
>

### 完整版：集成

```apl
set stock 5000
```

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private StringRedisTemplate redisTemplate;

    public void deduct() {
        // 防误删，每一个锁都有自己的名字，使用uuid，只去释放自己的锁
        String uuid = UUID.randomUUID().toString();
        // 加锁，获取锁失败重试
        while (BooleanUtils.isNotTrue(this.redisTemplate.opsForValue()
                .setIfAbsent("lock", uuid,3,TimeUnit.SECONDS))){
            // 重试，循环
            try {
                // 减少锁竞争压力，防止死锁发生
                Thread.sleep(40);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            // 1. 查询库存信息
            String stock = redisTemplate.opsForValue().get("stock").toString();
            // 2. 判断库存是否充足
            int st = Integer.parseInt(stock);
            if (st > 0) {
                // 3.扣减库存
                redisTemplate.opsForValue().set("stock", String.valueOf(--st));
            }
        } finally {
            // 先判断是否自己的锁，再解锁,StringUtils是commons-lang3包下的
            if (StringUtils.equals(this.redisTemplate.opsForValue().get("lock"),uuid)) {
                // 解锁
                this.redisTemplate.delete("lock");
            }
        }
    }
}
```

扣减成功，最终结果为0

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209051724488.png" alt="image-20220905172449420" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061052044.png" alt="image-20230506105203947" style="zoom:80%;" />

## Redis+Lua

### 现实问题

> **redis采用单线程架构，可以保证单个命令的原子性，但是无法保证一组命令在高并发场景下的原子性**。例如：

![1606711874388](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225874.png)

> **在串行场景下：A和B的值肯定都是3，在并发场景下：A和B的值可能在0-6之间。**

> **极限情况下1：则A的结果是0，B的结果是3**

![1606712580214](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225888.png)

> **极限情况下2：则A和B的结果都是6**

![1606712697401](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225958.png)

> 如果redis客户端通过lua脚本把3个命令一次性发送给redis服务器，那么这三个指令就不会被其他客户端指令打断。Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI/ EXEC 包围的事务很类似。 
>

> 但是MULTI/ EXEC方法来使用事务功能，将一组命令打包执行，无法进行业务逻辑的操作。这期间有某一条命令执行报错（例如给字符串自增），其他的命令还是会执行，并不会回滚。
>

### Lua基本语法

对lua脚本感兴趣的同学，请移步到官方教程或者《菜鸟教程》。这里仅以redis中可能会用到的部分语法作介绍。

```lua
a = 5               -- 全局变量
local b = 5         -- 局部变量， redis只支持局部变量
a, b = 10, 2*x      -- 等价于       a=10; b=2*x
```

流程控制：

```lua
if( 布尔表达式 1)
then
   --[ 在布尔表达式 1 为 true 时执行该语句块 --]
elseif( 布尔表达式 2)
then
   --[ 在布尔表达式 2 为 true 时执行该语句块 --]
else 
   --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]
end
```

在redis中需要通过eval命令执行lua脚本。

#### 基本语法⭐

```lua
eval script numkeys key [key ...] arg [arg ...]
-- 参数分析
script：-- lua脚本字符串，这段Lua脚本不需要（也不应该）定义函数。
numkeys：-- lua脚本中KEYS数组的大小
key [key ...]：-- KEYS数组中的元素
arg [arg ...]：-- ARGV数组中的元素
```

#### 案例1：基本案例

```shell
eval "return 10" 0
# 输出：(integer) 10
eval "return {1,2,3,4}" 0
# 输出 1，2，3，4
```

#### 案例2：动态传参

```shell
# 第一个5表示key数组为5个值，第六个到后面为ARGV数组   
EVAL "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 5 10 20 30 40 50 60 70 80 90
# 输出：10 20 60 70

EVAL "if KEYS[1] > ARGV[1] then return 1 else return 0 end" 1 10 20
# 输出：0

EVAL "if KEYS[1] > ARGV[1] then return 1 else return 0 end" 1 20 10
# 输出：1
```

传入了两个参数10和20，KEYS的长度是1，所以KEYS中有一个元素10，剩余的一个20就是ARGV数组的元素。

redis.call()中的redis是redis中提供的lua脚本类库，仅在redis环境中可以使用该类库。

#### 案例3：执行redis方法

```lua
-- 设置一个aaa值为10
set aaa 10  
-- 通过return把call方法返回给redis客户端，打印："10"
eval "return redis.call('get', 'aaa')" 0
```

> 注意：**脚本里使用的所有键都应该由 KEYS 数组来传递。**但并不是强制性的，代价是这样写出的脚本不能被 Redis 集群所兼容。
>

#### 案例4：给redis类库方法动态传参

```shell
eval "return redis.call('set', KEYS[1], ARGV[1])" 1 bbb 20
get bbb
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225070.png" alt="1600610957600" style="zoom:80%;" />

学到这里基本可以应付redis分布式锁所需要的脚本知识了。

#### 案例5：pcall函数的使用（了解）

```lua
-- 当call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，输出错误信息
eval "return redis.call('sets', KEYS[1], ARGV[1]), redis.call('set', KEYS[2], ARGV[2])" 2 bbb ccc 20 30
-- pcall函数不影响后续指令的执行
eval "return redis.pcall('sets', KEYS[1], ARGV[1]), redis.pcall('set', KEYS[2], ARGV[2])" 2 bbb ccc 20 30
```

**注意：set方法写成了sets**，肯定会报错。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061109669.png" alt="image-20230506110926537" style="zoom:80%;" />

### Lua删除原子性⭐

#### 脚本实现⭐

lua实现

```lua
-- 判断是否自己的锁，如果是自己的锁，执行删除操作。
-- key: lock arg: uuid
if redis.call('get', KEYS[1]) == ARGV[1]
then
    -- 删除锁成功，返回结果1
	return redis.call('del', KEYS[1])
else 
	return 0
end
```

测试脚本,进入redis-cli测试脚本

```lua
set lock 123-321
eval "if redis.call('get', KEYS[1]) == ARGV[1]  then return redis.call('del', KEYS[1]) else return 0 end" 1 lock  123-321
```

可以看到，设置锁时释放成功，返回1，否则返回0

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209072130239.png" alt="image-20220907213054918" style="zoom:80%;" />

#### 代码实现

```sh
set stock 5000
```

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private StringRedisTemplate redisTemplate;
    
    public void deduct() {
        // 防误删，每一个锁都有自己的名字，使用uuid，只去释放自己的锁
        String uuid = UUID.randomUUID().toString();
        // 加锁，获取锁失败重试
        while (BooleanUtils.isNotTrue(this.redisTemplate.opsForValue()
                .setIfAbsent("lock", uuid,3,TimeUnit.SECONDS))){
            // 重试，循环
            try {
                // 减少锁竞争压力，防止死锁发生
                Thread.sleep(40);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            // 1. 查询库存信息
            String stock = redisTemplate.opsForValue().get("stock").toString();
            // 2. 判断库存是否充足
            // 2. 判断库存是否充足
            if (stock != null && stock.length() != 0) {
                Integer st = Integer.valueOf(stock);
                if (st > 0) {
                    // 3.扣减库存
                    redisTemplate.opsForValue().set("stock", String.valueOf(--st));
                }
            }
        } finally {
            // 先判断是否自己的锁，再解锁,lua脚本删除锁保证原子性
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] " +
                    "then " +
                    "   return redis.call('del', KEYS[1]) " +
                    "else " +
                    "   return 0 " +
                    "end";
            this.redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class),
                    Arrays.asList("lock"), uuid);
        }
    }
}
```

压力测试，库存量也没有问题

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209052126151.png" alt="image-20220905212620050" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061122486.png" alt="image-20230506112246381" style="zoom:80%;" />

## 可重入锁

### 可重入概述

> 由于上述加锁命令使用了 SETNX ，一旦键存在就无法再设置成功，这就导致后续同一线程内继续加锁，将会加锁失败。当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的子任务代码，可重入性就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。
>

用一段 Java 代码解释可重入：

```java
public synchronized void a() {
    b();
}

public synchronized void b() {
    // pass
}
```

> 假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时**不可重入**，线程就必须等待锁释放，再次争抢锁。
>

> 锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~
>

> 可重入性就可以解决这个尴尬的问题，当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。可以看到可重入锁最大特性就是计数，计算加锁的次数。所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。
>

> 解决方案：Redis + Hash
>

### 加锁脚本

> 可重入锁加锁流程：ReentrantLock.lock() --> NonfairSync.lock() --> AQS.acquire(1) --> NonfairSync.tryAcquire(1) --> 
> Sync.nonfairTryAcquire(1)
>
> 1.CAS获取锁，如果没有线程占用锁（state==0），加锁成功并记录当前线程是有锁线程(两次)
> 2.如果state的值不为0，说明锁已经被占用。则判断当前线程是否是有锁线程，如果是则重入（state + 1）
> 3.否则加锁失败，入队等待

> 可重入锁解锁流程：ReentrantLock.unlock() --> AQS.release(1) --> Sync.tryRelease(1)
> 1.判断当前线程是否是有锁线程，不是则抛出异常
> 2.对state的值减1之后，判断state的值是否为0，为0则解锁成功，返回true
> 3.如果减1后的值不为0，则返回false

> Redis 提供了 Hash （哈希表）这种可以存储键值对数据结构。**所以我们可以使用 Redis Hash 存储的锁的重入次数，然后利用 lua 脚本判断逻辑**。

```sh
hset user name zhangsan
hset user age 20
```

参照ReentrantLock中的非公平可重入锁实现分布式可重入锁：hash + lua脚本，加锁：

```lua
-- 1.判断锁是否存在（exists），则直接获取锁 hset key field value
-- 2.如果锁存在则判断是否自己的锁（hexists），如果是自己的锁则重入：hincrby key field increment
-- 3.否则重试：递归 循环
if (redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1) 
then
    redis.call('hincrby', KEYS[1], ARGV[1], 1);
    redis.call('expire', KEYS[1], ARGV[2]);
    return 1;
else
	return 0;
end
```

> 假设值为：KEYS:[lock], ARGV[uuid, expire]，如果锁不存在或者这是自己的锁，就通过hincrby（不存在就新增并加1，存在就加1）获取锁或者锁次数加1。
>

### 解锁脚本

可重入锁解锁流程：ReentrantLock.unlock() --> AQS.release(1) --> Sync.tryRelease(1)

- 判断当前线程是否是有锁线程，不是则抛出异常
- 对state的值减1之后，判断state的值是否为0，为0则解锁成功，返回true
- 如果减1后的值不为0，则返回false

```lua
-- 判断 hash set 可重入 key 的值是否等于 0
-- 如果为 nil 代表 自己的锁已不存在，在尝试解其他线程的锁，解锁失败
-- 如果为 0 代表 可重入次数被减 1
-- 如果为 1 代表 该可重入 key 解锁成功
if(redis.call('hexists', KEYS[1], ARGV[1]) == 0) then 
    return nil; 
elseif(redis.call('hincrby', KEYS[1], ARGV[1], -1) > 0) then 
    return 0; 
else 
    redis.call('del', KEYS[1]); 
    return 1; 
end;
```

### 代码实现

由于加解锁代码量相对较多，这里可以封装成一个工具类：

 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225150.png" alt="image-20220504095916188" style="zoom:80%;" />

DistributedLockClient工厂类具体实现：

```java
@Component
public class DistributedLockClient {

    @Autowired
    private StringRedisTemplate redisTemplate;

    private String uuid;

    public DistributedLockClient() {
        this.uuid = UUID.randomUUID().toString();
    }

    public DistributedRedisLock getRedisLock(String lockName){
        return new DistributedRedisLock(redisTemplate, lockName, uuid);
    }
}
```

DistributedRedisLock实现如下：

```java
public class DistributedRedisLock implements Lock {

    private StringRedisTemplate redisTemplate;

    private String lockName;

    private String uuid;

    private long expire = 30;

    public DistributedRedisLock(StringRedisTemplate redisTemplate, String lockName, 
                                String uuid) {
        this.redisTemplate = redisTemplate;
        this.lockName = lockName;
        this.uuid = uuid;
    }

    @Override
    public void lock() {
        this.tryLock();
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        try {
            return this.tryLock(-1L, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 加锁方法
     * @param time
     * @param unit
     * @return
     * @throws InterruptedException
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        if (time != -1){
            this.expire = unit.toSeconds(time);
        }
        String script = "if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 " +
                "then " +
                "   redis.call('hincrby', KEYS[1], ARGV[1], 1) " +
                "   redis.call('expire', KEYS[1], ARGV[2]) " +
                "   return 1 " +
                "else " +
                "   return 0 " +
                "end";
        while (!this.redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class),
                                           Arrays.asList(lockName), getId(), 
                                           String.valueOf(expire))){
            Thread.sleep(50);
        }
        return true;
    }

    /**
     * 解锁方法
     */
    @Override
    public void unlock() {
        String script = "if redis.call('hexists', KEYS[1], ARGV[1]) == 0 " +
                "then " +
                "   return nil " +
                "elseif redis.call('hincrby', KEYS[1], ARGV[1], -1) == 0 " +
                "then " +
                "   return redis.call('del', KEYS[1]) " +
                "else " +
                "   return 0 " +
                "end";
        Long flag = this.redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), 
                                               Arrays.asList(lockName), getId());
        if (flag == null){
            throw new IllegalMonitorStateException("this lock doesn't belong to you!");
        }
    }

    @Override
    public Condition newCondition() {
        return null;
    }

    /**
     * 给线程拼接唯一标识
     * @return
     */
    String getId(){
        return uuid + ":" + Thread.currentThread().getId();
    }
}
```

### 使用及测试

在业务代码中使用：

```java
public void deduct() {
    DistributedRedisLock redisLock = this.distributedLockClient.getRedisLock("lock");
    redisLock.lock();
    try {
        // 1. 查询库存信息
        String stock = redisTemplate.opsForValue().get("stock").toString();
        // 2. 判断库存是否充足
        if (stock != null && stock.length() != 0) {
            Integer st = Integer.valueOf(stock);
            if (st > 0) {
                // 3.扣减库存
                redisTemplate.opsForValue().set("stock", String.valueOf(--st));
            }
        }
    } finally {
        redisLock.unlock();
    }
}
```

测试：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225167.png" alt="1606747747780" style="zoom:80%;" />

测试可重入性：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225262.png" alt="image-20220504101636357" style="zoom:80%;" />

## 自动续期

**Lua脚本**

> **自动续期**：**定时任务（时间驱动 Timer定时器） + lua脚本**
>
> **判断自己的锁是否存在（hexists），如果存在则重置过期时间**

```lua
if(redis.call('hexists', KEYS[1], ARGV[1]) == 1) then 
    redis.call('expire', KEYS[1], ARGV[2]); 
    return 1; 
else 
    return 0; 
end
```

**在RedisDistributeLock中添加renewExpire方法**：

```java
public class DistributedRedisLock implements Lock {

    private StringRedisTemplate redisTemplate;

    private String lockName;

    private String uuid;

    private long expire = 30;

    public DistributedRedisLock(StringRedisTemplate redisTemplate, String lockName, 
                                String uuid) {
        this.redisTemplate = redisTemplate;
        this.lockName = lockName;
        this.uuid = uuid + ":" + Thread.currentThread().getId();
    }

    @Override
    public void lock() {
        this.tryLock();
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        try {
            return this.tryLock(-1L, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 加锁方法
     * @param time
     * @param unit
     * @return
     * @throws InterruptedException
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        if (time != -1){
            this.expire = unit.toSeconds(time);
        }
        String script = "if redis.call('exists', KEYS[1]) == 0 or redis.call('hexists', KEYS[1], ARGV[1]) == 1 " +
                "then " +
                "   redis.call('hincrby', KEYS[1], ARGV[1], 1) " +
                "   redis.call('expire', KEYS[1], ARGV[2]) " +
                "   return 1 " +
                "else " +
                "   return 0 " +
                "end";
        while (!this.redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class),
                                           Arrays.asList(lockName), uuid, 
                                           String.valueOf(expire))){
            Thread.sleep(50);
        }
        // 加锁成功，返回之前，开启定时器自动续期
        this.renewExpire();
        return true;
    }

    /**
     * 解锁方法
     */
    @Override
    public void unlock() {
        String script = "if redis.call('hexists', KEYS[1], ARGV[1]) == 0 " +
                "then " +
                "   return nil " +
                "elseif redis.call('hincrby', KEYS[1], ARGV[1], -1) == 0 " +
                "then " +
                "   return redis.call('del', KEYS[1]) " +
                "else " +
                "   return 0 " +
                "end";
        Long flag = this.redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), 
                                               Arrays.asList(lockName), uuid);
        if (flag == null){
            throw new IllegalMonitorStateException("this lock doesn't belong to you!");
        }
    }

    @Override
    public Condition newCondition() {
        return null;
    }

    // String getId(){
    //     return this.uuid + ":" + Thread.currentThread().getId();
    // }

    private void renewExpire(){
        String script = "if redis.call('hexists', KEYS[1], ARGV[1]) == 1 " +
                "then " +
                "   return redis.call('expire', KEYS[1], ARGV[2]) " +
                "else " +
                "   return 0 " +
                "end";
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                if (redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class), 
                    Arrays.asList(lockName), uuid, String.valueOf(expire))) {
                    renewExpire();
                }
            }
        }, this.expire * 1000 / 3);
    }
}
```

在tryLock方法中使用：

![image-20220504100503780](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225365.png)

构造方法作如下修改：

![image-20220504100728343](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225378.png)

解锁方法作如下修改：

![image-20220504100850162](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225457.png)

## 手写分步式锁总结

### 特征

> 1. 独占排他：setnx
>
> 2. 防死锁：Redis客户端程序获取到锁之后，立马宕机。给锁添加过期时间，不可重入：可重入
>
> 3. 防误删：先判断是否自己的锁才能删除
>
> 4. 原子性：加锁和过期时间之间：set k v ex 3 nx，判断和释放锁之间：lua脚本
>
> 5. 可重入性：hash（key field value） + lua脚本 
>
> 6. 自动续期：Timer定时器 + lua脚本
>
> 7. 在集群情况下，导致锁机制失效
>
>    1. 客户端程序10010，从主中获取锁
>    2. 从还没来得及同步数据，主挂了
>    3. 于是从升级为主
>    4. 客户端程序10086就从新主中获取到锁，导致锁机制失效

### 加锁

> 1. setnx：独占排他   死锁、不可重入、原子性
>
> 2. set k v ex 30 nx：独占排他、死锁 、不可重入 
>
> 3. hash + lua脚本：可重入锁
>
>    1. 判断锁是否被占用（exists），如果没有被占用则直接获取锁（hset/hincrby）并设置过期时间（expire）
>    2. 如果锁被占用，则判断是否当前线程占用的（hexists），如果是则重入（hincrby）并重置过期时间（expire）
>    3. 否则获取锁失败，将来代码中重试
>
> 4. Timer定时器 + lua脚本：实现锁的自动续期
>
>    判断锁是否自己的锁（hexists == 1），如果是自己的锁则执行expire重置过期时间

### 解锁

> 1. del：导致误删
>
> 2. 先判断再删除同时保证原子性：lua脚本
>
> 3. hash + lua脚本：可重入 
>
>    1. 判断当前线程的锁是否存在，不存在则返回nil，将来抛出异常
>
>          2. 存在则直接减1（hincrby -1），判断减1后的值是否为0，为0则释放锁（del），并返回1
>          3. 不为0，则返回0
>
> 重试：递归 循环 

## 红锁算法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305072147640.png" alt="image-20230507214725361" style="zoom:80%;" />

Redis集群状态下的问题：

> 1. 客户端A从master获取到锁
> 2. 在master将锁同步到slave之前，master宕掉了。
> 3. slave节点被晋级为master节点
> 4. 客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。

**安全失效**！解决集群下锁失效，参照redis官方网站针对redlock文档：https://redis.io/topics/distlock

> 在算法的分布式版本中，我们假设有N个Redis服务器。这些节点是完全独立的，因此我们不使用复制或任何其他隐式协调系统。**前几节已经描述了如何在单个实例中安全地获取和释放锁，在分布式锁算法中，将使用相同的方法在单个实例中获取和释放锁。**将N设置为5是一个合理的值，因此需要在不同的计算机或虚拟机上运行5个Redis主服务器，确保它们以独立的方式发生故障。
>

为了获取锁，客户端执行以下操作：

> 1. 客户端以毫秒为单位获取当前时间的时间戳，作为**起始时间**。
> 2. 客户端尝试在所有N个实例中顺序使用相同的键名、相同的随机值来获取锁定。每个实例尝试获取锁都需要时间，客户端应该设置一个远小于总锁定时间的超时时间。例如，如果自动释放时间为10秒，则**尝试获取锁的超时时间**可能在5到50毫秒之间。这样可以防止客户端长时间与处于故障状态的Redis节点进行通信：如果某个实例不可用，尽快尝试与下一个实例进行通信。
> 3. 客户端获取当前时间 减去在步骤1中获得的**起始时间**，来计算**获取锁所花费的时间**。当且仅当客户端能够在大多数实例（至少3个）中获取锁时，并且获取锁所花费的总时间小于锁有效时间，则认为已获取锁。
> 4. 如果获取了锁，则将锁有效时间减去 **获取锁所花费的时间**，如步骤3中所计算。
> 5. 如果客户端由于某种原因（无法锁定N / 2 + 1个实例或有效时间为负）而未能获得该锁，它将尝试解锁所有实例（即使没有锁定成功的实例）。

> 每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来产生很小的时钟漂移。只有在拥有锁的客户端将在锁有效时间内（如步骤3中获得的）减去一段时间（仅几毫秒）的情况下终止工作，才能保证这一点。以补偿进程之间的时钟漂移
>

> 当客户端无法获取锁时，它应该在随机延迟后重试，以避免同时获取同一资源的多个客户端之间不同步（这可能会导致脑裂的情况：没人胜）。同样，客户端在大多数Redis实例中尝试获取锁的速度越快，出现裂脑情况（以及需要重试）的窗口就越小，因此理想情况下，客户端应尝试将SET命令发送到N个实例同时使用多路复用。
>

> 值得强调的是，对于未能获得大多数锁的客户端，尽快释放（部分）获得的锁有多么重要，这样就不必等待锁定期满才能再次获得锁（但是，如果发生了网络分区，并且客户端不再能够与Redis实例进行通信，则在等待密钥到期时需要付出可用性损失）。
>

# Redisson分布式锁⭐⭐

## 概述

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225473.png" alt="image-20220501155501783" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225718.png" alt="1568176834908" style="zoom:80%;" />

基于setnx实现的分布式锁存在下面的问题：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205041636119.png" alt="image-20220504163642038" style="zoom: 67%;" />

> Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205041637834.png" alt="image-20220504163729780" style="zoom:67%;" />

官网地址： [https://redisson.org](https://redisson.org/)

GitHub地址： https://github.com/redisson/redisson

官方文档地址：https://github.com/redisson/redisson/wiki

## 功能特点

### 失败无限重试

拿锁失败时会不停的重试，具有 Watch Dog 自动延期机制，默认续 30s 每隔 30/3=10 秒续到 30s。

```java
RLock lock = redisson.getLock("码哥字节");
try {

  // 1.最常用的第一种写法
  lock.lock();

  // 执行业务逻辑
  .....

} finally {
  // 解锁  
  lock.unlock();
}
```

### 失败超时重试，自动续命

```java
// 尝试拿锁10s后停止重试,获取失败返回false，具有Watch Dog 自动延期机制， 默认续30s
boolean flag = lock.tryLock(10, TimeUnit.SECONDS);
```

### 超时自动释放锁

我们也可以通过给锁设置过期时间，让其自动解锁。如下所示，设置锁 8 秒后自动过期。

```java
lock.lock(8, TimeUnit.SECONDS);
```

如果业务执行时间超过 8 秒，手动释放锁将会报错，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204241100217.png" alt="image-20220424110012169" style="zoom:67%;" />

所以我们如果设置了锁的自动过期时间，则执行业务的时间一定要小于锁的自动过期时间，否则就会报错。

### 超时重试，自动解锁

```java
// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁,没有 Watch dog
boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
if (res) {
   try {
     ...
   } finally {
       lock.unlock();
   }
}
```

### Watch Dog 自动延时⭐

> 如果获取分布式锁的节点宕机，且这个锁还处于锁定状态，就会出现死锁。为了避免这个情况，我们都会给锁设置一个超时自动释放时间。然而，还是会存在一个问题。
>

> 假设线程获取锁成功，并设置了 30 s 超时，但是在 30s 内任务还没执行完，锁超时释放了，就会导致其他线程获取不该获取的锁。
>

> 所以，Redisson 提供了 watch dog 自动延时机制，提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期。也就是说，如果一个拿到锁的线程一直没有完成逻辑，那么看门狗会帮助线程不断的延长锁超时时间，锁不会因为超时而被释放。
>

> 默认情况下，看门狗的续期时间是 30s，也可以通过修改 `Config.lockWatchdogTimeout` 来另行指定。另外 `Redisson` 还提供了可以指定 `leaseTime` 参数的加锁方法来指定加锁的时间。超过这个时间后锁便自动解开了，不会延长锁的有效期。
>

原理如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205221111638.png" alt="image-20220522111103529" style="zoom:80%;" />

**有两个点需要注意：**

> watchDog 只有在未显示指定加锁超时时间（leaseTime）时才会生效，lockWatchdogTimeout 设定的时间不要太小 ，比如设置的是 100 毫秒，由于网络直接导致加锁完后，watchdog 去延期时，这个 key 在 redis 中已经被删除了

### 看门狗原理

> 如果负责储存这个分布式锁的 Redisson 节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的**`看门狗`**，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。

> 默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。如果我们未制定 lock 的超时时间，就使用 30 秒作为看门狗的默认时间。只要占锁成功，就会启动一个`定时任务`：每隔 10 秒重新给锁设置过期的时间，过期时间为 30 秒。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204241059198.png" alt="image-20220424105925148" style="zoom:67%;" />

> 当服务器宕机后，因为锁的有效期是 30 秒，所以会在 30 秒内自动解锁。（30秒等于宕机之前的锁占用时间+后续锁占用的时间）。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204241059515.png" alt="image-20220424105949474" style="zoom:67%;" />

## 基本配置

### 引入依赖

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.11.2</version>
</dependency>
```

### 添加配置

```java
@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redissonClient(){
        Config config = new Config();
        // 可以用"rediss://"来启用SSL连接
        config.useSingleServer().setAddress("redis://192.168.88.101:6379").setPassword("315217");
        return Redisson.create(config);
    }
}
```

### 注入对象

```java
@Autowired
private RedissonClient redissonClient;
```

### 其它配置

 [配置文件地址](https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95#221-%E9%80%9A%E8%BF%87yaml%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE)

```java
@Bean
public RedissonClient redissonClient(){
    Config config = new Config();
    // 可以用"redis://"来启用SSL连接
    // 集群连接
    config.useClusterServers().addNodeAddress("redis://192.168.88.101:6379").(...);
    // 单节点连接
    config.useSingleServer()
            .setAddress("redis://127.0.0.1:6379") // redis服务器地址
            .setDatabase(0) // 指定redis数据库编号
            // .setClientName("w") // 给当前连接起名
            // .setPassword("123456") // 密码
            .setConnectionMinimumIdleSize(10) // 连接池最小空间连接数
            .setIdleConnectionTimeout(30) // 线程超时时间
            .setConnectionPoolSize(50) // 连接池最大线程数
            .setConnectTimeout(200) // 客户端程序获取redis链接超时时间
            .setTimeout(200); //响应超时时间
    return Redisson.create(config);
}
```

### 基本使用

```java
@Service
public class StockService {

    @Autowired
    private StringRedisTemplate redisTemplate;
	// 注入对象
    @Autowired
    private RedissonClient redissonClient;

    public void deduct() {
        // 获取锁
        RLock lock = this.redissonClient.getLock("lock");
        // 加锁，可以加上过期时间，这样不解锁也能释放锁：lock.lock(10,TimeUnit.SECONDS);
        lock.lock();
        try {
            // 1. 查询库存信息
            String stock = redisTemplate.opsForValue().get("stock").toString();
            // 2. 判断库存是否充足
            if (stock != null && stock.length() != 0) {
                Integer st = Integer.valueOf(stock);
                if (st > 0) {
                    // 3.扣减库存
                    redisTemplate.opsForValue().set("stock", String.valueOf(--st));
                }
            }
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

## 公共方法

> 大家都知道，如果负责储存这个分布式锁的Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，**Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期**。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改[Config.lockWatchdogTimeout](https://github.com/redisson/redisson/wiki/2.-配置方法#lockwatchdogtimeout监控锁的看门狗超时单位毫秒)来另行指定。
>

另外Redisson还通过加锁的方法提供了`leaseTime`的参数来指定加锁的时间。超过这个时间后锁便自动解开了。

```java
// 10秒钟以后自动解锁
// 无需调用unlock方法手动解锁
lock.lock(10, TimeUnit.SECONDS);

// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
lock.unlock();
```

## 可重入锁（Reentrant Lock）

> 大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗检查锁的超时时间是30秒钟，也可以通过修改`Config.lockWatchdogTimeout`来另行指定。
>

> 可重入锁（Reentrant Lock）是一种具有重入性质的锁，允许同一个线程多次获得同一个锁。在一个线程已经获得了某个锁时，如果该锁是可重入的，那么这个线程在后续尝试获得该锁时，仍然能够获得该锁，而不是被阻塞。

### 基本语法

```java
RLock lock = redisson.getLock("anyLock");
lock.lock();
// 加锁以后10秒钟自动解锁
// 无需调用unlock方法手动解锁
lock.lock(10, TimeUnit.SECONDS);
// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
if (res) {
   try {
     ...
   } finally {
       lock.unlock();
   }
}
```

Redisson同时还为分布式锁提供了异步执行的相关方法：

```java
RLock lock = redisson.getLock("anyLock");
lock.lockAsync();
lock.lockAsync(10, TimeUnit.SECONDS);
Future<Boolean> res = lock.tryLockAsync(100, 10, TimeUnit.SECONDS);
```

`RLock`对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出`IllegalMonitorStateException`错误。但是如果遇到需要其他进程也能解锁的情况，请使用[分布式信号量`Semaphore`](https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器#86-信号量semaphore) 对象.

### MySQL

```java
@Autowired
private RedissonClient redissonClient;

public void checkAndLock() {
    // 加锁，获取锁失败重试
    RLock lock = this.redissonClient.getLock("lock");
    lock.lock();
    // 先查询库存是否充足
    stock stock = this.stockMapper.selectById(1L);
    // 再减库存
    if (stock != null && stock.getCount() > 0){
        stock.setCount(stock.getCount() - 1);
        this.stockMapper.updateById(stock);
    }
    // 释放锁
    lock.unlock();
}
```

### Redis⭐

```java
@Service
public class StockService {

    @Autowired
    private RedissonClient redissonClient;

    public void deduct() {
        // 加锁，获取锁失败重试
        RLock lock = this.redissonClient.getLock("lock");
        lock.lock();
        try {
            // 1. 查询库存信息
            String stock = redisTemplate.opsForValue().get("stock").toString();
            // 2. 判断库存是否充足
            if (stock != null && stock.length() != 0) {
                Integer st = Integer.valueOf(stock);
                if (st > 0) {
                    // 3.扣减库存
                    redisTemplate.opsForValue().set("stock", String.valueOf(--st));
                }
            }
        } finally {
            // 确保锁一定被释放
            lock.unlock();
        }
    }
}
```

压力测试，性能跟我们手写的区别不大。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061623072.png" alt="image-20230506162352969" style="zoom:80%;" />

数据库也没有问题

## 验证自动续期 & 可重入性

### 自动续期

添加一个睡眠时间

```java
public void deduct() {
    // 加锁，获取锁失败重试
    RLock lock = this.redissonClient.getLock("lock");
    lock.lock();
    try {
        // 1. 查询库存信息
        String stock = redisTemplate.opsForValue().get("stock").toString();
        // 2. 判断库存是否充足
        if (stock != null && stock.length() != 0) {
            Integer st = Integer.valueOf(stock);
            if (st > 0) {
                // 3.扣减库存
                redisTemplate.opsForValue().set("stock", String.valueOf(--st));
            }
        }
        // 测试自动续期
        try {
            TimeUnit.SECONDS.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    } finally {
        lock.unlock();
    }
}
```

重新启动任务

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061648984.png" alt="image-20230506164817875" style="zoom:80%;" />

访问，查看Redis锁状态

/stock/deduct

> 不断刷新，发现锁一直在20s-30s，没有过期，因为任务没有结束

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061648993.png" alt="image-20230506164845905" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061649090.png" alt="image-20230506164903001" style="zoom:80%;" />

### 可重入性

```java
@Service
public class StockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    public void deduct() {
        // 加锁，获取锁失败重试
        RLock lock = this.redissonClient.getLock("lock");
        lock.lock();
        try {
            // 1. 查询库存信息
            String stock = redisTemplate.opsForValue().get("stock").toString();
            // 2. 判断库存是否充足
            if (stock != null && stock.length() != 0) {
                Integer st = Integer.valueOf(stock);
                if (st > 0) {
                    // 3.扣减库存
                    redisTemplate.opsForValue().set("stock", String.valueOf(--st));
                }
            }
            // 测试可重入
            this.test();
        } finally {
            lock.unlock();
        }
    }
	// 测试可重入性
    public void test() {
        RLock lock = this.redissonClient.getLock("lock");
        lock.lock();
        System.out.println("测试可重入锁");
        lock.unlock();
    }
}
```

## 公平锁（Fair Lock）⭐

> 它**保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程**。**所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒**。**谁的手速、网速快，谁先得到锁，谁就先完成业务**

```java
RLock fairLock = redisson.getFairLock("lock");
fairLock.lock();
// 业务实现
fairLock.unlock();
```

测试公平锁

```java
@GetMapping("test/fair/lock/{id}")
public String testFairLock(@PathVariable("id") Long id){
    this.stockService.testFairLock(id);
    return "Hello, testFairLock";
}
```

```java
@Service
public class StockService {

    @Autowired
    private RedissonClient redissonClient;

    public void testFairLock(Long id) {
        RLock fairLock = redissonClient.getFairLock("lock");
        fairLock.lock();
        try {
            TimeUnit.SECONDS.sleep(10);
            System.out.println("测试公平锁=====" + id);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            fairLock.unlock();
        }
    }
}
```

访问测试，发现是按顺序打印的内容

/test/fair/lock/1

/test/fair/lock/2

/test/fair/lock/3

进入redis中查看锁的状态，得快点，不然锁就自动删除了

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061706586.png" alt="image-20230506170659493" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061706540.png" alt="image-20230506170624442" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305061706912.png" alt="image-20230506170640817" style="zoom:80%;" />

## 联锁（MultiLock）

> 基于Redis的Redisson分布式联锁[`RedissonMultiLock`](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/RedissonMultiLock.html)对象可以将多个`RLock`对象关联为一个联锁，每个`RLock`对象实例可以来自于不同的Redisson实例。**没啥用，任意一台Redis宕机锁就不能用了**
>

```java
RLock lock1 = redissonInstance1.getLock("lock1");
RLock lock2 = redissonInstance2.getLock("lock2");
RLock lock3 = redissonInstance3.getLock("lock3");

RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);
// 同时加锁：lock1 lock2 lock3
// 所有的锁都上锁成功才算成功
lock.lock();
// 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开
// lock.lock(10, TimeUnit.SECONDS);
...
lock.unlock();
```



## 红锁（RedLock）

基于Redis的Redisson红锁`RedissonRedLock`对象实现了[Redlock](http://redis.cn/topics/distlock.html)介绍的加锁算法。该对象也可以用来将多个`RLock`对象关联为一个红锁，每个`RLock`对象实例可以来自于不同的Redisson实例。使用不多

```java
RLock lock1 = redissonInstance1.getLock("lock1");
RLock lock2 = redissonInstance2.getLock("lock2");
RLock lock3 = redissonInstance3.getLock("lock3");

RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);
// 同时加锁：lock1 lock2 lock3
// 红锁在大部分节点上加锁成功就算成功。
lock.lock();
...
lock.unlock();
```

## 读写锁（ReadWriteLock）

写锁是一个排他锁（互斥锁），读锁是一个共享锁。

> - 读锁 + 读锁：相当于没加锁，可以并发读。
> - 读锁 + 写锁：写锁需要等待读锁释放锁。
> - 写锁 + 写锁：互斥，需要等待对方的锁释放。
> - 写锁 + 读锁：读锁需要等待写锁释放。

分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。

```java
RReadWriteLock rwlock = redisson.getReadWriteLock("anyRWLock");
// 最常见的使用方法
rwlock.readLock().lock();
// 或
rwlock.writeLock().lock();

// 10秒钟以后自动解锁
// 无需调用unlock方法手动解锁
rwlock.readLock().lock(10, TimeUnit.SECONDS);
// 或
rwlock.writeLock().lock(10, TimeUnit.SECONDS);

// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);
// 或
boolean res = rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);
...
lock.unlock();
```

添加StockController方法：

```java
@GetMapping("test/read")
public String testRead(){
    String msg = stockService.testRead();
    return "测试读";
}

@GetMapping("test/write")
public String testWrite(){
    String msg = stockService.testWrite();
    return "测试写";
}
```

添加StockService方法：

```java
public String testRead() {
    // 读写锁名称要一致，不然就没用了
    RReadWriteLock rwLock = this.redissonClient.getReadWriteLock("rwLock");
    rwLock.readLock().lock(10, TimeUnit.SECONDS);
    System.out.println("测试读锁。。。。");
    // rwLock.readLock().unlock();

    return null;
}

public String testWrite() {
    RReadWriteLock rwLock = this.redissonClient.getReadWriteLock("rwLock");
    rwLock.writeLock().lock(10, TimeUnit.SECONDS);
    System.out.println("测试写锁。。。。");
    // rwLock.writeLock().unlock();
    return null;
}
```

打开开两个浏览器窗口测试：由下可见，只有读是可以并发，其他都不能并发

- 同时访问写：一个写完之后，等待一会儿（约10s），另一个写开始
- 同时访问读：不用等待
- 先写后读：读要等待（约10s）写完成
- 先读后写：写要等待（约10s）读完成

## 信号量（Semaphore）⭐

### 基本语法

> 关于信号量的使用大家可以想象一下这个场景，有三个停车位，当三个停车位满了后，其他车就不停了。可以把车位比作信号，现在有三个信号，停一次车，用掉一个信号，车离开就是释放一个信号。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204241101129.png" alt="image-20220424110149074" style="zoom: 50%;" />

```java
acquire()：获取信号量

tryAcquire()：尝试获取信号量，如果当前信号量已被占用，则返回 false

release()：释放信号量

drainPermits()：获取当前可用的信号量数量

availablePermits()：获取当前剩余的信号量数量

reducePermits(int reduction)：减少当前可用的信号量数量
```



```java
RSemaphore semaphore = redisson.getSemaphore("semaphore");
semaphore.trySetPermits(3); // 限定资源量，只有3个资源
semaphore.acquire(); // 获取信号量
semaphore.release(); // 释放信号量
```

### 单机版本(JUC自带)

```java
// JUC自带的
public static void t1() {
    Semaphore semaphore = new Semaphore(3);
    for (int i = 0; i < 3; i++) {
        new Thread(()->{
            try {
                semaphore.acquire();
                System.out.println(Thread.currentThread().getName()+"抢到停车位");
                TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                System.out.println(Thread.currentThread().getName()+"停了一会开走了");
                semaphore.release();
            } catch (Exception e) {
                e.printStackTrace();
            }
        },i+"号车").start();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209060943867.png" alt="image-20220906094314774" style="zoom:80%;" />

### 分布式版本⭐

在StockController添加方法：

```java
@GetMapping("test/semaphore")
public String testSemaphore(){
    this.stockService.testSemaphore();
    return "测试信号量";
}
```

在StockService添加方法：

```java
public void testSemaphore() {
    RSemaphore semaphore = this.redissonClient.getSemaphore("semaphore");
    // 限定资源量，再次修改需要先在redis中删除semaphore，再进行修改才生效
    semaphore.trySetPermits(3);
    try {
        // 获取信号量
        semaphore.acquire();
        // 开始处理业务逻辑
        this.redisTemplate.opsForList()
            .rightPush("log","10086获取资源，开始业务处理"+Thread.currentThread().getName());
        // 随机睡眠时间
        TimeUnit.SECONDS.sleep(new Random().nextInt(10)); 
        this.redisTemplate.opsForList()
            .rightPush("log","10086处理完业务，开始释放资源"+Thread.currentThread().getName());
        // 释放信号量
        semaphore.release();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

添加测试用例：并发3次，循环1次

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209060955413.png" alt="image-20220906095537321" style="zoom:80%;" />

控制台效果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209060958572.png" alt="image-20220906095858482" style="zoom:80%;" />

> 停车位场景
>

```java
@Autowired
private RedissonClient redisson;
```

先定义一个占用停车位的方法：

```java
// 停车，占用停车位,总共 3 个车位
@GetMapping("park")
public String park() throws InterruptedException {
    // 获取信号量（停车场）
    RSemaphore park = redisson.getSemaphore("park");
    // 限定资源量，再次修改需要先在redis中删除semaphore，再进行修改才生效
    park.trySetPermits(3);
    // 获取一个信号（停车位）
    park.acquire();
    return "OK";
}
```

再定义一个离开车位的方法：

```java
// 释放车位，总共 3 个车位
@GetMapping("leave")
public String leave() throws InterruptedException {
    // 获取信号量（停车场）
    RSemaphore park = redisson.getSemaphore("park");
    // 释放一个信号（停车位）
    park.release();
    return "OK";
}
```

执行3次停车方法：/park

执行leave方法，才能继续执行上面的park方法：/leave

**注意**：多次执行释放信号量操作，剩余信号量会一直增加，而不是到 3 后就封顶了。

## 闭锁（CountDownLatch）⭐

### 基本语法

> CountDownLatch 的作用是**阻塞一个或多个线程，直到一个或多个事件完成为止，也可以称为倒计数器**
>

```java
RCountDownLatch latch = redisson.getCountDownLatch("anyCountDownLatch");
latch.trySetCount(10); // 设置计数器数量为 10
latch.await(); // 阻塞当前线程，等待计数器为 0

// 在其他线程或其他JVM里
RCountDownLatch latch = redisson.getCountDownLatch("anyCountDownLatch");
latch.countDown(); // 减少计数器数量
```

需要两个方法：一个等待，一个计数countDown

### 单机版本(JUC自带)

```java
public static void t1() throws InterruptedException {
    CountDownLatch countDownLatch = new CountDownLatch(3);
    for (int i = 0; i < 3; i++) {
        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"准备出门了");
                TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                System.out.println(Thread.currentThread().getName()+"出门了");
                countDownLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
            }
        },i+"号同学").start();
    }
    countDownLatch.await();
    System.out.println(Thread.currentThread().getName()+"班长锁门");
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209061008644.png" alt="image-20220906100840553" style="zoom:80%;" />

### 分布式版本⭐

给StockController添加测试方法：

```java
@GetMapping("test/latch")
public String testLatch(){
    this.stockService.testLatch();
    return "班长锁门。。。";
}

@GetMapping("test/countdown")
public String testCountDown(){
    this.stockService.testCountDown();
    return "出来了一位同学";
}
```

给StockService添加测试方法：

```java
// 注意起的名字"latch"要一样，这样才能进行正常的减小
public void testLatch() {
    RCountDownLatch latch = this.redissonClient.getCountDownLatch("latch");
    latch.trySetCount(6); // 设置计数器数量为 6
    try {
        latch.await();  // 阻塞当前线程，等待计数器为 0
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

public void testCountDown() {
    RCountDownLatch latch = this.redissonClient.getCountDownLatch("latch");
    latch.trySetCount(6);
    latch.countDown();  // 减少计数器数量
}
```

重启测试，打开两个页面：当第二个请求执行6次之后，第一个请求才会执行。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225765.png" alt="1606962536746" style="zoom:80%;" />



# 基于zookeeper的分布式锁

## 基本概述

> 实现分布式锁目前有三种流行方案，分别为基于数据库、Redis、Zookeeper的方案。这里主要介绍基于zk怎么实现分布式锁。在实现分布式锁之前，先回顾zookeeper的相关知识点
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225963.png" alt="image-20220622191952608" style="zoom:80%;" />

> **数据组织：数据节点以树形目录(类似文件系统)组织管理，每一个节点中都会保存数据信息和节点信息**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211100931589.png" alt="image-20221110093121482" style="zoom:80%;" />

> **集群模式：通常是由3、5个基数实例组成集群，当超过半数服务实例正常工作就能对外提供服务，既能避免单点故障，又尽量高可用，每个服务实例都有一个数据备份，以实现数据全局一致**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211100932138.png" alt="image-20221110093224026" style="zoom:80%;" />

> **顺序更新：更新请求都会转由leader执行，来自同一客户端的更新将按照发送的顺序被写入到ZK，处理写请求创建Znode时，Znode名称后会被分配一个全局唯一的递增编号，可以通过顺序号推断请求的顺序，利用这个特性可以实现高级协调服务**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211100932039.png" alt="image-20221110093235962" style="zoom:50%;" />

> **监听机制：给某个节点注册监听器，该节点一旦发生变更（例如更新或者删除），监听者就会收到一个Watch Event，可以感知到节点\数据的变更**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211100933755.png" alt="image-20221110093308635" style="zoom:50%;" />

> **临时节点：session链接断开临时节点就没了，不能创建子节点（很关键）**

ZK的分布式锁正是基于以上特性来实现的，简单来说是：

> - **临时节点：用于支撑异常情况下的锁自动释放能力**
> - **顺序节点：用于支撑公平锁获取锁和排队等待的能力**
> - **监听机制：用于支撑抢锁能力**
> - **集群模式：用于支撑锁服务的高可用**

## 基础使用

### 安装配置

https://zookeeper.apache.org/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209070834168.png" alt="image-20220907083402952" style="zoom:80%;" />

安装：把zk安装包上传到/opt目录下，并切换到/opt目录下，执行以下指令

```shell
# 解压
tar -zxvf zookeeper-3.7.0-bin.tar.gz
# 重命名
mv apache-zookeeper-3.7.0-bin/ zookeeper
# 打开zookeeper根目录
cd zookeeper
# 创建一个数据目录，备用
mkdir data
# 打开zk的配置目录
cd conf
# copy配置文件，zk启动时会加载zoo.cfg文件
cp zoo_sample.cfg zoo.cfg
# 编辑配置文件
vim zoo.cfg
# 修改dataDir参数为之前创建的数据目录：/root/zookeeper/data
```

### 配置文件

```apl
# zookeeeper集群通信时间，单位ms，心跳
tickTime=2000
# 初始周期，节点数据同步时间，10个心跳时间，10个周期
initLimit=10
# 发送请求和获取响应时间，5个心跳时间没获取响应，就挂了
syncLimit=5
# 数据目录
dataDir=/root/zookeeper/data
# 监听端口号
clientPort=2181
# 服务器端口号，默认8080，启动出错就切换端口号
admin.serverPort=10086
```

### 启动停止

```sh
# 切换到bin目录
cd /root/zookeeper/bin
# 启动 
./zkServer.sh start
./zkServer.sh status # 查看启动状态
./zkServer.sh stop # 停止
./zkServer.sh restart # 重启
./zkCli.sh # 进入zk客户端
```

如下，说明启动成功：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209070933618.png" alt="image-20220907093336504" style="zoom:67%;" />

如果启动失败，查看启动错误

```sh
./zkServer.sh start-foreground
```

可能原因：8080端口被占用，替换端口即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209070931228.png" alt="image-20220907093114083" style="zoom:80%;" />

如果要使用服务器直接换一个端口号即可，在配置文件conf中的zoo.cfg添加`admin.serverPort=10086`即可

### 加解锁流程⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211100934077.png" alt="image-20221110093406995" style="zoom:80%;" />

> 1. 创建一个永久节点作为锁节点（/lock2）
> 2. 试图加锁的客户端在指定锁名称节点（/lock2）下，创建临时顺序子节点
> 3. 获取锁节点（/lock2）下所有子节点
> 4. 对所获取的子节点按节点自增序号从小到大排序
> 5. 判断自己是不是第一个子节点，若是，则获取锁
> 6. 若不是，则监听比该节点小的那个节点的删除事件（这种只监听前一个节点的方式避免了惊群效应）
> 7. 若是阻塞申请锁，则申请锁的操作可增加阻塞等待
> 8. 若监听事件生效（说明前节点释放了，可以尝试去获取锁），则回到第3步重新进行判断，直到获取到锁
> 9. 解锁时，将第一个子节点删除释放

## 节点操作

> Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。并且每个节点都是唯一的。

### 基本命令

```sh
# 进入zk客户端
cd /root/zookeeper/bin
./zkCli.sh 
```

```sh
# 查看子节点
ls /
ls /zookeeper
# 查看子节点的数据
get /zookeeper
# 创建节点
create /aa
# 创建节点并添加数据
create /bb "test"
# 删除节点
delete /aa 
# 为已有的节点添加数据
set /aa "test1"
get /aa
# 获取帮助命令
xx
```

### 节点类型

```sh
# 永久节点PERSISTENT：客户端与zookeeper断开连接后，该节点依旧存在
create /ren "say hello"
# 临时节点EPHEMERAL：客户端与zookeeper断开连接后，该节点被删除
create -e /ren1 "say hello1"
# 永久序列化节点PERSISTENT_SEQUENTIAL：客户端与zookeeper断开连接后，该节点依旧存在，同时进行顺序编号
create -s /ren2 "say hello2"
# 临时序列化节点EPHEMERAL_SEQUENTIAL：客户端与zookeeper断开连接后，该节点被删除，同时进行顺序编号
create -s -e /ren3 "say hello3"
```

### 事件监听

> 事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper针对节点的监听有如下四种事件：

```sh
# 打开两个shell窗口，分别进入
cd /root/zookeeper/bin
./zkCli.sh 
```

```sh
# 查看节点基本信息
stat /zookeeper
# 监听节点状态，进入令一个窗口，创建节点
stat -w /bb
create /bb "say hello"
# 节点数据变化：NodeDataChanged
get -w /bb
# 子节点变化：NodeChildrenChanged
ls -w /bb
```

## Java客户端

ZooKeeper的java客户端有：原生客户端、ZkClient、Curator框架（类似于redisson，有很多功能性封装）。

### 引入依赖

```xml
<dependency>
    <groupId>org.apache.zookeeper</groupId>
    <artifactId>zookeeper</artifactId>
    <version>3.7.0</version>
    <exclusions>
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### 连接操作

```java
public class zkTest {
    public static void main(String[] args) throws InterruptedException {
        // 获取zookeeper链接
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ZooKeeper zooKeeper = null;
        try {
            // 第一个参数是IP:PORT，第二个参数是超时时间，第三个参数是监听器
            zooKeeper = new ZooKeeper("192.168.88.101:2181", 30000, new Watcher() {

                @Override
                public void process(WatchedEvent event) {
                    //获取连接状态
                    Event.KeeperState state = event.getState();
                    if (Event.KeeperState.SyncConnected.equals(state)) {
                        System.out.println("获取链接成功。。。。。。" + event);
                        countDownLatch.countDown();
                    } else if (Event.KeeperState.Closed.equals(state)) {
                        System.out.println("关闭链接。。。");
                    }
                }
            });
            countDownLatch.await();
            System.out.println("一顿操作猛如虎。。。");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 关闭zookeeper
            if (zooKeeper != null) {
                zooKeeper.close();
            }
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071045469.png" alt="image-20230507104519303" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071045357.png" alt="image-20230507104542211" style="zoom:80%;" />

### 节点新增

> 要先创建根节点，不然会报错
>

```java
// 节点新增：永久，临时，永久序列化，临时序列化
// 创建一个节点，1-节点路径 2-节点内容 3-节点的访问权限 4-节点类型，永久，临时等
// OPEN_ACL_UNSAFE：任何人可以操作该节点
// CREATOR_ALL_ACL：创建者拥有所有访问权限
// READ_ACL_UNSAFE: 任何人都可以读取该节点
// 创建根节点
zooKeeper.create("/atguigu", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.PERSISTENT);

zooKeeper.create("/atguigu/aa", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.PERSISTENT);

zooKeeper.create("/test", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                 CreateMode.EPHEMERAL);

zooKeeper.create("/atguigu/cc", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                 CreateMode.PERSISTENT_SEQUENTIAL);

zooKeeper.create("/atguigu/dd", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                 CreateMode.EPHEMERAL_SEQUENTIAL);

zooKeeper.create("/atguigu/dd", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                 CreateMode.EPHEMERAL_SEQUENTIAL);

zooKeeper.create("/atguigu/dd", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                 CreateMode.EPHEMERAL_SEQUENTIAL);
```

```java
package com.it.zk;

import org.apache.zookeeper.*;
import java.util.concurrent.CountDownLatch;

public class zkTest {
    public static void main(String[] args) throws InterruptedException {
        // 获取zookeeper链接
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ZooKeeper zooKeeper = null;
        try {
            // 第一个参数是IP:PORT，第二个参数是超时时间，第三个参数是监听器
            zooKeeper = new ZooKeeper("192.168.88.101:2181", 30000, new Watcher() {

                @Override
                public void process(WatchedEvent event) {
                    //获取连接状态
                    Event.KeeperState state = event.getState();
                    if (Event.KeeperState.SyncConnected.equals(state)) {
                        System.out.println("获取链接成功。。。。。。" + event);
                        countDownLatch.countDown();
                    } else if (Event.KeeperState.Closed.equals(state)) {
                        System.out.println("关闭链接。。。");
                    }
                }
            });
            countDownLatch.await();
            System.out.println("一顿操作猛如虎。。。");
            // 新增节点
            zooKeeper.create("/atguigu", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                    CreateMode.PERSISTENT);
            zooKeeper.create("/atguigu/aa", "haha~~".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                   CreateMode.PERSISTENT);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 关闭zookeeper
            if (zooKeeper != null) {
                zooKeeper.close();
            }
        }
    }
}
```

### 节点查询

```java
// 就在这个下面进行操作
System.out.println("一顿操作猛如虎。。。");
// 1、判断节点是否存在
Stat stat = zooKeeper.exists("/atguigu", false);
if (stat != null){
    System.out.println("当前节点存在！" + stat.getVersion());
} else {
    System.out.println("当前节点不存在！");
}

// 2、获取一个节点的数据
byte[] data = zooKeeper.getData("/atguigu/aa", false, stat);
System.out.println(new String(data));

// 3、查询一个节点的所有子节点
List<String> children = zooKeeper.getChildren("/atguigu", false);
System.out.println(children);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071030190.png" alt="image-20220907103008957" style="zoom:80%;" />

### 更新和删除

```java
// 判断节点是否存在
Stat stat = zooKeeper.exists("/atguigu/aa", false);

// 更新，版本号必须和当前节点一致，否则更新失败，版本号可以设置成-1，表示不关心版本号
zooKeeper.setData("/atguigu/aa", "wawa...".getBytes(), stat.getVersion());
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071038581.png" alt="image-20220907103854471" style="zoom:80%;" />

```java
// 删除一个节点，第二个参数也是版本号，同更新一样,再次查询已经没有数据了
zooKeeper.delete("/atguigu/aa", -1);
```

### 节点监听

```java
List<String> children = zooKeeper.getChildren("/atguigu", new Watcher() {
    @Override
    public void process(WatchedEvent watchedEvent) {
        System.out.println("子节点发生变化");
    }
});
System.out.println(children);
System.out.println(children);
// 实现客户端不关闭，为了监听
System.in.read();
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071100097.png" alt="image-20230507110008952" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071049937.png" alt="image-20220907104940796" style="zoom:80%;" />

## ZK分布式锁

### 分布式锁步骤

> 1. 获取锁：create一个节点
> 2. 删除锁：delete一个节点
> 3. 重试：没有获取到锁的请求重试

> 1. 接收到请求时，在/locks节点下创建一个临时序列化节点
> 2. 判断自己是不是/locks节点下最下的节点：是则获取到锁，不是则监听前一个节点
> 3. 获取锁，处理完业务逻辑，通过delete删除当前节点释放锁。监听当前节点的下一个节点收到通知，重复第二步

### 基本实现

> 1. 多个请求同时添加一个相同的临时节点，只有一个可以添加成功。添加成功的获取到锁
> 2. 执行业务逻辑
> 3. 完成业务流程后，删除节点释放锁。

由于zookeeper获取链接是一个耗时过程，这里可以在项目启动时，初始化链接，并且只初始化一次。借助于spring特性，代码实现如下：

```java
@Component
public class ZkClient {

    private static final String connectString = "192.168.88.101:2181";

    private static final String ROOT_PATH = "/distributed";

    private ZooKeeper zooKeeper;
    // 该注解表示项目启动会立即执行该方法
    @PostConstruct
    public void init(){
        try {
            // 连接zookeeper服务器
            this.zooKeeper = new ZooKeeper(connectString, 30000, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    System.out.println("获取链接成功！！");
                }
            });
            // 创建分布式锁根节点
            if (this.zooKeeper.exists(ROOT_PATH, false) == null){
                this.zooKeeper.create(ROOT_PATH, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                                      CreateMode.PERSISTENT);
            }
        } catch (Exception e) {
            System.out.println("获取链接失败！");
            e.printStackTrace();
        }
    }
    // 项目停止立刻释放连接
    @PreDestroy
    public void destroy(){
        try {
            if (zooKeeper != null){
                zooKeeper.close();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    // 初始化zk分布式锁对象方法
    public ZkDistributedLock getZkDistributedLock(String lockName){
        return new ZkDistributedLock(zooKeeper, lockName);
    }
}
```

zk分布式锁具体实现

```java
public class ZkDistributedLock {

    private static final String ROOT_PATH = "/distributed";

    private String path;

    private ZooKeeper zooKeeper;

    public ZkDistributedLock(ZooKeeper zooKeeper, String lockName){
        this.zooKeeper = zooKeeper;
        this.path = ROOT_PATH + "/" + lockName;
    }

    public void lock(){
        try {
            zooKeeper.create(path, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        } catch (Exception e) {
            // 重试
            try {
                Thread.sleep(200);
                lock();
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    public void unlock(){
        try {
            this.zooKeeper.delete(path, 0);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }
}
```

改造StockService的deduct方法：

```java
@Autowired
private ZKClient client;

public void deduct() {
    // 加锁，获取锁失败重试
    ZkDistributedLock lock = this.client.getZkDistributedLock("lock");
    lock.lock();

    // 先查询库存是否充足
    Stock stock = this.stockMapper.selectById(1L);
    // 再减库存
    if (stock != null && stock.getCount() > 0){
        stock.setCount(stock.getCount() - 1);
        this.stockMapper.updateById(stock);
    }

    // 释放锁
    lock.unlock();
}
```

Jmeter压力测试：

![1607046072239](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225994.png)

性能一般，mysql数据库的库存余量为0（注意：所有测试之前都要先修改库存量为5000）

基本实现存在的问题：

1. 性能一般（比mysql分布式锁略好）
2. 不可重入

接下来首先来提高性能

## 优化：性能优化

基本实现中由于无限自旋影响性能：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225010.png" alt="1607048160051" style="zoom:67%;" />

试想：每个请求要想正常的执行完成，最终都是要创建节点，如果能够避免争抢必然可以提高性能。

这里借助于zk的临时序列化节点，实现分布式锁：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225215.png" alt="1607048783043" style="zoom:80%;" />

### 实现阻塞锁

代码实现：

```java
public class ZkDistributedLock {

    private static final String ROOT_PATH = "/distributed";

    private String path;

    private ZooKeeper zooKeeper;

    public ZkDistributedLock(ZooKeeper zooKeeper, String lockName){
        try {
            this.zooKeeper = zooKeeper;
            this.path = zooKeeper.create(ROOT_PATH + "/" + lockName + "-", null, 
                                         ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                                         CreateMode.EPHEMERAL_SEQUENTIAL);
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void lock(){
        String preNode = getPreNode(path);
        // 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑
        if (StringUtils.isEmpty(preNode)){
            return ;
        }
        // 重新检查。是否获取到锁
        try {
            Thread.sleep(20);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        lock();
    }

    public void unlock(){
        try {
            this.zooKeeper.delete(path, 0);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取指定节点的前节点
     * @param path
     * @return
     */
    private String getPreNode(String path){

        try {
            // 获取当前节点的序列化号
            Long curSerial = Long.valueOf(StringUtils.substringAfterLast(path, "-"));
            // 获取根路径下的所有序列化子节点
            List<String> nodes = this.zooKeeper.getChildren(ROOT_PATH, false);

            // 判空
            if (CollectionUtils.isEmpty(nodes)){
                return null;
            }

            // 获取前一个节点
            Long flag = 0L;
            String preNode = null;
            for (String node : nodes) {
                // 获取每个节点的序列化号
                Long serial = Long.valueOf(StringUtils.substringAfterLast(node, "-"));
                if (serial < curSerial && serial > flag){
                    flag = serial;
                    preNode = node;
                }
            }

            return preNode;
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

主要修改了构造方法和lock方法：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225233.png" alt="1607051823582" style="zoom:80%;" />

并添加了getPreNode获取前置节点的方法。测试结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225251.png" alt="1607051896117" style="zoom:80%;" />

> 性能反而更弱了。原因：虽然不用反复争抢创建节点了，但是会自旋判断自己是最小的节点，这个判断逻辑反而更复杂更耗时。解决方案：监听。
>

### 监听实现阻塞锁

> 对于这个算法有个极大的优化点：假如当前有1000个节点在等待锁，如果获得锁的客户端释放锁时，这1000个客户端都会被唤醒，这种情况称为“羊群效应”；在这种羊群效应中，zookeeper需要通知1000个客户端，这会阻塞其他的操作，最好的情况应该只唤醒新的最小节点对应的客户端。

> 应该怎么做呢？在设置事件监听时，每个客户端应该对刚好在它之前的子节点设置事件监听，例如子节点列表为/locks/lock-0000000000、/locks/lock-0000000001、/locks/lock-0000000002，序号为1的客户端监听序号为0的子节点删除消息，序号为2的监听序号为1的子节点删除消息。

所以调整后的分布式锁算法流程如下：

- 客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/locks/lock-0000000000，第二个为/locks/lock-0000000001，以此类推；
- 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，**否则监听刚好在自己之前一位的子节点删除消息**，获得子节点变更通知后重复此步骤直至获得锁；
- 执行业务代码；
- 完成业务流程后，删除对应的子节点释放锁。

改造ZkDistributedLock的lock方法：

```java
public void lock(){
    try {
        String preNode = getPreNode(path);
        // 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑
        if (StringUtils.isEmpty(preNode)){
            return ;
        } else {
            CountDownLatch countDownLatch = new CountDownLatch(1);
            if (this.zooKeeper.exists(ROOT_PATH + "/" + preNode, new Watcher(){
                @Override
                public void process(WatchedEvent event) {
                    countDownLatch.countDown();
                }
            }) == null) {
                return;
            }
            // 阻塞。。。。
            countDownLatch.await();
            return;
        }
    } catch (Exception e) {
        e.printStackTrace();
        // 重新检查。是否获取到锁
        try {
            Thread.sleep(200);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        lock();
    }
}
```

压力测试效果如下：

![1607052541669](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225268.png)

由此可见性能提高不少，接近于redis的分布式锁

## 优化：可重入锁

引入ThreadLocal线程局部变量保证zk分布式锁的可重入性。

```java
public class ZkDistributedLock {

    private static final String ROOT_PATH = "/distributed";
    private static final ThreadLocal<Integer> THREAD_LOCAL = new ThreadLocal<>();

    private String path;

    private ZooKeeper zooKeeper;

    public ZkDistributedLock(ZooKeeper zooKeeper, String lockName){
        try {
            this.zooKeeper = zooKeeper;
            if (THREAD_LOCAL.get() == null || THREAD_LOCAL.get() == 0){
                this.path = zooKeeper.create(ROOT_PATH + "/" + lockName + "-", null, 
                                             ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                                             CreateMode.EPHEMERAL_SEQUENTIAL);
            }
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void lock(){
        Integer flag = THREAD_LOCAL.get();
        if (flag != null && flag > 0) {
            THREAD_LOCAL.set(flag + 1);
            return;
        }
        try {
            String preNode = getPreNode(path);
            // 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑
            if (StringUtils.isEmpty(preNode)){
                THREAD_LOCAL.set(1);
                return ;
            } else {
                CountDownLatch countDownLatch = new CountDownLatch(1);
                if (this.zooKeeper.exists(ROOT_PATH + "/" + preNode, new Watcher(){
                    @Override
                    public void process(WatchedEvent event) {
                        countDownLatch.countDown();
                    }
                }) == null) {
                    THREAD_LOCAL.set(1);
                    return;
                }
                // 阻塞。。。。
                countDownLatch.await();
                THREAD_LOCAL.set(1);
                return;
            }
        } catch (Exception e) {
            e.printStackTrace();
            // 重新检查。是否获取到锁
            try {
                Thread.sleep(200);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            lock();
        }
    }

    public void unlock(){
        try {
            THREAD_LOCAL.set(THREAD_LOCAL.get() - 1);
            if (THREAD_LOCAL.get() == 0) {
                this.zooKeeper.delete(path, 0);
                THREAD_LOCAL.remove();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取指定节点的前节点
     * @param path
     * @return
     */
    private String getPreNode(String path){

        try {
            // 获取当前节点的序列化号
            Long curSerial = Long.valueOf(StringUtils.substringAfterLast(path, "-"));
            // 获取根路径下的所有序列化子节点
            List<String> nodes = this.zooKeeper.getChildren(ROOT_PATH, false);

            // 判空
            if (CollectionUtils.isEmpty(nodes)){
                return null;
            }

            // 获取前一个节点
            Long flag = 0L;
            String preNode = null;
            for (String node : nodes) {
                // 获取每个节点的序列化号
                Long serial = Long.valueOf(StringUtils.substringAfterLast(node, "-"));
                if (serial < curSerial && serial > flag){
                    flag = serial;
                    preNode = node;
                }
            }

            return preNode;
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

## ZK分布式锁小结

参照redis分布式锁的特点：

1. 互斥 排他：zk节点的不可重复性，以及序列化节点的有序性
2. 防死锁：
   1. 可自动释放锁：临时节点
   2. 可重入锁：借助于ThreadLocal
3. 防误删：临时节点
4. 加锁/解锁要具备原子性
5. 单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。
6. 集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。
7. 公平锁：有序性节点

# Curator分布式锁⭐⭐

> Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。**Curator解决了很多zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册wathcer和NodeExistsException 异常**等。
>

通过查看官方文档，可以发现Curator主要解决了三类问题：

> - 封装ZooKeeper client与ZooKeeper server之间的连接处理
> - 提供了一套Fluent风格的操作API
> - 提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装，这些实现都遵循了zk的最佳实践，并考虑了各种极端情况

Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：

> - curator-framework：提供了常见的zk相关的底层操作
> - curator-recipes：提供了一些zk的典型使用场景的参考。本节重点关注的分布式锁就是该包提供的

## 接口介绍

```java
// 获取互斥锁
public void acquire() throws Exception;

// 在给定的时间内获取互斥锁
public boolean acquire(long time, TimeUnit unit) throws Exception;

// 释放锁处理public void release() throws Exception;
// 如果当前线程获取了互斥锁，则返回true
boolean isAcquiredInThisProcess();
```

## 基本配置

最新版本的curator 4.3.0支持zookeeper 3.4.x和3.5，但是需要注意curator传递进来的依赖，需要和实际服务器端使用的版本相符，以我们目前使用的zookeeper 3.4.14为例。

```xml
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-framework</artifactId>
    <version>4.3.0</version>
    <exclusions>
        <exclusion>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-recipes</artifactId>
    <version>4.3.0</version>
    <exclusions>
        <exclusion>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.apache.zookeeper</groupId>
    <artifactId>zookeeper</artifactId>
    <version>3.4.14</version>
</dependency>
```

添加curator客户端配置：

```java
@Configuration
public class CuratorConfig {

    @Bean
    public CuratorFramework curatorFramework(){
        // 重试策略，这里使用的是指数补偿重试策略，重试3次，
        // 初始重试间隔1000ms，每次重试之后重试间隔递增。
        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        // 初始化Curator客户端：指定链接信息 及 重试策略
        CuratorFramework client = CuratorFrameworkFactory
                         .newClient("192.168.88.101:2181", retry);
        client.start(); // 开始链接，如果不调用该方法，很多方法无法工作
        return client;
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071940307.png" alt="image-20230507194033050" style="zoom:80%;" />

注入使用

```java
@Autowired
private CuratorFramework curatorFramework;
```

## 可重入锁

> Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类**InterProcessMutex**来实现。
>

使用案例，改造service测试方法：

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;
    // 注入curator对象
    @Autowired
    private CuratorFramework curatorFramework;

    public void deduct() {
        // 设置获取锁，此时只需要启动zk，无需手动创建路径
        InterProcessMutex mutex = new InterProcessMutex(curatorFramework, "/curator/lock");
        try {
            // 加锁，可以设置带超时时间的可重入锁acquire(long time, TimeUnit unit);
            mutex.acquire();
            // 先查询库存是否充足
            Stock stock = this.stockMapper.selectById(1L);
            // 再减库存
            if (stock != null && stock.getCount() > 0){
                stock.setCount(stock.getCount() - 1);
                this.stockMapper.updateById(stock);
            }
            // 释放锁
            mutex.release();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

注意：**如想重入，则需要使用同一个InterProcessMutex对象。**

压力测试结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071946911.png" alt="image-20230507194653656" style="zoom:80%;" />

## 不可重入锁

> 具体实现：InterProcessSemaphoreMutex。与InterProcessMutex调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入。
>

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private CuratorFramework curatorFramework;

    public void deduct() {
         InterProcessSemaphoreMutex mutex = new InterProcessSemaphoreMutex(curatorFramework,
                "/curator/lock");
         try {
            // 加锁
            mutex.acquire();
            // 先查询库存是否充足
            Stock stock = this.stockMapper.selectById(1L);
            // 再减库存
            if (stock != null && stock.getCount() > 0){
                stock.setCount(stock.getCount() - 1);
                this.stockMapper.updateById(stock);
            }
            // 释放锁
            mutex.release();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071954144.png" alt="image-20230507195416929" style="zoom:80%;" />

## 可重入读写锁

> 类似JDK的ReentrantReadWriteLock。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁。从读锁升级成写锁是不成的。

> - 读读可以并发的
> - 读写不可以并发
> - 写写不可以并发
> - 写锁在释放之前会阻塞请求线程，而读锁是不会的。

主要实现类InterProcessReadWriteLock：

注意：**写锁在释放之前会一直阻塞请求线程，而读锁不会**

```java
@RestController
public class StockController {

    @Autowired
    private StockService stockService;

    @GetMapping("test/zk/read")
    public String testRead(){
        stockService.testZkRead();
        return "测试读";
    }

    @GetMapping("test/zk/write")
    public String testWrite(){
        stockService.testZkWrite();
        return "测试写";
    }
}
```

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private CuratorFramework curatorFramework;

    public void testZkRead() {
        try {
            InterProcessReadWriteLock rwlock = new InterProcessReadWriteLock(curatorFramework,
                    "/curator/rwlock");
            rwlock.readLock().acquire(10, TimeUnit.SECONDS);
            // TODO：一顿读的操作。。。。
            // rwlock.readLock().unlock();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void testZkWrite() {
        try {
            InterProcessReadWriteLock rwlock = new InterProcessReadWriteLock(curatorFramework,
                    "/curator/rwlock");
            rwlock.writeLock().acquire(10, TimeUnit.SECONDS);
            // TODO：一顿写的操作。。。。
            // rwlock.writeLock().unlock();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

在浏览器进行访问测试读写情况

:10011/test/zk/write

:10011/test/zk/read

## 联锁

> InterProcessMultiLock用处不大，联锁  redisson中的联锁对象

> Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。实现类InterProcessMultiLock：
>

```java
// 构造函数需要包含的锁的集合，或者一组ZooKeeper的path
public InterProcessMultiLock(List<InterProcessLock> locks);
public InterProcessMultiLock(CuratorFramework client, List<String> paths);

// 获取锁
public void acquire();
public boolean acquire(long time, TimeUnit unit);

// 释放锁
public synchronized void release();
```

## 信号量

> InterProcessSemaphoreV2：信号量，限流。一个计数的信号量类似JDK的Semaphore。JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。注意，所有的实例必须使用相同的numberOfLeases值。调用acquire会返回一个租约对象。客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。

> 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。主要实现类InterProcessSemaphoreV2：

```java
// 构造方法
public InterProcessSemaphoreV2(CuratorFramework client, String path, int maxLeases);

// 注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。
// 同时还提供了超时的重载方法
public Lease acquire();
public Collection<Lease> acquire(int qty);
public Lease acquire(long time, TimeUnit unit);
public Collection<Lease> acquire(int qty, long time, TimeUnit unit)

// 租约还可以通过下面的方式返还
public void returnAll(Collection<Lease> leases);
public void returnLease(Lease lease);
```

StockController中添加方法：

```java
@GetMapping("test/semaphore")
public String testSemaphore(){
    this.stockService.testSemaphore();
    return "hello Semaphore";
}
```

StockService中添加方法：

```java
public void testSemaphore() {
    // 设置资源量 限流的线程数
    InterProcessSemaphoreV2 semaphoreV2 = new InterProcessSemaphoreV2(curatorFramework, 
                                                                      "/locks/semaphore", 5);
    try {
        // 获取资源，获取资源成功的线程可以继续处理业务操作。否则会被阻塞住
        Lease acquire = semaphoreV2.acquire();
        this.redisTemplate.opsForList().rightPush("log", "10010获取了资源，开始处理业务逻辑。"
                                                  + Thread.currentThread().getName());
        TimeUnit.SECONDS.sleep(10 + new Random().nextInt(10));
        this.redisTemplate.opsForList().rightPush("log", "10010处理完业务逻辑，释放资源===" + 
                                                  Thread.currentThread().getName());
        // 手动释放资源，后续请求线程就可以获取该资源
        semaphoreV2.returnLease(acquire); 
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

## 共享计数器

利用ZooKeeper可以实现一个集群共享的计数器。只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数，一个用long来计数。

### SharedCount

共享计数器SharedCount相关方法如下：

```java
// 构造方法
public SharedCount(CuratorFramework client, String path, int seedValue);
// 获取共享计数的值
public int getCount();
// 设置共享计数的值
public void setCount(int newCount) throws Exception;
// 当版本号没有变化时，才会更新共享变量的值
public boolean  trySetCount(VersionedValue<Integer> previous, int newCount);
// 通过监听器监听共享计数的变化
public void addListener(SharedCountListener listener);
public void addListener(final SharedCountListener listener, Executor executor);
// 共享计数在使用之前必须开启
public void start() throws Exception;
// 关闭共享计数
public void close() throws IOException;
```

StockController：

```java
@GetMapping("test/zk/share/count")
public String testZkShareCount(){
    this.stockService.testZkShareCount();
    return "hello shareData";
}
```

StockService：

```java
public void testZkShareCount() {
    try {
        // 第三个参数是共享计数的初始值
        SharedCount sharedCount = new SharedCount(curatorFramework, "/curator/count", 0);
        // 启动共享计数器
        sharedCount.start();
        // 获取当前共享计数的值
        int count = sharedCount.getCount();
        // 生成1000以内的随机值
        int random = new Random().nextInt(1000);
        sharedCount.setCount(random);
        System.out.println("我获取了共享计数的初始值：" + count +
                           "，并把计数器的值改为：" + random);
        sharedCount.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

进行访问：/test/zk/share/count，可以发现不同控制台共享了数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071616487.png" alt="image-20220907161632191" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071616102.png" alt="image-20220907161647034" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071617290.png" alt="image-20220907161705230" style="zoom:80%;" />

### DistributedAtomicNumber

DistributedAtomicNumber接口是分布式原子数值类型的抽象，定义了分布式原子数值类型需要提供的方法。

DistributedAtomicNumber接口有两个实现：`DistributedAtomicLong` 和 `DistributedAtomicInteger`

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225439.png" alt="image-20220711225708066" style="zoom:80%;" />

这两个实现将各种原子操作的执行委托给了`DistributedAtomicValue`，所以这两种实现是类似的，只不过表示的数值类型不同而已。这里以`DistributedAtomicLong` 为例进行演示

DistributedAtomicLong除了计数的范围比SharedCount大了之外，比SharedCount更简单易用。它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用InterProcessMutex方式来更新计数值。此计数器有一系列的操作：

- get(): 获取当前值
- increment()：加一
- decrement(): 减一
- add()：增加特定的值
- subtract(): 减去特定的值
- trySet(): 尝试设置计数值
- forceSet(): 强制设置计数值

你必须检查返回结果的succeeded()， 它代表此操作是否成功。如果操作成功， preValue()代表操作前的值， postValue()代表操作后的值。

```java
public void testZkShareCount() {
    try {
        // 参数2：判断是否有节点，没有节点则赋值为0，有则转换为数字相加
        // 参数3: 更新重试策略(睡眠时间，重试次数)
        DistributedAtomicInteger da = new DistributedAtomicInteger(curatorFramework, 
                                                                   "/curator/count1", 
                                      new ExponentialBackoffRetry(1000, 3));
        // 计数的值+1
        AtomicValue<Integer> increment = da.increment();
        System.out.println("提交前：" + increment.preValue() + 
                           ",提交后：" + increment.postValue());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

可以看到，多次访问，三个控制台的数字都是连续的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071645759.png" alt="image-20220907164558509" style="zoom: 67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071646746.png" style="zoom: 67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209071646785.png" alt="image-20220907164639727" style="zoom:67%;" />

# 基于MySQL实现分布式锁

> 性能非常差，一般不用。不管是jvm锁还是mysql锁，为了保证线程的并发安全，都提供了悲观独占排他锁。所以**独占排他**也是分布式锁的基本要求。**可以利用唯一键索引不能重复插入的特点实现**。

> - MySQL数据库实现：**唯一键索引**
> - Redis：**基于Key唯一性**
> - zk：**基于znode节点唯一性**

## 初始准备

数据库表

```mysql
create table `tb_lock` (
  `id` bigint(20) not null auto_increment,
  `lock_name` varchar(50) not null comment '锁名',
  `class_name` varchar(100) default null comment '类名',
  `method_name` varchar(50) default null comment '方法名',
  `server_name` varchar(50) default null comment '服务器ip',
  `thread_name` varchar(50) default null comment '线程名',
  `create_time` timestamp null default null on update current_timestamp comment '获取锁时间',
  `desc` varchar(100) default null comment '描述',
  primary key (`id`),
  unique key `idx_unique` (`lock_name`)
) engine=innodb default charset=utf8;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071123715.png" alt="image-20230507112302577" style="zoom:80%;" />

Lock实体类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("tb_lock")
public class Lock {
    private Long id;
    private String lockName;
    private String className;
    private String methodName;
    // private String serverName;
    // private String threadName;
    private LocalDateTime createTime;
}
```

LockMapper接口

```java
@Mapper
public interface LockMapper extends BaseMapper<Lock> {
}
```

## 基本思路

### 基本流程

> - 加锁：INSERT INTO tb_lock(lock_name) values ('lock')  执行成功代表获取锁成功
> - 释放锁：获取锁成功的请求执行业务操作，执行完成之后通过delete删除对应记录
> - 重试：递归

> synchronized关键字和ReetrantLock锁都是独占排他锁，即多个线程争抢一个资源时，同一时刻只有一个线程可以抢占该资源，其他线程只能阻塞等待，直到占有资源的线程释放该资源。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208302225503.png" alt="1606620944823" style="zoom:80%;" />

> 1. 线程同时获取锁（insert）
> 2. 获取成功，执行业务逻辑，执行完成释放锁（delete）
> 3. 其他线程等待重试

### 关键分析

- 独占排他互斥使用  唯一键索引 

- 防死锁：客户端程序获取到锁之后，客户端程序的服务器宕机。给锁记录添加一个获取锁时间列。 

  额外的定时器检查获取锁的系统时间和当前系统时间的差值是否超过了阈值。

- 不可重入：可重入 记录服务信息 及 线程信息 重入次数

- 防误删： 借助于id的唯一性防止误删

- 原子性：一个写操作   还可以借助于mysql悲观锁

- 可重入：

- 自动续期：服务器内的定时器重置获取锁的系统时间

- 单机故障，搭建mysql主备

- 集群情况下锁机制失效问题。

## 代码实现

改造StockService：

```java
@Service
public class StockService {

    @Resource
    private StockMapper stockMapper;

    @Autowired
    private LockMapper lockMapper;

    public void deduct() {
        // 加锁
        Lock lock = new Lock(null, "lock", this.getClass().getName(), null,
                LocalDateTime.now());
        try {
            this.lockMapper.insert(lock);
        } catch (Exception ex) {
            // 获取锁失败，则重试
            try {
                Thread.sleep(50);
                this.deduct();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 先查询库存是否充足
        Stock stock = this.stockMapper.selectById(1L);
        // 再减库存
        if (stock != null && stock.getCount() > 0){
            stock.setCount(stock.getCount() - 1);
            this.stockMapper.updateById(stock);
        }
        // 释放锁
        this.lockMapper.deleteById(lock.getId());
    }
}
```

使用Jmeter压力测试结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305071537931.png" alt="image-20230507153736751" style="zoom:80%;" />

可以看到性能感人。mysql数据库库存余量为0，可以保证线程安全。

## 缺陷及解决方案

- 独占排他互斥使用  **`唯一键索引 `**
- 集群情况下锁机制失效问题

- 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。


​       解决方案：**`给 锁数据库 搭建主备`**

- 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。

​       解决方案：**`只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。`**

- 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。


​       解决方案：**`记录获取锁的主机信息和线程信息，如果相同线程要获取锁，直接重入。`**

- 受制于数据库性能，并发能力有限。解决方案：**`无法解决`**

# 常见锁分类⭐

[5000字 | 24张图带你彻底理解Java中的21种锁 (qq.com)](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247489377&idx=1&sn=5d173537dd7dae8a116b84847655cde3&chksm=cf21c848f856415e4030711183b71e1a78a70a073bd9e92ec5810e454171edfcebed8856c64d&mpshare=1&scene=23&srcid=0718yg8JPGmQbzV0kwwVGQqH&sharer_sharetime=1658152217205&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

[聊聊Java中那18 把锁 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247491700&idx=1&sn=6ad0512fb2874b4e4a7da006bbbf0a61&chksm=c0e8389cf79fb18ac93255ab2029b60f779557d2854c8943e4d809ba2d32021f0bf8cd4f304a&mpshare=1&scene=23&srcid=0423bnxeFFzxxVyt7qsPKrjW&sharer_sharetime=1650721580042&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207202108192.png" alt="image-20220720210807083" style="zoom:67%;" />

## 乐观锁和悲观锁

### 悲观锁

> 在select的时候就会加锁，采用先加锁后处理的模式，虽然保证了数据处理的安全性，但也会阻塞其他线程的写操作。悲观锁适用于写多读少的场景，因为拿不到锁的线程，会将线程挂起，交出CPU资源，可以把CPU给其他线程使用，提高了CPU的利用率。**悲观锁：具有强烈的独占和排他特性，在整个数据处理过程中，将数据处于锁定状态。适合于写比较多，会阻塞读操作**。

> 悲观锁具有强烈的独占和排他特性，在整个数据处理过程中，将数据处于锁定状态。适合于写比较多，会阻塞读操作。对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。

> 举个生活中的例子，假设厕所只有一个坑位了，悲观锁上厕所会第一时间把门反锁上，这样其他人上厕所只能在门外等候，这种状态就是「阻塞」了。

> 回到代码世界中，一个共享数据加了悲观锁，那线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261453787.png" alt="image-20220426145345723" style="zoom:50%;" />

> 在 Java 语言中 `synchronized` 和 `ReentrantLock`等就是典型的悲观锁，还有一些使用了 synchronized 关键字的容器类如 `HashTable` 等也是悲观锁的应用。
>

### 乐观锁

> 在select的时候不会加锁，是基于程序实现的，所以不会存在死锁的情况。适用于读多写少的场景（写的并发量相对不高），可以提高系统的吞吐量。因为如果写多的话，乐观锁会有很大机率更新失败，需要不断的自旋执行查找和更新操作。自旋的时候会一直占用CPU，会耗费大量的CPU资源。**乐观锁：采取了更加宽松的加锁机制，大多是基于数据版本（ Version ）及时间戳来实现。。适合于读比较多，不会阻塞读**

> **乐观锁**：**采取了更加宽松的加锁机制，大多是基于数据版本（ Version ）及时间戳来实现。适合于读比较多，不会阻塞读**。对应于生活中乐观的人，乐观的人总是想着事情往好的方向发展。

> 举个生活中的例子，假设厕所只有一个坑位了，乐观锁认为：这荒郊野外的，又没有什么人，不会有人抢我坑位的，每次关门上锁多浪费时间，还是不加锁好了。你看乐观锁就是天生乐观！回到代码世界中，**乐观锁操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207161343971.png" alt="image-20220716134331822" style="zoom: 50%;" />

> 乐观锁可以使用**`版本号机制`和`CAS算法`**实现。在 Java 语言中 `java.util.concurrent.atomic`包下的原子类就是使用CAS 乐观锁实现的。
>

> 乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**
>

> CAS 是一种乐观锁实现机制，**主要是三部分：内存值+旧的预期值+要修改的值。每次修改数据先比较内存中值与预期值是否相同，不同就自旋，相同才修改**。实现依靠`unsafe`(里面全是native修饰的本地方法，可以直接调用操作系统)+`lock cmpxchg`(底层依靠硬件指令)。
>

> 如图，原本共享变量 old value=0 ，线程修改数据先比较内存中的值是否为0，若为0，代表没有线程占用，此时才修改为 new value=1，当其他线程到达，发现内存值与 old value 不一样了，便自旋等待。
>

**CAS缺点：**

> - 可能造成`ABA (version)`问题——当一个值从A被更新为B，然后又改回来，普通 CAS 机制发现不了。
> - 一直 while 浪费资源:若并发量高，许多线程反复尝试更新变量又更新不成功，循环往复，会给 CPU 带来高消耗
> - 不能保证代码块原子性:只能保证一个变量的原子操作，代码块要用 sychronized。

### 使用场景

悲观锁和乐观锁没有孰优孰劣，有其各自适应的场景。

> 乐观锁适用于读多写少的场景，因为它是不加锁的，相较于悲观锁不用加锁、释放锁，节省了开销。但是若写多，冲突严重，可能导致线程一直 while 自旋，浪费资源，反而降低了性能。此时在这种写多读少的场景使用悲观锁就更合适。

> 如果是写多读少的场景，即冲突比较严重，线程间竞争激励，使用乐观锁就是导致线程不断进行重试，这样可能还降低了性能，这种场景下使用悲观锁就比较合适。

## 独占锁和共享锁

### 独占锁、互斥锁、排他锁

> 独占锁、互斥锁、排他锁：保证在任一时刻，只能被一个线程独占排他持有。synchronized、ReentrantLock
> 共享锁：可同时被多个线程共享持有。CountDownLatch到计数器、Semaphore信号量。**独占锁是指锁一次只能被一个线程所持有。如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261455812.png" alt="image-20220426145513747" style="zoom:50%;" />

JDK中的`synchronized`和`java.util.concurrent(JUC)`包中Lock的实现类就是独占锁。

### 共享锁

> `共享锁`是指锁可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。CountDownLatch到计数器、Semaphore信号量

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261455110.png" alt="image-20220426145540051" style="zoom:50%;" />

在 JDK 中 `ReentrantReadWriteLock` 就是一种共享锁

## 互斥锁和读写锁

### 互斥锁

> `互斥锁`是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261456210.png" alt="image-20220426145614144" style="zoom: 50%;" />

> 互斥锁一次只能一个线程拥有互斥锁，其他线程只有等待。**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对**。
>

### 读写锁

> **读锁：共享锁，写锁：独占排他锁**，**读写锁适用于能明确区分读操作和写操作的场景**

> 读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。

> 读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。
>

> **读写锁在读多写少的场景，能发挥出优势**。**公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261456329.png" alt="image-20220426145645268" style="zoom:50%;" />

在 JDK 中定义了一个读写锁的接口：`ReadWriteLock`

```java
public interface ReadWriteLock {
    // 获取读锁
    Lock readLock();

    // 获取写锁
    Lock writeLock();
}
```

`ReentrantReadWriteLock` 实现了`ReadWriteLock`接口，具体实现这里不展开，后续会深入源码解析。

如何使用：

```java
/**
* 创建一个读写锁
* 它是一个读写融为一体的锁，在使用的时候，需要转换
*/
private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
```

获取读锁和释放读锁

```java
// 获取读锁
rwLock.readLock().lock();

// 释放读锁
rwLock.readLock().unlock();
```

获取写锁和释放写锁

```java
// 创建一个写锁
rwLock.writeLock().lock();

// 写锁 释放
rwLock.writeLock().unlock();
```

**Java中的读写锁：**`ReentrantReadWriteLock`

## 公平锁和非公平锁

### 公平锁

> **有优先级的锁，先来先得，谁先申请锁就先获取到锁**。公平锁是指多个线程按照申请锁的顺序来获取锁，`这里类似排队买票，先来的人先买，后来的人在队尾排着，这是公平的`。获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁

> 锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261457367.png" alt="image-20220426145731298" style="zoom:67%;" />

在 java 中可以通过构造函数初始化公平锁

```java
// 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁
Lock lock = new ReentrantLock(true);
```

### 非公平锁

> **无优先级的锁，后来者也有机会先获取到锁**。**`非公平锁`**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的状态（某个线程一直得不到锁）。

> 这就好比磊哥去加油，到了加油站之后发现前面有人在加，于是我就在车里刷起了抖音，过了一会，前面的车加完油走了，但磊哥没注意到，还在车里愉快的刷着抖音。然而此时加油站又来了一辆车，发现有空闲的油枪，于是就抢先在磊哥之前把油加了。这里的油枪就是锁，没有按照到达的先后顺序得到油枪，这就是非公平锁。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261458657.png" alt="image-20220426145808590" style="zoom: 50%;" />

在 java 中 synchronized 关键字是非公平锁，ReentrantLock默认也是非公平锁。

```java
// 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁
Lock lock = new ReentrantLock(false);
```

使用非公平锁的吞吐率（单位时间内成功获取锁的平均速率）要比公平锁高很多。

## 可重入锁

> **`可重入锁`又称之为`递归锁`，`是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁`。**

> **可重入锁**：又名递归锁。同一个线程在外层方法获取锁的时候，在进入内层方法时会自动获取锁。
>
> **不可重入锁**：例如早期的synchronized

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261502102.png" alt="image-20220426150240040" style="zoom:50%;" />

> 对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁。对于Synchronized而言，也是一个可重入锁。

> 敲黑板：**`可重入锁的一个好处是可一定程度避免死锁。`**以 synchronized 为例，看一下下面的代码：
>

```java
public synchronized void mehtodA() throws Exception{
 // Do some magic tings
 mehtodB();
}

public synchronized void mehtodB() throws Exception{
 // Do some magic tings
}
```

> `上面的代码中 methodA 调用 methodB`，如果一个线程调用methodA 已经获取了锁再去调用 methodB 就不需要再次获取锁了，这就是可重入锁的特性。如果不是可重入锁，mehtodB 可能不会被当前线程执行，可能造成死锁

## 自旋锁和阻塞锁

> **自旋锁**：**当线程尝试获取锁失败时（锁已经被其它线程占用了），无限循环重试尝试获取锁**
>
> **阻塞锁**：**当线程尝试获取锁失败时，线程进入阻塞状态，直到接收信号后被唤醒。在竞争激烈情况下，性能较高**

`自旋锁` 是线程在没有获取到锁时不会立即阻塞，会一直while循环去尝试获取锁，这个便称为自旋。

> - **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；
> - **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207161346030.png" alt="image-20220716134644915" style="zoom: 67%;" />

> 自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。

> 如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能。因此自旋锁是不适应锁占用时间长的并发情况的。

在 Java 中，`AtomicInteger` 类有自旋的操作，我们看一下代码：

```java
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
```

CAS 操作如果失败就会一直循环获取当前 value 值然后重试。另外自适应自旋锁也需要了解一下。

> 在JDK1.6又引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。

## 分段锁

> **`分段锁`** 是一种锁的设计，并不是具体的一种锁。分段锁设计目的是将锁的粒度进一步细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261503602.png" alt="image-20220426150345537" style="zoom:67%;" />

在 Java 语言中 CurrentHashMap 底层就用了分段锁，使用Segment，就可以进行并发使用了。

## 无锁|偏向锁|轻量级锁|重量级锁

> JDK1.6 为了提升性能减少获得锁和释放锁所带来的消耗，引入了4种锁的状态：`无锁`、`偏向锁`、`轻量级锁`和`重量级锁`，它会随着多线程的竞争情况逐渐升级，但不能降级。
>

### 无锁

> `无锁`状态其实就是上面讲的乐观锁，这里不再赘述。

### 偏向锁

> **偏向锁：一直被一个线程所访问，那么该线程会自动获取锁**，Java偏向锁(Biased Locking)是指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。

> 偏向锁的实现是通过控制对象`Mark Word`的标志位来实现的，如果当前是`可偏向状态`，需要进一步判断对象头存储的线程 ID 是否与当前线程 ID 一致，如果一致直接进入。

### 轻量级锁

> **轻量级锁（CAS）：当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能**。

> 当线程竞争变得比较激烈时，偏向锁就会升级为`轻量级锁`，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过`自旋方式`等待上一个线程释放锁。不会阻塞，提高性能。

### 重量级锁

> **当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候（10次），还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低**

> 如果线程并发进一步加剧，线程的自旋超过了一定次数（10次），或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为`重量级锁`，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。性能降低。以上其实是synchronized的锁升级过程

升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。

> 在 Java 中，synchronized 关键字内部实现原理就是锁升级的过程：无锁 --> 偏向锁 --> 轻量级锁 --> 重量级锁。这一过程在后续讲解 synchronized 关键字的原理时会详细介绍。
>

> **重量级锁是一种称谓：** `synchronized`是通过对象内部的一个叫做监视器锁（`monitor`）来实现的，监视器锁本身依赖底层的操作系统的 `Mutex Lock`来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 `Mutex Lock`来实现的锁称为重量级锁。为了优化`synchonized`，引入了`轻量级锁`，`偏向锁`。

**Java中的重量级锁：** synchronized

## 锁优化技术（锁粗化、锁消除）

**锁粗化**

> **`锁粗化`**就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。

```java
private static final Object LOCK = new Object();

for(int i = 0;i < 100; i++) {
    synchronized(LOCK){
        // do some magic things
    }
}
```

经过`锁粗化`后就变成下面这个样子了：

```java
synchronized(LOCK){
    for(int i = 0;i < 100; i++) {
        // do some magic things
    }
}
```

**锁消除**

`锁消除`是指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除。

举个例子让大家更好理解。

```java
public String test(String s1, String s2){
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(s1);
    stringBuffer.append(s2);
    return stringBuffer.toString();
}
```

上面代码中有一个 test 方法，主要作用是将字符串 s1 和字符串 s2 串联起来。

> test 方法中三个变量s1, s2, stringBuffer， 它们都是局部变量，局部变量是在栈上的，栈是线程私有的，所以就算有多个线程访问 test 方法也是线程安全的。
>

> 我们都知道 StringBuffer 是线程安全的类，append 方法是同步方法，但是 test 方法本来就是线程安全的，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为`锁消除`。
>

```java
StringBuffer.class

// append 是同步方法
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

## 表级锁和行级锁

> **表级锁**：对整张表加锁，加锁快开销小，不会出现死锁，但并发度低，会增加锁冲突的概率
>
> **行级锁**：是mysql粒度最小锁，只针对操作行，可大大减少锁冲突概率，并发度高，加锁慢，开销大，会出现死锁

## 死锁

> **死锁是一种现象：**如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就会造成死锁。Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意程序的并发场景，避免造成死锁。

## Lock和synchronized区别

**`Lock`：** 是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。

> - Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别
> - Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。
> - synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。
> - Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。
> - 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
> - Lock 可以通过实现读写锁提高多个线程进行读操作的效率。

**synchronized的优势：**

> - 足够清晰简单，只需要基础的同步功能时，用synchronized。
> - Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即使出现异常，锁也能被自动释放。
> - 使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。

## 图总结

前面讲了 Java 语言中各种各种的锁，最后再通过六个问题统一总结一下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204261505482.png" alt="image-20220426150511372" style="zoom:67%;" />









