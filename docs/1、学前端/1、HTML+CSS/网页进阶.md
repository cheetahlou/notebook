





# 字体图标

## 字体图标简介

> - 字体图标展示的是图标，本质是字体。
> - 处理简单的、颜色单一的图片

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205091326270.png" alt="image-20220509132648209" style="zoom:80%;" />

字体图标的优点：

> - 灵活性：灵活地修改样式，例如：尺寸、颜色等
> - 轻量级：体积小、渲染快、降低服务器请求次数
> - 兼容性：几乎兼容所有主流浏览器
> - 使用方便

## 本地字体使用

可以通过@font-face 指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了。



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261936124.png" alt="image-20230326193601034" style="zoom:80%;" />

```html
<div>
    <h1 class="t1">春风得意马蹄疾，不信人间有别离</h1>
    <h1 class="t2">春风得意马蹄疾，不信人间有别离</h1>
</div>
```

```SAS
<style>
    /* 语法（简写方式） */
    @font-face {
        /* font-family：名称随便起 */
        font-family: "情书字体";
        src: url('./font1/方正手迹.ttf');
    }

    /* 语法（高兼容性写法） */
    @font-face {
        font-family: "atguigu";
        font-display: swap;
        src: url('./font2/webfont.eot'); /* IE9 */
        src: url('./font2/webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
        url('./font2/webfont.woff2') format('woff2'),
        url('./font2/webfont.woff') format('woff'), /* chrome、firefox */
        url('./font2/webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari*/
        url('./font2/webfont.svg#webfont') format('svg'); /* iOS 4.1- */
    }
    
    .t1 {
        font-size: 100px;
        font-family: '情书字体';
    }
    .t2 {
        font-size: 100px;
        font-family: 'atguigu';
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261933549.png" alt="image-20230326193336439" style="zoom:80%;" />

## Iconfont 图标库

> 相比图片更加清晰。灵活性高，更方便改变大小、颜色、风格等。兼容性好， IE 也能支持。字体图标的具体使用方式，每个平台不尽相同，最好参考平台使用指南，视频中我们是以使用最多的阿里图标库作为演示。

> 阿里图标官网地址：https://www.iconfont.cn/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162134774.png" alt="image-20221016213459698" style="zoom:80%;" />

### 创建项目保存图标(可选)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162206923.png" alt="image-20221016220605883" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162205410.png" alt="image-20221016220534352" style="zoom:80%;" />

### 下载字体包

> 登录（新浪微博） → 选择图标库 → 选择图标，加入购物车 → 购物车 → 添加至项目 → 下载至本地

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162138021.png" alt="image-20221016213822978" style="zoom:80%;" />

### 解压并查看字体图标



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162139550.png" alt="image-20221016213908508" style="zoom: 80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162139117.png" alt="image-20221016213940075" style="zoom:80%;" />

### 使用字体图标

#### Unicode编码⭐

> - 引入样式表：iconfont.css
> - 复制粘贴图标对应的Unicode编码
> - 设置文字字体

```css
<link rel="stylesheet" href="font_icon/iconfont.css">
```




<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162145799.png" alt="image-20221016214557754" style="zoom:67%;" />

```html
<i class="iconfont">&#xf0179;</i>
```

```css
.iconfont {
    font-size: 75px;
    color: red;
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162144633.png" alt="image-20221016214421601" style="zoom:80%;" />

#### class类名⭐

font-class 是 Unicode 使用方式的一种变种，主要是解决 Unicode 书写不直观，语意不明确的问题。

> - 相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。
> - 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。

第一步：引入项目下面生成的 fontclass 代码：

```html
<link rel="stylesheet" href="font_icon/iconfont.css">
```

第二步：挑选相应图标并获取类名，应用于页面：

- iconfont：基本样式，包含字体的使用等
- icon-xxx：图标对应的类名

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162147549.png" alt="image-20221016214751506" style="zoom:80%;" />

```html
<i class="iconfont icon-gouwucheman"></i>
```

```css
.iconfont {
    font-size: 75px;
    color: red;
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162148273.png" alt="image-20221016214808240" style="zoom:80%;" />

> " iconfont" 是你项目下的 font-family。可以通过编辑项目查看，默认是 "iconfont"。
>
> **修改样式时不要直接span，这样标签选择器会不起作用，要.iconfont这样用类名选择器**

#### Symbol 引用

这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇[文章]() 这种用法其实是做了一个 SVG 的集合，与另外两种相比具有如下特点：

- 支持多色图标了，不再受单色限制。
- 通过一些技巧，支持像字体那样，通过 `font-size`, `color` 来调整样式。
- 兼容性较差，支持 IE9+，及现代浏览器。
- 浏览器渲染 SVG 的性能一般，还不如 png。

第一步：引入项目下面生成的 symbol 代码：

```html
<script src="./font3/iconfont.js"></script>
```

第二步：挑选相应图标并获取类名，应用于页面

```html
<svg class="icon" aria-hidden="true">
    <use xlink:href="#icon-chengzi"></use>
</svg>
```

第三步：修改样式，可选

```css
<style>
    svg {
        width: 150px;
    }
</style>
```

### 在线使用

将对应的css或js替换成链接即可

```css
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_3904680_cctp97jw61q.css">
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303262140284.png" alt="image-20230326214028172" style="zoom:80%;" />



## 字体图标更新

在项目管理中，直接下载至本地，然后将文件进行替换即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162214343.png" alt="image-20221016221441287" style="zoom:80%;" />





## 购物车案例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161716424.png" alt="image-20221016171629386" style="zoom:80%;" />

```html
<link rel="stylesheet" href="./iconfont/iconfont.css">
```

```html
<div class="nav">
    <ul>
        <li>
            <a href="#">
                <span class="iconfont icon-cart-Empty-fill orange"></span>
                <span>购物车</span>
                <span class="iconfont icon-arrow-down"></span>
            </a>
        </li>
    </ul>
</div>
```

```css
<style>
    * {
        margin: 0;
        padding: 0;
    }

    li {
        list-style: none;
    }

    a {
        color: #333;
        text-decoration: none;
    }

    .nav {
        width: 200px;
        margin: 50px auto;
        font-size: 18px;
    }

    .nav .iconfont{
        font-size: 23px;
    }

    .orange {
        color: #f40;
    }
</style>
```

## 上传自定义图标

思考：如果图标库没有项目所需的图标怎么办？

答：IconFont网站上传矢量图生成字体图标

> 1. 与设计师沟通，得到SVG矢量图
>
> 2. IconFont网站上传图标，下载使用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162201639.png" alt="image-20221016220134602" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161718584.png" alt="image-20221016171850528" style="zoom:80%;" />



# 私有前缀

> 我们在编码时，不用过于关注浏览器私有前缀，不用绞尽脑汁的去记忆，也不用每个都去查询，因为常用的CSS3 新特性，主流浏览器都是支持的，即便是为了老浏览器而加前缀，我们也可以借助现代的构建工具，去帮我们添加私有前缀。

## 什么是私有前缀

如下代码中的-webkit- 就是私有前缀

```css
div {
   width:400px;
   height:400px;
   -webkit-border-radius: 20px;
}
```

## 为什么要有私有前缀

> W3C 标准所提出的某个CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核，使用私有前缀来测试该CSS 特性，在浏览器正式支持该CSS 特性后，就不需要私有前缀了。举个例子：

```css
-webkit-border-radius: 20px;
-moz-border-radius: 20px;
-ms-border-radius: 20px;
-o-border-radius: 20px;
border-radius: 20px;
```

查询CSS3 兼容性的网站： https://caniuse.com/

## 常见浏览器私有前缀

> - Chrome 浏览器： -webkit-
> - Safari 浏览器： -webkit-
> - Firefox 浏览器： -moz-
> - Edge 浏览器： -webkit-
> - 旧 Opera 浏览器： -o-
> - 旧 IE 浏览器： -ms-

> 注意：我们在编码时，不用过于关注浏览器私有前缀，不用绞尽脑汁的去记忆，也不用每个都去查询，因为常用的CSS3 新特性，主流浏览器都是支持的，即便是为了老浏览器而加前缀，我们也可以借助现代的构建工具，去帮我们添加私有前缀。



# 渐变

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161731668.png" alt="image-20221016173154572" style="zoom:67%;" />

## 线性渐变

多个颜色之间的渐变， 默认从上到下渐变。

```css
background-image: linear-gradient(red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261740315.png" alt="image-20230326174054236" style="zoom:80%;" />

使用关键词设置线性渐变的方向。

```css
background-image: linear-gradient(to top,red,yellow,green);
background-image: linear-gradient(to right top,red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261741725.png" alt="image-20230326174141636" style="zoom:80%;" />

使用角度设置线性渐变的方向。

```css
background-image: linear-gradient(30deg,red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261743653.png" alt="image-20230326174312564" style="zoom:80%;" />

调整开始渐变的位置。

```css
background-image: linear-gradient(red 50px,yellow 100px ,green 150px);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261743421.png" alt="image-20230326174300340" style="zoom:80%;" />

```html
<body>
    <div class="box box1">默认情况（从上到下）</div>
    <div class="box box2">通过关键词调整线性渐变渐变的方向</div>
    <div class="box box3">通过角度调整线性渐变渐变的方向</div>
    <div class="box box4">调整线性渐变的区域</div>
    <div class="box box5">你好啊</div>
</body>
```

```css
<style>
    .box {
        width: 300px;
        height: 200px;
        border: 1px solid black;
        float: left;
        margin-left: 50px;
        font-size: 20px;
    }
    .box1 {
        background-image: linear-gradient(red,yellow,green);
    }
    .box2 {
        background-image: linear-gradient(to right top,red,yellow,green);
    }
    .box3 {
        background-image: linear-gradient(20deg,red,yellow,green);
    }
    .box4 {
        background-image: linear-gradient(red 50px,yellow 100px,green 150px);
    }
    .box5 {
        background-image: linear-gradient(20deg,red 50px,yellow 100px,green 150px);
        font-size: 80px;
        text-align: center;
        line-height: 200px;
        font-weight: bold;
        color: transparent;
        -webkit-background-clip: text;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261750834.png" alt="image-20230326175013715" style="zoom:80%;" />

## 径向渐变

多个颜色之间的渐变， 默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比）

```css
background-image: radial-gradient(red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261745728.png" alt="image-20230326174555632" style="zoom:80%;" />

使用关键词调整渐变圆的圆心位置。

```css
background-image: radial-gradient(at right top,red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261746863.png" alt="image-20230326174614770" style="zoom:80%;" />

使用像素值调整渐变圆的圆心位置。

```css
background-image: radial-gradient(at 100px 50px,red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261747612.png" alt="image-20230326174716470" style="zoom:80%;" />

调整渐变形状为正圆 。

```css
background-image: radial-gradient(circle,red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261747257.png" alt="image-20230326174747160" style="zoom:80%;" />

调整形状的半径 。

```css
background-image: radial-gradient(100px,red,yellow,green);
background-image: radial-gradient(50px 100px,red,yellow,green);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261748777.png" alt="image-20230326174824680" style="zoom:80%;" />

调整开始渐变的位置。

```css
background-image: radial-gradient(red 50px,yellow 100px,green 150px);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261745790.png" alt="image-20230326174517700" style="zoom:80%;" />

```html
<body>
    <div class="box box1">默认情况</div>
    <div class="box box2">通过关键词调整径向渐变圆的圆心</div>
    <div class="box box3">通过像素值调整径向渐变圆的圆心</div>
    <div class="box box4">通过circle关键字调整为正圆</div>
    <div class="box box5">通过像素值调整为正圆</div>
    <div class="box box6">调整径向渐变的区域</div>
    <div class="box box7">综合写法</div>
</body>
```

```css
<style> 
    .box {
        width: 300px;
        height: 200px;
        border: 1px solid black;
        float: left;
        margin-left: 50px;
        font-size: 20px;
        margin-top: 20px;
    }
    .box1 {
        background-image: radial-gradient(red,yellow,green);
    }
    .box2 {
        background-image: radial-gradient(at right top,red,yellow,green);
    }
    .box3 {
        background-image: radial-gradient(at 100px 50px,red,yellow,green);
    }
    .box4 {
        background-image: radial-gradient(circle,red,yellow,green);
    }
    .box5 {
        background-image: radial-gradient(200px 200px,red,yellow,green);
    }
    .box6 {
        background-image: radial-gradient(red 50px,yellow 100px,green 150px);
    }
    .box7 {
        background-image: radial-gradient(100px 50px at 150px 150px,red 50px,yellow 100px
                                          ,green 150px);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261751460.png" alt="image-20230326175145274" style="zoom:67%;" />



## 重复渐变

无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变。

> - 使用repeating-linear-gradient 进行重复线性渐变，具体参数同linear-gradient 。
> - 使用repeating-radial-gradient 进行重复径向渐变，具体参数同radial-gradient 。

我们可以利用渐变，做出很多有意思的效果：例如：横格纸、立体球等等。

```css
<body>
    <div class="box box1">重复线性渐变</div>
    <div class="box box2">重复径向渐变</div>
</body>
```

```css
<style>
    .box {
        width: 300px;
        height: 200px;
        border: 1px solid black;
        float: left;
        margin-left: 50px;
        font-size: 20px;
    }
    .box1 {
        background-image: repeating-linear-gradient(red 50px,yellow 100px,green 150px);
    }
    .box2 {
        background-image: repeating-radial-gradient(red 50px,yellow 100px,green 150px);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261752095.png" alt="image-20230326175235990" style="zoom:80%;" />

## 渐变案例

```css
<body>
    <div class="box1"></div>
    <div class="box2"></div>
</body>
```

```css
<style>
    .box1 {
        width: 600px;
        height: 800px;
        padding: 20px;
        border: 1px solid black;
        margin: 0 auto;
        background-image: repeating-linear-gradient(transparent 0px,transparent 29px,gray 30px);
        background-clip: content-box;
    }
    .box2 {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        background-image: radial-gradient(at 80px 80px,white,#333);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261753050.png" alt="image-20230326175351945" style="zoom:50%;" /><img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303261754329.png" alt="image-20230326175414245" style="zoom:80%;" />



# 2D变换

## 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161722076.png" alt="image-20221016172239026" style="zoom:80%;" />

## 位移⭐

### 位移语法

```css
transform: translate(水平移动距离, 垂直移动距离);
```

```css
/* 直接移动像素距离 */
transform: translate(100px, 50px);

/* 百分比: 盒子自身尺寸的百分比 */
transform: translate(100%, 50%); 

transform: translate(-100%, 50%); 

/* 只给出一个值表示x轴移动距离 */
transform: translate(100px); 

transform: translateY(100px);
```

### 位移基本使用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162223670.png" alt="image-20221016222340627" style="zoom:67%;" />

```html
<div class="father">
    <div class="son"></div>
</div>
```

```css
.father {
    width: 500px;
    height: 300px;
    margin: 100px auto;
    border: 1px solid #000;
}

.son {
    width: 200px;
    height: 100px;
    background-color: pink;
    transition: all 0.5s;
}
```

```css
/* 鼠标移入到父盒子，son改变位置 */
.father:hover .son {
   transform: translate(100px, 50px);
}
```

### 位移定位盒子居中

> 使用translate快速实现绝对定位的元素居中效果，下面是旧写法和新写法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161723974.png" alt="image-20221016172353938" style="zoom:80%;" /><img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161725863.png" alt="image-20221016172535827" style="zoom:80%;" />

```html
<div class="father">
    <div class="son"></div>
</div>
```

```css
.father {
    position: relative;
    width: 500px;
    height: 300px;
    margin: 100px auto;
    border: 1px solid #000;
}

.son {
    /*一定是绝对定位，子绝父相*/
    position: absolute;
    width: 200px;
    height: 100px;
    left: 50%;
    top: 50%;
    background-color: pink;
    /* 根据自身宽高进行位移，水平向左，垂直向上50% */
    transform: translate(-50%, -50%);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205091429052.png" alt="image-20220509142937016" style="zoom:50%;" />

### 双开门效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205091433276.png" alt="image-20220509143311211" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205091433598.png" alt="image-20220509143328476" style="zoom:67%;" />

```html
<div class="box">

</div>
```

```css
<style>
    * {
        margin: 0;
        padding: 0;
    }

    .box {
        width: 1366px;
        height: 600px;
        margin: 0 auto;
        background: url('./images/bg.jpg');
         /* 超出盒子部分直接隐藏 */
        overflow: hidden;
    }
    /* 通过伪元素创建标签，因为创建的是行内模式，所以要加上float */
    .box::before,
    .box::after {
        float: left;
        content: '';
        width: 50%;
        height: 600px;
        background-image: url(./images/fm.jpg);
         /* 移动加上动画 */
        transition: all .5s;
    }

    .box::after {
        background-position: right 0;
    }

    /* 鼠标移入的时候的位置改变的效果 */
    .box:hover::before {
        transform: translate(-100%);
    }

    .box:hover::after {
        transform: translateX(100%);
    }
</style>
```

### 注意事项

> 1. **位移与相对定位很相似，都不脱离文档流，不会影响到其它元素**。
> 2. 与相对定位的区别：**相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是其自身**。
> 3. **浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高**。
> 4. **transform 可以链式编写，例如：transform: translateX(30px) translateY(40px);**
> 5. **位移对行内元素无效**。

```css
/* 位移配合定位，可实现元素水平垂直居中 */
.box {
   position: absolute;
   left: 50%;
   top: 50%;
   transform: translate(-50%, -50%);
}
```

## 旋转

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161728190.png" alt="image-20221016172842128" style="zoom:80%;" />

```HTML
<img src="./images/rotate.png" alt="">
```

```CSS
img {
    width: 250px;
    /* 必须加上这个，不然就不转了 */
    transition: all 2s;
}

img:hover {
    /* 顺 */
    transform: rotate(360deg);

    /* 逆 */
    /* transform: rotate(-360deg); */
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210170932505.png" alt="image-20221017093245284" style="zoom:67%;" />

## 缩放

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161731246.png" alt="image-20221016173102162" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303270937338.png" alt="image-20230327093738233" style="zoom:80%;" />

> 1. scale 的值，是支持写负数的，但几乎不用，因为容易让人产生误解。
> 2. 借助缩放，可实现小于12px 的文字。

```html
<div class="box">
    <img src="./images/product.jpeg" alt="">
</div>
```

```css
.box {
    width: 300px;
    height: 210px;
    margin: 100px auto;
    background-color: pink;
}

.box img {
    width: 100%;
    transition: all 0.5s;
}

.box:hover img {
    /* width: 150%; */
    transform: scale(1.2);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210170939340.png" alt="image-20221017093904269" style="zoom:80%;" />

```html
<div class="box">
    <ul>
        <li>
            <div class="pic"><img src="./images/party.jpeg" alt=""></div>
            <p>【和平精英】“初火”音乐概念片：四圣觉醒......</p>
        </li>
    </ul>
</div>
```

```css
<style>
    * {
        margin: 0;
        padding: 0;
    }

    li {
        list-style: none;
    }

    img {
        width: 100%;
    }

    .box {
        width: 249px;
        height: 210px;
        margin: 50px auto;
        overflow: hidden;
    }

    .box p {
        color: #3b3b3b;
        padding: 10px 10px 0 10px;
    }

    .box .pic {
        position: relative;
    }

    .box .pic::after {
        /* 播放按钮压在图片上面 - 居中 */
        position: absolute;
        left: 50%;
        top: 50%;
        /* margin-left: -29px;
        margin-top: -29px; */
        /* transform: translate(-50%, -50%); */

        content: '';
        width: 58px;
        height: 58px;
        background-image: url(./images/play.png);

        /* 大图 */
        transform: translate(-50%, -50%) scale(5);

        /* 透明,看不见 */
        opacity: 0;
        transition: all .5s;
    }

    /* li hover的时候,  谁变小pic::after */
    .box li:hover .pic::after {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210170942338.png" alt="image-20221017094214276" style="zoom:80%;" /><img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210170942777.png" alt="image-20221017094232713" style="zoom:80%;" />

## 扭曲

2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303270944187.png" alt="image-20230327094457090" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: deepskyblue;
        /* transform: skewX(-30deg); */
        /* transform: skewY(30deg); */
        /* transform: skewX(30deg) skewY(30deg); */
        transform: skew(30deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303270950703.png" alt="image-20230327095041606" style="zoom:80%;" />

## 多重转换

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161730270.png" alt="image-20221016173012218" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161730788.png" alt="image-20221016173022761" style="zoom:80%;" />

```html
<div class="box">
    <img src="./images/tyre1.png" alt="">
</div>
```

```css
<style>
    .box {
        width: 800px;
        height: 200px;
        border: 1px solid #000;
    }
    
    img {
        width: 200px;
        transition: all 8s;
    }
    
    .box:hover img {
        /* 边走边转 */
        transform: translate(600px) rotate(360deg);
        transform:translate(100px,100px) rotate(30deg);
        /* 旋转可以改变坐标轴向 */
        /* transform: rotate(360deg) translate(600px); */
        
        /* 层叠性 */
        /* transform: translate(600px);
        transform: rotate(360deg); */
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210170947905.png" alt="image-20221017094714841" style="zoom:80%;" />

## 变换原点

> 元素变换时，默认的原点是元素的中心，使用transform-origin 可以设置变换的原点。修改变换原点对位移没有影响， 对旋转和缩放会产生影响。

> 如果提供两个值，第一个用于横坐标，第二个用于纵坐标。如果只提供一个，若是像素值，表示横坐标，纵坐标取50% ；若是关键词，则另一个坐标取50%

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161729596.png" alt="image-20221016172935539" style="zoom:80%;" />

```HTML
<img src="./images/rotate.png" alt="">
```

```css
img {
    width: 250px;
    border: 1px solid #000;
    transition: all 2s;
    transform-origin: right bottom;
    /*transform-origin: left bottom;*/
}

img:hover {
    transform: rotate(360deg);
}
```

> 1. transform-origin: 50% 50% ， 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值
> 2. transform-origin: left top ，变换原点在元素的左上角 。
> 3. transform-origin: 50px 50px ， 变换原点距离元素左上角 50px 50px 的位置。
> 4. transform-origin: 0 ，只写一个值的时候，第二个值默认为 50% 。

## 综合案例---华为

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210170955145.png" alt="image-20221017095553958" style="zoom:80%;" />

```html
<div class="box">
    <ul>
        <li>
            <a href="#">
                <div class="pic">
                    <img src="./images/product.jpeg" alt="">
                </div>
                <div class="txt">
                    <h4>产品</h4>
                    <h5>OceanStor Pacific 海量存储斩获2021 Interop金奖</h5>
                    <p>
                        <span>了解更多</span>
                        <i></i>
                    </p>
                </div>

                <!-- 添加渐变背景 -->
                <div class="mask"></div>
            </a>
        </li>
        <li>
            <a href="#">
                <div class="pic">
                    <img src="./images/huawei1.jpeg" alt="">
                </div>
                <div class="txt">
                    <h4>行业洞察</h4>
                    <h5>迈向智能世界2030</h5>
                    <p>
                        <span>了解更多</span>
                        <i></i>
                    </p>
                </div>
                <!-- 添加渐变背景 -->
                <div class="mask"></div>
            </a>
        </li>
        <li>
            <a href="#">
                <div class="pic">
                    <img src="./images/huawei2.jpeg" alt="">
                </div>
                <div class="txt">
                    <h4>《ICT新视界》刊首语</h4>
                    <h5>笃行致远，共建具有获得感、幸福感、安全感的智慧城市</h5>
                    <p>
                        <span>了解更多</span>
                        <i></i>
                    </p>
                </div>
                <!-- 添加渐变背景 -->
                <div class="mask"></div>
            </a>
        </li>
    </ul>
</div>
```

```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

li {
    list-style: none;
}

a {
    text-decoration: none;
}

img {
    width: 100%;
    vertical-align: middle;
}

.box {
    width: 1110px;
    height: 247px;
    margin: 20px auto;
    /* background-color: pink; */
}

.box li {
    position: relative;
    float: left;
    width: 350px;
    height: 247px;
    margin-right: 30px;
    overflow: hidden;
}

.box li:last-child {
    margin-right: 0;
}

.box .txt {
    position: absolute;
    left: 0;
    bottom: -50px;
    width: 350px;
    height: auto;
    padding: 20px 30px;
    color: #fff;
    transition: transform .5s;
    /* transition: all .5s; */
}

.box .txt h4 {
    font-size: 14px;
    font-weight: 400;
    line-height: 2em;
    color: #fff;
}

.box .txt h5 {
    margin-bottom: 40px;
    font-size: 18px;
    line-height: 1.5em;
    color: #fff;
}

.box .txt p {
    color: #fff;
    font-size: 14px;
}

.box .txt p .iconfont {
    color: #c7000b;
    vertical-align: middle;
    font-size: 20px;
    font-weight: 700;
}

/* 1. 渐变背景的盒子 */
.box .mask {
    position: absolute;
    left: 0;
    top: 0;
    width: 350px;
    height: 247px;
    background-image: linear-gradient(
        transparent,
        rgba(0,0,0,.6)
    );
    opacity: 0;
    transition: all .5s;
}

/* 2. hover效果 */
/* 2.1 图片缩放 */
.box li .pic img {
    transition: all .5s;
}
.box li:hover .pic img {
    transform: scale(1.2);
}


/* 2.2 渐变背景显示 */
.box li:hover .mask {
    opacity: 1;
}

/* 2.3 文字向上移动 */
.box li:hover .txt {
    transform: translateY(-50px);
}
```

# 3D变换

## 开启3D空间

重要原则：元素进行3D 变换的首要操作：父元素必须开启3D 空间！使用transform-style 开启3D 空间，可选值如下：

> - flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值
> - preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间）

## 设置景深

何为景深？—— 指定观察者与z=0 平面的距离，能让发生3D 变换的元素，产生透视效果，看来更加立体。

使用perspective 设置景深，可选值如下：

> - none ： 不指定透视 ——（默认值）
> - 长度值 ： 指定观察者距离z=0 平面的距离，不允许负值。
> - 注意： perspective 设置给发生3D 变换元素的父元素！

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: deepskyblue;
        transform: rotateX(30deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271011335.png" alt="image-20230327101130236" style="zoom:80%;" />

## 透视点位置

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161734603.png" alt="image-20221016173432564" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161734194.png" alt="image-20221016173450163" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161735347.png" alt="image-20221016173511298" style="zoom:80%;" />

所谓透视点位置，就是观察者位置；默认的透视点在元素的中心。

使用perspective-origin 设置观察者位置（透视点的位置），例如：

```css
/* 相对坐标轴往右偏移400px， 往下偏移300px（相当于人蹲下300像素，然后向右移动400像素看元素）*/
perspective-origin: 400px 300px;
```

注意：通常情况下，我们不需要调整透视点位置。

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
        /* 设置透视点的位置 */
        perspective-origin: 102px 102px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: deepskyblue;
        transform: rotateX(45deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271012540.png" alt="image-20230327101242450" style="zoom:80%;" />

## 3D 位移

3D 位移是在2D 位移的基础上，可以让元素沿z 轴位移

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271004883.png" alt="image-20230327100400788" style="zoom: 80%;" />

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
        /* 设置透视点的位置 */
        perspective-origin: 102px 102px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: rgba(0, 191, 255, 0.726);
        transform: translateZ(150px);
        /*transform: translate3d(50%,50%,50%);*/
        box-shadow: 0 0 10px black;
    }
</style>
```

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271015711.png" alt="image-20230327101507623" style="zoom:80%;" />

## 3D 旋转

3D 旋转是在2D 旋转的基础上，可以让元素沿x 轴和y 轴旋转

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271003332.png" alt="image-20230327100329222" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
        /* 设置透视点的位置 */
        perspective-origin: 102px 102px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: rgba(0, 191, 255, 0.726);
        /* transform: rotateX(315deg); */
        /* transform: rotateY(-35deg); */
        transform: rotate3d(1,1,1,30deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271016553.png" alt="image-20230327101618454" style="zoom:80%;" />

## 3D 缩放

3D 缩放是在2D 缩放的基础上，可以让元素沿z 轴缩放

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271000874.png" alt="image-20230327100053776" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
        /* 设置透视点的位置 */
        perspective-origin: 102px 102px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: rgba(0, 191, 255, 0.726);
        /* transform: scaleZ(4) rotateY(45deg); */
        transform: scale3d(1.5,1.5,1) rotateY(45deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271017747.png" alt="image-20230327101705652" style="zoom:80%;" />

## 多重变换

多个变换，可以同时使用一个transform 来编写。

```css
transform: translateZ(100px) scaleZ(3) rotateY(40deg);
```

注意点：多重变换时，建议最后旋转。

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
        /* 设置透视点的位置 */
        perspective-origin: 102px 102px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: rgba(0, 191, 255, 0.726);
        /* transform-origin: 202px 180px; */
        /* transform: rotateX(-45deg); */
        transform: translateZ(100px) scaleZ(1) rotateY(45deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271017133.png" alt="image-20230327101750023" style="zoom:80%;" />

## 背部可见性

使用backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下：

> - visible ： 指定元素背面可见，允许显示正面的镜像。—— 默认值
> - hidden ： 指定元素背面不可见
>
> 注意： backface-visibility 需要加在发生3D 变换元素的自身上。

```html
<div class="outer">
    <div class="inner">你好啊</div>
</div>
```

```css
<style>
    .outer {
        width: 200px;
        height: 200px;
        border: 2px solid black;
        margin: 100px auto 0;
        /* 开启3D空间 */
        transform-style: preserve-3d;
        /* 设置景深（有了透视效果，近大远小） */
        perspective: 500px;
        /* 设置透视点的位置 */
        perspective-origin: 102px 102px;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: orange;
        transform: rotateY(0deg);
        backface-visibility: hidden;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271019244.png" alt="image-20230327101911150" style="zoom:80%;" />

# 过渡

过渡可以在不使用 Flash 动画，不使用 JavaScript 的情况下，让元素从一种样式，平滑过渡为另一种样式。

## transition-property

作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡效果。常用值：

1. none ：不过渡任何属性。
2. all ：过渡所有能过渡的属性。
3. 具体某个属性名，例如： width 、heigth ，若有多个以逗号分隔。

> 不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。

## transition-duration

作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久。常用值：

> 1. 0 ：没有任何过渡时间 —— 默认值。
> 2. s 或ms ：秒或毫秒。
> 3. 列表：想让所有属性都持续一个时间，那就写一个值。想让每个属性持续不同的时间那就写一个时间的列表

```html
<div class="box1"></div>
```

```css
<style>
    .box1 {
        width: 200px;
        height: 200px;
        background-color: orange;
        opacity: 0.5;
        /* 设置哪个属性需要过渡效果 */
        /*transition-property: width,height,background-color; */
        /* 让所有能过渡的属性，都过渡 */
        transition-property: all;

        /* 分别设置时间 */
        /* transition-duration: 1s,2s,3s; */
        /* 设置一个时间，所有人都用 */
        transition-duration: 1s;
    }
    .box1:hover {
        width: 400px;
        height: 400px;
        background-color: green;
        transform: rotate(45deg);
        box-shadow: 0 0 20px black;
        opacity: 1;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271035320.png" alt="image-20230327103559215" style="zoom:67%;" />

## transition-delay

作用：指定开始过渡的延迟时间，单位： s 或ms

## transition-timing-function

作用：设置过渡的类型常用值：在线制作贝赛尔曲线： https://cubic-bezier.com

1. ease ： 平滑过渡 —— 默认值
2. linear ： 线性过渡
3. ease-in ： 慢 → 快
4. ease-out ： 快 → 慢
5. ease-in-out ： 慢 → 快 → 慢
6. step-start ： 等同于 steps(1, start)
7. step-end ： 等同于 steps(1, end)
8. steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start 或end ，指定每一步的值发生变化的时间点。第二个参数默认值为end 。
9. cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。

```html
<div class="outer">
    <div class="box box1">ease（慢，快，慢）</div>
    <div class="box box2">linear（匀速）</div>
    <div class="box box3">ease-in（慢，快）</div>
    <div class="box box4">ease-out（快，慢）</div>
    <div class="box box5">ease-in-out（慢，快，慢）</div>
    <div class="box box6">step-start不考虑过渡的时间，直接就是终点</div>
    <div class="box box7">step-end考虑过渡时间，但无过渡效果，过渡时间到了以后，瞬间到达终点</div>
    <div class="box box8">steps分步过渡</div>
    <div class="box box9">无敌的贝赛尔曲线</div>
</div>
```

```css
<style>
    .outer {
        width: 1300px;
        height: 900px;
        border: 1px solid black;
    }
    .outer:hover .box {
        width: 1300px;
    }
    .box {
        width: 200px;
        height: 100px;
        /* 让所有能过渡的属性，都过渡 */
        transition-property: all;
        /* 设置一个时间，所有人都用 */
        transition-duration: 5s;
        /* 过渡延迟 */
        /* transition-delay: 2s; */
    }
    .box1 {
        background-color: skyblue;
        transition-timing-function: ease;
    }
    .box2 {
        background-color: orange;
        transition-timing-function: linear;
    }
    .box3 {
        background-color: gray;
        transition-timing-function: ease-in;
    }
    .box4 {
        background-color: tomato;
        transition-timing-function: ease-out;
    }
    .box5 {
        background-color: green;
        transition-timing-function: ease-in-out;
    }
    .box6 {
        background-color: purple;
        transition-timing-function: step-start;
    }
    .box7 {
        background-color: deepskyblue;
        transition-timing-function: step-end;
    }
    .box8 {
        background-color: chocolate;
        transition-timing-function: steps(20,end);
    }
    .box9 {
        background-color: rgb(18, 78, 34);
        transition-timing-function: cubic-bezier(1,.35,.78,1.24);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271037850.png" alt="image-20230327103750705" style="zoom:67%;" />

## transition 复合属性

> 如果设置了一个时间，表示duration ；如果设置了两个时间，第一是duration ，第二个是delay ；
>
> 其他值没有顺序要求。

```css
transition:1s 1s linear all;
```

```html
<div class="outer">
    <div class="inner"></div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 100px;
        border: 1px solid black;
    }
    .inner {
        width: 100px;
        height: 100px;
        background-color: orange;
        transition:linear all 3s 0.5s ;
    }
    .outer:hover .inner {
        width: 1000px;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271038565.png" alt="image-20230327103842454" style="zoom:80%;" />

## 过渡案例

```html
<div class="outer">
    <img src="../images/shanghai.jpg" alt="">
    <div class="mask">上海</div>
</div>
<div class="outer">
    <img src="../images/shanghai.jpg" alt="">
    <div class="mask">上海</div>
</div>
```

```css
<style>
    .outer {
        width: 400px;
        height: 224px;
        position: relative;
        overflow: hidden;
    }
    .mask {
        width: 400px;
        height: 224px;
        background-color: black;
        color: white;
        position: absolute;
        top: 0;
        left: 0;
        text-align: center;
        line-height: 224px;
        font-size: 100px;
        opacity: 0;
        transition: 1s linear;
        cursor: pointer;
    }
    img {
        transition: 0.5s linear;
    }
    .outer:hover .mask {
        opacity: 0.5;
    }
    .outer:hover img {
        transform: scale(1.6) rotate(20deg);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271041295.png" alt="image-20230327104117123" style="zoom:80%;" />

# 动画

## 动画概述

> 动画效果：实现多个状态间的变化过程，动画过程可控（重复播放、最终画面、是否暂停）
>
> 动画的本质是快速切换大量图片时在人脑中形成的具有连续性的画面
>
> 构成动画的最小单元：帧或动画帧

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161740898.png" alt="image-20221016174050824" style="zoom:80%;" />

### 什么是帧

> 一段动画，就是一段时间内连续播放n 个画面。每一张画面，我们管它叫做“帧”。一定时间内连续快速播放若干个帧，就成了人眼中所看到的动画。**同样时间内，播放的帧数越多，画面看起来越流畅**。

### 什么是关键帧

> 关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的2-3 帧。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271045972.png" alt="image-20230327104539850" style="zoom:67%;" />



## 动画的实现步骤

### 定义动画

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161741183.png" alt="image-20221016174159146" style="zoom:80%;" />

### 使用动画

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161742569.png" alt="image-20221016174220538" style="zoom:80%;" />

### 实现示例

```html
<div class="outer">
    <div class="inner"></div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 100px;
        border: 1px solid black;
    }
    /* 定义一个动画（定义一组关键帧）—— 第一种方式 */
    @keyframes wangyoudong {
        /* 第一帧 */
        from {

        }
        /* 最后一帧 */
        to {
            transform: translate(900px);
            background-color: red;
        }
    }
    /* 定义一个动画（定义一组关键帧）—— 第二种方式 */
    @keyframes wangyoudong2 {
        /* 第一帧 */
        0% {

        }
        29% {
          background-color: red;
        }
        48% {
            background-color: orange;
        }
        88% {
            background-color: yellow;
        }
        /* 最后一帧 */
        100% {
            transform: translate(900px) rotate(360deg);
            background-color: purple;
            border-radius: 50%;
        }
    }
    .inner {
        width: 100px;
        height: 100px;
        background-color: deepskyblue;
        /* 应用动画到元素，使用第二种方式定义 */
        animation-name: wangyoudong2;
        /* 动画持续的时间 */
        animation-duration: 3s;
        /* 动画延迟时间 */
        animation-delay: 0.2s;
    }

</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271051390.png" alt="image-20230327105154285" style="zoom:80%;" />

## 动画属性

> 目标：使用animation相关属性控制动画执行过程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161738398.png" alt="image-20221016173809362" style="zoom:80%;" />

> -  动画名称和动画时长必须赋值
> -  取值不分先后顺序
> -  如果有2个时间值，第一个时间表示动画时长，第二个时间表示延迟时间

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161742650.png" alt="image-20221016174249596" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161743368.png" alt="image-20221016174308308" style="zoom:80%;" />

> 1. ease ： 平滑动画 —— 默认值
> 2. linear ： 线性过渡
> 3. ease-in ： 慢 → 快
> 4. ease-out ： 快 → 慢
> 5. ease-in-out ： 慢 → 快 → 慢
> 6. step-start ： 等同于 steps(1, start)
> 7. step-end ： 等同于 steps(1, end)
> 8. steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start 或end ，指定每一步的值发生变化的时间点。第二个参数默认值为end 。
> 9. cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。

```html
<div class="outer">
    <div class="inner"></div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 100px;
        border: 1px solid black;
    }
    @keyframes atguigu {
        from {
            
        }
        to {
            transform: translate(900px) rotate(360deg);
            background-color: purple;
            border-radius: 50%;
        }
    }
    .inner {
        width: 100px;
        height: 100px;
        background-color: deepskyblue;
        /* 应用动画到元素 */
        animation-name: atguigu;
        /* 动画持续的时间 */
        animation-duration: 3s;
        /* 动画延迟时间 */
        animation-delay: 0.2s;

        /* ********其他属性--start*********** */
        /* 设置动画的方式 */
        animation-timing-function: linear;

        /* 动画播放的次数 */
        animation-iteration-count: infinite;

        /* 动画的方向 */
        animation-direction: alternate;

        /* 动画以外的状态（不发生动画的时候在哪里） */
        /* animation-fill-mode: forwards; */
    }
    .outer:hover .inner {
        /* 动画的播放状态 */
        animation-play-state: paused;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271053240.png" alt="image-20230327105311134" style="zoom:80%;" />

## 逐帧动画

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161744243.png" alt="image-20221016174452210" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161744585.png" alt="image-20221016174432546" style="zoom:80%;" />

如果想让小人跑远一些，该如何实现？答：精灵动画的同时添加盒子位移动画。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161745869.png" alt="image-20221016174524833" style="zoom:80%;" />



## 动画复合属性

只设置一个时间表示duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求。

```css
.inner {
	animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards;
}
```

备注： animation-play-state 一般单独使用。

```html
<div class="outer">
    <div class="inner"></div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 100px;
        border: 1px solid black;
    }
    @keyframes atguigu {
        from {
            
        }
        to {
            transform: translate(900px) rotate(360deg);
            background-color: purple;
            border-radius: 50%;
        }
    }
    .inner {
        width: 100px;
        height: 100px;
        background-color: deepskyblue;
        /* 动画复合属性 */
        animation: forwards 3s 0.5s alternate-reverse linear 2 atguigu;
    }
    .outer:hover .inner {
        /* 动画的播放状态 */
        animation-play-state: paused;
    }
    
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271054584.png" alt="image-20230327105456478" style="zoom:80%;" />

## 动画 VS 过渡

> 动画不需要触发条件
>
> 动画可以设置运动关键帧

```html
<div class="outer">
    <div class="inner inner1">过渡</div>
    <div class="inner inner2">动画</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 200px;
        border: 1px solid black;
        text-align: center;
    }
    .inner {
        width: 100px;
        height: 100px;
    }
    /* 用过渡，实现inner1跑到右边去 */
    .inner1 {
        background-color: orange;
        transition: 3s linear;
    }
    .outer:hover .inner1 {
        transform: translate(900px);
    }
    /* 用动画，实现inner2跑到右边去 */
    @keyframes atguigu {
        0%{}
        50%{
            background-color: red;
            border-radius: 50%;
            box-shadow: 0 0 20px black;
        }
        100%{
            transform: translate(900px);
        }
    }
    .inner2 {
        background-color: green;
        animation: atguigu 3s linear forwards;
    }

</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271057935.png" alt="image-20230327105752826" style="zoom:80%;" />

## 综合案例

### 走马灯

> 目标：使用animation实现逐帧图片位移效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161737554.png" alt="image-20221016173708522" style="zoom:80%;" />

```html
<div class="box">
  <ul>
    <li><img src="../images/bg-lb.png" alt=""></li>
    <li><img src="../images/bg-lt.png" alt=""></li>
    <li><img src="../images/bg.jpg" alt=""></li>
    <li><img src="../images/bg01.jpg" alt=""></li>
    <li><img src="../images/bg-lt.png" alt=""></li>
    <li><img src="../images/bg03.jpg" alt=""></li>
    <!--每次在box中可视范围是（610-2*5）/150=4四张图片，当移动至最后几张时，会导致空白出现，
    为了保证走马灯的无缝隙，将最初未移动时可视范围内的几张图片添加至末尾以遮住留白 -->
    <li><img src="../images/bg-lb.png" alt=""></li>
    <li><img src="../images/bg-lt.png" alt=""></li>
    <li><img src="../images/bg.jpg" alt=""></li>
    <li><img src="../images/bg01.jpg" alt=""></li>
  </ul>
</div>
```

```css
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  ul {
    list-style: none;
  }

  .box {
    margin: 100px auto;
    width: 610px;
    height: 110px;
    border: 5px solid black;

    overflow: hidden;
  }

  .box ul {
    /* 如果不设置ul的宽度会导致li浮动的时候由于父级元素的宽度不够而换行，所以ul需要设置足够的宽度呈放所有的li 10*150=1500 */
    width: 1500px;

    /* 使用动画 */
    /* linear匀速运动 */
    animation: move 4s infinite linear;
  }

  /* 当鼠标移入box中的时候动画停止，移出动画继续 */
  .box:hover ul{
    animation-play-state: paused;
  }

  .box li {
    float: left;
    width: 150px;
    height: 100px;
  }

  .box li img {
    width: 150px;
    height: 100px;
  }

  /* 定义动画 */
  @keyframes move{
    /* from 是从原始位置出发，所以可以省略 */
    to{
    /* 移动至添加最初四个li之前的最后一个li（150*6=900），此时如果未在li末尾进行添加就会导致空白出现 */
      transform: translate(-900px);
    }
  }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271120072.png" alt="image-20230327112001952" style="zoom:80%;" />

### 骑自行车

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271101865.png" alt="image-20230327110138767" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271059986.png" alt="image-20230327105939886" style="zoom:80%;" />

```html
<div></div>
```

```css
<style>
    div {
        width: 130px;
        height: 130px;
        background-image: url('../images/bike.png');
        margin: 100px auto 0;
        animation: bike 1s steps(31) infinite;
    }
    @keyframes bike {
        from{}
        to{
            /* 第一个位置横坐标为0，纵坐标的最后一张图片的 */
            /* 4160-130=4030 */
            background-position: 0 -4030px;
        }
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303271100294.png" alt="image-20230327110014189" style="zoom:80%;" />

# 变量

##  基本使用

CSS变量即**自定义属性**，它包含的值可以在整个文档中重复使用。下面来看看CSS变量是如何定义和使用的。

首先，我们要声明一个自定义属性，属性名以两个减号（--）开始，属性值可以是任何有效的CSS值，并且这个属性和其他属性一样可以写在规则集之内：

```css
:root {
  --main-bg-color: #C92E33;
}
```

通常，最佳实践是将CSS变量定义在根伪类`:root`下，这样就可以在HTML文档的任何地方访问到它了。在使用CSS变量时，使用 `var()` 函数包裹所需变量的变量名即可：

```css
div {
  background-color: var(--main-bg-color)
}
```

除了变量名之外，`var()` 还有第二个参数——**备用值**。在发现变量值不可访问的情况下，将使用备用值来代替它：

```css
div {
  background-color: var(--main-bg-color, red);
}
```

对于CSS变量的备用值，在替换的过程中，会有四种可能：

- 浏览器不支持 CSS 变量，带有`var()`的代码行将会被忽略，将使用浏览器的默认值；
- 浏览器支持变量，并且该变量设置为正确值，则直接使用该变量；
- 浏览器支持变量，并且变量未设置为任何值，则直接使用备用值；
- 浏览器支持变量，并且该变量设置为无效值，则使用浏览器的默认值。

我们甚至可以在**媒体查询**中重新设置变量，这些重新设置的值可以在任何地方使用，这是预处理器变量无法实现的：

```css
<div></div>
<div></div>
<div></div>
<div></div>


:root {
  --width: 25%;
  --margin: 20px;
}

@media (max-width: 400px) {
  :root {
    --width: 50%;
    --margin: 10px;
  }
}

body {
    display: flex;
    flex-wrap: wrap;
}

div {
    flex: 1;
    height: 220px;
    flex-basis: calc(var(--width) - (var(--margin) * 3));
    background: #ccc;
    margin: var(--margin);
}
```

CSS 变量使重用和自定义 CSS 代码成为了可能，因为它们使封装成为可能。假如我们有一个按钮，它的 `class` 为 flat，代码如下：

```css
button.flat {
   border: 1px solid black;
   background: transparent;
   color: black;
}

button.flat:hover {
   background: black;
   color: white;
}
```

假如我们想要不同的按钮有不同的操作，比如红色的按钮用于危险操作，那么我们就可以使用 `danger` 类来覆盖对应的样式声明：

```css
button.flat.danger {
   border-color: red;
   color: red;
}

button.flat.danger:hover {
   background: red;
   color: white;
}
```

如果有很多种颜色和操作，那就需要多次定义样式来覆盖之前的样式。我们可以使用变量来替换颜色：

```css
button {
   --color-initial: black;
   border: 1px solid var(--color, var(--color-initial));
   background: transparent;
   color: var(--color, var(--color-initial));
}

button:hover {
   background: var(--color, var(--color-initial));
   color: white;
}
```

现在想要主题化这个按钮，只需要定义`--color`变量即可：

```css
button.flat.danger {
   --color: red;
}
```

这样就相当于将CSS代码进行了封装，代码简洁了很多~

## 作用域

我们可以在全局范围内声明 CSS 变量，这些变量可以在整个应用程序中使用。也可以在局部范围内设置 CSS 变量，它只在特定的选择器中可用。

### 1 CSS 全局变量

要在全局范围内声明变量，就要将变量定义在 :`root` 选择器中：

```css
:root {
  --primary-color: #000;
}

h1 {
  color: var(--primary-color);
}
```

### 2 CSS 局部变量

要在局部范围声明变量，只需要在选择器中定义变量即可，这样声明的变量只能在该选择器中使用，如果尝试在其他地方使用，它不会有任何效果：

```css
h2 {
  --h2-color: #999;
  color: var(--h2-color);
}

h3 {
  color: var(--h2-color);  /* 不生效 */
}
```

### 3 优先级和继承

现在我们知道了，如果在根目录中定义变量，它将是全局变量，如果在选择器中定义变量，它将是局部变量。那如果在两个地方都声明了同一变量，谁的优先级更高呢？

实际上，CSS变量和JavaScript变量类似，CSS 变量中的**局部作用域优先于全局作用域**。

```css
:root {
  --color: red;
}

h2 {
  --color: orange;
  color: var(--color);
}
```

这里`<h2>`标签的内容将是橙色的，因为局部变量的优先级比全局变量的优先级更高。

在CSS中是存在继承的概念的，对于CSS变量也是如此，如果没有为元素找到变量，它会从其父元素继承变量值。下面的`<h2>`标签的内容也将是橙色的，因为`<h2>`在其选择器中没有找到 `--color` 变量，所以就会在其父级逐级往上查找这个变量：

```css
:root {
    --color: red;
}

body {
   --color: orange;
}

h2 {
  color: var(--color);
}
```

## 注意事项

### 1 CSS变量区分大小写

> 在定义CSS变量时需要注意，CSS变量的变量名（即属性名）对大小写是敏感的，`--my-color` 和 `--My-color` 会被认为是两个不同的CSS变量。

### 2 避免循环依赖

在定义CSS变量时不能出现循环依赖关系，这会导致页面无法加载：

```css
--variable_name_1 : var(variable_name_2, fallback);
--variable_name_2 : var(variable_name_1, fallback);
```

### 3 CSS 变量不能是属性名

不能使用 CSS 中的现有属性作为 CSS 的变量名。例如，我们不能使用名称“font-size”来初始化变量。

## 在 JavaScript 中使用

使用 CSS 变量的一大好处就是可以在 JavaScript 中访问它。

假如我们通过内联样式来设置 CSS 变量：

```css
<p style="--color: red"></p>
```

可以通过以下代码来获取变量值：

```css
// 获取 <p> 元素
const element = document.querySelector('p');

// 检索CSS变量 --color 
element.style.getPropertyValue('--color'); // 'red'
```

如果在CSS文件中设置CSS变量：

```css
p {
  --color: red;
}
```

就需要通过以下形式来获取变量值：

```css
// 获取 <p> 元素
const element = document.querySelector('p');

// 获取CSS变量 --color 
getComputedStyle(element).getPropertyValue('--color'); // 'red'
```

当然也可以使用这种形式来获取变量值：

```css
<p style="--color: red"></p>

// 获取 <p> 元素
const element = document.querySelector('p');

// 获取CSS变量 --color
getComputedStyle(element).getPropertyValue('--color'); // 'red'
```

可以通过以下形式使用JavaScript来设置CSS变量：

```css
// 获取 <p> 元素
const element = document.querySelector('p');

// 将 --color 变量设置为 blue 
element.style.setProperty('--color', 'blue');
```

## SASS 变量 vs CSS 变量

下面来看看 CSS 变量出现之前都是如何做的。在CSS变量出现之前开发人员会使用 SASS 变量，它们的目的是相似的，但是不够流畅和灵活。

SASS 变量在定义时需在变量名前加上“$”，在使用变量时直接使用变量名即可：

```css
$main-bg-color: #C92E33;

background-color: $main-bg-color;
```

SASS 的问题就在于它是一个预处理器，所以，任何在 SASS 中声明的变量都需要经过编译才能执行。上面的代码就会编译成这样：

```css
background-color: #C92E33;
```

这样才是有效的CSS，代码经过编译后，变量也就消失了。因此，我们不能在 CSS 运行时更改变量值。

预处理器中的变量范围归结为嵌套的大括号块。然而，因为 CSS 变量是属性，所以它们的作用域是基于 DOM 的。这意味着 CSS 变量是按元素解析的，而不是按作用域解析的，来看下面的例子：

```css
body {
  --shadow-color: red;
}

button {
  box-shadow: 1px 1px 1px var(--shadow-color);
}

button:hover {
  --shadow-color: blue;
}
```

当我们将鼠标悬停在按钮上时，按钮的红色变为了蓝色。那使用预处理器语言 SASS 会是什么结果呢，来看代码：

```less
body {
 $shadow-color: gray;
}

button {
 box-shadow: 1px 1px 1px $shadow-color;
}

button:hover {
 $shadow-color: blue;
}
```

这样就会出现语法错误，第六行使用了未定义的变量。因为SASS不知道 `<button>` 在 `<body>` 里面（因为它不是使用 CSS 在浏览器中的 HTML 上下文执行的），也不知道button:hover 是一个按钮，所以两个定义的变量都没有被识别到。

CSS 变量与预处理器变量最重要的区别就是**CSS变量是动态分配的**。它们在页面的整个生命周期中保持活动状态，当更新它们时，所有引用它们的地方都会更新。因为它们是属性，所以可以通过任何更新 CSS 属性的机制来更新它们：样式表、内联样式，甚至 JavaScript。

下面是 CSS 变量和 SASS 变量的主要区别：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212200959153.png" alt="image-20221220095921061" style="zoom:80%;" />

## 浏览器兼容性

目前，CSS 变量已经得到了各大浏览器的支持：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212200959804.png" alt="image-20221220095933706" style="zoom:80%;" />

# 多列布局

## 应用场景

作用：专门用于实现类似于报纸的布局。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281508134.png" alt="image-20230328150813655" style="zoom: 67%;" />

## 常用属性

> - column-count ：指定列数，值是数字。
> - column-width ：指定列宽，值是长度。
> - columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求。
> - column-gap ：设置列边距，值是长度。
> - column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致。
> - column-rule-width ：设置列与列之间边框的宽度，值是长度。
> - column-rule-color ：设置列与列之间边框的颜色。
> - coumn-rule ：设置列边框，复合属性。
> - column-span 指定是否跨列；值: none 、all 。

## 应用一 报纸

```html
<div class="outer">
    <h1>《震惊！国际名模也来尚硅谷学前端了！》</h1>
    <p>【开始】唐僧师徒四人忙着赶路，吃不好、睡不好，走了几天。【结束】</p>
    <img src="../images/start.jpg" alt="">
    <p>【开始】两人摘了人参果，趁着唐僧的徒弟不在，偷偷拿来给唐僧吃。唐僧看见人参果就好像刚【结束】</p>
    <p>【开始】一会儿，悟空放马回来，八戒连忙把刚才的事情告诉了师兄。悟空早就听说过人参果，。【结束】</p>
    <p>【开始】悟空送走土地神后，一手拿金击子敲，一手扯着自己的衣服接了三个果子。【结束】</p>
    <p>【开始】刚开始，悟空师兄三人怎么也不承认偷吃了人参果，后来，经唐僧的一番开导，觉得确实【结束】</p>
    <p>【开始】悟空回到房中，收回毫毛，让两个童子随便骂，也不还口。两个童子见唐僧他们一句话【结束】</p>
    <p>【开始】接着，他们给唐僧师徒们准备了很多饭菜，趁他们吃饭时，关上门，又用一把大铜锁【结束】</p>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        margin: 0 auto;

        /* 直接指定列数 */
        /* column-count: 5; */

        /* 指定每一列的宽度，会自动计算列数 */
        /* column-width:220px ; */

        /* 复合属性，能同时指定列宽和列数（不推荐使用） */
        columns: 4;

        /* 调整列间距 */
        column-gap: 20px;

        /* 每一列的边框宽度 */
        /* column-rule-width: 2px; */

        /* 每一列的边框风格 */
        /* column-rule-style: dashed; */

        /* 每一列的边框颜色 */
        /* column-rule-color: red; */

        /* 边框相关的复合属性 */
        column-rule: 2px dashed red;
    }
    h1 {
        column-span: all;
        text-align: center;
        font-size: 50px;
    }
    img {
        width: 100%;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281514077.png" alt="image-20230328151422699" style="zoom:80%;" />

## 应用二 流式图片

```html
<div class="outer">
    <img src="../images/img1.jpg">
    <img src="../images/img2.jpg">
    <img src="../images/img3.jpg">
    <img src="../images/img4.jpg">
    <img src="../images/img5.jpg">
    <img src="../images/img6.jpg">
    <img src="../images/img7.jpg">
    <img src="../images/img8.jpg">
    <img src="../images/img9.jpg">
    <img src="../images/img10.jpg">
    <img src="../images/img11.jpg">
    <img src="../images/img12.jpg">
    <img src="../images/img13.jpg">
    <img src="../images/img14.jpg">
    <img src="../images/img1.jpg">
    <img src="../images/img2.jpg">
    <img src="../images/img3.jpg">
    <img src="../images/img4.jpg">
    <img src="../images/img5.jpg">
    <img src="../images/img6.jpg">
    <img src="../images/img7.jpg">
</div>
```

```css
<style>
    .outer {
        /* 父盒子设置成5列 */
        column-count: 5;
    }
    img {
        /* 图片设置宽度100%，不然图片显示不全 */
        width: 100%;
        /* 鼠标移动到图片上的过渡效果 */
        transition: 0.2s linear;
    }
    img:hover {
        box-shadow: 0 0 20px black;
        transform: scale(1.02);
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281520722.png" alt="image-20230328152008415" style="zoom:80%;" />

# 百分比布局⭐

> 百分比布局， 也叫流式布局，效果： **宽度自适应，高度固定**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161800392.png" alt="image-20221016180018361" style="zoom:80%;" />

```html
<div class="toolbar">
    <ul>
     
        <li>
            <a href="#"><img src="./images/classify.png" alt=""></a>
        </li>
        <li>
            <a href="#"><img src="./images/jd.png" alt=""></a>
        </li>
        <li>
            <a href="#"><img src="./images/car.png" alt=""></a>
        </li>
        <li>
            <a href="#"><img src="./images/login.png" alt=""></a>
        </li>
    </ul>
</div>
```

```css
<style>
    * {
        margin: 0; /* 去除li标签的边距 */
        padding: 0;
    }

    li {
        list-style: none; /* 去除li标签的小圆点 */
    }

    .toolbar { /* 父盒子*/
        position: fixed; /* 固定到底部 */
        left: 0;  
        bottom: 0;
        /* 百分比布局：宽度100%，高度固定  流式布局 */
        width: 100%;
        height: 50px; 
        background-color: gainsboro;
        border-top: 1px solid #ccc;
    }

    .toolbar li img {
        height: 100%; /* li里面的图片也要给高度 */
    }

    .toolbar li { /* 左浮动，平行显示，各占20%，子盒子高度=父盒子高度 */
        float: left; 
        width: 20%;
        height: 50px;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210171027956.png" alt="image-20221017102736908" style="zoom:80%;" />

# 弹性盒子布局⭐

> 是一种**浏览器提倡的布局模型**，布局网页更简单、灵活 避免浮动脱标的问题。2009 年， W3C 提出了一种新的盒子模型 —— Flexible Box （伸缩盒模型，又称：弹性盒子）。它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序 .......截止目前，除了在部分IE 浏览器不支持，其他浏览器均已全部支持。伸缩盒模型的出现，逐渐演变出了一套新的布局方案 —— flex 布局。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161800599.png" alt="image-20221016180038522" style="zoom:80%;" />

> 传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float属性。
>
> flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上。

## 伸缩容器、伸缩项目

伸缩容器： 开启了 flex 的元素，就是：伸缩容器。

> 给元素设置： display:flex 或 display:inline-flex ，该元素就变为了伸缩容器。
>
> display:inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。
>
> 一个元素可以同时是：伸缩容器、伸缩项目。

伸缩项目：伸缩容器所有子元素自动成为了：伸缩项目。

> 仅伸缩容器的子元素成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。
>
> 无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。

```html
<div class="outer">
    <div class="inner">1</div>
    <div class="inner">2</div>
    <div class="inner inner3">
        <div>a</div>
        <div>b</div>
        <div>c</div>
    </div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 600px;
        background-color: #888;
        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
    .inner3 {
        display: flex;
        /* font-size: 20px; */
        /* line-height: 2em; */
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281606287.png" alt="image-20230328160634897" style="zoom:50%;" />

## 主轴与侧轴

> 主轴： 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。
>
> 侧轴： 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。

## 主轴方向

属性名： flex-direction，常用值如下：

> 1. row ：主轴方向水平从左到右 —— 默认值
> 2. row-reverse ：主轴方向水平从右到左。
> 3. column ：主轴方向垂直从上到下。
> 4. column-reverse ：主轴方向垂直从下到上。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281537914.png" alt="image-20230328153756544" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">1</div>
    <div class="inner">2</div>
    <div class="inner">3</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 600px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        /* flex-direction: row; */

        /* 调整主轴方向，水平从右到左 */
        flex-direction: row-reverse;

        /* 调整主轴方向，垂直从上到下 */
        /* flex-direction: column; */

        /* 调整主轴方向，垂直从下到上 */
        /* flex-direction: column-reverse; */
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281609944.png" alt="image-20230328160930567" style="zoom:67%;" />

> 注意：改变了主轴的方向，侧轴方向也随之改变。

## 主轴换行方式

属性名： flex-wrap，常用值如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281538708.png" alt="image-20230328153850303" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">1</div>
    <div class="inner">2</div>
    <div class="inner">3</div>
    <div class="inner">4</div>
    <div class="inner">5</div>
    <div class="inner">6</div>
    <div class="inner">7</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 600px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，不换行，默认值 */
        /* flex-wrap: nowrap; */

        /* 主轴换行方式，换行 */
        flex-wrap: wrap;

        /* 主轴换行方式，反向换行 */
        /* flex-wrap: wrap-reverse; */
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281626658.png" alt="image-20230328162617252" style="zoom:50%;" />

只需要加上：align-content: flex-start;，侧轴对齐，即可实现空白去除

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281625970.png" alt="image-20230328162539556" style="zoom:50%;" />

## 主轴对齐方式

属性名： justify-content，常用值如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211282019366.png" alt="image-20221128201938244" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281540351.png" alt="image-20230328154029927" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">1</div>
    <div class="inner">2</div>
    <div class="inner">3</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 600px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        flex-wrap: wrap;

        /* 主轴的对齐方式，主轴的起始位置 */
        /* justify-content: flex-start; */

         /* 主轴的对齐方式，主轴的结束位置 */
         /* justify-content: flex-end; */

         /* 主轴的对齐方式，中间对齐 */
         /* justify-content: center; */

         /* 主轴的对齐方式，项目均匀的分布在一行中，项目与项目之间的距离，是项目距边缘的二倍 */
        /* justify-content: space-around; */

         /* 主轴的对齐方式，项目均匀的分布在一行中，项目与项目之间的距离是相等的，项目距边缘没有距离 */
        justify-content: space-between;

        /* 主轴的对齐方式，项目均匀的分布在一行中 */
        /* justify-content: space-evenly; */
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281618820.png" alt="image-20230328161800402" style="zoom:50%;" />



## 侧轴对齐方式

> 使用align-items调节元素在侧轴的对齐方式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161805685.png" alt="image-20221016180528643" style="zoom:80%;" />

> 还有的属性：baseline : 伸缩项目的第一行文字的基线对齐。

### 一行的情况

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281544739.png" alt="image-20230328154434385" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">1x</div>
    <div class="inner inner2">2x</div>
    <div class="inner inner3">3x</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 600px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        flex-wrap: wrap;

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;

        /* 侧轴的对齐方式，侧轴的起始位置对齐 */
        align-items: flex-start;

        /* 侧轴的对齐方式，侧轴的结束位置对齐 */
        /* align-items: flex-end; */

        /* 侧轴的对齐方式，侧轴的中间位置对齐 */
        /* align-items: center; */

        /* 侧轴的对齐方式，侧轴的中间位置对齐 */
        /* align-items: baseline; */

        /* 侧轴的对齐方式，拉伸到整个父容器（前提：伸缩项目不能给高度），默认 */
        /* align-items: stretch; */
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
    .inner2 {
        height: 300px;
        font-size: 80px;
    }
    .inner3 {
        height: 100px;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281628999.png" alt="image-20230328162854587" style="zoom:50%;" />

### 多行的情况

所需属性： align-content，常用值如下：

> 1. flex-start ：与侧轴的起点对齐。
> 2. flex-end ：与侧轴的终点对齐。
> 3. center ：与侧轴的中点对齐。
> 4. space-between ：与侧轴两端对齐，中间平均分布。
> 5. space-around ：伸缩项目间的距离相等，比距边缘大一倍。
> 6. space-evenly : 在侧轴上完全平分。
> 7. stretch ：占满整个侧轴。—— 默认值

flex-start

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281629133.png" alt="image-20230328162929730" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281630952.png" alt="image-20230328163007541" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281630459.png" alt="image-20230328163027045" style="zoom:80%;" />

```html
<div class="outer">
    <div class="inner">1</div>
    <div class="inner inner2">2</div>
    <div class="inner inner3">3</div>
    <div class="inner">4</div>
    <div class="inner">5</div>
    <div class="inner">6</div>
    <div class="inner">7</div>
    <div class="inner">8</div>
    <div class="inner">9</div>
    <div class="inner">10</div>
    <div class="inner">11</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 900px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        flex-wrap: wrap;

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;

        /* 侧轴的对齐方式（多行）侧轴的起始位置对齐 */
        /* align-content: flex-start; */

        /* 侧轴的对齐方式（多行）侧轴的结束位置对齐 */
        /* align-content: flex-end; */

        /* 侧轴的对齐方式（多行）侧轴的中间位置对齐 */
        /* align-content: center; */

        /* 侧轴的对齐方式（多行），伸缩项目之间的距离是相等的，且是边缘距离的2倍 */
        /* align-content:space-around; */

        /* 侧轴的对齐方式（多行），伸缩项目之间的距离是相等的，且边缘没有距离 */
        /* align-content:space-between; */

        /* 侧轴的对齐方式（多行），伸缩项目之间的距离是相等的 */
        /* align-content:space-evenly; */

        /* 侧轴的对齐方式（多行），拉伸，默认 */
        /* align-content: stretch; */
        
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
    .inner2 {
        height: 300px;
    }
    .inner3 {
        height: 100px;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281631731.png" alt="image-20230328163138286" style="zoom:50%;" />

## 伸缩性

### flex-basis（基准长度）

> 概念： flex-basis 设置的是主轴方向的基准长度，会让宽度或高度失效。这个属性默认就可以了
>
> 备注：主轴横向：宽度失效；主轴纵向：高度失效
>
> 作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值auto ，即：伸缩项目的宽或高。

```html
<div class="outer">
    <div class="inner">1</div>
    <div class="inner inner2">2</div>
    <div class="inner">3</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 900px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        flex-wrap: wrap;

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;


    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
    }
    .inner2 {
        /* 设置伸缩项目在主轴上的基准长度，若主轴是横向的宽失效，
           若主轴是纵向的高失效 */
        flex-basis: 300px;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281636176.png" alt="image-20230328163624741" style="zoom: 33%;" />

### flex-grow（伸）

概念： flex-grow 定义伸缩项目的放大比例，默认为0 ，即：纵使主轴存在剩余空间，也不拉伸（放大）。规则：

> 1. 若所有伸缩项目的 flex-grow 值都为1 ，则：它们将等分剩余空间（如果有空间的话）。
> 2. 若三个伸缩项目的flex-grow 值分别为： 1 、2 、3 ，则：分别瓜分到： 1/6 、2/6 、3/6 的空间。

```html
<div class="outer">
    <div class="inner inner1">1</div>
    <div class="inner inner2">2</div>
    <div class="inner inner3">3</div>
</div>
```

```css
<style>
    .outer {
        width: 1000px;
        height: 900px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        flex-wrap: wrap;

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
        flex-grow: 0;
    }
    /* .inner1 {
        flex-grow: 1;
    } */
    .inner2 {
        /* flex-grow: 2; */
        width: 300px;
    }
    /* .inner3 {
        flex-grow: 3;
    } */
    
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281638423.png" alt="image-20230328163830006" style="zoom:67%;" />

### flex-shrink（缩）

概念： flex-shrink 定义了项目的压缩比例，默认为1 ，即：如果空间不足，该项目将会缩小。收缩项目的计算，略微复杂一点，我们拿一个场景举例：例如：

> 三个收缩项目，宽度分别为： 200px 、300px 、200px ，它们的flex-shrink 值分别为： 1 、2 、3。若想刚好容纳下三个项目，需要总宽度为700px ，但目前容器只有400px ，还差300px。所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算：

1. 计算分母： (200×1) + (300×2) + (200×3) = 1400

2. 计算比例：

   项目一： (200×1) / 1400 = 比例值1

   项目二： (300×2) / 1400 = 比例值2

   项目三： (200×3) / 1400 = 比例值3

3. 计算最终收缩大小：

   项目一需要收缩： 比例值1 × 300

   项目二需要收缩： 比例值2 × 300

   项目三需要收缩： 比例值3 × 300

```html
<div class="outer">
    <div class="inner inner1">
        <div style="width: 50px;height:50px;background-color: green;">1</div>
    </div>
    <div class="inner inner2">2</div>
    <div class="inner inner3">3</div>
</div>
```

```css
<style>
    .outer {
        width: 400px;
        height: 900px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        /* flex-wrap: wrap; */

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;

        /* 侧轴的对齐方式 */
        align-content: flex-start;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
        flex-grow: 1;
    }
    .inner1 {
        flex-shrink: 1;
    }
    .inner2 {
        flex-shrink: 2;
        width: 300px;
    }
    .inner3 {
        flex-shrink: 3;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281652553.png" alt="image-20230328165258134" style="zoom:80%;" />

## flex复合属性

flex-flow 是一个复合属性，复合了 flex-direction 和 flex-wrap 两个属性。 值没有顺序要求。不建议用

```css
flex-flow: row wrap;
```

flex 是复合属性，复合了： flex-grow 、 flex-shrink 、flex-basis 三个属性，默认值为 0 1auto 。

> - 如果写 flex:1 1 auto ，则可简写为： flex:auto
> - 如果写 flex:1 1 0 ，则可简写为： flex:1
> - 如果写 flex:0 0 auto ，则可简写为： flex:none
> - 如果写 flex:0 1 auto ，则可简写为： flex:0 auto —— 即 flex 初始值。

```html
<div class="outer">
    <div class="inner inner1">1</div>
    <div class="inner inner2">2</div>
    <div class="inner inner3">3</div>
</div>
```

```css
<style>
    .outer {
        width: 600px;
        height: 900px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        /* flex-wrap: wrap; */

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;

        /* 侧轴的对齐方式 */
        align-content: flex-start;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
        /* 可以拉伸 */
        /* flex-grow: 1; */

        /* 可以压缩 */
        /* flex-shrink: 1; */

        /* 基准长度 */
        /* flex-basis: 100px; */

        /* 可以拉伸 可以压缩 不设置基准长度，可简写为：flex:auto */
        /* flex:1 1 auto; */

        /* 可以拉伸 可以压缩 设置基准长度为0，可简写为：flex:1 */
        /* flex: 1 1 0; */

        /* 不可以拉伸 不可以压缩 不设置基准长度，可简写为：flex:none  */
        /* flex: 0 0 auto; */

        /* 不可以拉伸 可以压缩 不设置基准长度，可简写为：flex:0 auto */
        /* flex: 0 1 auto; */
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281701379.png" alt="image-20230328170119946" style="zoom:80%;" />

## 项目排序 & 单独对齐

> order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 。

> - 通过align-self 属性，可以单独调整某个伸缩项目的对齐方式
> - 默认值为 auto ，表示继承父元素的 align-items 属性。

```html
<div class="outer">
    <div class="inner inner1">1</div>
    <div class="inner inner2">2</div>
    <div class="inner inner3">3</div>
</div>
```

```css
<style>
    .outer {
        width: 600px;
        height: 900px;
        background-color: #888;
        margin: 0 auto;

        /* 伸缩盒模型相关属性-start */

        /* 将该元素变为了伸缩容器（开启了flex布局） */
        display: flex;

        /* 调整主轴方向，水平从左到右，默认 */
        flex-direction: row;

        /* 主轴换行方式，换行 */
        /* flex-wrap: wrap; */

        /* 主轴的对齐方式，主轴的起始位置 */
        justify-content: flex-start;

        /* 侧轴的对齐方式 */
        align-content: flex-start;
    }
    .inner {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        border: 1px solid black;
        box-sizing: border-box;
        /* 可以拉伸 可以压缩 设置基准长度为0，可简写为：flex:1 */
        flex: 1 1 0;
    }
    /* .inner1 {
        order: 3;
    }
    .inner2 {
        order: 2;
    }
    .inner3 {
        order: 1;
    } */

    .inner2 {
        align-self: center;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281704887.png" alt="image-20230328170400306" style="zoom:67%;" />

## 水平垂直居中

```html
<div class="outer">
    <div class="inner"></div>
</div>
```

方法一：父容器开启flex 布局，随后使用justify-content 和align-items 实现水平垂直居中

```css
.outer {
   width: 400px;
   height: 400px;
   background-color: #888;
   display: flex;
   justify-content: center;
   align-items: center;
}
.inner {
   width: 100px;
   height: 100px;
   background-color: orange;
}
```

方法二：父容器开启flex 布局，随后子元素margin: auto

```css
.outer {
   width: 400px;
   height: 400px;
   background-color: #888;
   display: flex;
}
.inner {
   width: 100px;
   height: 100px;
   background-color: orange;
   margin: auto;
}
```









## 父元素属性总结

想要使用flex布局，首先需要给父元素指定为flex布局，这样容器内的元素才能实现flex布局：

```
<div class="container"></div>

.container {
    display: flex | inline-flex;
}
```

这里有两种方式可以设置flex布局，使用`display: flex;`会生成一个块状的flex容器盒子，使用`display: inline-flex;`会生成一个行内的flex容器盒子。如果我们使用块状元素，比如div标签，就可以使用flex，如果使用行内元素，就可以使用inline-flex。多数情况下，我们会使用 `display: flex;`。

父元素（容器）可以设置以下六个属性：

- flex-direction
- flex-wrap
- flex-flow
- justify-content
- align-items
- align-content

### 1. flex-direction

**flex-direction**：主轴方向，它决定了容器内元素排列方向，它有四个属性值：

```
.container {
    flex-direction: row | row-reverse | column | column-reverse;
}
```

（1）`flex-direction: row`：默认值，沿水平主轴从左到右排列，起点在左沿

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjo8zIh5ufWddDCL57gnQCkicZgdibGzIQiaSdBe5hxibVB489QZiaWKDRjUBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（2）`flex-direction: row-reverse`：沿水平主轴从右到左排列，起点在右沿

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjorsrcSCicOHiaAYBXtZbkKOAicOzyR0Mf1falGtJwfVXdOpwGYOTT24iaqA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（3）`flex-direction: column`：沿垂直主轴从上到下排列，起点在上沿

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoetgzobIHibAdHpYdoyvjnQfaty2PJVsA95sibVGt2C7eqxD0C3mE0wQA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（4）`flex-direction: column-reverse`：沿垂直主轴从下到上排列，起点在下沿

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoMDqabIvlPOhDUMQDiaY8ib5VvCGjeJDPOvIxedJG8XKJ9aA35ZQrcdgA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 2. flex-wrap

`flex-wrap`：容器内元素是否可以换行，它有三个属性值：

```
.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
```

（1）`flex-wrap: nowrap`：默认值，不换行。当主轴的长度是固定并且空间不足时，项目尺寸会随之进行调整，而不会换行。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjo72x3epAialjxK8iaUbhjoomoXwUbicoACYQ9G9ibrHSicibKmepNTH9HhPWw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（2）`flex-wrap: wrap`：换行，第一行在上面

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoFfZzjicSO4wI9PxC0SYlac2900BibjzC1eVwglcczQNSwVmGVQkHjbbQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（3）`flex-wrap: wrap-reverse`：换行，第一行在下面

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjo1gqrt2p3GBJ8nEjRwnZEJibWl8gu0YlUfPULZmkM3iawdawjOuSuicB6w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 3. flex-flow

`flex-flow` 是 `flex-direction` 属性和`flex-wrap`属性的简写，默认为:`flex-flow:row nowrap`，用处不大，最好还是分开来写。该属性的书写格式如下：

```
.container {
    flex-flow: <flex-direction> <flex-wrap>;
}
```

### 4. justify-content

`justify-content`：元素在主轴的对齐方式，它有五个属性值：

```
.container {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

这里以水平方向为主轴进行举例，即`flex-direction: row`。

（1）`justify-content : flex-start`：默认值，元素在主轴上**左对齐**（**上对齐**）

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoBpwqvBVnoibFrlSRkX9TlW3M1xDpgh1DH8eOp169BR7gibagt5zfIbvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（2）`justify-content : flex-end`：元素在主轴上**右对齐**（**下对齐）**

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoQkNyKZ2AqGMmqUr78vZC2caibGJyUSwWp6lGt22PrIpPNhtWbicZPKrg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（3）`justify-content : center` ：元素在主轴上**居中对齐**

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoEZpWmjjUOI1SG5pD65F5hcddafpaxNkYsP4A6Fzss0lrOZgY7Zndibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（4）`justify-content : space-between`：元素在主轴上**两端对齐**，元素之间间隔相等

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjocib7BSxliasvaNnKXMc7Azibnse5aoxKPmqDibkZHUxLrrLsic40MF8Hic9w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（5）`justify-content : space-around` ：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoVjkxxm9IoXrAiaAB2kwWib1T8PvHldn3LQicd56YtVucS8s3mhNptsUbg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 5. align-items

`align-item`：元素在交叉轴上的对齐方式，它有五个属性值：

```
.container {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```

这里以水平方向为主轴进行举例，即`flex-direction: row`。

（1）`align-item：flex-start`：交叉轴的起点对齐（上面或左边）。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoQHkhDSicjvpic1y5z0yvvLh6HIeW1tBxun7TKxZBiceiciaWiaFk1TSYibLUw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（2）`align-item：flex-end`：交叉轴的终点对齐（下面或右边）。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoLM6vWzmn4uG0NRuh3f1Nm57WhjXTdkLS3hZYKVw9drVvTGSFDHEIJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（3）`align-item：center`：交叉轴的中点对齐。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoXkaC8ibJ2eDSbFzgCBX2nqyl2T3CLREB8ooicbEZ4fN2OOxssC58MELg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（4）`align-item：stretch`：默认值、如果元素未设置高度或设为auto，将占满整个容器的高度。假设容器高度设置为 100px，而项目没有设置高度，则项目的高度也为 100px：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjo3n8IbfAnLeSHkkNcWfYk8Q0BI7Zsozc5GGVWEkYWXySGPcAP9NIyvA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（5）`align-item：baseline`：以元素的第一行文字的基线对齐

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoy0ia3aQFy3Yrs5bfLI3vJExLSM7kukAaEqo6p763gJJU2TWH10R9vug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 6. align-content

`align-content`：多根轴线对齐方式。如果元素只有一根轴线，该属性不起作用。它有六个属性值：

```
.container {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

那这个轴线数怎么确定呢？实际上这主要是由`flex-wrap`属性决定的，当`flex-wrap` 设置为 `nowrap` 时，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。当 `flex-wrap` 设置为 `wrap` 时，容器可能会出现多条轴线，这时就需要去设置多条轴线之间的对齐方式。

这里以水平方向为主轴时举例，即：`flex-direction: row; flex-wrap: wrap`;

（1）`align-content: stretch`：默认值，轴线占满整个交叉轴。这里我们先设置每个项目都是固定宽度，效果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoK9GibtEUvVI7vZp1yWvSwVx4ZmIunc8ibpPGIU5MajJCzUINLZ91zacA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

下面就去掉每个项目的高度，它会占满整个交叉轴，效果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoJR3XoawBchvkIBcIoawxLGWzKEYzH7N6ekZU33tBHGQwcDzeJd1boA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（2）`align-content: flex-start`：从交叉轴开始位置填充

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoyRK7CkvicgoElzt6VfickpvibFPu7hdhdXVeQCAxMoFY0pbhib2QHnfXxQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（3）`align-content: flex-end`：从交叉轴结尾位置填充

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjo5VKm63x6GNqlsgduhWuhONwuXniaZWx7Gv9nzALu28WrtzmT0gnKhxQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（4）`align-content: center`：与交叉轴中点对齐

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoH1SJwKV482UgGJEicg2nlCkrBicib5aSSDr4nHcnoej9td8BWA4HP609w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（5）`align-content: space-between`：与交叉轴两端对齐，轴线之前的间隔平均分布

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoQMXOggs26icMXny0891SH9OXXw9hRvWW5gAh8AgMY5LH73mdqlNiadlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

（6）`align-content: space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjonicxiaEtia4OAzwtdhgG8Akb3xrc8z9OKX6L4GlwrNcUGtNiahOA1zpksQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 子元素属性总结

子元素有以下六个属性：

- order
- flex-grow
- flex-shrink
- flex-basis
- flex
- align-self

### 1. order

`order`属性用来定义项目的排列顺序。数值越小，排列越靠前，默认为`0`。使用形式如下：

```
.item {
    order: <integer>;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjodHibVVc3hPSTqFPRfynJknbiaNyKYNv78hHaEu561e6vwFTlj4QfP7sw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 2. flex-basis

`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间，浏览器会根据这个属性来计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。使用形式如下：

```
.item {
    flex-basis: <length> | auto;
}
```

当主轴设置为水平时，当设置了 flex-basis，设置的项目宽度值会失效，`flex-basis` 需要跟 `flex-grow` 和 `flex-shrink` 配合使用才能生效。有两种特殊的值：

- 当 `flex-basis` 值为 0 % 时，项目尺寸会被认为是0，因此无论项目尺寸设置多少都用；
- 当 `flex-basis` 值为 auto 时，则跟根据尺寸的设定值来设置大小。

### 3. flex-grow

`flex-grow`属性定义项目的放大比例，默认为0，即如果存在剩余空间时也不放大。

当容器中所有的项目都设置了flex-basis属性时，如果仍有是剩余的空间，设置的 `flex-grow` 属性才能生效。

如果所有项目的`flex-grow`属性都设置为1，那么它们会均分剩余的空间，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoHH8c60lP30ayhNg8jLjovDZUD70OskX8VxsMpddqaLeY0xUjRZ1ZicA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果其中一个项目的`flex-grow`属性设置为2，其他均为1，那么它占据的剩余空间就是其他项目的两倍，如图所示

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoYibJokzFd3AVibGhHTLGic7r9rJI2toSqjmjxduSb7NUwPgO4aDBjnDGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 4. flex-shrink

`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。不能设置负值，使用如下：

```
.item {
    flex-shrink: <number>;
}
```

如果所有项目的 `flex-shrink` 属性都为 1，当空间不足时，都将等比例缩小，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjojSRehWht1Qqib8kHcicEL3wgHoEYLxxYB6bRyAth0CXN6l2V6nicKpEcA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果一个项目的 `flex-shrink` 属性为 0，其他项目都为 1，则空间不足时，前者不缩小，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjo6wBm1PxrhUHaUkyBB50RicmdyClynQxNiaYHHhicib7N3iaSnulRdhxPCuw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 5. flex

`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，后两个属性可选。默认值为：`flex:0 1 auto。`使用形式如下：

```
.item{
    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

对于flex的取值有几种常用的特殊情况：

（1）默认值：`flex:0 1 auto`，即在有剩余空间时，只放大不缩小

```
.item {
  flex:0 1 auto;
}
.item {
  flex-grow: 0;
  flex-shrink: 1;
  flex-basis: auto;
}
```

（2）`flex: none`，即有剩余空间时，不放大也不缩小，最终尺寸通常表现为最大内容宽度。

```
.item {
  flex:0 0 auto;
}
.item {
  flex-grow: 0;
  flex-shrink: 0;
  flex-basis: auto;
}
```

（3）`flex: 0`，即当有剩余空间时，项目宽度为其内容的宽度，最终尺寸表现为最小内容宽度。

```
.item {
  flex:0 1 0%;
}
.item {
  flex-grow: 0;
  flex-shrink: 1;
  flex-basis: 0%;
}
```

（4）`flex: auto`，即元素尺寸可以弹性增大，也可以弹性变小，具有十足的弹性，但在尺寸不足时会优先最大化内容尺寸。

```
.item {
  flex:1 1 auto;
}
.item {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: auto;
}
```

（5）`flex: 1`，即元素尺寸可以弹性增大，也可以弹性变小，具有十足的弹性，但是在尺寸不足时会优先最小化内容尺寸，

```
.item {
  flex:1 1 0%;
}
.item {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
}
```

### 6. align-self

`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

```
.item {
     align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

这个属性和`align-items`属性的效果是一样的，只不过这个属性只对单个项目生效，而`align-items`是对容器中所有的项目生效。

设置容器的`align-items`属性为`flex-start`，容器中第三个项目的`align-self`属性为`flex-end`，效果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMOybcUicSVmcLcZSA5qPdNjoJqrric4yqgeN8dv7049lhwEQDgPbDAftCG363OoZm8I82URIK9h7LbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 实战演练

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281711521.png" alt="image-20230328171113432" style="zoom:80%;" />

```html
<body>
    <!-- 头部 -->
    <header class="page-header">
        <a href="#">
            <img src="../images/logo.png" alt="logo">
        </a>
        <ul class="header-nav">
            <li><a href="#">国内校区</a></li>
            <li><a href="#">缅甸校区</a></li>
            <li><a href="#">非洲校区</a></li>
            <li><a href="#">美国校区</a></li>
        </ul>
    </header>
    <!-- 内容区 -->
    <div class="page-content">
        <div class="content-nav">
            <div class="item">
                <img src="../images/item1.png" alt="">
                <span>我的邮箱</span>
            </div>
            <div class="item">
                <img src="../images/item2.png" alt="">
                <span>云服务</span>
            </div>
            <div class="item">
                <img src="../images/item3.png" alt="">
                <span>手机课堂</span>
            </div>
            <div class="item">
                <img src="../images/item4.png" alt="">
                <span>微信服务</span>
            </div>
            <div class="item">
                <img src="../images/item5.png" alt="">
                <span>在线客服</span>
            </div>
        </div>
    </div>
</body>
```

```css
<style>
    * { 
        font-family: Arial; 
        font-size: 14px; 
        margin: 0; 
        padding: 0; 
        border: none; 
    }
    a { text-decoration: none; }
    ul { list-style: none; }

    html,body {
        width: 100%;
        height: 100%;
    }
    body {
        background-image: url('../images/bg.jpg');
        background-repeat: no-repeat;
        background-size: cover;
    }
    .page-header {
        height: 70px;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 20px;
    }
    .header-nav {
        display: flex;
        
    }
    .header-nav li a {
        color: white;
        font-size: 20px;
        border: 1px solid white;
        border-radius: 8px;
        padding: 10px;
        margin-right: 20px;
    }
    .header-nav li:last-child a {
        margin-right: 0;
    }
    .page-content {
        display: flex;
        /* 100%-页面头部70px */
        height: calc(100vh - 70px);
    }
    .content-nav {
        width: 1000px;
        height: 300px;
        margin: auto;
        display: flex;
        justify-content: space-evenly;
        align-items: center;
    }
    .content-nav .item {
        width: 180px;
        height: 200px;
        background-color: orange;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-evenly;
        transition: 0.2s linear;
        cursor: pointer;
    }
    .content-nav .item:hover {
        box-shadow: 0px 0px 20px black;
    }
    .content-nav .item span {
        font-size: 20px;
        color: white;
    }
    .content-nav .item:nth-child(1) {
        background-color:#595CA8;
    }
    .content-nav .item:nth-child(2) {
        background-color:#FF9D2E;
    }
    .content-nav .item:nth-child(3) {
        background-color:#01A6DE;
    }
    .content-nav .item:nth-child(4) {
        background-color:#015E91;
    }
    .content-nav .item:nth-child(5) {
        background-color:#1DC128;
    }
</style>
```

# 网格布局

## 总览

[图解 CSS Grid 布局](https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247508653&idx=1&sn=5a661e1255123566efde0f965712ff0c&chksm=fc7eecf6cb0965e03aaa6e711cbd633abfc2c6a68cc1d6e3a7245b8cbeb4db2ae0f8512156c5&mpshare=1&scene=23&srcid=1220clt55bJT0CltYSm8s0DH&sharer_sharetime=1671533418028&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

> Grid（网格）布局是最强大的 CSS 布局方案，用于构建二维布局。Grid 布局将页面划分成一个个网格，可以任意组合不同的网格，实现各种各样的布局。下面就来看看 CSS Grid 布局是如何使用的！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212211433482.png" alt="image-20221221143331344" style="zoom:67%;" />

## Grid 布局概述

在解释 CSS Grid 布局之前，我们先来看看 Grid 布局中一些重要概念。

### （1）网格容器

网格容器是所有网格项的父元素，网格容器会定义`display:grid`。下面例子中，类名为 `container` 的 `div` 元素就是网格容器：

```
.container {
 display: grid;
}
<div class="container">
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
  <div class="item">4</div>
</div>
```

### （2）网格项

网格项是网格容器的子元素，上面例子中类名为`item`的`div`元素就是网格项。

### （3）网格线

构成网格结构的水平和垂直分隔线就是网格线，这些线位于列（列网格线）或行（行网格线）的任一侧。

下图中的网格有 9 个网格项，有 4 条行网格线和 4 条列网格线：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81Cc8lt6CNLO6WiajmD7QQrDGkwMMRNWoy0vrVLC4Op9Sn70waBofic9gg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （4）网格轨道

两条相邻网格线之间的区域就是网格轨道。下图紫色区域就是网格轨道（红线圈起来的位置）：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ZsAiapm37bhHzoDw0LuekPSPQvAmL0zsw3sdRicL5WZQ1SdRxbzNBDlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （5）网格单元

两条**相邻的列网格线**和两条**相邻的行网格线**组成是的网格单元。它是网格的单个单元，也是最小单元。下图紫色区域就是一个单元网格：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81EWaWcZfZluxg25CS7a30jVU6c3iaQ9IRAKh5VqJDnX6uic2Y3ADxCr8Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （6）网格区域

网格区域就是网格上的一个矩形区域，由一个或多个网格单元组成。下图中紫色的区域就是网格区域：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP814cybibtMggqagibiaXBl9XmUdWvt4kALDcnwrjAHl9O56866AyhAAttibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 设置基本网格

要想创建 CSS 网格布局，首先需要定义网格容器。可以使用`display: grid`或者`display: inline-grid`指定一个容器为网格布局。这样网格容器的所有直接子元素都会隐式转换为网格项。

```
.container {
  display: grid;
}

.container {
  display: inline-grid;
}
```

下面来看一个例子：

```
<div class="container">
  <div class="box a">1</div>
  <div class="box b">2</div>
  <div class="box c">3</div>
  <div class="box d">4</div>
</div>
```

在上面的代码中，我们定义了一个类名为 `container` 的 `div` 元素，其有四个子元素。下面来将其设置为网格容器：

```
.container {
  display: grid;
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81A2UMvvIGWPPndgicicaiaLf6buFISWABdjhqXhdiaiaGiamcTJcdNYkYxVJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)当元素设置了网格布局，`column`、`float`、`clear`、`vertical-align`属性都会失效。

## 设置行和列宽度

将元素单独设置为网格容器不会立即影响子元素的显示方式，因为我们还没有指定布局的央样式。要更改网格中网格项的布局，就需要明确定义网格的行和列。这就用到了 `grid-template-columns` 和 `grid-template-rows` 属性。

### （1）grid-template-columns

可以使用 `grid-template-columns` 属性来指定网格容器中所需的列数以及每列的宽度。

该属性接受一个或多个非负 CSS 长度值，这些值的个数就是网格容器的列数，每个值表示每列（即每个网格轨道）的宽度。例如：

```
.container {
  display: grid;
  grid-template-columns: 400px 400px 400px;
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81hIWDHAPNNKDdyibKTHNuibU05aoJLKAMeicqpeBKPgteyNVrgDggXOsDw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在这个例子中，我们使用 `grid-template-columns` 属性将网格容器的布局设置为三列，每列宽 400px。由于网格容器有四个子元素，而我们只给网格指定了三列，所以当网格容器中的网格项数量超过三个时，CSS 会将其他网格项放到新行中以保持容器的布局。

### （2）grid-template-rows

可以使用 `grid-template-rows` 属性来指定网格容器中每一行的高度。与 `grid-template-columns` 属性不同，它并没有指定网格容器的行数，而只用来设置每行的高度。这是因为每当网格项换行时，网格容器都会隐式创建一个新行。因此，我们无法使用 `grid-template-rows` 属性来控制网格的行数。

该属性接受一个或多个非负CSS 长度值，其中每个值表示网格容器中每一行的高度，从第一行到最后一行。例如：

```
.container {
  display: grid;
  grid-template-columns: 400px 400px 400px;
  grid-template-rows: 100px 200px;
}
```

在上面的代码中，我们指定了网格容器的第一行高度为 100px，第二行高度为 200px。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ibKhaCyPQEXZjxK47Ug05UqneuNe7EC8ckia2k4DoeTeBfkWrfzkpEicA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

上面我们仅设置了网格容器中前两行的高度。如果向网格容器中添加更多的网格项，那么那些隐式创建的行的高度将不是由 `grid-template-rows` 属性决定，而由其内容的大小决定。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ENLf4sfFrsBzFqJDCPHlbzmV3Yia1Ptmibhia4SFEuvICt7xIQcsO43mQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （3）grid-template-areas

可以使用`grid-template-areas`属性来定义网格区域。该属性有以下三个属性值：

- `grid-area-name`：使用`grid-area`属性设置的网格区域的名称
- `.` ：空网格单元
- `none`：没有定义网格区域

下面来看一个例子：

```
.container{
    grid-template-areas: "header header header header"
                         "main main . sidebar"
                         "footer footer footer footer";
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81bVQ6jQq67xRiboX360TRfktCkHcy2quD6cnnBfxjlDgPCMB8gE03tZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （4）网格线名称

`grid-template-columns` 和 `grid-template-rows` 属性还可以使用方括号来指定每一条网格线的名字，方便引用。

下面来看一个例子：

```
.container{
  grid-template-columns: [one] 40px [two] 50px [three] auto [four];
  grid-template-rows: [five] 25% [six] 100px [seven] auto [eight];
}
```

这里定义了一个 3 行 4 列的网格，其中 one、two、three、four是列网格线的名称，five、six、seven、eight 是行网格线的名称。

## 行和列之间添加间隙

当这样设置完一个基础的网格之后，有时想要在网格项之间有一些距离，就可以通过调整网格线的大小在列和行之间添加间距。这就需要用到 `row-gap` 和 `column-gap` 属性。

### （1）column-gap

可以使用 `column-gap` 属性来通过调整网格容器中垂直网格线的宽度来增加列之间的间距。它接受一个非负 CSS 长度值，该值用来定义每列之间的网格线的宽度。例如：

```
.container { 
   display: grid; 
   column-gap: 28px;
}
```

这里将网格容器中每条垂直（列）网格线的宽度设置为了 28px。使得网格中每一列之间的距离增加了28px。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81QpRTmIm0o0ib3TMpSialITLRxwZ3Tibzq0s7TAa3mMBbv9A9fONqgMMEA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （2）row-gap

可以使用 `row-gap` 属性来通过调整网格容器中所有水平网格线的高度来在网格容器中的行之间添加间距。它接受一个非负 CSS 长度值，该值定义每行之间网格线的大小。

例如：

```
.container { 
   display: grid; 
   column-row: 40px;
}
```

这里将网格容器中每条水平（行）网格线的高度设置为 40px。使得网格中每一行之间的距离增加了40px。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP814VvjEWfEymftznuGYicXAEa3mB4CL1DI2kO2teleCGO24txz6HHyG7Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以结合 `column-gap` 和 `row-gap` 属性来分隔列和行：

```
.container { 
   display: grid; 
   column-row: 40px;
   row-gap: 20px;
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81wQkJibxUVTbygFrg6vbkGD1SNT44arxFc6OqviccIDJfB5PY7hTxgtPQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 水平对齐内容

Grid  布局提供了六个属性来控制网格项沿网格容器的行或列的对齐方式。下面就来看看沿网格容器的列水平对齐网格项的属性都是如何使用的。

### （1）justify-items

可以使用` justify-items` 属性来控制所有网格项沿水平方向的对齐方式。它被传递给网格容器，其值适用于网格中的所有网格项。它接受四个可能的值：

- `start`：将网格项对齐到所有列的开头，即其单元格的左边缘。

```
.container {
   justify-items: start;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81RLty8vUtDt1LkwqhfaEP14dWbfvHvyhO1jBqRRmqJqupOib6z8L9w5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `end`：将网格项对齐到所有列的末尾，即其单元格的右边缘

```
.container {
   justify-items: end;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ib6NLZ5B8sjAJRc7zLzHmMib9KdKaWD68Bm8q78GmuHlEt71bl5wJRsw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `center`：将所有网格项目放在其单元格的中心

```
.container {
   justify-items: center;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81VibYwk60kOYxfV710kIy5nJTgrrKa9YZ41aL18uOptzZiaWzWBHAtsDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `stretch`：将拉伸网格项目以填充其单元格的整个宽度（默认值）

```
.container {
   justify-items: stretch;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81nKojwSmCpqrZPmAyhmZ0c5XODJe20QubdyWPlIjpRYMuBPLHLJy4kQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （2）justify-content

可以使用`justify-content`属性来设置**网格在网格容器内**沿着水平方向的对齐方式。它接受七个可能的值。

- `start`：将网格与网格容器的左边对齐

```
.container {
   justify-content: start;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81mYzVdYBkytcycUHeia1Siaww4emMZibeW8WIXhNvGWswZvgKYn0eU0ZAA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `end`：将网格与网格容器的右边对齐

```
.container {
   justify-content: end;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81E92r6Luf144ve2OzWTMJRPjIM2ZVSDPQd4wo0ic5UxfVnsOoHGjvDjw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `center`：将整个网格水平放置在网格容器的中心

```
.container {
   justify-content: center;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81regqS1n4tjvPficqq72oWibxfsEprGJHr5YqKn6EhsbicnwlfM7ltXnNQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `stretch`：调整网格项大小，让宽度填充整个网格容器（默认值）

```
.container {
   justify-content: stretch;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81VpBPtkEj43v8mzI96ngsAOCnJDhCG6nABZBqWKPpv2SibjFAiaU3ianYw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `space-around`：在网格项之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半

```
.container {
   justify-content: space-around;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81SnpdQtujF378gZicTBA9XZdj1ib6y01n7MMpTRFrFQhib85vmiazOy9qbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `space-between`：在网格项之间设置均等宽度空白间隙，其外边缘无间隙

```
.container {
   justify-content: space-between;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81tKPMGRIxEXmjhdAibHSXURNMADJMz4RP5wJSwkoojNZImNprjb6wiavQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `space-evenly`：在每个网格项之间设置均等宽度的空白间隙，包括外边缘

```
.container {
   justify-content: space-evenly;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81SnpdQtujF378gZicTBA9XZdj1ib6y01n7MMpTRFrFQhib85vmiazOy9qbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （3）justify-self

可以使用 `justify-self` 属性来设置单元格内容的水平位置，此属性定义在网格项上，它接受四个可能得值。

- `start`：将网格项对齐到列的开头，即其单元格的左边缘

```
.box-1 {
   justify-self: start;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ibQ7xb6ygPia586BKTsJKVD2lVYaovvy5wONGkRdM5z0Br1xYNMEmkVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `end`：将网格项对齐到列的末尾，即其单元格的右边缘

```
.box-2 {
   justify-self: end;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ZgvGd6QVHPfoVeh27geyep5a9yLyFPmrP4UFtrZdIJ1ibgzMxiaadOKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `center`：单将网格项放置在其单元格的中心

```
.box-3 {
   justify-self: center;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP811ICvhCsrYm9ickibCqFTM2PqgLddjfGoxkxqAqPxFwtA8gxvBqbXGicJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `stretch`：将拉伸网格项以填充整个单元格宽度（默认值）

```
.box-4 {
   justify-self: stretch;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81lm6wibgQyoVkpVs68VtXQt5ACmMlbpjVfwUZhia2OU6H8mSG1xjnVBcw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 垂直对齐内容

### （1）align-items

可以使用`align-items` 属性来控制所有网格项沿垂直方向的对齐方式。它被传递给网格容器，其值适用于网格中的所有网格项。它接受四个可能的值：

- `start`：将所有网格项放在所有行的顶部

```
.container {
   align-items: start;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81K42ltmcE1lLWEGGgiaY6ibJMIYktQ6oX3ebibxF5UicY3p4vqJWyNsfianw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `end`：将所有网格项放在所有行的底部。

```
.container {
   align-items: end;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81SibFnNo9krltSLGicvER7tnhhmH9ia19jcicZRUluP4hZlZibgrUXblwjvQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `center`：将所有网格项目放在其单元格的中心

```
.container {
   align-items: center;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81UQRVEGUyMzm1VF6CpfIiab3E31lmhIH2Th8tawodbqZJyOuGdyFwJVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `stretch`：将拉伸所有网格项目以填充其单元格的整个高度（默认值）

```
.container {
   align-items: stretch;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81lm6wibgQyoVkpVs68VtXQt5ACmMlbpjVfwUZhia2OU6H8mSG1xjnVBcw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （2）align-content

可以使用`align-content`属性来设置**网格在网格容器内**沿着垂直方向的对齐方式。它接受七个可能的值。

- `start`：将整个网格对齐到网格容器的顶部

```
.container {
   align-content: start;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81dU3WCLOV83iasbTfrSffB5ltcPvibCcJhj0Qj5lw4q0VdFuECPeHeWrw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `end`：将整个网格与网格容器的底部对齐

```
.container {
   align-content: end;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP816xYJPMJwPvPzpt8yhcKLonTtyPFobqrH7Yc8hPw0nBWF70txiahicNhQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- **center**：将整个网格垂直放置在网格容器的中心

```
.container {
   align-content: center;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ukvwOB6DwrwdBlNEQ2Avev90VDuKRR7b187l1RGOejNLFp8f15SibGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `stretch`：网格项目拉伸以填充容器网格的整个高度（默认值）

```
.container {
   align-content: stretch;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81UK9SqibUGaBbWPh6ZZicNaq9hfLkiaGr3OthGylEePFBianGj9cHpl76ug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `space-around`：在网格项之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半

```
.container {
   align-content: space-around;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81aXzhrEY9VuVFx5YdeQQT9j5Bf5fllCUEy2CrRhIvgLWs0eGItz9h6Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `space-between`：在网格项之间设置均等宽度空白间隙，其外边缘无间隙

```
.container {
   align-content: space-between;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81rBDM0IYj252TEhMxMRHcuwYpM3NmLdRSybdHyfBEKB1cDNvKqzJ4iag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `space-evenly`：在每个网格项之间设置均等宽度的空白间隙，包括外边缘

```
.container {
   align-content: space-evenly;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81iac7EOQxSdrcZfSMNTrMAG5xZiavuXE3Q3FribE8vTtIZo51OdeCXSHPQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （3）align-self

可以使用 `align-self` 属性来设置单元格内容的垂直位置，此属性定义在网格项上，它接受四个可能得值。

- `start`：在其单元格的顶部放置一个网格项

```
.box-4 {
   align-self: start;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP817AKZpIhnsF1MCLT0N5dUcGtAf4tjPJzy00yXOibFONOG6NxoT7071XQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `end`：在其单元格的底部放置一个网格项

```
.box-5 {
   align-self: end;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81Vzev885W7Y5iaozJvaxwicCnmvXWvAZOuPNHnhicOhztoXwdfJMdMUMNw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `center`：将一个网格项放置在其单元格的中心

```
.box-6 {
   align-self: center;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP814v6dgRAzZmPtQNrL6lsFyCoibX33jyq6eCl8iclqB78hvna3y1W6ib40Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- stretch：将拉伸网格项目以填充其单元格的整个高度（默认值）

```
.box-1 {
  align-self: stretch;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81R0ibkcaR0ZRMhCPHibTNBtibbkhhiaibBz0D58C6wGRjyiclZXlRbSica5Zog/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 新的测量单位

除了非负CSS 长度值（例如px、rem、vw和百分比 ( %) ）之外，我们还可以使用特殊的大小单位和关键字来控制网格中网格项的大小。

### （1）fr 单位

fr单位是“fractional”的缩写，是 CSS 网格布局中引入的长度单位。它代表网格容器中可用空间的一部分。这使它成为定义响应列和行的理想单位，这些列和行将随着浏览器的视口缩小和增大而缩放。

下面来看一个简单的例子，假设我们要创建一个由三列组成的网格布局，其中第一列占网格宽度的 1/6，第二列是第一列宽度的两倍，第三列是第一列宽度的三倍。如果没有fr 单位，我们就需要执行一些数学运算，先用网格的总宽度100%除以6，然后将结果乘以每列的跨度：

- 第一列的宽度 = 100% / 6 * 1 —> 15%
- 第二列的宽度 = 100% / 6 * 2 —> 30%
- 第三列的宽度 = 100% / 6 * 3 —> 45%

随着布局变得越来越复杂，使用百分比或任何CSS 数学函数将变得不可持续。这时 fr 单位就派上用场了。fr单位通过让我们指定网格容器中的可用空间应如何在其行和列之间进行分配，然后按该顺序分配可用空间：

```
.container {
   display: grid;
   grid-template-columns: 1fr 2fr 3fr;
}
```

上面的代码中，我们将容器宽度的一部分分给第一列，第二列的宽度是第一列的两倍，第三列的宽度是第一列的三倍。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP8167vyvQgvAsbmscqgyH1wskDCYEGBgnep86icDdV4A9I1BJZbpybLamg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （2）min-content

min-content 是一个用于调整大小的关键字，它将网格轨迹的宽度设置为最小宽度，通常是网格项中最小内容或文本的大小。它的工作原理类似于CSS函数：`min()`，但被用作间距单位而不是函数。

当应用于列或行时，它们会变得与轨迹中最长的内容一样窄。这可以获得网格项内内容的最短长度。

下面来看一个例子；

```
.container {
   display: grid;
   grid-template-columns: 1fr min-content 1fr;
}
```

在上面的代码中，我们将第一列和第三列的宽度设置为网格容器的小部分，同时将第二列设置为 `min-content`，使其缩小到网格项中内容的大小。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81hibJicDR92rMCFIQsmq9qPGdHEUv0ls4qFBerjuGfugpbRM2faQ8CibpQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （3）max-content

`max-content`关键字的效果与`min-content`相反，它类似于CSS函数：max()。当应用于列或行时，轨道将变得尽可能宽，以便网格项中的所有内容都显示在一条完整的长行中。

使用`max-content`的好处就是，可以让网格项中的内容扩展，而不是将它们包装成新行，这会导致垂直文本溢出。

下面来看一个例子：

```
.container {
   display: grid;
   grid-template-columns: 1fr max-content 1fr;
}
```

上面的代码定义了三列，并将第二列的宽度设置为`max-content`关键字。如果在第二列的网格项中添加大量内容，这些网格项中的文本将不会溢出。相反，第二列的宽度将增加，第一列和第三列将缩小以适应它。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81huyr4lqtnEnicoxuDFsSuwYql2iaZYBKjFibDKEdrpV7MPR7CmxQgEmWA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## CSS函数

在使用 CSS Grid 进行布局时，一些CSS数学函数可以帮助我们提高效率。比如 `repeat()` 、`minmax()`、`fit-content()`。

### （1）repeat()

`repeat()` 函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。。

例如，在使用`grid-template-columns`和`grid-template-rows`这两个属性时，可以使用 `repeat()` 函数更简洁地声明这些重复模式。

该函数有两个参数：① 第一个参数用来指定行或列的重复模式重复的次数，有三种取值方式：

- `<number>`：整数，确切的重复次数。
- `<auto-fill>`：以网格项为准自动填充。
- `<auto-fit>`：以网格容器为准自动填充。

② 第二个参数用来指定行或列的重复模式重复的内容，有以下取值方式：

- `<length>`：非负长度。
- `<percentage>`：相对于列轨道中网格容器的内联大小的非负百分比，以及行轨道中网格容器的块长宽。
- `<flex>`：单位为`fr`的非负长度，指定轨道弹性布局的系数值。
- `max-content`：表示网格的轨道长度自适应内容最大的那个单元格。
- `min-content`：表示网格的轨道长度自适应内容最小的那个单元格。
- `auto`：作为最大值时，等价于`max-content`。作为最小值时，它表示轨道中单元格最小长宽(`min-width`/`min-height)`的最大值。

假设我们要创建一个具有六个相等列的网格。如果没有 `repeat()` 函数，我们必须使用 `grid-template-columns` 属性显式定义每个列。代码如下：

```
.container {
     display: grid;
     grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
}
```

然而，随着列数的增加，这种方法变得不可持续和冗长。我们可以使用`repeat()`函数将其重写为更紧凑的形式。代码如下：

```
.container {
     display: grid;
     grid-template-columns: repeat(6, 1fr);
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP813ywgjicdRL9blBc3S3UpMUCoyCRkVALUGCnTrwqgXfeLfqv5rU4q9pg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （2）minmax()

定义响应式网格布局时，我们可能希望为每个网格轨道指定最小和最大宽度，以确保它们在视口调整大小时上下缩放以适应其内容。这时 `minmax()` 就派上用场了。

`minmax()` 函数允许我们指定网格轨道的最小和最大尺寸，它是一个长宽范围的闭区间。当网格在视口中调整大小时，网格轨道将在该范围内增长和缩小。在较小的屏幕上，它会缩小直到达到最小尺寸。在更大的屏幕上，它会拉伸直到达到最大尺寸。

`minmax()` 函数接受 CSS Grid 大小单位、关键字、长度和百分比值。其有两个参数：

- `min`：轨道的最小尺寸。
- `max`：轨道的最大尺寸。

下面来看一个例子：

```
.container {
  display: grid;
   grid-template-columns: repeat(3, 1fr);
   grid-template-rows: repeat(2, minmax(100px, max-content));
}
```

在上面的代码中，我们使用 `minmax()` 函数将网格容器中两行的最小高度设置为 100px，将最大高度设置 `max-content`。这样就可以确保每一行在超过 100px 时都能伸展并变得尽可能宽，以容纳其内容。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81E1arvmNLGtYRvOiaX1libVNEf30trCPnuqXutw0nibMeMbadkM2t8qf7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

`minmax()` 函数的一个显著优点就是它减少了对媒体查询的需要。它不依靠媒体查询来控制跨视口的网格轨道（列和行）的大小，而是允许在一定程度上设置网格轨道值的响应式转换。

### （3）fit-content()

`fit-content()` 函数的操作类似于 `minmax()` 函数。不同之处在于，使用` fit-content()` 时，最小值是网格项中内容的大小，最大值是我们传递给它的值。这样就可以将内容设置为最小值，并根据需要将其放大到某个值。

当应用于网格轨道时，它将网格轨道的大小设置为最小宽度，这是其网格项目中最小的内容或文本的大小。需要注意的是，最小的内容或文本大小不大于函数中指定的值。

但是，如果最小宽度的值超过了提供给函数的值，则网格轨道的大小将设置为传递给 `fit-content()` 函数的值，并且网格项的内容将换行。

下面来看一个例子：

```
.container {
   display: grid;
   grid-template-columns: fit-content(200px) fit-content(300px) fit-content(400px);
}
```

上面的代码使用 `fit-content()` 函数分别创建了宽度为 200px、300px 和 400px 的三列。这意味着每列的大小将等于其网格项目中最小的内容或文本的大小，但如果这变得大于提供给 `fit-content()` 函数的值，则列将设置为传递给 `fit-content()` 函数的值。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81WJA71g2LmtyyQVVy3wOwVlJo0iclIE2JMCde6w9UKlo0SiaWCPmL3KdQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 网格项属性

在网格容器中，每条网格线都根据其在网格上的位置给出一个编号。第一条网格线（行或列）的编号为 1，第二条为 2，依此类推。

例如，下图在一个三列两行的网格容器上存在的网格线的数量，其中列线是橙色圆圈内从 1 到 4 的数字，而行线是蓝色圆圈内的数字从 1 到 3 圈。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81e9RibVk6sONeCiajJfqjHNYCZzWXztGXuVajGrH0HIFcvIgiakJHvgibIA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

浏览器使用这些网格线来控制网格中项目的布局和位置。CSS Grid 提供了一些属性来控制网格项目沿这些网格线的位置，以及它们在水平和垂直方向上跨越的宽度。

可用于控制网格项的位置以及它们如何跨越这些行的属性是：

- grid-column-start
- grid-column-end
- grid-row-start
- grid-row-end

### （1）grid-column-start

可以使用 grid-column-start 属性来指定网格项沿网格容器内的列网格线的水平起始位置。这个开始位置定义了网格项目左边缘的开始。

使用下面的网格布局，来定位第一个网格项并将其水平起始位置设置为第 2 列。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81FWazuo9xBOEHiaqjk5YBmFiaf2QZWndZiaAI1Htoqgl82icMhj2JB50KiaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

选择第一个子元素，并定位：

```
.container div:nth-of-type(1) {
  grid-column-start: 2;
}
```

这样，所选网格项的水平起始位置将位于第二条垂直网格线（第 2 列）上。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP812gibibNcFXoibkUGEfMdA5I98zXrkJBYicz7DzqXMwxdkP45uCQI2FcLZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

上图中，第一个网格项现在从第 2 列开始，而其他网格项被移动，换行到了新行或在网格上创建了空白空间。

### （2）grid-column-end

除了使用 `grid-column-start` 指定网格项的水平起始位置外，还可以使用 `grid-column-end` 属性设置网格项的结束位置。

例如：

```
.container div:nth-of-type(1) {
  grid-column-start: 2;
  grid-column-end: 4;
}
```

这使得第一个网格项从第 2 列开始，跨越两条网格线，并在第 4 行结束。使用 `grid-column-start` 和 `grid-column-end` 属性，可以有效地控制网格的水平起始位置以及它跨越网格的宽度。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ibW69CCZ9D2FlS1OMTttbWAicCSdF5PRMsQDocaWNY38vQZtjqNeg57g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （3）grid-row-start

可以使用 grid-row-start 属性来指定网格项沿网格容器内水平（行）网格线的垂直起始位置。它用于设置网格项开始的行。

例如：

```
.container div:nth-of-type(2) {
  grid-row-start: 1;
}
```

在上面的代码中，使用 `grid-row-start`属性将第二个 `div` 元素的垂直起始位置设置为第 1 行。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81icibLzZMtOABwLufalicrhIEz2wJic8uaZCsJVuNSO4iaviaSC2mN2He2hqA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （4）grid-row-end

可以使用 grid-row-end 属性来指定网格项沿网格容器内水平（行）网格线的垂直结束位置。

例如：

```
.container div:nth-of-type(2) {
   grid-row-start: 1;
   grid-row-start: 4;
}
```

这使得第二个网格项从第一行开始，跨越三个网格线，在第 4 行结束。使用 `grid-row-start` 和 `grid-row-end` 属性，可以有效地控制网格项的垂直起始位置及其在网格中的高度。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81GAiadBI0YW2S1W8eL2qqqNwokEsfTkjzibxibcGZ8ibticUUNG6tp8zKFPw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （5）其他

上面的四个属性使用特定的网格线来确定网格项在网格内的位置，它们的属性值有以下几种：

- `<line>`：可以是一个数字来指代相应编号的网格线，也可使用名称指代相应命名的网格线；
- `span <number>`：网格项将跨越指定数量的网格轨道；
- `span <name>`：网格项将跨越一些轨道 ，直到遇到指定命名的网格线；
- `auto`：自动布局，或者自动跨越，或者跨越一个默认的轨道。

下面来看一个例子：

```
.container div:nth-of-type(1) {
  grid-column-start: span 2;
}
```

这里使用 `span` 来表示第一个单元格跨越了2个网格。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81qFKOEG9Q5gBa8HS6v9JXmnicYQIUDFiahic7LE935dMndwTeWodsSvrHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

下面来结合使用上面的四个属性：

```
.container div:nth-of-type(1) {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 2;
  grid-row-end: 4;
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81Ep2y3XO2icFMddEn00xHpfSgv1iapjSKpdicShc6IqZs3iaRmSTia2QLjicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 隐式网格轨道

当我们设置的网格不足以放下所有的网格项时，就会自动出现一些网格轨道，这些多出来的行的高度是`auto`的，可以使用`grid-auto-columns`和 `grid-auto-rows` 属性来指定**自动生成的网格轨道**（又称为隐式网格轨道）的大小。

例如：

```
.container {
   display: grid;
   grid-auto-columns: 100px
   grid-auto-rows: 80px
}
```

这里， `grid-auto-columns` 属性指定了隐式创建的网格垂直方向轨道的宽度为 100px，grid-auto-rows 属性指定了隐式创建的网格水平方向轨道的高度为 80px。

## 速记属性

像大多数 CSS 属性一样，CSS Grid 提供了一些速记属性，它们提供了一种更短、更先进的方式来同时设置多个 CSS Grid 属性的值。使用这些速记属性，我们就可以编写更简洁 更易读的样式，从而节省开发时间。下面就来看看这些属性。

### （1）gap

`column-gap` 和 `row-gap` 属性用来设置网格之前的距离，即网格线的宽度。可以通过 `gap` 属性简写这两个属性，其语法如下：

```
gap: <row-gap> <column-gap>
```

其中 `<column-gap>` 是一个可选值，如果省略，则设置为与 `<row-gap>` 相同的值。下面来看一个例子：

```
.container {
   display: grid;
   gap: 20px;
}
```

这在网格容器中的所有列和行之间都添加了 20px 的空间，与下面的代码等价：

```
.container { 
 display: grid; 
 column-row: 20px;
 row-gap: 20px;
}
```

### （2）place-items

`place-items` 用来设置 `align-items` 和 `justify-items` 属性的值，它能够同时控制所有网格项目的水平和垂直对齐。

它接受两个值：第一个值设置 `align-items` 属性的值，第二个值设置 `justify-item`s 属性的值。如果未指定第二个值，则将第一个值指定为两个属性的值。

例如：

```
.container { 
 display: grid; 
 place-items: center; 
}
```

这会将 `align-items` 和 `justify-items` 属性的值都设置为 `center`，将所有网格项放置在其网格区域的中心。

### （3）place-content

`place-content` 用来设置网格属性 `align-content` 和 `justify-content` 的值，它能够同时控制网格容器内整个网格的水平和垂直对齐方式。

它接受两个值：第一个值设置 `align-content` 属性的值，第二个值设置 `justify-content` 属性的值。如果未指定第二个值，则将第一个值指定为两个属性的值。

例如：

```
.container { 
 display: grid; 
 place-content: center; 
}
```

这样就会将 `align-content` 和 `justify-content` 属性的值都设置为 `center`，使整个网格在网格容器中水平和垂直居中。

### （4）place-self

`place-items` 可以设置 `align-self` 和 `justify-self` 属性的值。它能够控制单个网格项目在其网格区域内的水平和垂直对齐方式。

它接受两个值：第一个值设置 `align-self` 属性的值，第二个值设置 `justify-self` 属性的值。如果未指定第二个值，则将第一个值指定为两个属性的值。

例如：

```
.item { 
   place-self: end center;
}
```

在上面的代码中，`align-self` 属性的值设置为`end`，这会将网格项垂直向下推到其网格单元格的底部。`justify-self` 属性设置为 `center`，将网格项目水平放置在其单元格的中心。

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81kNB99poiaCicCYunTSdSRGvEqhiaSJ2K1QWibVgmpFX4Gzf5ujicy8nJ5icw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （5）grid-column

`grid-column` 是 `grid-column-start` 和 `grid-column-end` 属性的简写属性。它可以指定网格项沿网格容器内的列网格线的水平起始位置以及网格项应该结束的位置。

`grid-column`的语法如下：

```
grid-column: column-start / column-end;
```

`grid-column` 属性接受两个由斜线 (/) 分隔的网格线值，其中：

- 第一个值 `column-start` 是 `grid-column-start` 属性的值；
- 第二个值 `column-end` 是 `grid-column-end` 属性的值；
- 斜杠 (/) 用作这两个值之间的分界线，因为两者都可以包含一个或多个空格。因此，需要通过斜线来消除错误和歧义。此外，作为最佳实践，建议在斜杠 (/) 的两侧添加一哥空格，以使 CSS 更具可读性。

例如：

```
.gird-item {
  grid-column: 1 / 3;
}
```

上面的代码告诉网格项从网格中的第 1 列水平跨越到第 3 列，与下面的代码等价：

```
.gird-item {
  grid-column-start: 1;
  grid-column-end: 3;
}
```

### （6）grid-row

`grid-row` 属性的工作方式与 `grid-column` 属性一样。它是 `grid-row-start` 和 `grid-row-end` 属性的简写属性。它可以指定网格项沿网格容器中的行网格线的垂直起始位置，以及网格项应该在网格中的何处结束。

例如：

```
.gird-item {
  grid-column: 2 / 5;
}
```

这就会使得网格项的高度从网格中的第 2 行向下跨越到第 5 行。

`grid-column` 和 `grid-row` 属性中也可以使用 `span` 关键字，以下两者是等效的：

```
.gird-item {
  grid-column: 1 / 3;
  grid-row: 1 / 3;
}

.gird-item {
  grid-column: 1 / span 2;
  grid-row: 1 / span 2;
}
```

斜杠后面的部分可以省略，表示跨越第一个网格。

### （7）grid-template

`grid-template-columns`、`grid-template-rows`、`grid-template-areas`这三个属性可以简写在`grid-template`属性中。

`grid-template`属性有三个属性值：

- `none`：将三个属性都设置为其初始值，即一行一列一个单元格；
- `subgrid`：把`grid-template-columns`和`grid-template-rows`设置为`subgrid`，并且把`grid-template-areas`设置为初始值；
- `grid-template-rows/grid-template-columns`：将`grid-template-columns`和`grid-template-rows`设为指定值，而`grid-template-areas`设置为`none`。

### （8）grid-area

`grid-area` 属性指定网格元素在网格布局中的大小和位置，它是`grid-row-start`、`grid-column-start`、`grid-row-end`、`grid-column-end`属性的合并简写形式，其语法如下：

```
grid-area: <row-start> / <column-start> / <row-end> / <column-end>;
```

对于下面这段代码：

```
.container div:nth-of-type(1) {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 2;
  grid-row-end: 4;
}
```

可以简写成这样：

```
.container div:nth-of-type(1) {
  grid-area: 2 / 1 / 4 / 3;
}
```

除此之外，`grid-area` 属性还可以对网格元素进行命名。命名的网格元素可以通过容器的 `grid-template-areas` 属性来引用。

下面来看一个例子：

```
.item1 { grid-area: header; }
.item2 { grid-area: main; }
.item3 { grid-area: sideber; }
.item4 { grid-area: footer; }
 
.container {
  grid-template-areas:
    'header header header'
    'menu main sideber'
    'footer footer footer';
}
```

结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81bVQ6jQq67xRiboX360TRfktCkHcy2quD6cnnBfxjlDgPCMB8gE03tZQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### （9）grid

`grid` 属性可以为每个显式网格容器属性（例如 `grid-template-rows`、`grid-template-columns` 和 `grid-template-areas`）以及每个隐式网格容器属性设置一个值（例如 `grid-auto-rows`、`grid-auto-columns` 和 `grid-auto-flow`）在一个声明中。

`grid` 属性的语法如下：

```
<grid-template> | <grid-template-rows> / [ auto-flow && dense? ] <grid-auto-columns>? | [ auto-flow && dense? ] <grid-auto-rows>? / <grid-template-columns>
```

## CSS Grid 调试

上面我们介绍了如何定义 CSS Grid 布局，那该如何调试呢？Chrome DevTools 支持对 Grid 布局进行提示。如果一个元素是 Grid 布局，在 DevTools 的 Elements 面板中，Grid 布局的容器元素上就会显示一个 grid 的标识，如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81icsDL3W4tJ36HRgZ78WDD1LJGG8qNppn1QokRBUIO42HhDUPgIIFOww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

点击这个 grid 标志，页面的 grid 网格就会显示数网格区域以及网格线，并且会为网格线进行编号，如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81HtcgMDlTRNY08wViaMjhicibH8zslkCqlRn1coUIWJhvzzxayicjsXr8DA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

下面切换到 Layout 选项卡，就可以看到 Grid 布局的一些选项，我们可以设置页面上是否显示轨道的宽度/高度，是否展示网格区域的名称，是否显示网格线的延长，是否显示网格线的名称。除此之外，还会显示当前页面上所有使用 Grid 布局的地方，可以进行显示隐藏：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81hKxxvuRfIVIALIiaz7iaMwpZEibxXUOulSibAicbnKSOqGXfw2HMXqdwTXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

通过这些选项，就可以对 CSS Grid 布局进行调试了。

## CSS Grid 生成器

最后来分享几个实用的 CSS Grid 生成器。通过这些生成器，可以可视化得调整 Grid 布局，最终会拿到生成的 Grid 布局代码。

### （1）CSS Grid Generator

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81JHdXPFiciaAWM0E1F8LR3iazLkZvlbOMLN8XKR91fbicicl2wrZJicdjahNA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**在线体验：**https://cssgrid-generator.netlify.app/

### （2）CSS Layout Generator

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP815tCNiaU4SBKsAcpndic8JP3x5HicP3RMvYA5l8yibKyxZZrEFJSfibtibE1Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**在线体验：**https://layout.bradwoods.io/customize

### （3）Grid LayoutIt

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP816I0icZm5iaiaHzp56micTwQuLopmFLYKgiagG2grddHNAM9QPvdQwoicrymQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**在线体验：**https://grid.layoutit.com/

### （4）Griddy

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81ibe2kPlKfYUserQribbiazbun5Gj7PHbZMRW5MwbvsbbF8AKLmmTtJicRw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**在线体验：**https://griddy.io/

### （5）Cssgr.id

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMQQ9EoYDlteQsSuMFXhP81NSBb3KVzlVNt90eHZuhSTlQzQFUWPoC53PG8G91ibEUL1QycPjJKdCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**在线体验：**https://cssgr.id/

# 九宫格布局

> 最近看到一个面试题：**实现一个九宫格布局，用尽可能多的方式去实现？** 搜了一下牛客面经，腾讯、字节跳动、百度、网易、京东等的面经中都出现过这道题目。所以今天就来实现一下，看有多少种实现方式（下面实现的九宫格布局是自适应页面大小的）。

[实现九宫格布局，你能想到多少种方法？](https://mp.weixin.qq.com/s?__biz=MzU2MTIyNDUwMA==&mid=2247486102&idx=1&sn=cff4a5d5b5cfbab8aa060f0986e5ffeb&chksm=fc7d44cdcb0acddbbb3005d1c383019ab4f7841db44ba416f56493e5e21a46452cd1fefd98e8&mpshare=1&scene=23&srcid=1220KLY6QMomN7BpFQclEz7Z&sharer_sharetime=1671533450475&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 实现效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212211625569.png" alt="image-20221221162505465" style="zoom: 33%;" />

## HTML结构

首先，定义好通用的HTML结构：

```html
.box>div{$}*9  // emmet语法
```

```html
<div class="box">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
    <div>7</div>
    <div>8</div>
    <div>9</div>
</div>
```

> 注，很多小伙伴说HTML结构有问题，在平时开发中可能定义结构用span和div多一点,主要来看样式的实现思路~

## flex实现

> 对于九宫格布局，我首先想到的就是flex布局，flex布局实现九宫格很简单，需要设置一个flex-wrap: wrap;使得盒子在该换行的时候进行换行。

> 由于我们给每个元素设置了下边距和右边距，所以最后同一列（3、6、9）的右边距和最后一行（7、8、9）的下边距撑大了ul，所以这里使用类型选择器来消除他们的影响。最终的实现代码如下：

```css
* {
    margin: 0;
    padding: 0;
}

.box {
    display: flex;
    flex-wrap: wrap;
    width: 600px;
    height: 600px;
    background-color: orange;
}

.box div {
    width: 30%;
    height: 30%;
    margin-right: 5%;
    margin-bottom: 5%;
    border-radius: 5px;
    background: skyblue;
    /* 以下是让子盒子内的元素居中 */
    display: flex;
    justify-content: center;
    align-items: center;
}

.box div:nth-of-type(3n){
    margin-right: 0;
}

.box div:nth-of-type(n+7){
    margin-bottom: 0;
}
```

## grid实现

grid布局相对于flex布局来说，实现九宫格就更加容易了，只需要设置几个属性即可：

```css
.box {
    width: 600px;
    height: 600px;
    background-color: orange;
    display: grid;
    grid-template-columns: 30% 30% 30%;
    grid-template-rows: 30% 30% 30%;
    grid-gap: 5%;
}

.box div {
    border-radius: 5px;
    background: skyblue;
    /* 以下是让子盒子内的元素居中 */
    display: flex;
    justify-content: center;
    align-items: center;
}
```

其中grid-template-columns属性用来设置每一行中单个元素的宽度，grid-template-rows属性用来设置每一列中单个元素的高度，grid-gap属性用来设置盒子之间的间距。其实Grid布局还是很有用，很方便的，近期会有一篇详解grid布局的文章，有想了解的小伙伴可以关注一波嗷~

## float实现

这里需要给每个盒子设置固定的宽高，为了让它自动换行，可以使用float来实现，由于子元素的浮动，形成了BFC，所以父元素ul使用overflow:hidden；来消除浮动带来的影响。最终的实现代码如下：

```css
ul {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

li {
  float: left;
  width: 30%;
  height: 30%;
  margin-right: 5%;
  margin-bottom: 5%;
}

li:nth-of-type(3n){ 
  margin-right: 0;
}

li:nth-of-type(n+7){ 
  margin-bottom: 0;
}
```

## inline-block实现

其实inline-block的作用和上面float的作用是一样的，都是用来让元素换行的，实现代码如下：

```css
ul {
  width: 100%;
  height: 100%;
  letter-spacing: -10px;
}

li {
  width: 30%;
  height: 30%;
  display: inline-block;
  margin-right: 5%;
  margin-bottom: 5%;
}

li:nth-of-type(3n){ 
  margin-right: 0;
}

li:nth-of-type(n+7){ 
  margin-bottom: 0;
}
```

需要注意的是，设置为inline-block的元素之间可能会出现间隙，就可能出现下面这种情况：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNW3KfeTyp3HQpDib4VqlG1MP41Q8Wadw4ptgGpaaibnvG5QCd3T65Ip2Y6ibv9J0ywl9QzYtqRM61dQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)image.png

这里使用了letter-spacing属性来消除这种影响，该属性可以用来增加或减少字符间的空白（字符间距）。使用之后就正常了，出现了预期的效果。也可以给ul设置font-size: 0;来消除盒子之间的字符间距：

```css
ul {
  font-size: 0;
}
```

## table实现

HTML结构：

```css
<ul class="table">
  <li>
    <div>1</div>
    <div>2</div>
    <div>3</div>
  </li>
  <li>
    <div>4</div>
    <div>5</div>
    <div>6</div>
  </li>
  <li>
    <div>7</div>
    <div>8</div>
    <div>9</div>
  </li>
</ul>
```

table布局也不算太难，首先给父元素设置为table布局，然后使用border-spacing设置单元格之间的间距，最后将li设置为表格行，将div设置为表格单元格，CSS样式如下：

```css
.table {
  width: 100%;
  height: 100%;
  display: table;
  border-spacing: 10px;
}

li {
  display: table-row; 
}

div {
  width: 30%;
  height: 30%;
  display: table-cell;
  text-align: center;
  border-radius: 5px;
  background: skyblue;
}
```

## 方法选择

对于上述实现方式，总结如下：

> - flex布局也是我平时用的比较多的布局方式，虽然其还有一些兼容性问题，但是由于我做的是B端项目，基本不需要考虑兼容问题。其实flex布局主要适用于移动端项目；
> - grid布局实现起来非常方便，但是它的规范并未成熟，主流的浏览器使用较少，不推荐使用在企业项目中；
> - 使用float可以使元素脱离文档流，形成BFC，在重新渲染时不会影响其他的元素。需要注意使用float的元素其父元素会塌陷，需要清除浮动。
> - 使用inline-block来实现九宫格布局时，定义了inline-block的元素之间会出现间隙，需要清除；
> - table布局现在感觉用的比较少了，几乎很少在项目中使用table布局。

# 响应式布局

## 什么是响应式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162028836.png" alt="image-20221016202824660" style="zoom:80%;" />

## 媒体查询

> 能够根据设备宽度的变化，设置差异化样式

### 媒体类型

> 完整列表请参考： https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281550039.png" alt="image-20230328155014673" style="zoom:80%;" />

```html
<body>
    <h1>新年快乐</h1>
</body>
```

```html
<style>
    h1 {
        width: 600px;
        height: 400px;
        line-height: 400px;
        background-image: linear-gradient(30deg,red,yellow,green);
        margin: 0 auto;
        text-align: center;
        font-size: 100px;
        color: white;
        text-shadow: 0 0 10px black;
    }
    /* 必须写在样式的下面，不然可能不会生效*/
    /* 只有在打印机或打印预览才应用的样式：ctrl+p，显示打印格式 */
    @media print {
        h1 {
            background: transparent;
        }
    }

    /* 只有在屏幕上才应用的样式 */
    @media screen {
        h1 {
            font-family: "翩翩体-简";
        }
    }

    /* 一直都应用的样式 */
    @media all {
        h1 {
            color: red;
        }
    }
    
</style>
```

网页上显示的样式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281720085.png" alt="image-20230328172038610" style="zoom:67%;" />

打印预览的样式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281721122.png" alt="image-20230328172126663" style="zoom:80%;" />



### 媒体特性

> 完整列表请参考： https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281550393.png" alt="image-20230328155047995" style="zoom:80%;" />

```html
<body>
    <h1>你好啊</h1>
</body>
```

```css
<style>
    * {
        margin: 0;
        padding: 0;
    }
    h1 {
        height: 200px;
        background-color: gray;
        text-align: center;
        line-height: 200px;
        font-size: 100px;
    }

    /* 检测到视口的宽度为800px时，应用如下样式 */
    @media (width:800px) {
        h1 {
            background-color: green;
        }
    }

    /* 检测到视口的宽度小于等于700px时，应用如下样式 */
    @media (max-width:700px) {
        h1 {
            background-color: orange;
        }
    }

    /* 检测到视口的宽度大于等于900px时，应用如下样式 */
    @media (min-width:900px) {
        h1 {
            background-color: deepskyblue;
        }
    }

    /* 检测到视口的高度等于800px时，应用如下样式 */
    @media (height:800px){
        h1 {
            background-color: yellow;
        }
    }

    /* 检测到屏幕的宽度等于1536px时，应用如下样式 */
    @media (device-width:1536px) {
        h1 {
            color: white;
        }
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281725974.png" alt="image-20230328172507509" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281725936.png" alt="image-20230328172519486" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281725897.png" alt="image-20230328172531440" style="zoom:67%;" />

## 运算符

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281551295.png" alt="image-20230328155136948" style="zoom:80%;" />

```html
<body>
    <h1>你好啊</h1>
</body>
```

```css
<style>
    * {
        margin: 0;
        padding: 0;
    }
    h1 {
        height: 200px;
        background-color: gray;
        text-align: center;
        line-height: 200px;
        font-size: 100px;
    }

    /* 且运算符，大于等于700且小于等于800 */
    @media (min-width:700px) and (max-width:800px) {
        h1 {
            background-color: orange;
        }
    }
    @media screen and (min-width:300px) and (max-width:600px) {
        h1 {
            background-color: orange;
        }
    }

    /* 或运算符，小于等于700或大于等于800 */
    @media screen and (max-width:700px) or (min-width:800px) {
        h1 {
            background-color: orange;
        }
    }

    /* 否定运算符 */
    @media not screen {
        h1 {
            background-color: orange;
        }
    }

    /* 肯定运算符 */
    @media only screen and (width:800px) {
        h1 {
            background-color: orange;
        }
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281729045.png" alt="image-20230328172916584" style="zoom:80%;" />

## 常用阈值

在实际开发中，会将屏幕划分成几个区间，例如：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281552022.png" alt="image-20230328155206670" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281955122.png" alt="image-20230328195521806" style="zoom:80%;" />

内容分别如下

```css
/* 超大屏幕 */
h1 {
    background-color: purple;
}
```

```css
* {
    margin: 0;
    padding: 0;
}
h1 {
    height: 200px;
    background-color: gray;
    text-align: center;
    line-height: 200px;
    font-size: 100px;
}
```

```css
/* 大屏幕 */
@media screen and (min-width:992px) and (max-width:1200px) {
    h1 {
        background-color: deepskyblue;
    }
}
```

```css
/* 中等屏幕 */
@media screen and (min-width:768px) and (max-width:992px) {
    h1 {
        background-color: green;
    }
}
```

```css
/* 超小屏幕 */
@media screen and (max-width:768px) {
    h1 {
        background-color: orange;
    }
}
```

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>03_媒体查询_运算符</title>
    <link rel="stylesheet" href="./css/small.css">
    <link rel="stylesheet" href="./css/middle.css">
    <link rel="stylesheet" href="./css/large.css">
    <link rel="stylesheet" media="screen and (min-width:1200px)" href="./css/huge.css">
</head>
<body>
    <h1>你好啊</h1>
</body>
</html>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281958611.png" alt="image-20230328195803308" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281958475.png" alt="image-20230328195818179" style="zoom: 50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281958729.png" alt="image-20230328195829426" style="zoom:33%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303281958042.png" alt="image-20230328195847740" style="zoom:25%;" />

## 结合外部样式的用法

用法一

```html
<link rel="stylesheet" media="具体的媒体查询" href="mystylesheet.css">
```

用法二

```css
@media screen and (max-width:768px) {
	/*CSS-Code;*/
}
@media screen and (min-width:768px) and (max-width:1200px) {
    /*CSS-Code;*/
}
```

# 常用布局方案

[建议收藏！总结了 42 种前端常用布局方案 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247503555&idx=2&sn=6a03a5695d46ee4b46f459621013e686&chksm=97c6536da0b1da7b6e4d2eddb17dd4f119435cdb32fe34f4b172b181d71aca92144ff43131ff&mpshare=1&scene=23&srcid=0314xOMQ9caKoqGSPWet8SDe&sharer_sharetime=1647228150418&sharer_shareid=845a75c5a618962a1579dfbc47b32379#rd)

本篇文章总结了四十二种CSS的常见布局，这四十二种布局可以细分为如下几类：

## 水平居中

实现水平布局比较简单，方法也比较多，这里总结了7种常用的布局方法，其公共的CSS代码如下所示：

```css
.parent { background: #ff8787; }
.child { height: 300px; width: 300px; background: #e599f7; }
```

其 `HTML` 结构也是固定的，就是一个父级，其宽度继承了 `<body>` 的宽度，还有一个子级，这里是固定的300px*300px，代码如下：

```html
<div class="parent">
  <div class="child"></div>
</div>
```

最终的实现效果如下：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdxsHhKMQibnJppAftaleXNOZWNT4ya8e1lmrJulibTucZDBULuzialBOa01RCkw3XYWokmQEn8vvL0TQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />

上图中玫瑰色的块是父级，随页面宽度增加的；淡紫色是子级，相对于父级居中的。

### 1. 使用text-align属性

若元素为行内块级元素，也就是 display: inline-block 的元素，可以通过为其父元素设置text-align: center 

实现水平居中。

实现的CSS代码如下：

```css
.parent {
  /* 对于子级为 display: inline-block; 可以通过 text-align: center; 实现水平居中 */
  text-align: center;
}

.child {
  /*转为行内块元素*/
  display: inline-block;
}
```



### 2. 定宽块级元素水平居中(最简单)

对于定宽的的块级元素实现水平居中，最简单的一种方式就是 `margin: 0 auto;`，

但是值得注意的是`一定需要设置宽度`。实现 `CSS` 代码如下：

```css
.child {
  /* 对于定宽的子元素，直接 margin:0 auto; 即可实现水平居中 */
  margin: 0 auto;
}
```



### 3. 定宽块级元素水平居中

对于开启定位的元素，可以通过 `left` 属性 和 `margin` 实现。实现CSS代码如下：

```css
.child {
  /* 开启定位 */
  position: relative;
  left: 50%;
  /* margin-left为负的宽度的一半 */
  margin-left: -150px;
}
```



### 4. 定宽块级元素水平居中

当元素开启决定定位或者固定定位时， `left` 属性和 `right` 属性一起设置就会拉伸元素的宽度，在配合 `width` 属性与 `margin` 属性就可以实现水平居中。

实现 `CSS` 代码如下：

```css
.parent {
  position: relative;
  height: 300px;
}

.child {
  /* 开启定位 父相子绝 */
  position: absolute;
  /* 水平拉满屏幕 */
  left: 0;
  right: 0;
  width: 300px;
  /* 拉满屏幕之后设置宽度，最后通过 margin 实现水平居中 */
  margin: auto;
}
```



### 5. 定宽块级元素水平居中

当元素开启决定定位或者固定定位时， `left` 属性和 `transform` 属性即可实现水平居中。

实现CSS代码如下：

```css
.parent {
  position: relative;
}

.child {
  /* 开启定位 */
  position: absolute;
  /* 该方法类似于 left 于 -margin 的用法，但是该方法不需要手动计算宽度。 */
  left: 50%;
  transform: translateX(-50%);
}
```



### 6. Flex方案

通过 `Flex` 可以有很多方式实现这个居中布局的效果。

实现 `CSS` 代码如下

```css
.parent {
  height: 300px;
  /* 开启 Flex 布局 */
  display: flex;
  /* 通过 justify-content 属性实现居中 */
  justify-content: center;
}

.child {
  /* 或者 子元素 margin: auto*/
  margin: auto;
}
```



### 7. Grid方案

通过Grid实现居中布局比通过Flex实现的方式更多一些。

实现CSS代码如下：

```css
.parent {
  height: 300px;
  /* 开启 Grid 布局 */
  display: grid;
  /* 方法一 */
  justify-items: center;
  /* 方法二 */
  justify-content: center;
}

.child {
  /* 方法三 子元素 margin: auto*/
  margin: auto;
}
```

以上就是水平居中布局常用的几种方式。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220401165449960.png" alt="image-20220401165449960" style="zoom: 33%;" />

## 垂直居中

实现垂直布局也是比较简单的，方法也比较多，这里总结了6种常用的布局方法，其公共的 `CSS` 代码如下所示：

```css
.parent {
  height: 500px;
  width: 300px;
  margin: 0 auto;
  background-color: #ff8787;
}
.child {
  width: 300px;
  height: 300px;
  background-color: #91a7ff;
}
```

其 `HTML` 结构也是固定的，就是一个父级包裹一个子级，这里的子级是固定的300px*300px，代码如下：

```css
<div class="parent">
  <div class="child"></div>
</div>
```

最终的实现效果如下：



### 1. 行内块级元素垂直居中

若元素是行内块级元素, 基本思想是子元素使用display: inline-block, vertical-align: middle;并让父元素行高等同于高度。

实现CSS代码如下：

```css
.parent {
  /* 为父级容器设置行高 */
  line-height: 500px;
}

.child {
  /* 将子级元素设置为 inline-block 元素 */
  display: inline-block;
  /* 通过 vertical-align: middle; 实现居中 */
  vertical-align: middle;
}
```



### 2. 定位方式实现(方法一)

第一种通过定位的方式实现就比较简单，实际就是通过top: 50%; margin-top: 等于负的高度的一半就可以实现垂直居中。

实现CSS代码如下：

```css
.parent {
  /* 为父级容器开启相对定位 */
  position: relative;
}

.child {
  position: absolute;
  top: 50%;
  /* margin-top: 等于负高度的一半 */
  margin-top: -150px;
}
```



### 3. 定位方式实现(方法二)

第二种通过定位的方式实现实现思路：`top` 和 `bottom` 将子元素拉伸至100%，设置指定的高度，通过margin:auto;即可实现垂直居中。

实现CSS代码如下：

```css
.parent {
  /* 为父级容器开启相对定位 */
  position: relative;
}

.child {
  height: 300px;
  position: absolute;
  /* 垂直拉满 */
  top: 0;
  bottom: 0;
  /* margin: auto 即可实现 */
  margin: auto;
}
```

### 4. 定位方式实现(方法三)

第三种通过定位的方式就比较灵活，适用于多种场合，使用 `top` 配合 `tansform` 即可。

实现CSS代码如下：

```css
.parent {
  /* 为父级容器开启相对定位 */
  position: relative;
}

.child {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
```

### 5. Flex方案

通过 Flex 可以有很多方式实现这个垂直居中布局的效果。

实现CSS代码如下：

```css
.parent {
  /* 开启 flex 布局 */
  display: flex;
  /* 方法一 */
  /* align-items: center; */
}

.child {
  /* 方法二 */
  margin: auto;
}
```

通过 Flex 布局实现不仅仅只有上面两种，这里只介绍最简单的方式。

### 6. Grid方案

通过 `Grid` 实现居中布局比通过 Flex 实现的方式更多一些。

实现CSS代码如下：

```css
.parent {
  display: grid;
  /* 方法一 */
  /* align-items: center; */
  /* 方法二 */
  /* align-content: center; */
}

.child {
  /* 方法三 */
  /* margin: auto; */
  /* 方法四 */
  align-self: center;
}
```

以上就是垂直居中布局常用的几种方式。

## 水平垂直居中

实现水平垂直布局基本就是将上面几种方式结合使用，这里总结了7种常用的布局方法，其公共的 `CSS` 代码如下所示：

```css
body {
  margin: 0;
}
.parent {
  height: 500px;
  width: 500px;
  background-color: #eebefa;
  margin: 0 auto;
}
.child {
  height: 300px;
  width: 300px;
  background-color: #f783ac;
}
```

其 `HTML` 结构也是固定的，就是一个父级包裹一个子级，这里的子级是固定的300px*300px，代码如下：

```css
<div class="parent">
  <div class="child"></div>
</div>
```

最终的实现效果如下：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdxsHhKMQibnJppAftaleXNOZoJsnO7LFF51UFAswKOMpdmS5QjmiaN2IM4QN07b2S7mjyvuLkMO6dyA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:25%;" />

### 1. 行内块级水平垂直居中方案

步骤如下：

- 容器元素行高等于容器高度
- 通过 text-align: center; 实现水平居中
- 将子级元素设置为水平块级元素
- 通过 vertical-align: middle; 实现垂直居中

实现CSS代码如下：

```css
.parent {
  /* 1. 设置行高等于容器高度 */
  line-height: 500px;
  /* 通过 text-align: center; 实现水平居中 */
  text-align: center;
}
.child {
  /* 将子级元素设置为水平块级元素 */
  display: inline-block;
  /* 通过 vertical-align: middle; 实现垂直居中 */
  vertical-align: middle;
}
```

### 2. 定位实现水平垂直居中方案(一)

步骤如下：

- 使子元素相对于容器元素定位
- 子元素开启绝对定位
- 设置该元素的偏移量，值为50% 减去宽度/高度的一半

实现CSS代码如下：

```css
.parent {
  /* 1. 使子元素相对于本元素定位 */
  position: relative;
}
.child {
  /* 2. 开启绝对定位 */
  position: absolute;
  /* 3. 设置该元素的偏移量，值为 50%减去宽度/高度的一半 */
  left: calc(50% - 150px);
  top: calc(50% - 150px);
}
```

### 3. 定位实现水平垂直居中方案(二)

步骤如下：

- 使子元素相对于容器元素定位
- 子元素开启绝对定位
- 设置该元素的偏移量，值为50%
- 通过外边距-值的方式将元素移动回去

实现CSS代码如下：

```css
.parent {
  /* 1. 使子元素相对于本元素定位 */
  position: relative;
}
.child {
  /* 2. 开启绝对定位 */
  position: absolute;
  /* 3. 设置该元素的偏移量，值为 50% */
  left: 50%;
  top: 50%;
  margin-left: -150px;
  margin-top: -150px;
}
```

### 4. 定位实现水平垂直居中方案(三)

步骤如下：

- 使子元素相对于容器元素定位
- 子元素开启绝对定位
- 将子元素拉满整个容器
- 通过margin:auto实现水平垂直居中

实现CSS代码如下：

```css
.parent {
  /* 1. 使子元素相对于本元素定位 */
  position: relative;
}
.child {
  /* 2. 开启绝对定位 */
  position: absolute;
  /* 3. 将子元素拉满整个容器 */
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  /* 4. 通过 margin:auto 实现水平垂直居中 */
  margin: auto;
}
```

### 5. 定位实现水平垂直居中方案(四)

步骤如下：

- 使子元素相对于容器元素定位
- 子元素开启绝对定位
- 设置该元素的偏移量，值为50%
- 通过 `translate` 反向偏移的方式，实现居中

实现 CSS 代码如下：

```css
.parent {
  /* 1. 使子元素相对于本元素定位 */
  position: relative;
}
.child {
  /* 2. 开启绝对定位 */
  position: absolute;
  /* 3. 设置该元素的偏移量，值为 50%*/
  left: 50%;
  top: 50%;
  /* 通过translate反向偏移的方式，实现居中 */
  transform: translate(-50%, -50%);
}
```

### 6. Flex方案

步骤如下：

- 将元素设置为 `Flex` 布局
- 通过 justify-content: center 以及 align-items: center 实现或者 margin: auto; 实现。

实现CSS代码如下：

```css
.parent {
  /* 1. 将元素设置为 Flex 布局 */
  display: flex;
  /* 2. 通过 justify-content 以及 align-items: center 实现 */
  /* justify-content: center;
  align-items: center; */
}
.child {
  /* 或者通过 margin auto 实现 */
  margin: auto;
}
```

### 7. Grid方案

`Grid` 方案的实现方式相对来说比较简单，方式也较多。

实现CSS代码如下：

```css
.parent {
  /* 1. 元素设置为Grid 元素 */
  display: grid;
  /* 通过 items 属性实现*/
  /* align-items: center; */
  /* justify-items: center; */
  /* items 的缩写 */
  /* place-items: center; */

  /* 或者通过 content 属性 */
  /* align-content: center; */
  /* justify-content: center; */
  /* content 的缩写 */
  /* place-content: center; */
}
.child {
  /* 或者通过 margin auto 实现 */
  /* margin: auto; */
  /* 或者通过 self 属性 */
  /* align-self: center;
  justify-self: center; */
  /* self 的缩写 */
  place-self: center;
}
```

实现水平垂直居中布局的方式大多是通过上面两种布局的方式相结合。

## 两列布局

所谓的两列布局就是一列定宽(也有可能由子元素决定宽度)，一列自适应的布局。最终效果如下所示：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdxsHhKMQibnJppAftaleXNOZXGwJw4VFPWibZUQ4Ugcibn2nicTzITqtRibm5o3dfoxUFTrn7ZcH0CcEfQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

这里用到的 `HTML` 结构如下：

```css
<!-- 解决高度塌陷 -->
<div class="container clearfix">
  <div class="left">定宽</div>
  <div class="right">自适应</div>
</div>
```

公共的 `CSS` 代码如下:

```css
body {
  margin: 0;
}
.container {
  height: 400px;
  background-color: #eebefa;
}
.left {
  height: 400px;
  width: 200px;
  background-color: #f783ac;
  font-size: 70px;
  line-height: 400px;
  text-align: center;
}
.right {
  height: 400px;
  background-color: #c0eb75;
  font-size: 70px;
  line-height: 400px;
}
/* 清除浮动 */
.clearfix:after {
  content: '';
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}
```

### 1. float+calc()函数完成左列定宽右列自适应

步骤如下：

- 左边列开启浮动
- 右边列开启浮动
- 右边列宽度为父级 100%减去左列的宽度

实现CSS代码如下：

```css
.left {
  /* 左边列开启浮动 */
  float: left;
}
.right {
  /* 右边列开启浮动 */
  float: left;
  /* 宽度减去左列的宽度 */
  width: calc(100% - 200px);
}
```

### 2. float+margin-left完成左列定宽右列自适应

步骤如下：

- 左边列开启浮动
- 通过外边距的方式使该容器的左边有左边列容器的宽度的外边距

实现CSS代码如下：

```css
.left {
  /* 左边列开启浮动 */
  float: left;
}
.right {
  /* 通过外边距的方式使该容器的左边有200px */
  margin-left: 200px;
}
```

### 3. absolute+margin-left完成左列定宽右列自适应

步骤如下：

- 开启定位脱离文档流
- 通过外边距的方式使该容器的左边有左边列容器的宽度的外边距

实现CSS代码如下：

```css
.left {
  /* 开启定位脱离文档流 */
  position: absolute;
}
.right {
  /* 通过外边距的方式使该容器的左边有200px */
  margin-left: 200px;
}
```

> 值得注意的是 以上几种方案左边列必须定宽，才可以实现，下面这几种方案左边列可以由子级撑起。

### 4. float+overflow完成左列定宽右列自适应

步骤如下：

- 左侧元素开始浮动
- 右侧自适应元素设置overflow会创建一个BFC完成自适应

实现CSS代码如下：

```css
.left {
  /* 1. 左侧元素开始浮动 */
  float: left;
}
.right {
  /* 2. 右侧自适应元素设置 overflow 会创建一个BFC 完成自适应 */
  overflow: hidden;
}
```

### 5. Flex方案

通过Flex布局实现该功能主要是通过 flex 属性来实现示例代码如下：

```css
.container {
  display: flex;
}
.right {
  flex: 1;
  /* flex: 1; 表示 flex-grow: 1; 即该项占所有剩余空间 */
}
```

### 6. Grid方案

通过 Grid 布局实现该功能主要是通过template属性实现，具体代码如下所示：

```css
.container {
  display: grid;
  /* 将其划分为两行，其中一列有本身宽度决定， 一列占剩余宽度*/
  grid-template-columns: auto 1fr;
}
```

## 三列布局

三列布局主要分为两种：

- 第一种是前两列定宽，最后一列自适应，这一种本质上与两列布局没有什么区别，可以参照两列布局实现。
- 第二种是前后两列定宽，中间自适应，最终效果图如下

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdxsHhKMQibnJppAftaleXNOZ6ycWAH5E3Vpd7JTSuicwUKKPbJtDy7Mb4A0DXarYLiciaMk5y6AyicTZsg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

公共 CSS 如下：

```css
body {
  margin: 0;
}
.container {
  height: 400px;
  background-color: #eebefa;
}
.left {
  height: 400px;
  width: 200px;
  background-color: #f783ac;
}
.content {
  height: 400px;
  background-color: #d9480f;
}
.right {
  height: 400px;
  width: 200px;
  background-color: #c0eb75;
}
.left,
.content,
.right {
  font-size: 70px;
  line-height: 400px;
  text-align: center;
}
/* 清除浮动 */
.clearfix:after {
  content: '';
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}
```

HTML 结构如下：

```css
<!-- 解决高度塌陷 -->
<div class="container clearfix">
  <div class="left">左</div>
  <div class="content">内容</div>
  <div class="right">右</div>
</div>
```

### 1. 通过float实现(一)

实现步骤：

- 为了完成效果需要调整HTML结构，调整后如下：

```css
<!-- 解决高度塌陷 -->
<div class="container clearfix">
  <div class="left">左</div>
  <div class="right">右</div>
  <div class="content">内容</div>
</div>
```

- 左列容器开启左浮动
- 右列容器开启右浮动
- 自适应元素设置overflow会创建一个BFC完成自适应

实现CSS代码如下

```css
.left {
  /* 1. 左列容器开启左浮动 */
  float: left;
}
.content {
  /* 自适应元素设置 overflow 会创建一个BFC 完成自适应 */
  overflow: hidden;
}
.right {
  /* 2. 右列容器开启右浮动 */
  float: right;
}
```

### 2. 通过float实现(二)

实现步骤：

- 为了完成效果需要调整 HTML 结构，调整后如下：

```css
<!-- 解决高度塌陷 -->
<div class="container clearfix">
  <div class="left">左</div>
  <div class="right">右</div>
  <div class="content">内容</div>
</div>
```

- 左列容器开启左浮动
- 右列容器开启右浮动
- 使中间自适应的宽度为父级容器减去两个定宽的列

实现CSS代码如下：

```css
.left {
  /* 1. 左列容器开启左浮动 */
  float: left;
}
.content {
  /* 3. 使中间自适应的宽度为父级容器减去两个定宽的列 */
  width: calc(100%-400px);
}
.right {
  /* 2. 右列容器开启右浮动 */
  float: right;
}
```

### 3. 通过position实现

实现步骤

- 左右两列脱离文档流，并通过偏移的方式到达自己的区域
- 使中间自适应的宽度为父级容器减去两个定宽的列
- 通过外边距将容器往内缩小

实现CSS代码如下：

```css
.left {
  /* 1. 左右两列脱离文档流，并通过偏移的方式到达自己的区域 */
  position: absolute;
  left: 0;
  top: 0;
}
.content {
  /* 2. 使中间自适应的宽度为父级容器减去两个定宽的列 */
  width: calc(100%-400px);
  /* 3. 通过外边距将容器往内缩小 */
  margin-right: 200px;
  margin-left: 200px;
}
.right {
  position: absolute;
  right: 0;
  top: 0;
}
```

### 4. Flex方案

通过 `Flex` 布局实现该功能主要是通过 `flex` 属性来实现。

实现CSS代码如下：

```css
.container {
  display: flex;
}
.right {
  flex: 1;
  /* flex: 1; 表示 flex-grow: 1; 即该项占所有剩余空间 */
}
```

### 5. Grid方案

通过 `Grid` 布局实现该功能主要是通过 `template` 属性实现。

实现CSS代码如下：

```css
.container {
  display: grid;
  /* 将其划分为两行，其中一列有本身宽度决定， 一列占剩余宽度*/
  grid-template-columns: auto 1fr auto;
}
```

## 等分布局

等分布局就是将一个容器平均分成几等份，这里以 4 等分为例，主要介绍4种方法。

公共CSS部分如下：

```css
body {
  margin: 0;
}
.container {
  height: 400px;
  background-color: #eebefa;
}
.item {
  height: 100%;
}
.item1 {
  background-color: #eccc68;
}
.item2 {
  background-color: #a6c1fa;
}
.item3 {
  background-color: #fa7d90;
}
.item4 {
  background-color: #b0ff70;
}
/* 清除浮动 */
.clearfix:after {
  content: '';
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}
```

公共HTML代码如下：

```css
<!-- 父元素清除浮动 -->
<div class="container clearfix">
  <div class="item item1"></div>
  <div class="item item2"></div>
  <div class="item item3"></div>
  <div class="item item4"></div>
</div>
```

最终的效果如下图所示：

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdxsHhKMQibnJppAftaleXNOZ4tT663WvtCa5SEicInEv5AeexxCzhfa0TTy4XY1qnRGorauCheP6fhQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

### 1. 浮动+百分比方式

这种方式比较简单，开启浮动，使每个元素占25%的宽度。

实现CSS代码如下：

```css
.item {
  /* 开启浮动，每个元素占 25% 的宽度 */
  width: 25%;
  float: left;
}
```

### 2. 行内块级+百分比方式

这种方式与上面那种方式类似，不过需要注意的是行内块级元素有一些类似于边距的几个像素，导致各25%会超出容器。

实现CSS代码如下：

```css
.item {
  /* 设置每个元素为行内块级元素，每个元素占 24.5% 的宽度 */
  width: 24.5%;
  /* 因为行内块级元素有一些类似于边距的几个像素，导致各占25会超出容器 */
  display: inline-block;
}
```

### 3. Flex方案

通过 Flex 布局实现该功能主要是通过 `flex` 属性来实现。

实现CSS代码如下：

```css
.container {
  /* 开启 flex 布局 */
  display: flex;
}
.item {
  /* 每个元素占相同的宽度 */
  flex: 1;
}
```

### 4. Grid方案

通过 Grid 布局实现该功能主要是通过 template 属性实现。

实现CSS代码如下

```css
.container {
  /* 开启 grid 布局 */
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  /* 使用 repeat 函数生成如下代码 */
  /* grid-template-columns: 1fr 1fr 1fr 1fr; */
}
```

## Sticky Footer布局

所谓的 `Sticky Footer` 布局并不是一种新的前端技术和概念，它就是一种网页布局。如果页面内容不够长时，底部栏就会固定到浏览器的底部；如果足够长时，底部栏就后跟随在内容的后面。如下图所示：

<img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/vNIM26FMqKfBkBs2BlwsHibiaPPibicAvVBS8uLMB5qNJU6IbzEALm73WtYz3YcAflDibcB9pHMnIFomV1bPrdFbFPw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" />

这里来介绍实现该布局的4种方式

公共的CSS代码如下：

```css
body {
    margin: 0;
}
.container {
    height: 400px;
    display: flex;
}
.left {
    height: 400px;
    width: 200px;
    background-color: #f759ab;
}
.content {
    height: 400px;
    background-color: #52c41a;
    flex: 1;
}
.right {
    height: 400px;
    width: 200px;
    background-color: #f759ab;
}
.left,
.content,
.right {
    font-size: 70px;
    line-height: 400px;
    text-align: center;
}
.header {
    height: 100px;
    background-color: #70a1ff;
}
.footer {
    height: 100px;
    background-color: #ff7a45;
}
.header,
.footer {
    line-height: 100px;
    font-size: 52px;
    text-align: center;
}
```

公共的HTML如下：

```css
<div class="main">
    <div class="header">header</div>
    <div class="container">
        <div class="left">left</div>
        <div class="content">content</div>
        <div class="right">right</div>
    </div>
    <div class="footer">footer</div>
</div>
```

### 1. 绝对定位的方式

通过绝对定位的方式实现Sticky Footer布局的步骤如下：

- 设置最外层容器高度为100%；
- 让子元素元素相对于容器元素进行定位，并设置容器元素最小高度为100%；
- 在中间区域设置padding-bottom为footer的高度 ；
- 底部栏绝对定位，并一直吸附在底部即可实现。

实现CSS代码如下：

```css
/* 1. 设置最外层容器为100% */
html,
body {
    height: 100%;
}
/* 2. 让子元素元素相对于容器元素进行定位，并设置容器元素最小高度为100% */
.main {
    position: relative;
    min-height: 100%;
}
/* 3. 在中间区域设置 padding-bottom 为footer 的高度 */
.container {
    padding-bottom: 100px;
}
/* 由于开启了绝对定位，宽度成了自适应，设置为100% bottom:0 始终保持底部 */
.footer {
    position: absolute;
    width: 100%;
    bottom: 0;
}
```

### 2. 使用calc函数实现

使用 `calc` 函数实现的方式会比较简单，中间的容器最少高度为视口宽度的100% - 头部和底部两部分的高度即可完成该功能。

实现CSS代码如下：

```css
.container {
    /* 这里的 中间 部分的容器最少为视口宽度的 100% - 头部和底部两部分的高度即可完成该功能 */
    min-height: calc(100vh - 200px);
}
```

### 3. Flex方案

实现步骤如下

- 开启 `flex` 布局
- 将子元素布局方向修改为垂直排列
- 设置最小高度为当前视口，使不管中间部分有多高，始终都可以保持在底部
- 设置中间部分容器高度为自适应

实现CSS代码如下：

```css
.main {
    /* 开启flex布局 */
    display: flex;
    /* 将子元素布局方向修改为垂直排列 */
    flex-flow: column;
    /* 设置最小高度为当前视口，使不管中间部分有多高，始终都可以保持在底部 */
    min-height: 100vh;
}
.container {
    /* 设置 中间 部分自适应 */
    flex: 1;
}
```

### 4. Grid方案

实现步骤如下

- 开启 `grid` 布局
- 置最小高度为当前视口，使不管中间部分有多高，始终都可以保持在底部

实现CSS代码如下：

```css
.main {
    /* 开启grid布局 */
    display: grid;
    grid-template-rows: auto 1fr auto;
    /* 设置最小高度为当前视口，使不管中间部分有多高，始终都可以保持在底部 */
    min-height: 100vh;
}
```

## 全屏布局

全部布局主要应用在后台，主要效果如下所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220401171353971.png" alt="image-20220401171353971" style="zoom: 33%;" />

这里介绍三种全屏布局的实现方法。

公共的CSS代码如下：

```css
body {
  margin: 0;
}
body,
html,
.container {
  height: 100vh;
  box-sizing: border-box;
  text-align: center;
  overflow: hidden;
}
.content {
  background-color: #52c41a;
  /* * 中间部门的布局可以参考 两列 三列 布局 */
  display: grid;
  grid-template-columns: auto 1fr;
}
.left {
  width: 240px;
  background-color: #52c41a;
  font-size: 80px;
  line-height: calc(100vh - 200px);
}
.right {
  background-color: #f759ab;
  font-size: 60px;
}
.header {
  height: 100px;
  background-color: #70a1ff;
}
.footer {
  height: 100px;
  background-color: #ff7a45;
}
.header,
.footer {
  line-height: 100px;
  font-size: 52px;
}
```

HTML结构如下：

```css
<div class="container">
    <div class="header">header</div>
    <div class="content">
        <div class="left">导航</div>
        <div class="right">
            <div class="right-in">自适应，超出高度出现滚动条</div>
        </div>
    </div>
    <div class="footer">footer</div>
</div>
```

### 1. 使用calc函数实现

实现步骤如下：

- 通过 `calc` 函数计算出中间容器的高度。
- 中间出现滚动条的容器设置overflow: auto即出现滚动条的时候出现滚动条。

实现CSS代码如下：

```css
.content {
    overflow: hidden;
    /* 通过 calc 计算容器的高度 */
    height: calc(100vh - 200px);
}
.left {
    height: 100%;
}
.right {
    /* 如果超出出现滚动条 */
    overflow: auto;
    height: 100%;
}
.right-in {
    /* 假设容器内有500px的元素 */
    height: 500px;
}
```

### 2. Flex 方案

使用 `Flex` 方式实现该布局比较简单。

实现CSS代码如下

```css
.container {
    /* 开启flex布局 */
    display: flex;
    /* 将子元素布局方向修改为垂直排列 */
    flex-flow: column;
}
.content {
    /* 如果超出出现滚动条 */
    overflow: auto;
    /* 设置 中间 部分自适应 */
    flex: 1;
}
.right-in {
    /* 假设容器内有500px的元素 */
    height: 500px;
}
```

### 3. Grid 方案

grid布局对于这种布局来说，实现起来是非常得心应手的，通过template属性即可实现。

实现CSS代码如下

```css
.container {
    /* 开启grid布局 */
    display: grid;
    grid-template-rows: auto 1fr auto;
}
.content {
    /* 如果超出出现滚动条 */
    overflow: auto;
}
.right-in {
    /* 假设容器内有500px的元素 */
    height: 500px;
}
```

# 布局游戏⭐

## Coding Fantasy⭐

地址：https://codingfantasy.com/games

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282007189.png" alt="image-20230328200720778" style="zoom:80%;" />

通过玩此网站上提供的游戏来提升你的 HTML、CSS 和 JavaScript 技能。

## Grid Gritters

地址：https://gridcritters.com/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282009857.png" alt="image-20230328200905164" style="zoom:80%;" />

CSS Grid是 CSS 中最难掌握的部分之一，也是最枯燥的部分之一。这个网站将帮助你以有趣的方式掌握 CSS Grid。

## CodeCombat

地址：https://codecombat.com/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282010409.png" alt="image-20230328201024900" style="zoom:80%;" />

一个适合初学者的多人实时编码策略游戏来学习编程的网站。

## Knights of the Flexbox

地址：https://knightsoftheflexboxtable.com/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282011803.png" alt="image-20230328201109327" style="zoom:80%;" />

Tailwind 是一个 CSS 框架，也是当今最常用与流行的框架之一，如果你想练习你的 CSS 和 Tailwind技能，那么，这个网站会是一个不错的地方。

## CSSBattle

地址：https://cssbattle.dev/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282012842.png" alt="image-20230328201212465" style="zoom:80%;" />

全球 CSS 挑战网站，通过解决问题获得全球奖励！

## Coding Games

地址：https://www.codingame.com

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282013925.png" alt="image-20230328201325990" style="zoom:80%;" />

一个面向程序员的基于编程挑战的培训平台，你可以在其中以有趣的方式提高你的编程技能。

## CSS Challenges

地址：https://css-challenges.com/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282014815.png" alt="image-20230328201443446" style="zoom:80%;" />

每天挑战自我，提高 CSS 技能并学习新技巧。

# BFC

## 什么是BFC

W3C 上对 BFC 的定义：

> 译文：浮动、绝对定位元素、不是块盒子的块容器（如inline-blocks 、table-cells 和table-captions ），以及overflow 属性的值除visible 以外的块盒，将为其内容建立新的块格式化上下文。

MDN 上对 BFC 的描述：

> 块格式化上下文（Block Formatting Context，BFC） 是Web 页面的可视CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

更加通俗的描述：

> BFC 是 Block Formatting Context （块级格式上下文），可以理解成元素的一个“特异功能”。
>
> 该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活。
>
> 所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）。

## 开启了BFC能解决什么问题

> 1. 元素开启BFC 后，其子元素不会再产生margin 塌陷问题。
> 2. 元素开启BFC 后，自己不会被其他浮动元素所覆盖。
> 3. 元素开启BFC 后，就算其子元素浮动，元素自身高度也不会塌陷。

## 如何开启BFC

> - 根元素
> - 浮动元素
> - 绝对定位、固定定位的元素
> - 行内块元素
> - 表格单元格： table 、thead 、tbody 、tfoot 、th 、td 、tr 、caption
> - overflow 的值不为 visible 的块元素
> - 伸缩项目
> - 多列容器
> - column-span 为 all 的元素（即使该元素没有包裹在多列容器中）
> - display 的值，设置为flow-root

```html
<div class="outer">
    <div class="inner inner1"></div>
    <div class="inner inner2"></div>
</div>
```

```css
<style>
    .outer {
        width: 400px;
        background-color: #888;
        /* float: left; */
        /* position: absolute; */
        /* display: inline-block; */
        /* display: table; */
        /* overflow: auto; */
        /* column-count: 1; */
        display: flow-root;
    }
    .inner {
        width: 100px;
        height: 100px;
        float: left;
    }
    .inner1 {
        background-color: orange;
    }
    .inner2 {
        background-color: green;
    }
</style>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303282001768.png" alt="image-20230328200100473" style="zoom:80%;" />

# Sass + Less

> Sass 是一个 CSS 预处理器，完全兼容所有版本的 CSS。实际上，Sass 并没有真正为 CSS 语言添加任何新功能。只是在许多情况下可以可以帮助我们减少 CSS 重复的代码，节省开发时间。下面就来看看 Sass 中常用的功能吧！

## Less

目标：使用Less运算写法完成px单位到rem单位的转换

思考：在px单位转换到rem单位过程中，哪项工作是最麻烦的？

答：除法运算。CSS不支持计算写法。 解决方案：可以通过Less实现。

### 初体验

> - Less是一个CSS预处理器, Less文件后缀是**.less**
> - 扩充了 CSS 语言, 使 CSS 具备一定的逻辑性、计算能力。
> - 注意：浏览器不识别Less代码，目前阶段，网页要引入对应的CSS文件。

Easy Less :  vscode插件、作用：less文件保存自动生成css文件，less文件都会内涵一个CSS文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291757334.png" alt="image-20221129175723265" style="zoom:80%;" />

```less
.father {
    color: red;

    width: (68 / 37.5rem);

    .son {
        background-color: pink;
    }
}
```

对应的CSS文件

```css
.father {
  color: red;
  width: 1.81333333rem;
}
.father .son {
  background-color: pink;
}
```

### 注释

> 注释：单行注释，无法渲染到CSS，不过无所谓，毕竟是注释：// 注释内容，快捷键：ctrl + /
>
> 块注释：/* 注释内容 */，快捷键： shift + alt + A

```less
// 单行注释

/* 
    块注释
    第二行
    第三行
*/
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291802628.png" alt="image-20221129180216537" style="zoom:80%;" />

### 运算

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162009341.png" alt="image-20221016200932292" style="zoom:80%;" />

```less
.box {
    width: 100 + 10px;
    width: 100 - 20px;
    width: 100 * 2px;

    // 除法
    // 68  > rem
    width: (68 / 37.5rem);
    // height: 29 ./ 37.5rem;
    // 不推荐，会有报错符，但是是正确的
    height: 29 / 37.5rem;
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291803362.png" alt="image-20221129180315233" style="zoom:80%;" />

### 后代选择器⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291110856.png" alt="image-20221129111032718" style="zoom:80%;" />

嵌套语法



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210162010203.png" alt="image-20221016201003140" style="zoom:80%;" />

```less
.father {
    width: 100px;
    .son {
        color: pink;
        // & 表示当前选择器
        &:hover {
            color: green;
        }
    }

    &:hover {
        color: orange;
    }
}
```

对应生成的CSS

```css
.father {
  width: 100px;
}
.father .son {
  color: pink;
}
.father .son:hover {
  color: green;
}
.father:hover {
  color: orange;
}
```

### Less变量

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291112696.png" alt="image-20221129111202588" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291112220.png" alt="image-20221129111240111" style="zoom:80%;" />

```less
// 1. 定义. 2.使用
@colora:green;

.box {
    color: @colora;
}

.father {
    background-color: @colora;
}

.aa {
    color: @colora;
}
```

对应生成的CSS

```css
.box {
  color: green;
}
.father {
  background-color: green;
}
.aa {
  color: green;
}
```

### Less文件导入

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291113344.png" alt="image-20221129111330224" style="zoom:80%;" />

```less
@import './01-体验less.less';
@import './02-注释';
```

目前，Less文件导出的CSS文件位置是哪里？

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211291113318.png" alt="image-20221129111356183" style="zoom:80%;" />

### Less实战演练

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210161950215.png" alt="image-20221016195057124" style="zoom:80%;" />

```less
@import './base';
@import './normalize';

// 变量: 存储37.5
@rootSize: 37.5rem;

body {
    background-color: #F0F0F0;
}

// 主体内容
.main {
    // padding-bottom: (50 / 37.5rem);
    padding-bottom: (50 / @rootSize);
    
    // banner
    .banner {
        height: (160 / @rootSize);
    }

    // 活动标题
    .title {
        height: (40 / @rootSize);
        line-height: (40 / @rootSize);
        padding-left: (15 / @rootSize);
        h4 {
            font-size: (14 / @rootSize);
            color: #3C3C3C;
        }
    }

    // 活动
    .item {
        margin-bottom: (10 / @rootSize);

        // 图
        .pic {
            height: (160 / @rootSize);
        }

        // 文字
        .txt {
            padding: (10 / @rootSize) (15 / @rootSize);
            background-color: #fff;
        }
    }
}


// 底部工具栏
footer {
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100%;
    // height: (50 / 37.5rem);
    height: (50 / @rootSize);
    background-color: #FECA49;
}
```

```html
<body>
    <!-- 主体内容 -->
    <div class="main">
        <!-- banner -->
        <div class="banner">
            <ul>
                <li><a href="#"><img src="./uploads/banner_1.png" alt=""></a></li>
            </ul>
        </div>

        <!-- 活动标题 -->
        <div class="title">
            <h4>乐园活动</h4>
        </div>

        <!-- 活动 -->
        <section class="item">
            <div class="pic">
                <a href="#"><img src="./uploads/item_2.png" alt=""></a>
            </div>
            <div class="txt">1</div>
        </section>
    </div>
    <!-- 主体内容 -->

    <!-- 底部工具栏 -->
    <footer>2</footer>
    <!-- 底部工具栏 -->
    <script src="./js/flexible.js"></script>
</body>
```

## Sass

### 注释

> 在 Sass 中支持两种类型的注释：需要注意，当 Sass 编译成CSS时，第一种注释不会编译到CSS中（只在Sass文件中可见），第二种注释会编译到CSS中。

```less
// 注释一

/* 注释二 */
```

### 嵌套

嵌套的写法是Sass的一大特点，通过嵌套这些代码，可以得到类似HTML结构的CSS代码，使代码更具可读性。

```less
nav {
    background : #C39BD3;
    padding : 10px;
    height: 50px;
  
    ul {
        display: flex;
        list-style : none;
        justify-content: flex-end;

        li {
            color: white;
            margin-right: 10px;
        } 
    }
}
```

那为什么要使用嵌套呢？在CSS中，如果想为其父元素的继承元素定义样式，就必须每次都选择父元素：

```less
html, body {
    height: 100%;
}

html #root, body #root {
    height: 100%;
}

html .div-with-button, body .div-with-button {
    background-color: black;
}

html .div-with-button button, body .div-with-button button {
    background-color: #e4c681;
}

html .div-with-button button:hover, body .div-with-button button:hover {
    background-color: #ffe082;
}
```

在Sass中就可以这样写，这样写就会使代码更加清晰、条理和简洁：

```less
html, body {
  height: 100%;

  #root {
    height: 100%;
  }

  .div-with-button {
    background-color: black;

    button {
      background-color: #e4c681;

      &:hover {
        background-color: #ffe082;
      }
    }
  }
}
```

注意，在编写Sass时，要嵌套嵌套太深，尽量不要超过三层，超过之后就会导致代码难以维护，并且在编译为CSS时就会出现不必要的选择器，就会导致CSS文件变大。

我们还可以在嵌套中使用 `&`，比如鼠标在按钮上悬浮时，改变颜色。在CSS中是这样的：

```less
button {
  background-color: #535353;
  color: #000;
}
button:hover {
  background-color: #000;
  color: #fff;
}
```

在Sass中就可以这么写：

```less
button {
  background-color: #535353;
  color: #000;
  &:hover {
    background-color: #000;
    color: #fff;
  }
}
```

通常，& 总是指向它上面的元素，可以用于伪类和伪元素：

```less
.box {
  &:focus{} 
  &:hover{}
  &:active{}
  &:first-child{} 
  &:nth-child(2){}
  &::after{} 
  &::before{} 
}
```

编译后的CSS代码如下：

```less
.box:focus{} 
.box:hover{}
.box:active{}
.box:frist-child{}
.box:nth-child(2){}
.box::after{}
.box::before{}
```

此外，如果类以相同的词开头（比如`box-yellow`和`box-red`），就可以嵌套它们：

```less
.box {
  &-yellow {
    background: #ff6347;
  }
  &-red {
    background: #ffd700;
  }
  &-green {
    background: #9acd32;
  }
}
```

编译成CSS就是这样的：

```less
.box-yellow {
  background: #ff6347;
}
.box-red {
  background: #ffd700;
}
.box-green {
  background: #9acd32;
}
```

Sass还支持使用`:`来嵌套属性：

```less
add-icon {
  background : {
    image: url("./assets/arrow-right-solid.svg");
    position: center center;
    repeat: no-repeat;
    size: 14px 14px;
  }
}
```

上面的代码编译为如下CSS：

```less
.add-icon {
  background-image: url("./assets/arrow-right-solid.svg");
  background-position: center center;
  background-repeat: no-repeat;
  background-size: 14px 14px;
}
```

### 变量

变量是用来储存数据的，在Sass中，我们可以将任何有效的CSS值保存在变量中。变量使用`$`符号定义：

```less
$red: #ee4444;
$black: #222;
$bg-color: #3e5e9e;
$link-color: red;
$p-color: #282A36;

$font-p: 13px;
$font-h1: 28px;

$base-font: 'Noto Sans KR', sans-serif;
```

变量的使用：

```less
body {
    background-color : $bg-color;
    font-size : $font-p;
    font-family : $base-font;
}

h1 {
    font-size: $font-h1;
    color: $black;
}

p {
    font-size: $font-p;
    color: $black;
}

a {
    color: $link-color;
}
```

当Sass编译成CSS时，所有的变量都会被替换为定义的变量值。变量可以减少重复、进行复杂的数学运算等。

需要注意，CSS变量是有范围的，位于顶层的变量都是全局变量，在块中定义的变量都是局部变量。全局变量可以在任何地方使用，局部变量只能在变量定义的块中使用。

```less
$my-global-variable: "global";

div {
  $my-local-variables: "local";
}
```

变量值是可以覆盖的：

```less
$color: #fefefe;
.content {
  background-color: $color;
}

$color: #939393;
.footer {
  background-color: $color;
}
```

在上面的代码中，`content`的背景颜色是`#fefefe`，而`footer`的背景颜色是`#939393`。要想改变全局变量，就需要添加`!global`修饰符：

```less
$color: #111;
.content {
  $color: #222;
  background-color: $color;
}
.footer {
  $color: #333 !global;
}
```

除此之外，Sass变量是可以指定默认值的：

```less
$message-color: blue !default;

.message {
    color: $message-color;
}
```

编译成的CSS代码如下：

```less
p.message {
  color: blue;
}
```

我们可以在 @import 之前覆盖模块默认值：

```less
$message-color: black;
@import 'my-module';

.message {
    color: $message-color;
}
```

编译成的CSS代码如下：

```less
p.message {
  color: black;
}
```

也就是说，带有 `!default` 的变量只有在没有值的情况下才会生效。

### Mixins 和  Include

`mixin` 是一组可以重用的 CSS 声明，语法类似于JavaScript中的函数，使用 `@mixin` 指令来代替 `function` 关键字。调用 `mixin` 是通过 `@include` 语句完成的。

以下是用 `mixins` 使元素水平垂直居中的方法：

```less
@mixin absolute-center() {
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
}

.element {
  @include absolute-center();
}
```

当然，mixin也是支持传递参数的：

```less
@mixin square($size) {
  width:$size;
  height:$size;
}
div {
  @include square(60px);
  background-color:#000;
}
```

参数可以是可选的，可选参数的定义和Sass变量的定义形式是一样的：

```less
@mixin square($width: 50px) {
  width:$size;
  height:$size;
}
```

我们还可以将 CSS 规则传递给 mixins。这些规则可以在使用 @content 的 mixin 中使用。

```less
@mixin hover-not-disabled {
  &:not([disabled]):hover {
    @content;
  }
}
.button {
  border: 1px solid black;
  @include hover-not-disabled {
    border-color: blue;
  }
}
```

这样`mixin`中的`@content`在编译后就会变成`border-color: blue;`这样写有助于减少&`:not([disabled]):hover`部分的重复。

### @import 和 @use

在CSS中我们通常会创建多个CSS文件并在需要时引入：

```less
<link rel="stylesheet" href="/path/to/css/1"></link>
<link rel="stylesheet" href="/path/to/css/2"></link> 
<link rel="stylesheet" href="/path/to/css/3"></link> 
```

这样做会使浏览器发出多个HTTP请求，从而在一定程度上降低应用的速度。而Sass会在代码发动到浏览器之前进行代码组合，这样只需要请求一个CSS文件。

下面来看看如何使用 @import 将文件分块并导入到一个父文件中：

```less
body {
  padding:0;
  margin:0;
}

body, html {
  width:100%;
  min-height:100%;
}
@import 'normalize';

content {
  max-width:660px;
}
```

假设 `normalize.scss` 和 `styles.scss` 都在同一个文件夹中，可以将一个导入另一个，如上所示。在使用`@import`时，所有变量、mixin 等都可以全局访问，因为一切都是全局的，所以库必须为其所有成员添加前缀以避免命名冲突。因此不建议使用 @import。

可以使用 @use 来代替，它的基本用法与@import 相同：

```less
@use 'normalize';

content {
  max-width:660px;
}
```

使用 `@use` 导入的文件称为模块。要使用这些模块的 mixin 或变量，必须使用命名空间来调用它们。默认情况下，命名空间是文件名（不带扩展名）。

```less
$accent-color: #535353;
@mixin dark-background {
  background-color:#000;
  color:#fff;
}
@use 'src/colors';
body {
  color: colors.$accent-color;
}
.dark-region {
  @include colors.dark-background;
}
```

还可以使用 as 来使用自定义命名空间：

```less
@use 'src/colors' as c;
body  {
  color: c.$accent-color;
}
```

当 `_` 被添加到 SCSS 文件的文件名前时，解析器知道它是一个部分文件并且它仅用于导入。导入时，`_` 部分是可选的。注意，这里使用 `src/colors` 来导入 `src/_colors.scss`。

### 算术运算符

在CSS中可以使用calc()进行数学计算，Sass 支持直接使用+、-、/、*、% 操作符对值和变量进行计算：

```less
$content-width: 600px;
content {
  width:$content-width;
}
.inner-content {
  width: $content-width - 60px; 
}
.outer-content {
  width: $content-width + 60px;
}
```

### 流程控制

在 Sass 中有四种类型的流程控制规则：`@if` /`@else`、`@each`、`@for` 和`@while`。其中 @if 和 @else 类似于 JavaScript 中的 if 和 else。

```less
@mixin theme($is-dark: false) {
  @if $is-dark {

  }
  @else {
    
  }
}
```

`@each` 类似于 JavaScript 中的 `for of`：

```less
$sizes: 40px, 50px, 80px;
@each $size in $sizes {
  .icon-#{$size} {
    font-size: $size;
    height: $size;
    width: $size;
  }
}
```

注意：#{$size} 表示法用于使用变量制作动态属性名称和选择器，这称为插值。

`@for` 类似于 JavaScript 中的 `for` 循环：

```less
@for $i from 1 through 4 {
  .bubble-#{$i} {
    transition-delay: .3 * $i;
  }
}
```

@while（不常用）类似于 JavaScript 中的 while 循环。

### 扩展/继承

有时需要编写一个仅用于扩展的样式规则。在这种情况下，可以使用占位符选择器，它看起来像以 `%` 而不是 `.` 开头的类选择器。

```less
%flex {
  display: flex;
}

.some-class {
  height: 50%;
  background-color: black;
}

%flex_with_color {
  @extend %flex;
  @extend .some-class;
}

%button_styles {
  height: 50px;
  width: 200px;
}

div {
  @extend %flex_with_color;

  button {
    @extend %button_styles;
    color: #424242;
    background-color: #d966fb;
  }
}
```

上面的代码编译成CSS之后将是这样的：

```less
div {
  display: flex;
}

.some-class, div {
  height: 50%;
  background-color: black;
}

div button {
  height: 50px;
  width: 200px;
}

div button {
  color: #424242;
  background-color: #d966fb;
}
```

### 媒体查询

在Sass中可以这样来使用媒体查询：

```less
body {
    article {
        p {
            font-size: 100%;
            color: black;
            padding: 10px;

            @media (max-width: 768px) {
                font-size: 150%;
            }
        }
    }
}
```

编译成的CSS代码如下：

```less
body article p {
  font-size: 100%;
  color: black;
  padding: 10px;
}

@media (max-width: 768px) {
  body article p {
    font-size: 150%;
  }
}
```

媒体查询是支持嵌套的，并将所有适用的查询与 and 运算符结合起来：

```less
p {
    @media (max-width: 768px) {
        font-size: 150%; 
        @media (orientation: landscape) {
            line-height: 75%; 
        }
    }
}
```

编译成的CSS代码如下：

```less
@media (max-width: 768px) {
  p {
    font-size: 150%;
  }
}

@media (max-width: 768px) and (orientation: landscape) {
  p {
    line-height: 75%;
  }
}
```

# 优化指南

## 避免高消耗属性

分析表明，一些CSS属性的渲染速度比其他属性慢，因此应该谨慎使用。包括以下属性：

- box-shadow
- border-radius
- position: fixed
- transform
- :nth-child
- filter

上述属性都是对性能要求比较高的。如果这些属性使用较少，那这就不是问题。但是如果一个页面出现几百次，那么整体的CSS可能会受到影响，所以要谨慎使用。

## 使用 link 代替 @import

@import 规则主要用于导入资源或者CSS文件。它会阻止其他文件并行下载，并可能会导致网站速度变慢。

❌ 不要在CSS中这样操作：

```js
@import url("header.css");
@import url("slider.css");
@import url("content.css");
@import url("footer.css");
```

可以使用多个HTML 中的`<link>`标签来代替@import，它将并行加载CSS文件，可以在一定程度上提高应用加载速度

✅ 可以在HTML这样操作：

```js
<link rel="stylesheet" href="header.css">
<link rel="stylesheet" href="slider.css">
<link rel="stylesheet" href="content.css">
<link rel="stylesheet" href="footer.css">
```

## 简化选择器

> 我们知道，有很多方法可以对 HTML 元素进行样式设置，而最复杂的 CSS 选择器可能需要几毫秒的时间来解析。降低选择器的复杂性就可以减少浏览器的负载并保持代码简洁明了。

❌ 避免这么写：

```css
.container > div.links-container ul li .link {

}
```

✅ 可以这么写：

```css
.container .link {

}
```

## 避免使用 !Important

> 在一些时候，可以使用!Important 来提高样式的优先级，以使样式生效。除非没有别的办法，否则不要使用!Important。

> 添加 !Important CSS声明将覆盖掉其他对应的样式声明，如果CSS的规则中 !Important 太多，浏览器就必须对代码进行额外的检查，这可能会降低页面的加载速度。所以，尽量避免使用!Important。在很多情况下我们是可以通过选择器来实现样式重写的，除非是想要对第三方库的CSS进行重写。

## CSS实现特效和SVG代替图片

> 页面中加载图像很可能需要很长的时间，尤其是在图像未针对web进行优化的情况下。在实现背景图、渐变、几何图形时，尽量少使用图片，而是使用CSS代码实现。使用 CSS 代码实现就会比图片加载速度更快。

还可以使用SVG来代替PNG或者JPG图片：

> - 可以给图片添加效果；
> - 图像加载速度更快；
> - 图像自动适应用户屏幕。

## 压缩 CSS

> 我们可以通过压缩CSS文件来删除文件中所有的空白和不必要的代码来减少文件的大小。CSS文件变小了，加载的时间自然就变少了，页面的加载速度就会变。

## 使用0而不是0px

> 当一个属性的值为0时，我们可以不添加任何单位。即不要这么写：0rem，0em，0px等。当然，这么写是没有错的，但是这些单位是没有用的，当处理一个巨大的CSS文件时，没有单位会比有单位时文件小一点。

## 使用十六进制而不是颜色名称

> 当我们将颜色设置为颜色名称时，浏览器就会花费更多时间来找出颜色的十六进制值。假如想使用红色，那设置为color:red之后，不同的浏览器显示效果可能是不一样的，作为开发人员，我们不能让浏览器来决定网页将如何显示。

> 因此，尽量使用使用十六进制（例如红色#ff0000）来定义颜色，就能确保在所有浏览器中以相同的色调准确得显示想要的颜色。

## 避免过多 font-family

为每个选择器去定义字体并不是一个好的办法，它会导致代码很难维护，假如以后想要更改字体，就不得不在每个选择器中更改它。

因此不要像下面这样来定义字体：

```css
h1 {
  font-family: Arial, Helvetica, sans-serif;
}

p {
  font-family: Arial, Helvetica, sans-serif;
}

.selection {
  font-family: Arial, Helvetica, sans-serif;
}

.footer {
  font-family: "Times New Roman", Times, serif;
}
```

可以在正文中定义要使用的字体，如果想要在其他选择器中覆盖该字体，就可以通过在该选择器中使用所需的字体来实现：

```css
body{
  font-family: Arial, Helvetica, sans-serif;
}

footer{
  font-family: "Times New Roman", Times, serif";
}
```

如果页面中很多部分的字体都不尽相同，就可以将字体定义在 class 中，然后在需要的HTML标签上使用该class即可：

```css
.font-helvetica {
  font-family: Arial, Helvetica, sans-serif;
}

.font-times {
  font-family: "Times New Roman", Times, serif";
}
```

## 使用备用字体

有些情况下，应用中使用的字体可能在用户设备上不可用。在这种情况下，可以指定使用其他备用字体：

```css
p{
  font-family: 'Open Sans', Arial, Helvetica, sans-serif;
}
```

这样，浏览器就会按顺序进行解析，直到解析到第一个可用的字体，如果都不可用，就会使用浏览器的默认字体。

## 使用 CSS 重置

每个浏览器都有自己的 HTML 元素默认样式。假如有一个没有任何样式的 H1 元素，那么在默认情况下，在Firefox中，会给它一个上下为21.433px，左右为 0 的margin值。而在Safari中，会给它一个上下为21px，左右为 0 的margin值。

因此，重置CSS样式，一个很好的做法就是从头开始定义样式。很多开发人员会使用通用选择器（*）来执行基本重置：

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
```

在使用通用选择器 (*) 进行重置有时会导致性能问题，因为它会针对每个标签去设置其样式。

可以使用一些常用的CSS重置代码库，比如normalize。也可以参考一些CSS重置的最佳实践。

## 减少重复代码

当两个元素或选择器具有相同的 CSS 属性时，可以使用逗号来组合这些选择器，而不是重复声明样式，这样它们将共享 CSS 样式。

❌ 避免这样写：

```css
.header {
  background-color: #fefefe;
  padding: 20px 0;
}

.footer {
  background-color: #fefefe;
  padding: 20px 0;
}
```

✅ 建议这样写：

```css
.header,
.footer {
  background-color: #fefefe;
  padding: 20px 0;
}
```







































































