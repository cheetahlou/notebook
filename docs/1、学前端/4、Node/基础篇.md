

2023.3.20完成

# 初识Node.js

## 整体流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161650442.png" alt="image-20230316165008340" style="zoom:67%;" />

## 前端核心技术体系

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161604715.png" alt="image-20230316160422590" style="zoom:80%;" />

## 前端三大框架

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161653175.png" alt="image-20230316165348069" style="zoom:67%;" />

## Node.js 是什么

Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位：

①基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用

②基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用

③基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目

④读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161659914.png" alt="image-20230316165940791" style="zoom:80%;" />

## Node.js 可以做什么

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161705888.png" alt="image-20230316170543759" style="zoom:80%;" />

### 开发服务器应用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161704396.png" alt="image-20230316170418280" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161705670.png" alt="image-20230316170522541" style="zoom: 80%;" />

### 开发工具类应用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161706337.png" alt="image-20230316170632202" style="zoom:67%;" />

### 开发桌面端应用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161708385.png" alt="image-20230316170812286" style="zoom:67%;" />

## Node安装⭐

如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。

> 安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页（**https://nodejs.org/en/**），点击绿色的按钮，下载所需的版本后，双击直接安装即可。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210042246401.png" alt="image-20221004224608337" style="zoom:80%;" />

### LTS版本和Current版本

> ①LTS 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js。
>
> ②Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的 Bug 或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js。

### 查看Node.js 的版本

> 打开终端，在终端输入命令 node –v 后，按下回车键，即可查看已安装的 Node.js 的版本号

```apl
node -v
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210042247299.png" alt="image-20221004224758262" style="zoom:80%;" />

### nvm安装Node⭐

#### 概述和安装

> nvm 全称 Node Version Manager 顾名思义它是用来管理 node 版本的工具，方便切换不同版本的Node.js

> nvm 的使用非常的简单，跟 npm 的使用方法类似，首先先下载 nvm，下载地址 https://github.com/coreybutler/nvm-windows/releases ，选择 nvm-setup.exe 下载即可（网络异常的小朋友可以在资料文件夹中获取）

#### 常用命令

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182119100.png" alt="image-20230318211956985" style="zoom:80%;" />



## Node注意点

> **Node.js 中不能使用BOM和DOM的API**

### 浏览器中的JS

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161731836.png" alt="image-20230316173141738" style="zoom:80%;" />

### Node 中的JS

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161737698.png" alt="image-20230316173752604" style="zoom: 80%;" />

## Node环境搭建

在当前文件夹的terminal输入

```sh
npm init -y
```

这样就能在当前文件夹生成package.json文件，可以方便下载和安装依赖

进入package.json，新增字段，就能实现ES6语法使用了

```json
"type": "module"
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202209270929118.png" alt="image-20220927092927045" style="zoom:80%;" />

# 计算机基础⭐

## CMD命令⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161727342.png" alt="image-20230316172714260" style="zoom:80%;" />

```sh
# 切换到D盘
d:
# 列出当前目录
dir
cd clash
# 切换上一级目录
cd ..
# 查看当前目录及所有子目录的内容
dir /s
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210062027242.png" alt="image-20221006202749165" style="zoom:80%;" />

## 计算机基本组成

### CPU & 内存 & 硬盘

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162105993.png" alt="image-20230316210510856" style="zoom:67%;" />

### 内存 & 硬盘

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162106618.png" alt="image-20230316210627475" style="zoom:67%;" />

### 主板

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162107042.png" alt="image-20230316210719870" style="zoom:67%;" />

### 机箱

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162108488.png" alt="image-20230316210834253" style="zoom:67%;" />

### 外设

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162109896.png" alt="image-20230316210926587" style="zoom:80%;" />

## 程序运行流程

> **程序一般保存在硬盘中，软件安装的过程就是将程序写入硬盘的过程**
>
> **程序在运行时会加入内存，然后由CPU读取并执行程序**

### 操作系统

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162111517.png" alt="image-20230316211105374" style="zoom:80%;" />

### 操作系统运行流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162112549.png" alt="image-20230316211215362" style="zoom:80%;" />

### 应用程序运行流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162113177.png" alt="image-20230316211342997" style="zoom:80%;" />

## 进程与线程

### 进程

> 运行中的程序

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162119054.png" alt="image-20230316211901947" style="zoom:80%;" />

### 线程

> 线程是一个进程中执行的一个工作流，一个线程是属于某个进程的

## HTTP协议

> HTTP（hypertext transport protocol）协议；中文叫超文本传输协议，是一种基于TCP/IP的应用层通信协议
>
> 这个协议详细**规定了浏览器和万维网服务器之间互相通信的规则。协议中主要规定了两个方面的内容**
>
> 客户端：**用来向服务器发送数据，可以被称之为请求报文**
>
> 服务端：**向客户端返回数据，可以被称之为响应报文**
>
> 报文：**可以简单理解为就是一堆字符串**

### 请求报文

> 组成：请求行、请求头、空行、请求体

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171438421.png" alt="image-20230317143816276" style="zoom:80%;" />

#### 请求行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171439988.png" alt="image-20230317143911917" style="zoom:80%;" />

##### 请求方法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171439903.png" alt="image-20230317143952813" style="zoom:80%;" />

##### URL统一资源定位符

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171441878.png" alt="image-20230317144157784" style="zoom:80%;" />

##### HTTP版本号

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171442650.png" alt="image-20230317144252572" style="zoom:80%;" />

#### 请求头

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171444968.png" alt="image-20230317144420874" style="zoom:80%;" />

#### 请求体


### 响应报文

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171448506.png" alt="image-20230317144818364" style="zoom:80%;" />

#### 响应行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171449073.png" alt="image-20230317144902993" style="zoom:80%;" />

#### 响应状态码

> 状态码网站：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171450765.png" alt="image-20230317145004678" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171451868.png" alt="image-20230317145100782" style="zoom:80%;" />

#### 响应状态描述

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171452505.png" alt="image-20230317145240384" style="zoom:80%;" />

#### 响应头

> Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据
>
> Connection 链接设置
>
> Content-Type:text/html;charset=utf-8 设置响应体的数据类型以及字符集,响应体为html，字符集utf-8
>
> Content-Length:响应体的长度，单位为字节

#### 响应体

> 响应体内容的类型是非常灵活的，常见的类型有 HTML、CSS、JS、图片、JSON

## 网络基础

### IP地址

> **IP** **地址**就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。

> IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）
>

> **互联网中每台** **Web** **服务器，都有自己的** **IP** **地址**，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210062122893.png" alt="image-20221006212216809" style="zoom:80%;" />

> 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172105294.png" alt="image-20230317210509128" style="zoom:80%;" />

### IP分类

#### 共享IP

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172106259.png" alt="image-20230317210643102" style="zoom:80%;" />

#### 局域网

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172107181.png" alt="image-20230317210748013" style="zoom:80%;" />

#### 公网

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172109391.png" alt="image-20230317210902287" style="zoom:80%;" />

#### 本地回环地址

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172109865.png" alt="image-20230317210958771" style="zoom:80%;" />

### 端口

> **应用程序的数字标识，一台现代计算机有65536个端口(0-65535)，一个应用程序可以使用一个或多个端口，实现不同主机应用程序之间通信**

> 计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。每个端口号不能同时被多个 web 服务占用。在实际应用中，URL 中的 80 端口可以被省略
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172111236.png" alt="image-20230317211103100" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172115984.png" alt="image-20230317211532825" style="zoom:80%;" />

### 域名

> 尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的**域名（Domain Name）地址**。
>

> IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做**域名服务器**(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，**域名服务器就是提供** **IP** **地址和域名之间的转换服务的服务器**。
>

> ①单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。
>
> ②开发期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别

## 浏览器查看HTTP报文

F12,点击网络

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181506312.png" alt="image-20230318150614214" style="zoom:80%;" />

### 查看请求行与请求头

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181506216.png" alt="image-20230318150655123" style="zoom:80%;" />

### 查看请求体

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181507608.png" alt="image-20230318150722517" style="zoom:80%;" />

### 查看 URL 查询字符串

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181507205.png" alt="image-20230318150744110" style="zoom:80%;" />

### 查看响应行与响应头

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181508364.png" alt="image-20230318150821278" style="zoom:80%;" />

### 查看响应体

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181508503.png" alt="image-20230318150839413" style="zoom:80%;" />

## 网页资源加载基本过程

> 网页资源的加载都是循序渐进的，首先获取 HTML 的内容， 然后解析 HTML 在发送其他资源的请求，如
> CSS，Javascript，图片等。理解了这个内容对于后续的学习与成长有非常大的帮助

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181558545.png" alt="image-20230318155849348" style="zoom:80%;" />

## 静态资源和动态资源

> 静态资源是指内容长时间不发生改变的资源，例如图片，视频，CSS 文件，JS文件，HTML文件，字体文件等
>
> 动态资源是指内容经常更新的资源，例如百度首页，网易首页，京东搜索列表页面等

### 网站根目录或静态资源目录

HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是静态资源目录，也称之为网站根目录

思考：vscode 中使用 live-server 访问 HTML 时， 它启动的服务中网站根目录是谁？

### 网页中的 URL

网页中的 URL 主要分为两大类：相对路径与绝对路径

#### 绝对路径

绝对路径可靠性强，而且相对容易理解，在项目中运用较多

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181632074.png" alt="image-20230318163239974" style="zoom: 80%;" />

```html
<!-- 绝对路径 -->
<a href="https://www.baidu.com">百度</a>
<a href="//jd.com">京东</a>
<a href="/search">搜索</a>
<hr>
```

#### 相对路径

相对路径在发送请求时，需要与当前页面 URL 路径进行计算，得到完整 URL 后，再发送请求，学习阶段用的较多

例如当前网页 url 为 http://www.atguigu.com/course/h5.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181633008.png" alt="image-20230318163317902" style="zoom:80%;" />

```html
<!-- 相对路径 -->
<a href="./css/app.css">访问CSS</a>
<a href="js/app.js">访问JS</a>
<a href="../img/logo.png">访问图片</a>
<a href="../../img/logo.png">访问图片</a>
```

#### 网页中使用 URL 的场景

> a 标签 href、link 标签 href、script 标签 src、img 标签 src
>
> video audio 标签 src、form 中的 action、AJAX 请求中的 URL

### 设置资源类型（mime类型）

> 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。

```
mime 类型结构： [type]/[subType]
例如： text/html text/css image/jpeg image/png application/json
```

HTTP 服务可以设置响应头 Content-Type 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理资源

下面是常见文件对应的 mime 类型

```js
html: 'text/html',
css: 'text/css',
js: 'text/javascript',
png: 'image/png',
jpg: 'image/jpeg',
gif: 'image/gif',
mp4: 'video/mp4',
mp3: 'audio/mpeg',
json: 'application/json'
```

> 对于未知的资源类型，可以选择 application/octet-stream 类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的下载效果

## GET和POST请求

GET 和 POST 是 HTTP 协议请求的两种方式。

> GET 主要用来**获取数据**，POST 主要用来**提交数据**
>
> GET 带参数请求是**将参数缀到 URL 之后**，在地址栏中输**入 url 访问网站就是 GET 请求**，
>
> POST 带参数请求是**将参数放到请求体中**
>
> POST 请求相对 GET 安全一些，因为在浏览器中参数会暴露在地址栏
>
> GET 请求大小有限制，一般为 2K，而 POST 请求则没有大小限制

# 模块化

```sh
npm init -y
```

## 什么是模块化

> 将一个复杂的程序文件依据一定规则（规范）拆分成多个文件的过程称之为模块化
>
> 其中拆分出的每个文件就是一个模块，模块的内部数据是私有的，不过模块可以暴露内部数据以便其他模块使用

> 好处：防止命名冲突、高复用性、高维护性、按需加载

## 模块化初体验

> 模块暴露数据的方式有两种：module.exports = value、exports.name = value

> module.exports 可以暴露任意数据，不能使用 exports = value 的形式暴露数据，模块内部 module 与 exports 的隐式关系，exports = module.exports = {} ，require 返回的是目标模块中 module.exports 的值

### me.js

```js
//声明一个函数
function tiemo(){
  console.log('贴膜...');
}
function niejiao(){
  console.log('捏脚...');
}
let name = '张三'

//暴露数据
module.exports = {
  tiemo,
  niejiao,
  name
};
```

### index.js

```js
//导入模块
const me = require('./me.js');

//调用函数
me.tiemo()
me.niejiao()
console.log(me.name)
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181712546.png" alt="image-20230318171216458" style="zoom:80%;" />

## 导入（引入）模块

### 基本语法

在模块中使用 require 传入文件路径即可引入文件

```js
const test = require('./me.js');
```

### 基本流程

> 1. 将相对路径转为绝对路径，定位目标文件
>
> 2. 缓存检测
> 3. 读取目标文件代码
> 4. 包裹为一个函数并执行（自执行函数）。通过 arguments.callee.toString() 查看自执行函数
> 5. 缓存模块的值
> 6. 返回 module.exports 的值

### 注意事项

> **对于自己创建的模块，导入时路径建议写相对路径，且不能省略./ 和../**
>
> js 和 json 文件导入时可以不用写后缀，c/c++编写的node 扩展文件也可以不写后缀，但是一般用不到
>
> 如果导入其他类型的文件，会以 js 文件进行处理

> 如果导入的路径是个文件夹，则会首先检测该文件夹下 package.json 文件中 main 属性对应的文件，如果存在则导入，反之如果文件不存在会报错。
>
> 如果 main 属性不存在，或者 package.json 不存在，则会尝试导入文件夹下的 index.js 和index.json ，如果没找到，就会报错

> **导入 node.js 内置模块时，直接 require 模块的名字即可，无需加./ 和../**

## 模块作用域⭐

### 什么是模块作用域

> 和函数作用域类似，在自定义模块中定义的变量、方法等成员，**只能在当前模块内被访问**，这种模块级别的访问限制，叫做**模块作用域**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061048893.png" alt="image-20221006104819834" style="zoom:80%;" />

### 模块作用域的好处

> 防止了全局变量污染的问题

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061049672.png" alt="image-20221006104907612" style="zoom:80%;" />

### 向外共享模块作用域中的成员⭐⭐

#### module 对象

> 在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061050974.png" alt="image-20221006105018914" style="zoom:80%;" />

#### module.exports 对象

> 在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。
>
> 外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。

创建自定义模块.js，写入如下内容

```js
// 在一个自定义模块中，默认情况下， module.exports = {}
const age = 20
module.exports.age = age
// 向 module.exports 对象上挂载 username 属性
module.exports.username = 'zs'
```

```js
// 向 module.exports 对象上挂载 sayHello 方法
module.exports.sayHello = function() {
   return "sayHello"
}
```

该模块域上面冲突，只能要么写上面的形式，要么写下面的形式。下面的优先级更高

```js
// 让 module.exports 指向一个全新的对象
module.exports = {
  nickname: '小黑',
  sayHi() {
    console.log('Hi!')
  }
}
```

导入模块进行使用

```js
// 在外界使用 require 导入一个自定义模块的时候，得到的成员，
// 就是 那个模块中，通过 module.exports 指向的那个对象
const m = require('./11.自定义模块')
console.log(m)
console.log(m.sayHello())
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210062301709.png" alt="image-20221006230147648" style="zoom:80%;" />

#### 共享成员时的注意点

> 使用 require() 方法导入模块时，导入的结果，**永远以** **module.exports** **指向的对象为准**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061051819.png" alt="image-20221006105131751" style="zoom:80%;" />

#### exports 对象⭐

> 由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061052245.png" alt="image-20221006105221180" style="zoom:80%;" />

#### exports **和** module.exports误区

> 时刻谨记，require() 模块时，得到的永远是 module.exports 指向的对象：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061154594.png" alt="image-20221006115430509" style="zoom:80%;" />

> **注意：**为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports

## 模块的加载机制

### 优先从缓存中加载

> **模块在第一次加载后会被缓存**。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。

注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。

### 内置模块的加载机制

> 内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。
>
> 例如，require('fs') 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。

### 自定义模块的加载机制

> 使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。

同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：

> ①按照确切的文件名进行加载
>
> ②补全 .js 扩展名进行加载
>
> ③补全 .json 扩展名进行加载
>
> ④补全 .node 扩展名进行加载
>
> ⑤加载失败，终端报错

### 第三方模块的加载机制

如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。

如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。

例如，假设在 'C:\Users\itheima\project\foo.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找：

> ① C:\Users\itheima\project\node_modules\tools
>
> ② C:\Users\itheima\node_modules\tools
>
> ③ C:\Users\node_modules\tools
>
> ④ C:\node_modules\tools

### 目录作为模块

当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：

> ①在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口
>
> ②如果目录里没有package.json文件，或者main入口不存在或无法解析，则Node.js将会加载目录下的 index.js
>
> ③如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'xxx'

## 默认导出和默认导入

ES6 模块化语法： 模块功能主要由两个命令构成：export 和 import；

> - export 命令用于规定模块的**对外接口**（导出模块）；
> - import 命令用于输入其他模块提供的功能（导入模块）；
> - **每个模块中，只允许使用唯一的一次 export default，否则会报错！**
> - **默认导入时的接收名称可以任意名称，只要是合法的成员名称即可**

### 创建t1.js文件

```js
let n1 = 10
let n2 = 20
function show() {
   console.log('hello')
}

//默认导出
export default {
  n1,
  show
}
```

### 导入使用

导入模块：注意，同级目录引入也要加上 ./

```js
// 注意，后缀必须写上，不然会报错，写成t1.js
import m1 from './t1.js'

console.log(m1)
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202209270930481.png" alt="image-20220927093049444" style="zoom:80%;" />

## 按需导出和按需导入

> ① 每个模块中可以使用多次按需导出
>
> ② 按需导入的成员名称必须和按需导出的名称保持一致
>
> ③ 按需导入时，可以使用 as 关键字进行重命名
>
> ④ 按需导入可以和默认导入一起使用

### 按需导出

分别暴露(按需导出)，可以有多个

```js
export let school = "尚硅谷";
export function teach(){
    console.log("我们可以教你开发技术！");
}
```

统一暴露

```js
let school = "尚硅谷";
function findJob(){
    console.log("我们可以帮你找到好工作！");
}
export {school,findJob}
```

默认暴露

```js
export default{
    school : "尚硅谷",
    change : function(){
        console.log("我们可以帮你改变人生！");
    }
}
```

### 按需导入

```js
// info是默认导入，不用写在花括号内，而其他的按需导入要写在花括号内部
import info, { s1, s2 as str2, say } from './03.按需导出.js'

console.log(s1)
console.log(str2)
console.log(say)
console.log(info)
```

## 直接导入并执行

在js页面里直接写个for循环

```js
for (let i = 0; i < 3; i++) {
  console.log(i)
}
```

在test.js直接导入，点击运行即可成功运行

```js
import './05.直接运行模块中的代码.js'
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202209270938188.png" alt="image-20220927093830155" style="zoom:80%;" />





# 内置模块⭐

## Buffer 缓冲区

### 概念

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161742854.png" alt="image-20230316174231736" style="zoom:67%;" />

### 特点

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162101321.png" alt="image-20230316210104224" style="zoom:80%;" />

### 创建Buffer

```js
//1. alloc,创建了一个长度为 10 字节的 Buffer，相当于申请了 10 字节的内存空间，每个字节的值为 0
let buf = Buffer.alloc(10);
console.log(buf); // 结果为 <Buffer 00 00 00 00 00 00 00 00 00 00>

//2. allocUnsafe，创建了长度为 10 字节的 Buffer，buffer可能存在旧数据, 可能会影响结果，所以叫unsafe
let buf_2 = Buffer.allocUnsafe(10000);
console.log(buf_2);

//3. from，通过字符串创建 Buffer
let buf_3 = Buffer.from('hello');
console.log(buf_3);
//4. from，通过数组创建 Buffer
let buf_4 = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]);
console.log(buf_4);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161747977.png" alt="image-20230316174732892" style="zoom:80%;" />

### Buffer与字符串转化

> 我们可以借助 toString 方法将 Buffer 转为字符串，toString 默认是按照 utf-8 编码方式进行转换的。

```js
let buf_4 = Buffer.from([105, 108, 111, 118, 101, 121, 111, 117]);

console.log(buf_4.toString()) // iloveyou
```

### 读写 Buffer

Buffer 可以直接通过[] 的方式对数据进行处理。

```js
//创建
let buf_3 = Buffer.from('hello');
console.log(buf_3);
console.log(buf_3[0].toString(2)); // 01101000
//读取
console.log(buf_3[1]);
//修改
buf_3[1] = 97;
//查看字符串结果
console.log(buf_3.toString());
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303161754547.png" alt="image-20230316175435477" style="zoom:80%;" />

```js
//溢出
let buf = Buffer.from('hello');
buf[0] = 361;// 舍弃高位的数字  0001 0110 1001  => 0110 1001
console.log(buf);

//中文
let buf = Buffer.from('你好');
console.log(buf);
```

## fs 文件模块

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162120918.png" style="zoom:67%;" />

### 写入文件

文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162122195.png" alt="image-20230316212208105" style="zoom:67%;" />

> 文件写入在计算机中是一个非常常见的操作，下面的场景都用到了文件写入。**下载文件、安装软件、保存程序日志，如 Git、编辑器保存文件、视频录制，当需要持久化保存数据的时候，应该想到文件写入**

#### 异步写入⭐

```js
// 1. 导入 fs 模块，require 是 Node.js 环境中的'全局'变量，用来导入模块
const fs = require('fs');

// 2. 写入文件，参数：file 文件名，data 待写入的数据，options 选项设置（可选），callback 写入回调
// 将『三人行，必有我师焉。』写入到当前文件夹下的『座右铭.txt』文件中
fs.writeFile('./座右铭.txt', '三人行, 则必有我师焉', err => {
   //如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null
   if(err){
      console.log('写入失败');
      return;
   }
   console.log('写入成功');
});
```

#### 同步写入

```js
// 导入 fs 模块，require 是 Node.js 环境中的'全局'变量，用来导入模块
const fs = require('fs');
// 同步写入，参数分别是文件名和数据
// 参数与 fs.writeFile 大体一致，只是没有 callback 参数
fs.writeFileSync('./data.txt', 'test data');
```

Node.js 中的磁盘操作是由其他线程完成的，结果的处理有两种模式：

> 同步处理：JavaScript 主线程**会等待其他线程的执行结果，然后再继续执行主线程的代码，效率较低**
>
> 异步处理：JavaScript 主线程**不会等待其他线程的执行结果**，**直接执行后续的主线程代码，效率较好**

#### 追加写入

> appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同

```js
// 1. 导入 fs 文件系统模块，方式一
const fs = require('fs')
fs.appendFile('./files/13.txt', '1231ok123', function(err) {
  if (err) {
    return console.log('文件追加失败！' + err.message)
  }
  console.log('文件追加成功！')
})
```

```js
// 2. 方式二，同步追加写入
const fs = require('fs');
// \r\n表示换行
fs.appendFileSync('./座右铭.txt', '\r\n温故而知新, 可以为师矣')
```

```js
// 3. 方式三，writeFile 实现追加写入
fs.writeFile('./座右铭.txt', 'love love love',{flag: 'a'}, err => {
  if(err) {
    console.log('写入失败~');
    return ;
  }
  console.log('写入成功');
});
```

#### 流式写入

> 程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数
>
> 流式写入方式适用于大文件写入或者频繁写入的场景, writeFile 适合于写入频率较低的场景

```js
let ws = fs.createWriteStream('./观书有感.txt');
ws.write('半亩方塘一鉴开\r\n');
ws.write('天光云影共徘徊\r\n');
ws.write('问渠那得清如许\r\n');
ws.write('为有源头活水来\r\n');
ws.end();
```





### 读取文件

> 电脑开机、程序运行、编辑器打开文件、查看图片、播放视频
>
> 播放音乐、Git 查看日志、上传文件、查看聊天记录

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303162122982.png" alt="image-20230316212245898" style="zoom:80%;" />

#### 异步读取

```js
// 1. 导入 fs 模块，来操作文件
const fs = require('fs')

// 2. 调用 fs.readFile() 方法读取文件
//    参数1：读取文件的存放路径
//    参数2：读取文件时候采用的编码格式，一般默认指定 utf8
//    参数3：回调函数，拿到读取失败和成功的结果  err  dataStr
fs.readFile('./观书有感.txt', 'utf8', (err, dataStr) => {
  // 2.1 打印失败的结果
  // 如果读取成功，则 err 的值为 null
  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined
  console.log(err)
  console.log('-------')
  // 2.2 打印成功的结果
  console.log(dataStr)
})
```

#### 同步读取

```js
// 导入 fs 模块，来操作文件
const fs = require('fs')

// 同步读取
let data = fs.readFileSync('./观书有感.txt');

console.log(data.toString());
```

#### 流式读取

```js
//1. 引入 fs 模块
const fs = require('fs');

//2. 创建读取流对象，只需要修改文件名即可，可以设置成任意文件
const rs = fs.createReadStream('../资料/笑看风云.mp4');

//3. 读取完整文件，绑定 data 事件   chunk 块儿  大块儿
rs.on('data', chunk => {
  console.log(chunk.length); // 65536 字节 => 64KB
  // console.log(chunk.toString()); // 65536 字节 => 64KB
});

//4. end  可选事件
rs.on('end', () => {
   console.log('读取完成');
});
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303170845608.png" alt="image-20230317084544519" style="zoom:80%;" />

### 文件复制

#### 方式一：读取并写入文件

```js
const fs = require('fs');
const process = require('process');

// 读取文件
let data = fs.readFileSync('../资料/笑看风云.mp4');
// 写入文件
fs.writeFileSync('../资料/笑看风云-2.mp4', data);
console.log(process.memoryUsage()); // rss：完整内存占用  110710784 字节   105MB
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303170911017.png" alt="image-20230317091110942" style="zoom:80%;" />

#### 方式二：流式复制

> 流式复制比上面的直接读写更好一点

```js
const fs = require('fs');
const process = require('process');
// 创建读取流对象
const rs = fs.createReadStream('../资料/笑看风云.mp4');
//创建写入流对象
const ws = fs.createWriteStream('../资料/笑看风云-3.mp4');

//绑定 data 事件
rs.on('data', chunk => {
  ws.write(chunk);
});

rs.on('end', () => {
  console.log(process.memoryUsage());  // 43106304   =>  41M
})
```

#### 方式三：流式复制简易版

```js
const fs = require('fs');
const rs = fs.createReadStream('../资料/笑看风云.mp4');
// 创建写入流对象
const ws = fs.createWriteStream('../资料/笑看风云-4.mp4');
// 进行复制，上面方法的简便方法，用的不太多
rs.pipe(ws);
```

### 文件移动 | 重命名 | 删除

#### 移动 | 重命名

```js
// 导入 fs 模块
const fs = require('fs');

// 文件重命名：调用 rename 方法，参数：旧名字，新名字，回调函数
fs.rename('./座右铭.txt', './论语.txt', err => {
  if(err) {
    console.log('操作失败~');
    return;
  }
  console.log('操作成功');
});

// 文件移动：调用 rename 方法，参数：旧名字，新名字，回调函数，只需要修改路径即可
fs.rename('./data.txt', '../资料/data.txt', err => {
  if(err) {
    console.log('操作失败~');
    return;
  }
  console.log('操作成功');
})

// 删除或移动同步版
fs.renameSync('./座右铭.txt', './论语/我的座右铭.txt');
```

#### 批量重命名

```js
// 导入 fs 模块
const fs = require('fs');

// 读取 code 文件夹
const files = fs.readdirSync('./code');

// 遍历数组
files.forEach(item => {
  // 拆分文件名，num是前面的数字，name是文件名
  let data = item.split('-');
  let [num, name] = data;
  // 判断
  if(Number(num) < 10){
    num = '0' + num;
  }
  // 创建新的文件名
  let newName = num + '-' + name;
  // 重命名
  fs.renameSync(`./code/${item}`, `./code/${newName}`);
})
```

#### 删除文件

```js
//1. 导入 fs 模块
const fs = require('fs');

//2. 调用 unlink 方法 unlinkSync，在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件
fs.unlink('./观书有感.txt', err => {
  if(err) {
    console.log('删除失败~');
    return;
  }
  console.log('删除成功');
});

// 调用 rm 方法  rmSync
fs.rm('./论语.txt', err => {
  if (err) {
    console.log('删除失败~');
    return;
  }
  console.log('删除成功');
})
```

### 文件夹操作

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171040280.png" alt="image-20230317104026173" style="zoom:80%;" />

#### 创建文件夹

```js
//1. 导入 fs 模块
const fs = require('fs');

//2. 创建文件夹  mk  make 制作  dir directory 文件夹
fs.mkdir('./html', err => {
  if(err) {
    console.log('创建失败~');
    return;
  }
  console.log('创建成功');
});
```

```js
// 递归创建
fs.mkdir('./a/b/c', {recursive: true},err => {
  if(err) {
    console.log('创建失败~');
    return;
  }
  console.log('创建成功');
});
```

#### 读取文件夹

```js
// 读取文件夹   read 读取  dir  directory 文件夹
fs.readdir('../资料', (err, data) => {
  if(err){
    console.log('读取失败');
    return;
  }
  console.log(data);
});
```

#### 删除文件夹

```js
// 删除文件夹  rm  remove 移除
fs.rmdir('./html', err => {
  if(err){
    console.log('删除失败');
    return;
  }
  console.log('删除成功');
});
```

```js
// 递归删除：不推荐使用rmdir
fs.rmdir('./a', {recursive: true},err => {
  if(err){
    console.log(err);
    return;
  }
  console.log('删除成功');
});
```

```js
// 递归删除：建议使用rm
fs.rm('./a', {recursive: true},err => {
  if(err){
    console.log(err);
    return;
  }
  console.log('删除成功');
});
```

### 查看资源状态

在 Node.js 中，我们可以使用 stat 或 statSync 来查看资源的详细信息

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171049215.png" alt="image-20230317104922137" style="zoom:80%;" />

```js
// 1. 导入 fs 模块
const fs = require('fs');

// 2. stat 方法  status 缩写 状态
// 异步获取状态
fs.stat('../资料/笑看风云.mp4', (err, data) => {
  if(err){
    console.log('操作失败');
    return;
  }
  // 文件信息
  console.log(data);
  // isFile
  console.log(data.isFile());
  // isDirectory
  console.log(data.isDirectory());
});

// 同步获取状态
let data = fs.statSync('./data.txt');
```

### 路径

#### 相对路径和绝对路径

> 相对路径中所谓的当前目录，指的是命令行的工作目录，而并非是文件的所在目录
>
> 所以当命令行的工作目录与文件所在目录不一致时，会出现一些 BUG

```js
// 导入 fs 模块
const fs = require('fs');

// 相对路径
fs.writeFileSync('./index.html', 'love');
fs.writeFileSync('index.html', 'love');
fs.writeFileSync('../index.html', 'love');

// 绝对路径
fs.writeFileSync('D:/index.html', 'love');
fs.writeFileSync('/index.html', 'love');
```

#### 相对路径问题解决

> 使用 fs 模块的时候，尽量使用 __dirname 将路径转化为绝对路径，这样可以避免相对路径产生的Bug。在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。

```js
const fs = require('fs');

// 相对路径参照物: 命令行的工作目录
fs.writeFileSync('./index.html', 'love');

// __dirname 表示当前文件所处的目录
// 绝对路径 '全局变量' 保存的是: 所在文件的所在目录的绝对路径：G:\尚硅谷NodeJS\代码\02_fs文件系统\代码
console.log(__dirname);
fs.writeFileSync(__dirname + '/index.html', 'love');
```

### 成绩整理案例

#### 问题要求

使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。整理前，成绩.txt文件中的

数据格式如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210042301285.png" alt="image-20221004230130250" style="zoom:80%;" />

整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210042301467.png" alt="image-20221004230146433" style="zoom:80%;" />

#### 核心步骤实现

①导入需要的 fs 文件系统模块

②使用 fs.readFile() 方法，读取素材目录下的 成绩.txt 文件

③判断文件是否读取失败

④文件读取成功后，处理成绩数据

⑤将处理完成的成绩数据，调用 fs.writeFile() 方法，写入到新文件 成绩-ok.txt 中

```js
// 1. 导入 fs 模块
const fs = require('fs')

// 2. 调用 fs.readFile() 读取文件的内容
fs.readFile('../素材/成绩.txt', 'utf8', function(err, dataStr) {
  // 3. 判断是否读取成功
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  console.log('读取文件成功！' + dataStr)

  // 4.1 先把成绩的数据，按照空格进行分割
  const arrOld = dataStr.split(' ')
  console.log('按照空格进行分割! '+arrOld)
  // 4.2 循环分割后的数组，对每一项数据，进行字符串的替换操作
  const arrNew = []
  arrOld.forEach(item => {
    arrNew.push(item.replace('=', '：'))
  })
  console.log('新数组! '+arrNew)
  // 4.3 把新数组中的每一项，进行合并，得到一个新的字符串
  const newStr = arrNew.join('\r\n')
  console.log('最终数组：'+newStr)
    
  // 5. 调用 fs.writeFile() 方法，把处理完毕的成绩，写入到新文件中
  fs.writeFile('./files/成绩-ok1.txt', newStr, function(err) {
    if (err) {
      return console.log('写入文件失败！' + err.message)
    }
    console.log('成绩写入成功！')
  })
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210062043143.png" alt="image-20221006204359070" style="zoom:80%;" />



## path 路径模块

> path 模块提供了操作路径的功能，我们将介绍如下几个较为常用的几个 API：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171108513.png" alt="image-20230317110805419" style="zoom:80%;" />

```js
const path = require('path');
//获取路径分隔符
console.log(path.sep);
//拼接绝对路径：重点resolve，也可以用join
console.log(path.resolve(__dirname, 'test'));
// 注意：  ../ 会抵消前面的路径
console.log(path.join('/a', '/b/c', '../../', './d', 'e'))  // \a\d\e
console.log(path.join(__dirname, './files/1.txt'))
//解析路径
let pathname = 'D:/program file/nodejs/node.exe';
console.log(path.parse(pathname));
//获取路径基础名称
console.log(path.basename(pathname))
//获取路径的目录名
console.log(path.dirname(pathname));
//获取路径的扩展名
console.log(path.extname(pathname));
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303171111257.png" alt="image-20230317111117156" style="zoom:80%;" />

## http 模块⭐

回顾：什么是客户端、什么是服务器？

在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。

> http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。

> 服务器和普通电脑的**区别**在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。

### 基本语法

```js
//1. 导入 http 模块
const http = require('http');

//2. 创建服务对象
const server = http.createServer((request, response) => {
  // 设置响应头，可选
  response.setHeader('content-type', 'text/html;charset=utf-8');
  // 设置响应体
  response.end('<h1>hello，HTTP Server</h1>');
});

//3. 监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

访问：http://127.0.0.1:9000/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303172128414.png" alt="image-20230317212834332" style="zoom:80%;" />

### 注意事项

> 命令行 ctrl + c 停止服务，当服务启动后，更新代码必须重启服务才能生效

```js
// 响应内容中文乱码的解决办法
response.setHeader('content-type','text/html;charset=utf-8');
```

> 端口号被占用：关闭当前正在运行监听端口的服务 （ 使用较多）、修改其他端口号

> HTTP 协议默认端口是 80 ，HTTPS 协议默认端口 443, HTTP 服务开发常用端口有 3000，8080，8090，9000 等

> 如果端口被其他程序占用，可以使用资源监视器找到占用端口的程序，然后使用任务管理器关闭对应的程序

```sh
# 查询指定端口
netstat -ano |findstr "端口号"
netstat -ano |findstr 8080
# 根据PID杀死任务
taskkill /F /PID "进程PID号"
taskkill /F /PID 26924
```

### 获取 HTTP 请求报文

想要获取请求的数据，需要通过 request 对象

#### 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181511330.png" alt="image-20230318151157234" style="zoom:80%;" />

#### 获取请求行和请求头

```js
//1. 导入 http 模块
const http = require('http');

//2. 创建服务对象
const server = http.createServer((request, response) => {
  //获取请求的方法
  console.log(request.method);
  //获取请求的 url
  console.log(request.url);// 只包含 url 中的路径与查询字符串
  //获取 HTTP 协议的版本号
  console.log(request.httpVersion);
  //获取 HTTP 的请求头
  console.log(request.headers.host);
  response.end('hello,http'); //设置响应体
});

//3. 监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

访问：http://127.0.0.1:9000/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181515382.png" alt="image-20230318151501296" style="zoom:80%;" />

#### 获取请求体

```js
//1. 导入 http 模块
const http = require('http');

//2. 创建服务对象
const server = http.createServer((request, response) => {
  //1. 声明一个变量
  let body = '';
  //2. 绑定 data 事件
  request.on('data', chunk => {
    body += chunk;
  })
  //3. 绑定 end 事件
  request.on('end', () => {
    console.log(body);
    //响应
    response.end('Hello HTTP');
  });
});

//3. 监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

启动服务之后，发起POST请求，才能获得请求体内容，进入页面提交即可

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <form action="http://127.0.0.1:9000/index.html" method="post" >
    <input type="text" name="username">
    <input type="text" name="password">
    <input type="submit" value="提交">
  </form>
</body>
</html>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181522731.png" alt="image-20230318152242643" style="zoom:80%;" />

#### 获取请求路径与查询字符串

```js
//导入 http 模块
const http = require('http');
//1. 导入 url 模块
const url = require('url');

//创建服务对象
const server = http.createServer((request, response) => {
  //2. 解析 request.url
  console.log(request.url);
  let res = url.parse(request.url, true);
  //路径
  console.log(res.pathname)
  //查询字符串
  console.log(res.query.keyword)

  response.end('url');
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

http://127.0.0.1:9000/123/qw

http://127.0.0.1:9000/123/qw/123

```js
//导入 http 模块
const http = require('http');

//创建服务对象
const server = http.createServer((request, response) => {
  // 实例化 URL 的对象，新版方式提取请求路径
  // let url = new URL('/search?a=100&b=200', 'http://127.0.0.1:9000');
  let url = new URL(request.url, 'http://127.0.0.1');
  //输出路径
  console.log(url.pathname);
  //输出 keyword 查询字符串
  console.log(url.searchParams.get('keyword'));
  response.end('url new');
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

#### 实战演练

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181532544.png" alt="image-20230318153202452" style="zoom:80%;" />

```js
//1. 导入 http 模块
const http = require('http');

//2. 创建服务对象
const server = http.createServer((request, response) => {
  //获取请求的方法
  let {method} = request;
  //获取请求的 url 路径
  let {pathname} = new URL(request.url, 'http://127.0.0.1');
  response.setHeader('content-type','text/html;charset=utf-8');
  //判断
  if(method === 'GET' && pathname === '/login'){
    //登录的情形
    response.end('登录页面');
  }else if(method === 'GET' && pathname === '/reg'){ // register 注册
    response.end('注册页面');
  }else{
    response.end('Not Found');
  }
});

//3. 监听端口 启动服务
server.listen(9000, () => {
  console.log('服务已经启动.. 端口 9000 监听中....');
})
```

http://127.0.0.1:9000/

http://127.0.0.1:9000/login

http://127.0.0.1:9000/reg

#### 注意事项

> 1. request.url 只能获取路径以及查询字符串，无法获取 URL 中的域名以及协议的内容
> 2. request.headers 将请求信息转化成一个对象，并将属性名都转化成了『小写』
> 3. 关于路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为『/ 』
> 4. 关于 favicon.ico：这个请求是属于浏览器自动发送的请求

### 设置 HTTP 响应报文

#### 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181540925.png" alt="image-20230318154054822" style="zoom:80%;" />

```js
//导入 http 模块
const http = require('http');

//创建服务对象
const server = http.createServer((request, response) => {
  //1. 设置响应状态码，默认200
  response.statusCode = 203;
  // response.statusCode = 404;
  //2. 响应状态的描述，基本无需自己设置
  response.statusMessage = 'i love you';
  //3. 响应头
  response.setHeader('content-type', 'text/html;charset=utf-8');
  response.setHeader('Server', 'Node.js');
  response.setHeader('myHeader', 'test test test');
  response.setHeader('test', ['a','b','c']);
  //4. 响应体的设置
  response.write('love');
  response.write('love');
  response.write('love');
  // response.end('renshuo'); 
  // 设置响应体，如果有write，就不需要在end里设置内容了
  response.end(); 
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

http://127.0.0.1:9000/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181546196.png" alt="image-20230318154655078" style="zoom:80%;" />

#### 实战演练

搭建 HTTP 服务，响应一个 4 行 3 列的表格，并且要求表格有隔行换色效果，且点击单元格能高亮显示

##### **基础版**

```js
//导入 http 模块
const http = require('http');

//创建服务对象
const server = http.createServer((request, response) => {
  response.end(`
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
      <style>
        td{
          padding: 20px 40px;
        }
        table tr:nth-child(odd){
          background: #aef;
        }
        table tr:nth-child(even){
          background: #fcb;
        }
        table, td{
          border-collapse: collapse;
        }
      </style>
    </head>
    <body>
      <table border="1">
        <tr><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td></tr>
      </table>
      <script>
        //获取所有的 td
        let tds = document.querySelectorAll('td');
        //遍历
        tds.forEach(item => {
          item.onclick = function(){
            this.style.background = '#222';
          }
        })
      </script>
    </body>
    </html>
  `); //设置响应体
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181552280.png" alt="image-20230318155250193" style="zoom:80%;" />

##### **优化版**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    td {
      padding: 20px 40px;
    }
    table tr:nth-child(odd) {
      background: rgb(179, 165, 201);
    }
    table tr:nth-child(even) {
      background: #fcb;
    }
    table,
    td {
      border-collapse: collapse;
    }
  </style>
</head>

<body>
  <table border="1">
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <script>
    //获取所有的 td
    let tds = document.querySelectorAll('td');
    //遍历
    tds.forEach(item => {
      item.onclick = function () {
        this.style.background = '#222';
      }
    })
  </script>
</body>

</html>
```

```js
//导入 http 模块
const http = require('http');
const fs = require('fs');

//创建服务对象
const server = http.createServer((request, response) => {
  //读取文件内容
  let html = fs.readFileSync(__dirname + '/10_table.html');
  response.end(html); //设置响应体
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

##### 升级版

```js
//导入 http 模块
const http = require('http');
const fs = require('fs');

//创建服务对象
const server = http.createServer((request, response) => {
  //获取请求url的路径
  let {pathname} = new URL(request.url, 'http://127.0.0.1');
  if(pathname === '/'){
    //读取文件内容
    let html = fs.readFileSync(__dirname + '/10_table.html');
    response.end(html); //设置响应体
  }else if(pathname === '/index.css'){
    //读取文件内容
    let css = fs.readFileSync(__dirname + '/index.css');
    response.end(css); //设置响应体
  }else if(pathname === '/index.js'){
    //读取文件内容
    let js = fs.readFileSync(__dirname + '/index.js');
    response.end(js); //设置响应体
  }else{
    response.statusCode = 404;
    response.end('<h1>404 Not Found</h1>')
  }
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="./index.css">
</head>

<body>
  <table border="1">
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table>
  <script src="./index.js"></script>
</body>

</html>
```

```css
td {
  padding: 20px 40px;
}

table tr:nth-child(odd) {
  background: rgb(179, 165, 201);
}

table tr:nth-child(even) {
  background: #fcb;
}

table,
td {
  border-collapse: collapse;
}
```

```js
//获取所有的 td
let tds = document.querySelectorAll('td');
//遍历
tds.forEach(item => {
  item.onclick = function () {
    this.style.background = '#222';
  }
})
```

### 静态资源服务

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181615698.png" alt="image-20230318161541599" style="zoom:80%;" />

#### server.js

```js
/**
 * 创建一个 HTTP 服务，端口为 9000，满足如下需求
 * GET  /index.html        响应  page/index.html 的文件内容
 * GET  /css/app.css       响应  page/css/app.css 的文件内容
 * GET  /images/logo.png   响应  page/images/logo.png 的文件内容
 */
//导入 http 模块
const http = require('http');
const fs = require('fs');
const path = require('path');
//声明一个变量
let mimes = {
  html: 'text/html',
  css: 'text/css',
  js: 'text/javascript',
  png: 'image/png',
  jpg: 'image/jpeg',
  gif: 'image/gif',
  mp4: 'video/mp4',
  mp3: 'audio/mpeg',
  json: 'application/json'
}

//创建服务对象
const server = http.createServer((request, response) => {
  if(request.method !== 'GET'){
    response.statusCode = 405;
    response.end('<h1>405 Method Not Allowed</h1>');
    return;
  }
  //获取请求url的路径
  let {pathname} = new URL(request.url, 'http://127.0.0.1');
  //声明一个变量
  let root = __dirname + '/page';
  // let root = __dirname + '/../';
  //拼接文件路径
  let filePath = root + pathname;
  //读取文件 fs 异步 API
  fs.readFile(filePath, (err, data) => {
    if(err){
      console.log(err);
      //设置字符集
      response.setHeader('content-type','text/html;charset=utf-8');
      //判断错误的代号
      switch(err.code){
        case 'ENOENT':
          response.statusCode = 404;
          response.end('<h1>404 Not Found</h1>');
        case 'EPERM':
          response.statusCode = 403;
          response.end('<h1>403 Forbidden</h1>');
        default:
          response.statusCode = 500;
          response.end('<h1>Internal Server Error</h1>');
      }
      
      return;
    }
    //获取文件的后缀名
    let ext = path.extname(filePath).slice(1);
    //获取对应的类型
    let type = mimes[ext];
    if(type){
      //匹配到了                          text/html;charset=utf-8
      if(ext === 'html'){
        response.setHeader('content-type', type + ';charset=utf-8');
      }else{
        response.setHeader('content-type', type);
      }
    }else{
      //没有匹配到
      response.setHeader('content-type', 'application/octet-stream');
    }
    //响应文件内容
    response.end(data);
  })
  
});

//监听端口, 启动服务
server.listen(9000, () => {
  console.log('服务已经启动....')
});
```

#### index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <title>尚硅谷</title>
   <!-- <link rel="stylesheet" href="./css/app.css"> -->
   <link rel="stylesheet" href="/css/app.css">
   <!-- <link rel="stylesheet" href="http://127.0.0.1:9000/css/app.css"> -->
</head>
<body>
   <h1>尚硅谷前端</h1>
</body>
</html>
```

#### app.css

```css
*{
   margin: 0;
   padding: 0;
}
/* 我是个注释 */
body{
   height: 100vh;
   padding: 20px;
   box-sizing: border-box;
   background:linear-gradient(to right bottom, rgb(148, 213, 201), rgb(167, 151, 104));
}
```

#### app.js

```js
//获取图片
let img = document.querySelector('img');
//绑定事件
img.onclick = function(){
  alert('尚硅谷前端欢迎你')
}
```

#### 访问测试

http://127.0.0.1:9000/index.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181617150.png" alt="image-20230318161727039" style="zoom:80%;" />

# 包管理工具

## 基本概念

> 『包』英文单词是 package ，代表了一组特定功能的源码集合

> 『包管理工具』是管理『包』的应用软件，可以对「包」进行下载安装， 更新， 删除， 上传等操作
>
> 借助包管理工具，可以快速开发项目，提升开发效率
>
> 包管理工具是一个通用的概念，很多编程语言都有包管理工具，所以掌握好包管理工具非常重要

> 常用的包管理工具：npm、yarn、cnpm

### 包的语义化版本规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 **2.24.0**，其中每一位数字所代表的含义：

> 第1位数字：大版本
>
> 第2位数字：功能版本
>
> 第3位数字：Bug修复版本

版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零

### 包管理配置文件

npm 规定，在项目根目录中，**必须**提供叫做 package.json 的包管理配置文件。记录与项目有关的一些配置信息

> - 项目的名称、版本号、描述等
> - 项目中都用到了哪些包
> - 哪些包只在开发期间会用到
> - 那些包在开发和部署时都需要用到

#### 多人协作的问题

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061325716.png" alt="image-20221006132549640" style="zoom:80%;" />

#### 如何记录项目中安装了哪些包

> 在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210062322598.png" alt="image-20221006232206538" style="zoom:80%;" />

> **注意**：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。



#### 快速创建 package.json

npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061327937.png" alt="image-20221006132734885" style="zoom:80%;" />

注意：

> 上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文和空格
>
> 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中

#### dependencies 节点

> package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061329463.png" alt="image-20221006132922407" style="zoom:80%;" />

### 包的分类

使用 npm 包管理工具下载的包，共分为两大类，分别是：项目包\全局包

#### 项目包

那些被安装到项目的 node_modules 目录中的包，都是项目包。

项目包又分为两类，分别是：

> - 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）
> - 核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061342034.png" alt="image-20221006134218977" style="zoom:80%;" />

#### 全局包⭐

> 在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。
>
> 全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061342849.png" alt="image-20221006134252792" style="zoom:80%;" />

注意：

> ①只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。
>
> ②判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。

#### i5ting_toc(md转html)

> i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，因此可以安装为全局包。使用步骤如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061451148.png" alt="image-20221006145156090" style="zoom:80%;" />

### 规范的包结构

在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。

一个规范的包，它的组成结构，必须符合以下 3 点要求：

> ①包必须以单独的目录而存在
>
> ②包的顶级目录下要必须包含 package.json 这个包管理配置文件
>
> ③package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。

注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：[包规范](https://yarnpkg.com/zh-Hans/docs/package-json)

## npm

> npm 全称 Node Package Manager ，翻译为中文意思是『Node 的包管理工具』。

### 基本使用

创建一个空目录，然后以此目录作为工作目录启动命令行工具，执行 npm init -y

npm init 命令的作用是将文件夹初始化为一个『包』， 交互式创建 package.json 文件

package.json 是包的配置文件，每个包都必须要有 package.json，package.json 内容示例：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181734982.png" alt="image-20230318173439884" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181735905.png" alt="image-20230318173521799" style="zoom:80%;" />

### 搜索下载使用包

#### 搜索包

```
npm s/search 关键字            命令行搜索包

https://www.npmjs.com/         网站上搜索自己所需要的包

https://registry.npmjs.org/    服务器上下载自己需要的包
```

#### 下载包

我们可以通过 npm install 和npm i 命令安装包

```sh
# 格式
npm install <包名>
npm i <包名>
npm install <包名>@版本

# 示例
npm install uniq
npm i uniq
npm install uniq@1.0.1
```

> 运行后下会增加两个资源：node_modules 文件夹存放下载的包，package-lock.json 包的锁文件，锁定包的版本

> 安装 uniq 之后， uniq 就是当前这个包的一个依赖包，有时会简称为依赖，比如我们创建一个包名字为 A，A 中安装了包名字是 B，我们就说 B 是 A 的一个依赖包，也会说A 依赖 B

#### 使用包

require 导入 npm 包基本流程

> 1. 在当前文件夹下 node_modules 中寻找同名的文件夹
> 2. 在上级目录中下的 node_modules 中寻找同名的文件夹，直至找到磁盘根目录

```js
//1. 导入 uniq 包
const uniq = require('uniq');

//2. 使用函数
let arr = [1,2,3,4,5,4,3,2,1];

const result = uniq(arr);

console.log(result);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181744635.png" alt="image-20230318174441536" style="zoom:80%;" />

### 生产和开发依赖👍

> 如果某些包**只在项目开发阶段**会用到，在**项目上线之后不会用到**，则建议把这些包记录到 devDependencies 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中

我们可以在安装时设置选项来区分依赖的类型，目前分为两类：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181802168.png" alt="image-20230318180244062" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303181802283.png" alt="image-20230318180259178" style="zoom:80%;" />

### 全局安装

我们可以执行安装选项 -g 进行全局安装

```sh
# 全局安装完成之后就可以在命令行的任何位置运行 nodemon 命令,该命令的作用是 自动重启 node 应用程序
npm i -g nodemon
```

> - 全局安装的命令不受工作目录位置影响
> - 可以通过 npm root -g 可以查看全局安装包的位置
> - 不是所有的包都适合全局安装， 只有全局类的工具才适合
> - 可以通过查看包的官方文档来确定安装方式，这里先不必太纠结

### 一次性安装所有包

在项目协作中有一个常用的命令就是 npm i ，通过该命令可以依据 package.json 和 packagelock.json 的依赖声明安装

```sh
npm i
npm install
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061330508.png" alt="image-20221006133022450" style="zoom:80%;" />

### 安装指定版本的包

项目中可能会遇到版本不匹配的情况，有时就需要安装指定版本的包，可以使用下面的命令的

```sh
# 格式
npm i <包名@版本号>
# 示例
npm i jquery@1.11.2
```

### 删除依赖

项目中可能需要删除某些不需要的包，可以使用下面的命令

```sh
# 局部删除
npm remove uniq
npm r uniq
# 全局删除
npm remove -g nodemon
```

当然，也可以使用npm uninstall 包名，来删除依赖

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061331541.png" alt="image-20221006133106488" style="zoom:80%;" />

### 配置命令别名

通过配置命令别名可以更简单的执行命令,配置 package.json 中的 scripts 属性

```js
{
	.
	.
	.
	"scripts": {
		"server": "node server.js",
		"start": "node index.js",
	},
	.
	.
}
```

配置完成之后，可以使用别名执行命令

```
npm run server
npm run start
```

不过 start 别名比较特别，使用时可以省略run

```
npm start
```

> npm start 是项目中常用的一个命令，一般用来启动项目
>
> npm run 有自动向上级目录查找的特性，跟require 函数也一样
>
> 对于陌生的项目，我们可以通过查看 scripts 属性来参考项目的一些操作

### 设置镜像源👍

#### 为什么下包速度慢

> 在使用 npm 下包的时候，默认从国外的 https://registry.npmjs.org/ 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。

#### 淘宝 NPM 镜像服务器

淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务。从而极大的提高了下包的速度。

**镜像**（Mirroring）是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061336629.png" alt="image-20221006133606561" style="zoom:80%;" />

#### 设置镜像

方式一直接配置：执行如下命令即可完成配置

```sh
npm config set registry https://registry.npm.taobao.org
npm config get registry
```

方式二：使用 nrm 配置 npm 的镜像地址 npm registry manager，nrm help

> 为了更方便的切换下包的镜像源，我们可以安装 **nrm** 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源

```sh
# 安装 nrm
npm i -g nrm
# 查看所有镜像
nrm ls
# 修改镜像
nrm use taobao
# 检查 registry 地址是否为 https://registry.npmmirror.com/ , 如果是则表明成功
# 检查是否配置成功（选做）
npm config list
```

## cnpm

### 概述和安装

> cnpm 是一个淘宝构建的 npmjs.com 的完整镜像，也称为『淘宝镜像』，网址：https://npmmirror.com/
>
> cnpm 服务部署在国内阿里云服务器上， 可以提高包的下载速度，官方提供一个全局工具包 cnpm

我们可以通过 npm 来安装 cnpm 工具

```sh
npm install -g cnpm --registry=https://registry.npmmirror.com
```

### 操作命令

> 虽然 cnpm 可以提高速度，但是 npm 也可以通过淘宝镜像进行加速，所以 npm 的使用率还是高于 cnpm

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182019180.png" alt="image-20230318201951061" style="zoom:80%;" />



## yarn

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182034208.png" alt="image-20230318203404088" style="zoom:80%;" />

### 概述和特点

yarn 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具，官方网址： https://yarnpkg.com/

- 速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大
- 化资源利用率，因此安装速度更快
- 超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性
- 超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的工作

### 安装和命令

我们可以使用 npm 安装 yarn

```
npm i -g yarn
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182036450.png" alt="image-20230318203621325" style="zoom:80%;" />

> 这里有个小问题就是全局安装的包不可用 ，yarn 全局安装包的位置可以通过 yarn global bin来查看，那你有没有办法使 yarn 全局安装的包能够正常运行？

### 配置镜像源

```sh
yarn config set registry https://registry.npm.taobao.org
yarn config list
```

### npm 和 yarn 选择

大家可以根据不同的场景进行选择

> 个人项目：如果是个人项目， 哪个工具都可以，可以根据自己的喜好来选择

> 公司项目：如果是公司要根据项目代码来选择，可以通过锁文件判断项目的包管理工具
> npm 的锁文件为 package-lock.json，yarn 的锁文件为 yarn.lock

> 包管理工具不要混着用，切记，切记，切记

## 管理发布包

### 创建与发布

我们可以将自己开发的工具包发布到 npm 服务上，方便自己和其他开发者使用，操作步骤如下：

#### 完整流程

> 1. 创建文件夹，并创建文件 index.js， 在文件中声明函数，使用 module.exports 暴露
> 2. npm 初始化工具包npm init -y，package.json 填写包的信息 (包的名字是唯一的)
> 3. 注册账号 https://www.npmjs.com/signup
> 4. 激活账号 （ 一定要激活账号）
> 5. 修改为官方的官方镜像 (命令行中运行 nrm use npm )
> 6. 命令行下 npm login 填写相关用户信息
> 7. 命令行下npm publish 提交包 👌

#### 基本程序

```sh
# 初始化配置文件，重点注意版本号和name
npm init -y
```

> name：安装的包名，不能重复，version：包版本，main：入口文件，description：简短描述信息npm官网搜索时能看到，keywords搜索关键词，license开源信息，默认ISC

```json
{
  "name": "atguigu_math_renshuo",
  "version": "1.0.0",
  "main": "index.js",
  "description": "提供了加减乘除功能",
  "keywords": [
    "atguigu",
    "sub",
    "add"
  ],
  "license": "ISC"
}
```

根目录有如下文件

> - package.json （包管理配置文件）npm init -y
> - index.js     （包的入口文件）
> - README.md （包的说明文档）

index.js

```js
//加法
function add(a,b){
  return a + b;
}

//减法
function sub(a, b){
  return a - b;
}

//暴露
module.exports = {
  add,
  sub
}
```

test.js

```js
const math = require('./index');

console.log(math.sub(3, 2))
```

#### 注册 npm 账号

> ①访问 https://www.npmjs.com/ 网站，点击 sign up 按钮，进入注册用户界面
>
> ②填写账号相关的信息：Full Name、Public Email、Username、Password
>
> ③点击 Create an Account 按钮，注册账号
>
> ④登录邮箱，点击验证链接，进行账号的验证

> 邮箱：1597374863@qq.com，密码：315217renS.，用户名：renshuo123

#### 登录 npm 账号

> npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。

```sh
# 切换回npm官方服务器路径，不是淘宝镜像路径
nrm use npm
# 进行登录
npm login
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210070900958.png" alt="image-20221007090001884" style="zoom:80%;" />

> 注意：在运行 npm login 命令前，必须把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布失败

#### 把包发布到 npm 上

> 将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。

```sh
npm publish
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182103264.png" alt="image-20230318210324135" style="zoom:80%;" />

进入官网查看：https://www.npmjs.com/settings/renshuo123/packages

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182102033.png" alt="image-20230318210249896" style="zoom:80%;" />

### 安装和使用

```sh
npm i atguigu_math_renshuo@1.0.1
```

```js
// 新建demo.js，进行验证
const math = require('atguigu_math_renshuo');
console.log(math.add(1,2))
```

### 更新包

后续可以对自己发布的包进行更新，操作步骤如下

更新包中的代码：修改index.js，新增乘法

```js
//乘法
function mul(a, b){
  return a * b;
}
```

测试代码是否可用：在test.js中测试函数是否可用

```js
const math = require('./index');

console.log(math.sub(3, 2))
console.log(math.mul(3,3))
```

修改 package.json 中的版本号：版本号不能与之前一样

```js
"version": "1.0.2",
```

发布更新：npm publish

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182108285.png" alt="image-20230318210827153" style="zoom:80%;" />

### 删除包

```sh
# 执行如下命令删除包
npm unpublish --force
```

> 删除包需要满足一定的条件， https://docs.npmjs.com/policies/unpublish
>
> 你是包的作者、发布小于 24 小时
>
> 大于 24 小时后，没有其他包依赖，并且每周小于 300 下载量，并且只有一个维护者

### 编写包的说明文档

> 包根目录中的 README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以 markdown 的格式写出来，方便用户参考。README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。

我们所创建的这个包的 README.md 文档中，会包含以下 6 项内容：

> 安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议

> 按3下数字1旁边的模板字符引号，即可选择输入代码块

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210070854833.png" alt="image-20221007085409759" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210070852454.png" alt="image-20221007085241349" style="zoom:67%;" />



## 其他包管理工具

在很多语言中都有包管理工具，比如：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182045531.png" alt="image-20230318204510408" style="zoom:80%;" />

除了编程语言领域有包管理工具之外，操作系统层面也存在包管理工具，不过这个包指的是『软件包』

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182045011.png" alt="image-20230318204529898" style="zoom:80%;" />

# express

## 初识express

> 官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。

> **Express** **的本质**：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。
>
> Express 的中文官网：[ http://www.expressjs.com.cn/](http://www.expressjs.com.cn/)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051040444.png" alt="image-20221005104025378" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051040435.png" alt="image-20221005104054385" style="zoom:80%;" />

## 基本使用⭐

### 安装依赖包

在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用

```apl
npm init
npm i express
```

### 初体验

```js
//1. 导入 express
const express = require('express');

//2. 创建应用对象
const app = express();

//3. 创建路由
app.get('/home', (req, res) => {
  res.end('hello express');
});

//4. 监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

访问：http://127.0.0.1:3000/home

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303182147777.png" alt="image-20230318214742671" style="zoom:80%;" />

## 路由⭐

### 什么是路由

> 广义上来讲，路由就是映射关系。路由确定了应用程序如何响应客户端对特定端点的请求，一个路由的组成有请求方法， 路径和回调函数组成express 中提供了一系列方法，可以很方便的使用路由

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051321923.png" alt="image-20221005132106835" style="zoom:80%;" />

### 路由匹配过程

> 每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052122414.png" alt="image-20221005212212338" style="zoom:80%;" />

### 基本实现

#### 完整实现⭐

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/home', (req, res) => {
  res.end('hello express');
});

//首页路由
app.get('/', (req, res) => {
  console.log(req.ip);
  // 防止乱码  
  res.setHeader('content-type','text/html;charset=utf-8');
  res.end('根目录：'+req.ip);
});

//post
app.post('/login', (req, res) => {
  res.end('login login')
});

//匹配所有的方法
app.all('/test', (req, res) => {
  res.end('test test');
})

//404 响应
app.all('*', (req, res) => {
  res.end('404 not Found')
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

http://127.0.0.1:3000/ 根目录

http://127.0.0.1:3000/home  hello express

http://127.0.0.1:3000/123  404 not Found

http://127.0.0.1:3000/test  test

#### 监听 GET 请求

> 通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051049285.png" alt="image-20221005104916226" style="zoom:80%;" />

```js
app.get('/user', (req, res) => {
  // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象
  res.send({ name: 'zs', age: 20, gender: '男' })
})
```

#### 监听 POST 请求

> 通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051051220.png" alt="image-20221005105125164" style="zoom:80%;" />

```js
app.post('/user', (req, res) => {
  // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串
  res.send('请求成功')
})
```

#### 把内容响应给客户端

> 通过 res.send() 方法，可以把处理好的内容，发送给客户端

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051052271.png" alt="image-20221005105226217" style="zoom:80%;" />

#### 获取 URL 中携带的查询参数

> 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051053720.png" alt="image-20221005105327663" style="zoom:80%;" />

```js
app.get('/', (req, res) => {
  // 通过 req.query 可以获取到客户端发送过来的 查询参数
  // 注意：默认情况下，req.query 是一个空对象
  console.log(req.query)
  res.send(req.query)
})
```

访问：http://127.0.0.1/?name=zs

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210070922825.png" alt="image-20221007092256669" style="zoom:80%;" />

#### 获取 URL 中的动态参数

> 通过 req.params 对象，可以访问到 URL 中，通过 **:** 匹配到的动态参数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051153804.png" alt="image-20221005115300728" style="zoom:80%;" />

```js
// 注意：这里的 :id 是一个动态的参数
app.get('/user/:ids/:username', (req, res) => {
  // req.params 是动态匹配到的 URL 参数，默认也是一个空对象
  console.log(req.params)
  res.send(req.params)
})
```

访问测试：http://127.0.0.1/user/1/12

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210070924231.png" alt="image-20221007092458159" style="zoom:80%;" />

### 路由参数

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/:id.html', (req, res) => {
  //获取 URL 路由参数
  console.log(req.params.id);
  res.setHeader('content-type','text/html;charset=utf-8');
  res.end('商品详情');
});


//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

http://127.0.0.1:3000/123.html

http://127.0.0.1:3000/312.html

http://127.0.0.1:3000/zhangsan.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191330080.png" alt="image-20230319133013969" style="zoom:80%;" />

### 实战演练

singers.json

```json
{
  "singers": [
    {
      "singer_name": "周杰伦",
      "singer_pic": "http://y.gtimg.cn/music/photo_new/T001R150x150M0000025NhlN2yWrP4.webp",
      "other_name": "Jay Chou",
      "singer_id": 4558,
      "id": 1
    },
    {
      "singer_name": "林俊杰",
      "singer_pic": "http://y.gtimg.cn/music/photo_new/T001R150x150M000001BLpXF2DyJe2.webp",
      "other_name": "JJ Lin",
      "singer_id": 4286,
      "id": 2
    },
    {
      "singer_name": "G.E.M. 邓紫棋",
      "singer_pic": "http://y.gtimg.cn/music/photo_new/T001R150x150M000001fNHEf1SFEFN.webp",
      "other_name": "Gloria Tang",
      "singer_id": 13948,
      "id": 3
    }
  ]
}
```

```js
//导入 express
const express = require('express');
//导入 json 文件，可以直接用require读取
const {singers} = require('./singers.json');
// console.log(singers)
//创建应用对象
const app = express();

//创建路由
app.get('/singer/:id.html', (req, res) => {
  //获取路由参数
  let {id} = req.params;
  //在数组中寻找对应 id 的数据
  let result = singers.find(item => {
    if(item.id === Number(id)){
      return true;
    }
  });

  //判断
  if(!result){
    res.statusCode = 404;
    res.end(`<h1>404 Not Found</h1>`)
    return;
  }

  res.end(`
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h2>${result.singer_name}</h2>
    <img src='${result.singer_pic}' />
  </body>
  </html>`);
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

http://127.0.0.1:3000/singer/1.html

http://127.0.0.1:3000/singer/2.html

http://127.0.0.1:3000/singer/3.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191336952.png" alt="image-20230319133625831" style="zoom:80%;" />

### 路由模块化⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052125505.png" alt="image-20221005212552437" style="zoom:80%;" />

#### 创建路由模块

```js
// 这是路由模块
// 1. 导入 express
const express = require('express')
// 2. 创建路由对象
const router = express.Router()

// 3. 挂载具体的路由
router.get('/user/list', (req, res) => {
  res.send('Get user list.')
})
router.post('/user/add', (req, res) => {
  res.send('Add new user.')
})

// 4. 向外导出路由对象
module.exports = router
```

#### 注册路由模块

```js
const express = require('express')
const app = express()

// 1. 导入路由模块
const router = require('./03.router')
// 2. 注册路由模块
app.use('/api', router)

// 注意： app.use() 函数的作用，就是来注册全局中间件
app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```

#### 启动访问测试

http://127.0.0.1/api/user/list

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210070956854.png" alt="image-20221007095644775" style="zoom:80%;" />

#### 为路由模块添加前缀(可选)

> 类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052127570.png" alt="image-20221005212751513" style="zoom:80%;" />

## 获取请求 & 响应参数

### 获取请求参数

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/request', (req, res) => {
  //原生操作
  console.log(req.method);
  console.log(req.url);
  console.log(req.httpVersion);
  console.log(req.headers);
  //express 操作
  console.log(req.path);
  console.log(req.query);
  //获取 ip
  console.log(req.ip);
  //获取请求头
  console.log(req.get('host'));
  res.end('hello express');
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191326135.png" alt="image-20230319132631988" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191326173.png" alt="image-20230319132654034" style="zoom:80%;" />

### 获取请求体数据

#### body-parser

express 可以使用 body-parser 包处理请求体

第一步：安装

```js
npm i body-parser
```

第二步：导入 body-parser 包

```js
const bodyParser = require('body-parser');
```

第三步：获取中间件函数

```js
//处理 querystring 格式的请求体
let urlParser = bodyParser.urlencoded({extended:false}));
//处理 JSON 格式的请求体
let jsonParser = bodyParser.json();
```

第四步：设置路由中间件，然后使用 request.body 来获取请求体数据

```js
app.post('/login', urlParser, (request,response)=>{
    //获取请求体数据
    //console.log(request.body);
    //用户名
    console.log(request.body.username);
    //密码
    console.log(request.body.userpass);
    response.send('获取请求体数据');
});
```

获取到的请求体数据：

```js
[Object: null prototype] { username: 'admin', userpass: '123456' }
```

#### 实战演练

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>登录页面</title>
</head>
<body>
  <h2>用户登录</h2>
  <hr />
  <form action="http://127.0.0.1:3000/login" method="post">
    用户名: <input type="text" name="username"><br />
    密码: <input type="password" name="password"><br />
    <button>登录</button>
  </form>
</body>
</html>
```

```js
/**
 * 按照要求搭建 HTTP 服务
 * GET   /login  显示表单网页
 * POST  /login  获取表单中的『用户名』和『密码』
 */
//导入 express
const express = require('express');
const bodyParser = require('body-parser')

//创建应用对象
const app = express();

//解析 JSON 格式的请求体的中间件
// const jsonParser = bodyParser.json()

//解析 querystring 格式请求体的中间件
const urlencodedParser = bodyParser.urlencoded({ extended: false })

//创建路由规则
app.get('/login', (req, res) => {
  // res.send('表单页面')
  //响应 HTML 文件内容
  res.sendFile(__dirname + '/11_form.html');
});

//post 规则
app.post('/login', urlencodedParser, (req, res) => {
  //获取 用户名 和 密码
  console.log(req.body);
  res.send('获取用户的数据')
});

//启动服务
app.listen(3000, () => {
  console.log('server is running...');
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191430151.png" alt="image-20230319143033015" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191431432.png" alt="image-20230319143119282" style="zoom:80%;" />

## 响应方式⭐

express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式

### 正常响应

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/response', (req, res) => {
  //原生响应
  res.statusCode = 404;
  res.statusMessage = 'love';
  res.setHeader('xxx', 'yyy');
  res.write('hello express ')
  res.end('response');

  //express 响应
  res.status(500);
  res.set('aaa','bbb');
  res.send('你好 Express');
  res.status(500).set('abc','def').send('这都是 OK 的');

});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

### 跳转响应

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/other', (req, res) => {
  //跳转响应，访问http://127.0.0.1:3000/other，就会自动跳转到该页面
  res.redirect('http://atguigu.com');
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

### 下载响应

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/other', (req, res) => {
  //下载响应访问：http://127.0.0.1:3000/other，即可下载文件
  res.download(__dirname + '/package.json');
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

### JSON响应

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/other', (req, res) => {
  // JSON 响应，就是正常响应JSON数据
  res.json({
    name: '尚硅谷',
    slogon: '让天下没有难学的技术'
  })
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

### 响应文件内容

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//创建路由
app.get('/other', (req, res) => {
  //响应文件内容，用path.resolve()拼接路径也可以
  res.sendFile(__dirname + '/test.html');
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191350420.png" alt="image-20230319135013169" style="zoom:80%;" />

## 托管静态资源

> Express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：

### 托管单个静态资源目录⭐

```js
const express = require('express')
const app = express()
const path = require('path');
// 在这里，调用 express.static() 方法，快速的对外提供静态资源，推荐使用绝对路径
// G:\尚硅谷NodeJS核心基础\代码\07_express\代码\public
app.use(express.static(path.resolve(__dirname, "../public")))
app.listen(3000, () => {
    console.log('express server running at http://127.0.0.1:3000')
})
```

> **注意：**Express 在指定的静态目录中查找文件。**因此，存放静态文件的目录名不会出现在 URL 中**。

现在，你就可以访问 public 目录中的所有文件了：

:3000/images/bg.jpg

:3000/css/style.css

:3000/js/login.js

### 托管多个静态资源目录

> 如果要托管多个静态资源目录，请多次调用 express.static() 函数：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051213177.png" alt="image-20221005121317127" style="zoom:80%;" />

访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。

### 挂载路径前缀

> 如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：
>
> 路径前缀任意，只是作为区分作用，第一个参数是路径前缀，第二个参数是文件实际目录

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210051259725.png" alt="image-20221005125902664" style="zoom:80%;" />

现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：

:3000/public/images/kitten.jpg

:3000/public/css/style.css

:3000/public/js/app.js

## nodemon 热更新

### 什么是热更新

> 在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。

### 使用步骤

在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：

```apl
npm install -g nodemon
```

> 当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。
>

> 现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。
>

```apl
# 正常执行命令
node app.js 
# 将上面的终端命令，替换为下面的终端命令，即可实现自动重启项目的效果
nodemon app.js 
```

## 中间件

### 什么是中间件

> 中间件（Middleware ），特指业务流程的中间处理环节。现实生活的例子：在处理污水的时候，一般都要经过三个处理环节，从而保证处理过后的废水，达到排放标准。处理污水的这三个中间处理环节，就可以叫做中间件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052130991.png" alt="image-20221005213022919" style="zoom:80%;" />

#### Express中间件的调用流程

> 当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052131615.png" alt="image-20221005213127547" style="zoom:80%;" />

#### Express 中间件的格式

> Express 的中间件，本质上就是一个 **function** **处理函数**，Express 中间件的格式如下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052132698.png" alt="image-20221005213231614" style="zoom:80%;" />

#### next 函数的作用

> **next** **函数**是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052134144.png" alt="image-20221005213413072" style="zoom:80%;" />

### 全局中间件

```js
//记录每个请求的 url 与 IP 地址
//导入 express
const express = require('express');
const fs = require('fs');
const path = require('path');

//创建应用对象
const app = express();

//声明中间件函数
function recordMiddleware(req, res, next){
  //获取 url 和 ip
  let {url, ip} = req;
  //将信息保存在文件中 access.log
  fs.appendFileSync(path.resolve(__dirname, './access.log'), `${url}  ${ip}\r\n`);
  //调用 next
  next();
}

//使用中间件函数
app.use(recordMiddleware);

//创建路由
app.get('/home', (req, res) => {
  res.send('前台首页');
});

app.get('/admin', (req, res) => {
  res.send('后台首页');
});

app.all('*',(req, res) => {
  res.send('<h1>404 Not Found</h1>')
})

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

http://127.0.0.1:3000/home

http://127.0.0.1:3000/admin

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191405222.png" alt="image-20230319140535094" style="zoom:80%;" />

### 路由中间件

```js
//针对 /admin  /setting 的请求, 要求 URL 携带 code=521 参数, 如未携带提示『暗号错误』  
//导入 express
const express = require('express');
//创建应用对象
const app = express();
//创建路由
app.get('/home', (req, res) => {
  res.send('前台首页');
});
//声明中间件
let checkCodeMiddleware = (req, res, next) => {
  //判断 URL 中是否 code 参数等于 521
  if(req.query.code === '521'){
    next();
  }else{
    res.send('暗号错误');
  }
}
//后台
app.get('/admin', checkCodeMiddleware, (req, res) => {
  res.send('后台首页');
});
//后台设置
app.get('/setting', checkCodeMiddleware, (req, res) => {
  res.send('设置页面');
});
app.all('*',(req, res) => {
  res.send('<h1>404 Not Found</h1>')
})
//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

### 静态资源中间件

express 内置处理静态资源的中间件

```js
//引入express框架
const express = require('express');
//创建服务对象
const app = express();
//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录
app.use(express.static(__dirname + '/public')); //当然这个目录中都是一些静态资源
//如果访问的内容经常变化，还是需要设置路由
//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，
//则谁书写在前，优先执行谁
app.get('/index.html',(req,res)=>{
  res.send('首页');
});
//监听端口
app.listen(3000,()=>{
  console.log('3000 端口启动....');
});
```

http://127.0.0.1:3000/index.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191412937.png" alt="image-20230319141257800" style="zoom:80%;" />

> 1. index.html 文件为默认打开的资源
> 2. 如果静态资源与路由规则同时匹配，谁先匹配谁就响应
> 3. 路由响应动态资源，静态资源中间件响应静态资源

练习

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191418811.png" alt="image-20230319141857671" style="zoom:80%;" />

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//设置静态资源中间件
app.use(express.static(__dirname + '/尚品汇'));

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

访问页面：http://127.0.0.1:3000/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191419168.png" alt="image-20230319141932943" style="zoom:80%;" />





### Express 中间件的初体验

#### 定义中间件函数

可以通过如下的方式，定义一个最简单的中间件函数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052135444.png" alt="image-20221005213511382" style="zoom:80%;" />

#### 全局生效的中间件

> 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。
>
> 通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件，示例代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052136373.png" alt="image-20221005213650302" style="zoom:80%;" />

#### 定义全局中间件的简化形式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052137636.png" alt="image-20221005213727563" style="zoom:80%;" />

#### 中间件开发中的作用

> 多个中间件之间，**共享同一份** **req** **和** **res**。基于这样的特性，我们可以在上游的中间件中，**统一**为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052138713.png" alt="image-20221005213811641" style="zoom:80%;" />

#### 中间件的使用⭐⭐

```js
const express = require('express')
const app = express()

// 这是定义全局中间件的简化形式
app.use((req, res, next) => {
  // 获取到请求到达服务器的时间
  // 为 req 对象，挂载自定义属性，从而把时间共享给后面的所有路由
  req.startTime = Date.now()
  next()
})

app.get('/', (req, res) => {
  res.send('Home page.' + req.startTime)
})
app.get('/user', (req, res) => {
  res.send('User page.' + req.startTime)
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```

http://127.0.0.1/user，User page.1665108535462

http://127.0.0.1/，Home page.1665108655014

#### 定义多个全局中间件

> 可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，**会按照中间件定义的先后顺序依次进行调用**，示例代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052150924.png" alt="image-20221005215010856" style="zoom:80%;" />

```js
const express = require('express')
const app = express()

// 定义第一个全局中间件
app.use((req, res, next) => {
  console.log('调用了第1个全局中间件')
  next()
})
// 定义第二个全局中间件
app.use((req, res, next) => {
  console.log('调用了第2个全局中间件')
  next()
})

// 定义一个路由
app.get('/user', (req, res) => {
  res.send('User page.')
})

app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```

#### 局部生效的中间件

> **不使用** app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052151108.png" alt="image-20221005215136031" style="zoom:80%;" />

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 1. 定义中间件函数
const mw1 = (req, res, next) => {
  console.log('调用了局部生效的中间件')
  next()
}

// 2. 创建路由
app.get('/', mw1, (req, res) => {
  res.send('Home page.')
})
app.get('/user', (req, res) => {
  res.send('User page.')
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

#### 定义多个局部中间件

> 可以在路由中，通过如下两种等价的方式，使用多个局部中间件：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052152214.png" alt="image-20221005215211139" style="zoom:80%;" />

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 1. 定义中间件函数
const mw1 = (req, res, next) => {
  console.log('调用了第一个局部生效的中间件')
  next()
}

const mw2 = (req, res, next) => {
  console.log('调用了第二个局部生效的中间件')
  next()
}

// 2. 创建路由
app.get('/', [mw1, mw2], (req, res) => {
  res.send('Home page.')
})
app.get('/user', (req, res) => {
  res.send('User page.')
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

#### 了解中间件的5个使用注意事项

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052153053.png" alt="image-20221005215302983" style="zoom:80%;" />

### 中间件的分类

> 为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052159033.png" alt="image-20221005215958972" style="zoom:80%;" />

#### 应用级别的中间件

> 通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052200369.png" alt="image-20221005220040307" style="zoom:80%;" />

#### 路由级别的中间件

> 绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052206736.png" alt="image-20221005220623671" style="zoom:80%;" />

#### 错误级别的中间件⭐

> 错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。
>
> 注意：错误级别的中间件，必须注册在所有路由之后

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 1. 定义路由
app.get('/', (req, res) => {
  // 1.1 人为的制造错误
  throw new Error('服务器内部发生了错误！')
  res.send('Home page.')
})

// 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃
app.use((err, req, res, next) => {
  console.log('发生了错误！' + err.message)
  res.send('Error：' + err.message)
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071018527.png" alt="image-20221007101829449" style="zoom:80%;" />



#### Express内置的中间件⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052211418.png" alt="image-20221005221125348" style="zoom:80%;" />

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置
// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据
app.use(express.json())
// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据
app.use(express.urlencoded({ extended: false }))

app.post('/user', (req, res) => {
  // 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据
  // 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined
  console.log(req.body)
  res.send('ok')
})

app.post('/book', (req, res) => {
  // 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据
  console.log(req.body)
  res.send('ok')
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071027543.png" alt="image-20221007102728447" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071027290.png" alt="image-20221007102754198" style="zoom:80%;" />



### 第三方的中间件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052216842.png" alt="image-20221005221601764" style="zoom:80%;" />

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 1. 导入解析表单数据的中间件 body-parser
const parser = require('body-parser')
// 2. 使用 app.use() 注册中间件
app.use(parser.urlencoded({ extended: false }))
// app.use(express.urlencoded({ extended: false }))

app.post('/user', (req, res) => {
  // 如果没有配置任何解析表单数据的中间件，则 req.body 默认等于 undefined
  console.log(req.body)
  res.send('ok')
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071036896.png" alt="image-20221007103624806" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071036019.png" alt="image-20221007103647940" style="zoom:80%;" />

#### 需求描述与实现步骤

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052215821.png" alt="image-20221005221528745" style="zoom:80%;" />

#### 定义中间件

使用 app.use() 来定义全局生效的中间件，代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052216804.png" alt="image-20221005221640745" style="zoom:80%;" />

#### **监听** **req** **的** data 事件

> 在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052217244.png" alt="image-20221005221731183" style="zoom:80%;" />

#### **监听** **req** **的** end事件

> 当请求体数据接收完毕之后，会自动触发 req 的 end 事件。
>
> 因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052218600.png" alt="image-20221005221814538" style="zoom:80%;" />

#### 使用 querystring 模块解析请求体数据

> Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052310934.png" alt="image-20221005231024888" style="zoom:80%;" />

#### 将解析出来的数据对象挂载为 req.body

> 上游的中间件和下游的中间件及路由之间，**共享同一份** **req** **和** **res**。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。示例代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052310953.png" alt="image-20221005231059902" style="zoom:80%;" />

#### 将自定义中间件封装为模块

> 为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052312520.png" alt="image-20221005231208465" style="zoom:80%;" />

#### 完整代码实现

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 1. 导入自己封装的中间件模块
const customBodyParser = require('./14.custom-body-parser')
// 2. 将自定义的中间件函数，注册为全局可用的中间件
app.use(customBodyParser)

app.post('/user', (req, res) => {
  res.send(req.body)
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

```js
// 导入 Node.js 内置的 querystring 模块
const qs = require('querystring')

const bodyParser = (req, res, next) => {
  // 定义中间件具体的业务逻辑
  // 1. 定义一个 str 字符串，专门用来存储客户端发送过来的请求体数据
  let str = ''
  // 2. 监听 req 的 data 事件
  req.on('data', (chunk) => {
    str += chunk
  })
  // 3. 监听 req 的 end 事件
  req.on('end', () => {
    // 在 str 中存放的是完整的请求体数据
    // console.log(str)
    // TODO: 把字符串格式的请求体数据，解析成对象格式
    const body = qs.parse(str)
    req.body = body
    next()
  })
}

module.exports = bodyParser
```

## 使用 Express 写接口

### 创建基本的服务器

```js
// 导入 express
const express = require('express')
// 创建服务器实例
const app = express()

// write your code here...

// 启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```

### 创建 API 路由模块

```js
const express = require('express')
const router = express.Router()

// 在这里挂载对应的路由...

module.exports = router
```

在上面的基本服务器的js导入路由

```js
// 导入路由模块
const router = require('./16.apiRouter')
// 把路由模块，注册到 app 上
app.use('/api', router)
```

### 编写接口请求⭐

#### 编写 GET 接口

```js
router.get('/get', (req, res) => {
  // 1. 通过 req.query 获取客户端通过查询字符串，发送到服务器的数据
  const query = req.query
  // 2. 调用 res.send() 方法，向客户端响应处理的结果
  res.send({
    status: 0, // 0 表示处理成功，1 表示处理失败
    msg: 'GET 请求成功！', // 状态的描述
    data: query, // 需要响应给客户端的数据
  })
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071144101.png" alt="image-20221007114447993" style="zoom:80%;" />

#### 编写 POST 接口

```js
// 定义 POST 接口
router.post('/post', (req, res) => {
  // 通过 req.body 获取请求体中包含的 url-encoded 格式的数据
  const body = req.body
  // 调用 res.send() 方法，向客户端响应结果
  res.send({
    status: 0,
    msg: 'POST 请求成功！',
    data: body,
  })
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071148309.png" alt="image-20221007114821209" style="zoom:80%;" />

> 注意：如果要获取 URL-encoded 格式的请求体数据，
>
> 必须配置中间件 app.use(express.urlencoded({ extended: false }))

#### 编写DELETE接口

```js
// 定义 DELETE 接口
router.delete('/delete', (req, res) => {
  res.send({
    status: 0,
    msg: 'DELETE请求成功',
  })
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071154654.png" alt="image-20221007115423542" style="zoom:80%;" />

## cors 跨域资源共享

刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。解决接口跨域问题的方案主要有两种：

> - CORS（主流的解决方案，推荐使用）
> - JSONP（有缺陷的解决方案：只支持 GET 请求）

### cors 概述

> CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，**这些** **HTTP** **响应头决定浏览器是否阻止前端** **JS** **代码跨域获取资源**。浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210052323717.png" alt="image-20221005232311653" style="zoom:80%;" />

### 使用 cors 中间件⭐

```sh
npm install cors
```

```js
...
// 1、npm install cors
// 2、一定要在路由之前，配置 cors 这个中间件，从而解决接口跨域的问题
const cors = require('cors')
// 3、配置中间件
app.use(cors())
...
// 导入路由模块
const router = require('./16.apiRouter')
// 把路由模块，注册到 app 上
app.use('/api', router)
```

## 防盗链

```js
//导入 express
const express = require('express');

//创建应用对象
const app = express();

//声明中间件
app.use((req, res, next) => {
  //检测请求头中的 referer 是否为 127.0.0.1
  //获取 referer
  let referer = req.get('referer');
  if(referer){
    //实例化
    let url = new URL(referer);
    //获取 hostname
    let hostname = url.hostname;
    //判断
    if(hostname !== '127.0.0.1'){
      //响应 404 
      res.status(404).send('<h1>404 Not Found</h1>');
      return;
    }
  }
  next();
});

//静态资源中间件设置
app.use(express.static(__dirname + '/public'));

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

## 模板引擎

> 模板引擎是分离用户界面和业务数据的一种技术。EJS 是一个高效的 Javascript 的模板引擎
>
> 官网：https://ejs.co/，中文站：https://ejs.bootcss.com/

```js
npm i ejs --save
```

```js
//执行JS代码
<% code %>
//输出转义的数据到模板上
<%= code %>
//输出非转义的数据到模板上
<%- code %>
```

### ejs初体验

```less
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h2>我爱你 <%= china %></h2>
  <p><%= weather %></p>
</body>
</html>
```

```js
//1. 安装 EJS
//2. 导入 EJS
const ejs = require('ejs');
const fs = require('fs');

//字符串
let china = '中国';
// let str = `我爱你 ${china}`;
let weather = '今天天气不错~';

//声明变量
let str = fs.readFileSync('./01_html.html').toString();

//使用 ejs 渲染
let result = ejs.render(str, {china: china, weather});

console.log(result);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191502848.png" alt="image-20230319150245689" style="zoom:80%;" />

### 列表渲染

```less
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>西游四人组</title>
</head>
<body>
  <h2>西游四人组</h2>
  <ul>
    <% xiyou.forEach(item => { %>
    <li><%= item %></li>
    <% }) %>
  </ul>
</body>
</html>
```

```js
const ejs = require('ejs');
//西游记
const xiyou = ['唐僧','孙悟空','猪八戒','沙僧'];

// EJS 实现
const fs = require('fs');
let html = fs.readFileSync('./02_西游.html').toString();
let result = ejs.render(html, {xiyou:xiyou});

console.log(result);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191506024.png" alt="image-20230319150653856" style="zoom:80%;" />

### 条件渲染

```less
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <header>
    <% if(isLogin){ %>
    <span>欢迎回来</span>
    <% }else{ %>
    <button>登录</button>  <button>注册</button>
    <% } %>
  </header>
</body>
</html>
```

```js
/**
 * 通过 isLogin 决定最终的输出内容
 * true   输出『<span>欢迎回来</span>』
 * false  输出『<button>登录</button>  <button>注册</button>』
 */
// 导入 ejs
const ejs = require('ejs');
const fs = require('fs');
//变量
let isLogin = true;

//EJS 实现
//读取 HTML 内容
let html = fs.readFileSync('./03_home.html').toString();
let result = ejs.render(html, {isLogin: isLogin});

console.log(result);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191509072.png" alt="image-20230319150911903" style="zoom:80%;" />

### express+ejs

views/home.ejs

```less
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h2><%= title %></h2>
</body>
</html>
```

```js
//导入 express
const express = require('express');
//导入 path
const path = require('path');
//创建应用对象
const app = express();
//1. 设置模板引擎
app.set('view engine', 'ejs');// pug  twing
//2. 设置模板文件存放位置   模板文件: 具有模板语法内容的文件,views/home.ejs
app.set('views', path.resolve(__dirname, './views'));

//创建路由
app.get('/home', (req, res) => {
  //3. render 响应
  // res.render('模板的文件名', '数据');
  //声明变量
  let title = '尚硅谷 - 让天下没有难学的技术';
  res.render('home', {title});
  //4. 创建模板文件
});

//监听端口, 启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191511222.png" alt="image-20230319151135029" style="zoom:80%;" />



## 模板生成

express-generator官网：https://www.expressjs.com.cn/starter/generator.html

```sh
npm i express-generator -g
```

### 创建项目

```
express -e demo
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191518368.png" alt="image-20230319151849211" style="zoom:80%;" />

### 生成文件内容

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191519235.png" alt="image-20230319151927075" style="zoom:80%;" />

## 文件上传

官网：https://www.npmjs.com/package/formidable

```sh
npm install formidable
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191531502.png" alt="image-20230319153122291" style="zoom:80%;" />

### 使用示例

```js
const express = require('express');
const formidable = require('formidable');

const app = express();

app.get('/', (req, res) => {
    res.send(`
    <h2>With <code>"express"</code> npm package</h2>
    <form action="/api/upload" enctype="multipart/form-data" method="post">
      <div>Text field title: <input type="text" name="title" /></div>
      <div>File: <input type="file" name="someExpressFiles" multiple="multiple" /></div>
      <input type="submit" value="Upload" />
    </form>
  `);
});

app.post('/api/upload', (req, res, next) => {
    // 创建form对象
    const form = formidable({
        multiples: true ,
        //设置上传文件的保存目录
        uploadDir: __dirname,
        //保持文件后缀
        keepExtensions: true
    });
    //解析请求报文
    form.parse(req, (err, fields, files) => {
        if (err) {
            next(err);
            return;
        }
        console.log(fields)
        console.log(files)
        //获取图片URL
        let url = files.someExpressFiles.newFilename;
        res.json({ fields, files,url });
    });
});

app.listen(3000, () => {
    console.log('Server listening on :3000 ...');
});
```

### 访问测试

官网：:3000/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191532586.png" alt="image-20230319153223416" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191545634.png" alt="image-20230319154504417" style="zoom:80%;" />



# API接口

## 概念和作用

> - 接口是前后端通信的桥梁。简单理解：一个接口就是服务中的一个路由规则，根据请求响应结果
> - 接口的英文单词是 API (Application Program Interface)，所以有时也称之为 API 接口
> - 这里的接口指的是『数据接口』， 与编程语言（Java，Go 等）中的接口语法不同

> 大多数接口都是由后端工程师开发的， 开发语言不限。一般情况下接口都是由前端工程师调用的，但有时后端工程师也会调用接口，比如短信接口，支付接口等

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200904286.png" alt="image-20230320090406173" style="zoom:67%;" />

## 接口组成

> 接口一般由如下几个部分组成：请求方法、接口地址（URL）、请求参数、响应结果
>
> 接口示例 ：https://www.free-api.com/doc/325

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200913270.png" alt="image-20230320091319138" style="zoom:80%;" />

> 体验一下： https://api.asilu.com/idcard/?id=371522199111299668

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200916458.png" alt="image-20230320091654349" style="zoom:80%;" />

## RESTful API

RESTful API 是一种特殊风格的接口，主要特点有如下几个：

扩展阅读： https://www.ruanyifeng.com/blog/2014/05/restful_api.html

> - URL 中的路径表示资源，**路径中不能有动词，例如create , delete , update 等这些都不能有**
> - **操作资源要与 HTTP 请求方法对应**
> - **操作结果要与 HTTP 响应状态码对应**

规则示例：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200908173.png" alt="image-20230320090840072" style="zoom:80%;" />

## 临时接口工具：json-server⭐

> json-server 本身是一个 JS 编写的工具包，可以快速搭建 RESTful API 服务。
>
> 官方地址: https://github.com/typicode/json-server

### 基本语法

全局安装 json-server

```js
npm install -g json-server
```

创建 JSON 文件（db.json），编写基本结构

```json
{
  "song": [
    { "id": 1, "name": "干杯", "singer": "五月天"},
    { "id": 2, "name": "当",  "singer": "动力火车"},
    { "id": 3, "name": "不能说的秘密", "singer": "Jay"},
    { "id": 4, "name": "双节棍", "singer": "Jay"}
  ],
  "user": []
}
```

以 JSON 文件所在文件夹作为工作目录，执行如下命令

```json
json-server --watch db.json
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200925266.png" alt="image-20230320092501161" style="zoom:80%;" />

> 接下来，使用apipost工具实现CURD

### 查询所有

http://127.0.0.1:3000/song

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200930027.png" alt="image-20230320093041906" style="zoom:80%;" />

### 获取单个

http://127.0.0.1:3000/song/1

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200931751.png" alt="image-20230320093147657" style="zoom:80%;" />

### 新增

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200938738.png" alt="image-20230320093817619" style="zoom:80%;" />

### 删除

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200939653.png" alt="image-20230320093932529" style="zoom: 80%;" />

### 更新

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200940558.png" alt="image-20230320094056466" style="zoom:80%;" />

## 接口测试工具⭐

### 基本工具

> - apipost https://www.apipost.cn/ (中文)
> - apifox https://www.apifox.cn/ (中文)
> - postman https://www.postman.com/ (英文)

### apipost

#### 设置URL前缀

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200934314.png" alt="image-20230320093413233" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200933966.png" alt="image-20230320093308874" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200934301.png" alt="image-20230320093432184" style="zoom:80%;" />

#### 批量添加请求头

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200945767.png" alt="image-20230320094546644" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200946161.png" alt="image-20230320094633052" style="zoom:80%;" />

#### 压力测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200948802.png" alt="image-20230320094829661" style="zoom:80%;" />



# 会话控制

## 基本概念

### 会话控制

> 所谓会话控制就是对会话进行控制。HTTP 是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端， 无法区分用户。而产品中又大量存在的这样的需求，所以我们需要通过会话控制来解决该问题
> 常见的会话控制技术有三种：cookie、session、token

### 身份认证

#### 什么是身份认证

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210060927089.png" alt="image-20221006092747033" style="zoom:80%;" />

#### 为什么需要身份认证

> 身份认证的目的，是为了**确认当前所声称为某种身份的用户，确实是所声称的用户**。例如，你去找快递员取快递，你要怎么证明这份快递是你的。在互联网项目开发中，如何对用户的身份进行认证，是一个值得深入探讨的问题。例如，如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。

#### 不同开发模式下的身份认证

对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：

> ① 服务端渲染推荐使用 **Session** **认证机制**
>
> ② 前后端分离推荐使用 **JWT** **认证机制**

### 服务端渲染 VS 前后端分离

目前主流的 Web 开发模式有两种，分别是：

> ①基于**服务端渲染**的传统 Web 开发模式
>
> ②基于**前后端分离**的新型 Web 开发模式

#### 服务端渲染

> 服务端渲染的概念：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。

> ① **前端耗时少。**因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面。尤其是移动端，更省电
>
> ② **有利于SEO。**因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO
>
> ① **占用服务器端资源。**即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定访问压力
>
> ② **不利于前后端分离，开发效率低。**使用服务器端渲染，则**无法进行分工合作**，尤其对**前端复杂度高**项目

#### 前后端分离

> 前后端分离的概念：前后端分离的开发模式，**依赖于** **Ajax** **技术的广泛应用**。简而言之，前后端分离的 Web 开发模式，就是**后端只负责提供** **API** **接口，前端使用** **Ajax** **调用接口**的开发模式。

> ① **开发体验好。**前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。
>
> ② **用户体验好。**Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。
>
> ③ **减轻了服务器端的渲染压力。**因为页面最终是在每个用户的浏览器中生成的。
>
> ① **不利于** **SEO**。**因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。**
>
> ① **解决方案：利用 Vue、React 等前端框架的 **SSR（server side render）技术能够很好的解决 SEO 问题！

#### 如何选择

> **不谈业务场景而盲目选择使用何种开发模式都是耍流氓。**比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染；而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。

> 另外，具体使用何种开发模式并不是绝对的，为了**同时兼顾**了**首页的渲染速度**和**前后端分离的开发效率**，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式。

## 会话控制技术

### cookie

#### 基本概念

> Cookie 是**存储在用户浏览器中的一段不超过** **4 KB** **的字符串**。它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。不同域名下的 Cookie 各自独立，每当客户端发起请求时，会**自动**把**当前域名下**所有**未过期的** **Cookie** 一同发送到服务器。

> - cookie 是 **HTTP 服务器发送到用户浏览器并保存在本地的一小块数据**
> - cookie 是**保存在浏览器端的一小块数据**
> - cookie 是**按照域名划分保存的**

> **自动发送、域名独立、过期时限、4KB 限制**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303200956417.png" alt="image-20230320095639316" style="zoom:80%;" />

> 浏览器向服务器发送请求时，会自动将当前域名下可用的 cookie 设置在请求头中，然后传递给服务器
>
> 这个请求头的名字也叫 cookie ，所以将 cookie 理解为一个 HTTP 的请求头也是可以的

#### 运行流程

> 客户端第一次请求服务器的时候，服务器**通过响应头的形式**，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。随后，当客户端浏览器每次请求服务器的时候，浏览器会**自动**将身份认证相关的 Cookie，**通过请求头的形式**发送给服务器，服务器即可验明客户端的身份。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210060933596.png" alt="image-20221006093326536" style="zoom:80%;" />

填写账号和密码校验身份，校验通过后下发 cookie

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201013001.png" alt="image-20230320101354884" style="zoom: 50%;" />

有了 cookie 之后，后续向服务器发送请求时，就会自动携带 cookie

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201014172.png" alt="image-20230320101439056" style="zoom:50%;" />

#### 浏览器查看和操作

> 进入浏览器设置，搜索cookie，即可查看或删除网站的cookie

### session

> Cookie 不具有安全性：由于 Cookie 是存储在浏览器中的，而且**浏览器也提供了读写** **Cookie** **的** **API**，因此 **Cookie** **很容易被伪造**，不具有安全性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210060934292.png" alt="image-20221006093419238" style="zoom:80%;" />

> **注意：千万不要使用** **Cookie** **存储重要且隐私的数据**！比如用户的身份信息、密码等。

> 提高身份认证的安全性：为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以**在收银机上进行刷卡认证**。只有收银机确认存在的会员卡，才能被正常使用。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210060948578.png" alt="image-20221006094835523" style="zoom:80%;" />

> 这种“**会员卡** **+** **刷卡认证**”的设计理念，就是 Session 认证机制的精髓

#### 基本概念

> session 是保存在**服务器端**的一块儿数据，保存当前访问用户的相关信息
>
> 实现会话控制，可以识别用户的身份，快速获取当前用户的相关信息

#### 运行流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210060949931.png" alt="image-20221006094920853" style="zoom:80%;" />

> 填写账号和密码校验身份，校验通过后创建 session 信息，然后将 session_id 的值通过响应头返回给浏览器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201031133.png" alt="image-20230320103131033" style="zoom:80%;" />

> 有了 cookie，下次发送请求时会自动携带 cookie，服务器通过 cookie 中的 session_id 的值确定用户的身份

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201032051.png" alt="image-20230320103236948" style="zoom:80%;" />

### token

#### 基本概念

> token 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token 中保存着用户信息。实现会话控制，可以识别用户的身份，主要用于移动端 APP。Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，**需要做很多额外的配置**，才能实现跨域 Session 认证。

> JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。三者之间使用英文的“.”分隔，格式如下：Header.Payload.Signature。**Payload** 部分**才是真正的用户信息**，它是用户信息经过加密之后生成的字符串。Header 和 Signature 是**安全性相关**的部分，只是为了保证 Token 的安全性。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210061000384.png" alt="image-20221006100006330" style="zoom:80%;" />

#### 运行流程

> 客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是**把** **JWT** **放在** **HTTP** **请求头的** **Authorization** **字段中**，格式如下：Authorization:Bearer \<token>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210060957763.png" alt="image-20221006095729698" style="zoom:80%;" />

填写账号和密码校验身份，校验通过后响应 token，token 一般是在响应体中返回给客户端的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201102454.png" alt="image-20230320110204347" style="zoom:80%;" />

后续发送请求时，需要手动将 token 添加在请求报文中，一般是放在请求头中

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201102933.png" alt="image-20230320110240826" style="zoom:80%;" />

#### token特点

> 服务端压力更小，数据存储在客户端，相对更安全，数据加密，可以避免 CSRF（跨站请求伪造）
> 扩展性更强，服务间可以共享，增加服务节点更简单

### cookie VS session

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201059953.png" alt="image-20230320105908839" style="zoom:80%;" />

## express + cookie

> express 中可以使用 cookie-parser 进行处理,不同浏览器中的 cookie 是相互独立的，不共享

### 完整实现

```js
//导入 express
const express = require('express');

// 安装 cookie-parser  npm i cookie-parser
const cookieParser = require('cookie-parser')

//创建应用对象
const app = express();

//设置 cookieParser 中间件
app.use(cookieParser());

//设置 cookie
app.get('/set-cookie', (req, res) => {
  res.cookie('sex', 'man'); // 会在浏览器关闭的时候, 销毁
  res.cookie('name','lisi', {maxAge: 60 * 1000}) // max 最大  age 年龄 60*1000标识一分钟
  res.cookie('theme', 'blue');
  res.send('home');
});

//删除 cookie
app.get('/remove-cookie', (req, res) => {
  //调用方法
  res.clearCookie('name');
  res.send('删除成功~~');
});

//获取 cookie
app.get('/get-cookie', (req, res) => {
  //获取 cookie
  console.log(req.cookies);
  res.send(`欢迎您 ${req.cookies.name}`);
})

//启动服务
app.listen(3000, () => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
})
```

### 设置cookie

```js
//设置 cookie
app.get('/set-cookie', (req, res) => {
  res.cookie('sex', 'man'); // 会在浏览器关闭的时候, 销毁
  res.cookie('name','lisi', {maxAge: 60 * 1000}) // max 最大  age 年龄 60*1000标识一分钟
  res.cookie('theme', 'blue');
  res.send('home');
});
```

http://127.0.0.1:3000/set-cookie

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201023059.png" alt="image-20230320102358918" style="zoom:80%;" />

### 获取cookie

```js
//获取 cookie
app.get('/get-cookie', (req, res) => {
  //获取 cookie
  console.log(req.cookies);
  res.send(`欢迎您 ${req.cookies.name}`);
})
```

http://127.0.0.1:3000/get-cookie

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201026404.png" alt="image-20230320102623297" style="zoom:80%;" />

### 删除cookie

```js
//删除 cookie
app.get('/remove-cookie', (req, res) => {
  //调用方法
  res.clearCookie('name');
  res.send('删除成功~~');
});
```

http://127.0.0.1:3000/remove-cookie

## express + session

### 依赖安装

```sh
npm i connect-mongo
npm i express
npm i cookie-parser
npm i express-session
```

### 完整实现

```js
//导入 express
const express = require('express');
//2. 引入 express-session  connect-mongo
const session = require("express-session");
const MongoStore = require('connect-mongo');
//创建应用对象
const app = express();
//3. 设置 session 的中间件
app.use(session({
  name: 'sid',   //设置cookie的name，默认值是：connect.sid
  secret: 'atguigu', //参与加密的字符串（又称签名）  加盐
  saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id
  resave: true,  //是否在每次请求时重新保存session  20 分钟    4:00  4:20
  store: MongoStore.create({ // 保存位置
    mongoUrl: 'mongodb://127.0.0.1:27017/bilibili' //数据库的连接配置
  }),
  cookie: {
    httpOnly: true, // 开启后前端无法通过 JS 操作
    maxAge: 1000 * 60 * 15 // 这一条 是控制 sessionID 的过期时间的！！！，15分钟
  },
}))

//首页路由
app.get('/', (req, res) => {
  res.send('home')
})

//登录  session 的设置
app.get('/login', (req, res) => {
  // username=admin&password=admin
  if(req.query.username === 'admin' && req.query.password === 'admin'){
    //设置 session 信息
    req.session.username = 'admin';
    req.session.uid = '258aefccc';
    //成功响应
    res.send('登录成功');
  }else{
    res.send('登录失败~~');
  }
})

//session 的读取
app.get('/cart', (req, res) => {
  //检测 session 是否存在用户数据
  if(req.session.username){
    res.send(`购物车页面, 欢迎您 ${req.session.username}`)
  }else{
    res.send('您还没有登录~~');
  }
});

//session 的销毁
app.get('/logout', (req, res) => {
  req.session.destroy(() => {
    res.send('退出成功~~');
  })
})

//启动服务
app.listen(3000,() => {
  console.log('服务已经启动, 端口 3000 正在监听中....')
});
```

### 登录测试

http://127.0.0.1:3000/login?username=admin&password=admin

数据库成功找到数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201055382.png" alt="image-20230320105556245" style="zoom:80%;" />

### 读取测试

http://127.0.0.1:3000/cart

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201057721.png" alt="image-20230320105700619" style="zoom:80%;" />

### 销毁测试

http://127.0.0.1:3000/logout

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201057870.png" alt="image-20230320105744779" style="zoom:80%;" />

### 实战演练

#### 登录页面

```js
<body>
  <!-- 登录表单 -->
  <form id="form1">
    <div>账号：<input type="text" name="username" autocomplete="off" /></div>
    <div>密码：<input type="password" name="password" /></div>
    <button>登录</button>
  </form>
  <script>
    $(function () {
      // 监听表单的提交事件
      $('#form1').on('submit', function (e) {
        // 阻止默认提交行为
        e.preventDefault()
        // 发起 POST 登录请求
        $.post('/api/login', $(this).serialize(), function (res) {
          // status 为 0 表示登录成功；否则表示登录失败！
          if (res.status === 0) {
            location.href = './index.html'
          } else {
            alert('登录失败！')
          }
        })
      })
    })
  </script>
</body>
```

#### 后台主页

```js
<body>
  <h1>首页</h1>
  <button id="btnLogout">退出登录</button>
  <script>
    $(function () {
      // 页面加载完成后，自动发起请求，获取用户姓名
      $.get('/api/username', function (res) {
        // status 为 0 表示获取用户名称成功；否则表示获取用户名称失败！
        if (res.status !== 0) {
          alert('您尚未登录，请登录后再执行此操作！')
          location.href = './login.html'
        } else {
          alert('欢迎您：' + res.username)
        }
      })

      // 点击按钮退出登录
      $('#btnLogout').on('click', function () {
        // 发起 POST 请求，退出登录
        $.post('/api/logout', function (res) {
          if (res.status === 0) {
            // 如果 status 为 0，则表示退出成功，重新跳转到登录页面
            location.href = './login.html'
          }
        })
      })
    })
  </script>
</body>
```

#### app.js

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// TODO_01：请配置 Session 中间件
const session = require('express-session')
```

```js
app.use(
    session({
      secret: '12345',  // 加密字符串 随便写
      name: 'name',  // 生成session 的key名，默认为 connect.sid  可以不设置
      cookie: {maxAge: 60*1000}, // 根据cookie设置过期时间   session在浏览器中保存的时间
      resave: false,  // 强制保存session 默认为 true。建议设置成 false
      saveUninitialized: true,  // 强制将未初始化的 session 存储 默认为 true。建议设置成 true
      rolling:true  
      // 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） 建议设置true
      // 设置过期时间如果是2分钟，如果在2分钟内一直操作（访问）浏览器页面，
      // 最后一个访问结束后的2分钟在让过期
    })
)
```

```js
// 托管静态页面
app.use(express.static('./pages'))
// 解析 POST 提交过来的表单数据
app.use(express.urlencoded({ extended: false }))
```

```js
// 登录的 API 接口
app.post('/api/login', (req, res) => {
  // 判断用户提交的登录信息是否正确
  if (req.body.username !== 'admin' || req.body.password !== '000000') {
    return res.send({ status: 1, msg: '登录失败' })
  }
  // TODO_02：请将登录成功后的用户信息，保存到 Session 中
  // 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性
  // .session后面可以跟上任意字段
  req.session.user = req.body // 用户的信息
  req.session.islogin = true // 用户的登录状态
  res.send({ status: 0, msg: '登录成功' })
})
```

```js
// 获取用户姓名的接口
app.get('/api/username', (req, res) => {
  // TODO_03：请从 Session 中获取用户的名称，响应给客户端
  if (!req.session.islogin) {
    return res.send({ status: 1, msg: 'fail' })
  }
  res.send({
    status: 0,
    msg: 'success',
    username: req.session.user.username,
  })
})
```

```js
// 退出登录的接口
app.post('/api/logout', (req, res) => {
  // TODO_04：清空 Session 信息
  req.session.destroy()
  res.send({
    status: 0,
    msg: '退出登录成功',
  })
})
```

```js
// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1:80')
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210080919533.png" alt="image-20221008091942429" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210080920468.png" alt="image-20221008092007419" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210080920574.png" alt="image-20221008092047523" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210080922381.png" alt="image-20221008092212331" style="zoom:80%;" />





## express + token

运行如下命令，安装如下两个 JWT 相关的包：

```sh
npm i jsonwebtoken express-jwt
```

> - **jsonwebtoken** 用于**生成** **JWT** **字符串**
> - **express-jwt 用于将JWT 字符串解析还原成JSON对象**

### 基本语法

#### 生成token

```js
//导入 jwt
const jwt = require('jsonwebtoken');

//创建(生成) token
// let token = jwt.sign(用户数据, 加密字符串, 配置对象);
let token = jwt.sign({
  username: 'zhangsan'
}, 'atguigu', {
  expiresIn: 60, //单位是秒
})

console.log(token);
```

#### 校验token

```js
let t = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InpoYW5nc2FuIiwiaWF0IjoxNjc5MjgxNjY3LCJleHAiOjE2NzkyODE3Mjd9.qw1mAHD_zY7kO4rYZrp-NPo8Wod9igKO0_s4-OWgLx4';

//校验 token
jwt.verify(t, 'atguigu', (err, data) => {
  if(err){
    console.log('校验失败~~');
    return
  }
  console.log(data);
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303201109066.png" alt="image-20230320110917964" style="zoom:80%;" />

### 实战演练⭐

#### 功能实现

```js
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt
const jwt = require('jsonwebtoken')
const expressJWT = require('express-jwt')

// 允许跨域资源共享
const cors = require('cors')
app.use(cors())
```

```js
// 解析 post 表单数据的中间件
const bodyParser = require('body-parser')
app.use(bodyParser.urlencoded({ extended: false }))

// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey
const secretKey = 'itheima No1 ^_^'

// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件
// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上
// /^\/api\//：正则表达式，表示哪些接口不需要访问权限
app.use(expressJWT({ secret: secretKey }).unless({ path: [/^\/api\//] }))
```

```js
// 登录接口
app.post('/api/login', function (req, res) {
  // 将 req.body 请求体中的数据，转存为 userinfo 常量
  const userinfo = req.body
  // 登录失败
  if (userinfo.username !== 'admin' || userinfo.password !== '000000') {
    return res.send({
      status: 400,
      message: '登录失败！',
    })
  }
  // 登录成功
  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端
  // 参数1：用户的信息对象
  // 参数2：加密的秘钥
  // 参数3：配置对象，可以配置当前 token 的有效期
  // 记住：千万不要把密码加密到 token 字符中
  const tokenStr = jwt.sign({ username: userinfo.username }, secretKey, { expiresIn: '30s' })
  res.send({
    status: 200,
    message: '登录成功！',
    token: tokenStr, // 要发送给客户端的 token 字符串
  })
})
```

```js
// 这是一个有权限的 API 接口
app.get('/admin/getinfo', function (req, res) {
  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端
  console.log(req.user)
  res.send({
    status: 200,
    message: '获取用户信息成功！',
    data: req.user, // 要发送给客户端的用户信息
  })
})
```

```js
// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误
app.use((err, req, res, next) => {
  // 这次错误是由 token 解析失败导致的
  if (err.name === 'UnauthorizedError') {
    return res.send({
      status: 401,
      message: '无效的token',
    })
  }
  res.send({
    status: 500,
    message: '未知的错误',
  })
})
```

```js
// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(8888, function () {
  console.log('Express server running at http://127.0.0.1:8888')
})
```

#### 访问测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210081010493.png" alt="image-20221008101039407" style="zoom:80%;" />

http://127.0.0.1:8888/admin/getinfo

> w3c规定，请求头`Authorization`用于验证用户身份。这就是告诉我们，`token`应该写在请求头`Authorization`中（当然你非要写在`cookie`，`body`或者写在`url`参数中也行，只要前后端开发约定好就行，但不建议）。

> w3c还规定，`Authorization`应当写成这样的形式`Authorization: <type> <credentials>`，`type`是指认证的方式，`credentials`则是认证需要的信息。所以才有了`jwt token`的标准写法`Authorization: Bearer aaa.bbb.ccc`

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210081015750.png" alt="image-20221008101555683" style="zoom:80%;" />













