



# npm 实用技巧

## 1. npm 基本概念

> npm 全称为 Node Package Manager，是一个基于 Node.js 的包管理器，也是 Node.js 社区最流行、支持的第三方模块最多的包管理器。它的初衷就是让开发人员更容易分享和重用代码。npm 提供了命令行工具，其主要功能是管理Node.js包，包括安装、更新、删除、查看、搜索、发布等。

npm 最初只是Node.js 的包管理器，但随着前端技术的不断发展，它的定位变成了广义的包管理器，可以实现JavaScript、React、Vue、Gulp、移动开发等包管理，是目前最大、生态最为健全的包管理器。

npm 能解决 Node.js 在模块管理上的很多问题，其常见的应用场景如下：

- 从npm镜像服务器下载第三方模块；
- 从npm镜像服务器下载并安装命令行程序到本地；
- 自己发布模块到npm镜像服务器供他人使用。

npm 不需要单独安装，在安装 Node.js 时，就会连带着一起安装 npm 了。但是安装的 npm 不一定是最新的版本，可以使用以下命令来查看本地 npm 的版本：

```apl
npm -v
```

这里的 -v 是 --version 的缩写，表示版本。如果想升级 npm 版本，可以使用以下命令：

```apl
npm install npm@latest -g
```

这里@latest表示最新的版本，-g 是 --global 的缩写，表示全局安装。

除此之外，还可以使用help命令来查看npm帮助：

```apl
npm 命令 --help
```

比如查看 install 的参数形式：

```apl
npm install --help
```

其中--help可以简写为-h，上面命令的执行结果如下，可以看到install命令的很多形式：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210192308096.png" alt="image-20221019230833852" style="zoom:80%;" />

常见的npm命令：

| **命令**                                                | **作用**                                                     |
| :------------------------------------------------------ | :----------------------------------------------------------- |
| npm -v                                                  | 查看 npm 版本。                                              |
| npm init                                                | 初始化后会出现一个 package.json 配置文件。可以在后面加上 -y ，快速跳过问答式界面。 |
| npm install                                             | 根据项目中的 package.json 文件自动下载项目所需的全部依赖。   |
| npm install 包名 --save-dev(npm install 包名 -D)        | 安装的包只用于开发环境，不用于生产环境，会出现在 package.json 文件中的 devDependencies 属性中。 |
| npm install 包名 --save(npm install 包名 -S)            | 安装的包需要发布到生产环境的，会出现在 package.json 文件中的 dependencies 属性中。 |
| npm list                                                | 查看当前目录下已安装的 node 包。                             |
| npm list -g                                             | 查看全局已经安装过的 node 包。                               |
| npm --help                                              | 查看 npm 帮助命令。                                          |
| npm update 包名                                         | 更新指定包。                                                 |
| npm uninstall 包名                                      | 卸载指定包。                                                 |
| npm config list                                         | 查看配置信息。                                               |
| npm 指定命令 --help                                     | 查看指定命令的帮助。                                         |
| npm info 指定包名                                       | 查看远程 npm 上指定包的所有版本信息。                        |
| npm config set registry https://registry.npm.taobao.org | 修改包下载源，这里修改为了淘宝镜像。                         |
| npm root                                                | 查看当前包的安装路径。                                       |
| npm root -g                                             | 查看全局的包的安装路径。                                     |
| npm ls 包名                                             | 查看本地安装的指定包及版本信息，没有显示 empty。             |
| npm ls 包名 -g                                          | 查看全局安装的指定包及版本信息，没有显示 empty。             |

说完这些概念，下面就来看看 npm 在使用时有哪些实用的技巧。

## 2. 初始化 package.json

凡是使用npm管理的项目，都需要初始化一个package.json文件。

可以使用以下命令来初始化一个包：

```apl
npm init
```

当执行这个命令时，它会通过问答的形式来一步步进行设置。如果不需要修改默认的配置，直接一路回车即可。如果想跳过向导，快速生成一个package.json 文件，可以执行以下命令：

```apl
npm init --yes
```

其中，--yes可以简写为-y。这时生成的package.json文件的配置项就是 npm 的默认配置。当然这个默认配置也是可以更改的，可以通过类似下面这样的形式来修改 npm 的默认配置：

```apl
npm config set init.author.name YOUR_NAME  
npm config set init.author.email YOUR_EMAIL  
```

当执行以上命令之后，之后再执行 npm init 命令时，package.json 的作者姓名和邮箱都会初始化为我们设定的值。

## 3. 快速了解 package.json

当要使用一个包时，如果想要了解它是如何使用的，可以使用以下命令来打开这个包的主页，它会自动启动浏览器并打开这个页面，这里以React为例：

```apl
npm home react
```

如果想要查看这个包现存的issue，或者公开的roadmap，可以执行以下命令：

```apl
npm bugs react
```

如果想要查看这个包的代码地址，可以执行以下命令：

```apl
npm repo react
```

如果想要查看这个包的详细信息，可以执行以下命令：

```apl
npm info react
```

执行结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86RQ6BkesPkC3gDzrbKWEUMDmDvVJhc9u1ORviatYGb91I8qJpQE0SGcg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这里返回的是一个JavaScript对象，里面包含react模块的详细信息，可以通过info命令来获取这个对象的成员信息：

```apl
npm info react description
```

执行结果如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86fcEpQNRO3k4YnlIwExVGh2HQibgfuulVlYGLuibwicIoZQWg9fAZ3bI8Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 4. 安装依赖

可以使用npm install命令来安装需要的包，如果想把这个包自动添加到package.json中，可以执行以下命令，这里以安装React为例：

```apl
npm install react --save
```

如果想要安装不同版本的包，可以这样：

```c
// 安装最新版本
npm install react@latest
// 安装指定版本
npm install react@16.8.0
// 安装指定区间版本
npm install react@">=16.8.0 <17.0.1"
```

当使用npm安装依赖时，分为本地安装（local）和全局安装（global），它俩的区别就是是否包含-g参数：

| **命令**   | **简写** | **说明**                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 无         | 无       | 将模块安装到本地node_modules目录下，但不保存在package.json中。 |
| --save     | -S       | 将模块安装到本地node_modules目录下，同时保存到package.json中的dependencies配置项中，在生产环境下这个包的依赖依然存在。 |
| --sava-dev | -D       | 将模块安装到本地node_modules目录下，同时保存到package.json中的devDependencies配置项中，仅供开发时使用。 |
| --global   | -g       | 安装的模块为全局模块，如果命令行模块，会直接链接到环境变量中。 |

可以使用require关键字来引入本地安装的包。为了避免引用模块消失，保证依赖模块都会出现在package.json中，最好在npm install 时加上--save。

需要注意，在执行npm install命令时，npm 5 之前只会下载，不会保存依赖信息。如果需要保存，就需要加上 --save 选项， npm 5 以后就可以省略 --save 选项了，它会自动保存。

## 5. 锁定依赖

当使用--save来安装依赖时，npm 会把这个依赖保存起来，并添加^前缀，他表示，当再次执行 npm install 命令时，会自动安装这个包在此大版本下的最新版本。如果想要修改这个功能，可以执行以下命令：

```c
npm config set save-prefix='~'
```

执行完该命令之后，就会把^符号改为~符号。当再次安装新模块时，就从只允许小版本的升级变成了只允许补丁包的升级。如果想要锁定当前的版本，可以执行以下命令：

```c
npm config set save-exact true
```

这样每次 npm install xxx --save 时就会锁定依赖的版本号，相当于加了 --save-exact 参数。建议线上的应用都采用这种锁定版本号的方式。

为了彻底的锁定依赖的版本，让应用在任何机器上都安装同样的版本，可以执行以下命令：

```c
npm shrinkwrap
```

执行这个命令之后，就会在项目的根目录产生一个npm-shrinkwrap.json配置文件，这里面包含了通过node_modules 计算出的模块的依赖树及版本。只要目录下有 npm-shrinkwrap.json 则运行 npm install 时就会优先使用 npm-shrinkwrap.json 中的配置进行安装，没有则使用 package.json 进行安装。

## 6. 搜索依赖

npm 为我们提供了search 命令，用于搜索npm仓库，它搜索的参数可以是一个字符串，也可以是一个正则表达式：

```c
npm search react
```

搜索结果如下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86voDPbaLDaD0H5dE1MeEtpx9mUhO1MNghDZNUZBaYcWDL96tbz4vmdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

当然，我们也可以去node.js官网去找：https://www.npmjs.com/

想要找到一个合适的依赖包可能并不是一件容易的事。这时，可以使用网站https://npms.io/，这里将各个包的质量、受欢迎度、可维护性等指标做了量化。这些指标包括：是否使用了过时的依赖包、是否有代码检查配置、是否经过测试以及最近的版本是何时发布的等。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86C0JX4g20PTzCT6iajfDvAxU9fzZuFflUTkoznWMBM9Hw5cAJeAmx06A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

推荐使用 Openbase 搜索合适的包：https://openbase.com/

## 7. 更新、卸载依赖

npm 为我们提供了更新依赖版本的命令：

```c
npm update [package name]
```

如果想要更新全局安装的模块，需要添加参数 -global：

```c
npm update -global [package name]
```

当执行这两个命令时，它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。

如果想要更新该依赖包在package.json中的版本，就需要使用-S或者--save参数。需要注意的是，从npm v2.6.1 开始，npm update只会更新顶层的模块，而不更新依赖的依赖模块，而之前的版本是递归更新的。如果想要这种效果，可以使用以下命令：

```c
npm --depth 9999 update
```

除了可以更新包之外，还可以删除指定的包：

```c
npm uninstall [package name]
```

如果想要删除全局的包，需要添加参数 -global：

```c
npm uninstall [package name] -global
```

### 8. 查找过时的包

npm 提供了一个命令来查看过时的依赖：

```c
npm outdated
```

在项目中执行该命令，输出结果如下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86wU7a1NhpgHDia3ibN7bKGCMibhkCviahlDuQkUy3BhWVqDrdFO90duUibuQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

可以看到，这里列出了过时依赖的包名称、当前的版本、希望的版本、最新的版本、依赖在本地路径、依赖这个包的项目名称。

可以通过以下命令来检查npm包的最新版本：

```c
// 展示包的信息
npm view <package-name>  
npm v <package-name>
// 展示最新版本
npm v <package-name> version
// 展示所有版本
npm v <package-name> versions
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm866TMMZYpcZSSvsKZpMIDfaLNt8ib0PAo3J128rNVmON1qwb4ByKNMGTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 9. 执行脚本

npm 不仅可以用于管理模块，还可以用于执行脚本。在package.json文件中有一个scripts字段，可以用于定义脚本命令，功npm 使用。我们除了可以在package.json文件中查看有哪些命令，也可以使用以下命令来查看所有脚本命令：

```
npm run
```

在项目中执行该命令之后的结果如下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86PMdwxyQuLsUXlqP8AyCKXOKvlme7jQRjiafOCRtBouvbicXlLjCT3QYA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

可以看到，这里定义了dev、build、build:test等命令，如果需要执行这些命令，只要这样执行即可：

```
npm run dev
npm run build
```

这里不在多说，这或许是我们平时用的最多的命令了，可以根据实际开发情况，来定制自己的npm命令。

## 10. 安装可靠的依赖

可以使用 npm ci 命令来清理、安装依赖项。它通常用于CI/CD等自动化环境，使用它可以获得可靠的依赖。

```
npm ci
```

当执行该命令时，它会先删除本地的node_modules文件，因此它不需要去校验已下载文件版本与控制版本的关系，也不用校验是否存在最新版本的库，所以下载的速度相比npm install会更快。之后它会按照 package-lock.json 文件来安装确切版本的依赖项。并且不会将这个版本写入package.json或者package-lock.json文件。

使用该命令时，需要注意：

- 项目必需有 package-lock.json 或 npm-shrinkwrap.json 文件，如果没有，该命令将不起作用；
- npm ci 是 npm v6 中引入了的新命令，所以使用该命令时需要确保npm版本要>=5.7；
- npm ci 不能用来安装单个依赖，只能用来安装整个项目的依赖；
- npm ci 会安装 dependencies 和 devDependencies；
- 整个安装过程不会更新 package.json 或 package-lock.json 文件，整个安装过程是锁死的；
- 当package-lock.json中的依赖和package.json中不一致时，npm ci 会退出但不会修改package-lock.json文件。

## 11. 删除重复的包

我们可以通过运行npm dedupe命令来删除重复的依赖项。该命令通过删除重复包并在多个依赖包之间共享公共依赖项来简化整体的结构。它会产生一个扁平的、去重的树。

```c
npm dedupe
npm ddp
```

## 12. 扫描漏洞

可以运行 npm audit 命令来扫描项目，来查找所有依赖项中存在的漏洞：

```c
npm audit
```

下面是扫描结果：

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm867pq29kTZJ6hJmEEowvVpcrwHbSJNUHL1Nv4MYjtzkoHibzBIL88mggQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

可以运行以下命令来自动安装所有易受攻击包的补丁版本：

```c
npm audit fix
```

## 13. 查看已安装的包

可以通过以下命令来获取整个项目的包信息：

```c
npm list
```

npm list 命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86QyuvyCOHAEWmffVqTG4vYFSkLB396G6sH1sVj5La5QfWuMLbpBt3ag/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

如果加上global参数，就会列出全局安装的模块：

```c
npm list -global
```

也可以查看指定包的依赖，比如在我现在做的项目下，执行以下命令：

```c
npm list react
```

还可以使用npm ls 命令来查看指定包的依赖信息：

```c
npm ls react
```

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMPZVYR6o9S0lr9k0G0RJm86nibcvnzibKAeFYtoXf59reQZKGriaRcKSlHAdEAdtm4F4VSCiccUe5hichg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

可以使用`--depth`参数来限制搜索的深度：

```c
npm ls --depth=1
```

## 14. 测试本地包

当我们在本地开发npm模块时，可以使用npm link命令来将本地的npm模块连接到对用的项目中去，便于对模块进行调试和测试。使用方式也很简单，在项目中执行以下命令：

```c
npm link
```

执行完该命令之后，就会为这个npm包创建到全局，路径是` {prefix}/lib/node_modules/<package>`，它是一个快捷方式。之后我们就可以使用以下命令来在需要这个模块的项目中链接这个包：

```c
npm link 模块名
```

这里的**模块名**就是依赖包的名称，也就是模块包的package.json文件中的name字段值。

如果不想继续使用了，执行以下命令来解除link即可：

```c
npm unlink 模块名
```



## 15. npm 有趣的用法

### 1、 npm 添加 === npm 安装

如果你尝试在 npm 官方文档中搜索 npm add 命令，你会发现这个命令似乎根本不存在，如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210271536917.png" alt="image-20221027153652830" style="zoom:50%;" />

但是我们确实可以在终端上使用这个命令：

```
$ npm add lodash
```

实际上，npm add 是 npm install 的别名之一。所以当我们使用 npm add 时，完全等同于为 npm 执行 npm install ！

同样，npm i 也是 npm install 的别名。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210271537608.png" alt="image-20221027153716539" style="zoom:50%;" />

### 2、npm instal ? 没关系

细心的读者可能已经发现，上面副标题中的安装是这个词的拼写错误。但它确实有效。

```
$ npm instal lodash
```

其实这是 npm 8.x 版本的一个新特性，叫做容错设计。如果用户不小心拼错了一个单词，NPM 仍然可以正常工作。

所以在 8.x 版本中，npm install 得到了 9 个别名，分别是：

```
in, ins, inst, insta, instal, isnt, isnta, isntal, isntall
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210271537947.png" alt="image-20221027153748883" style="zoom:50%;" />

### 3、每个脚本执行前后执行额外的动作

假设我们有一个名为 greet 的脚本：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210271540102.png" alt="image-20221027154014044" style="zoom:67%;" />

现在我们想要：

- 在greet执行之前输出一些东西：在greet之前做一些事情；
- 在greet执行后输出一些东西：在greet之后做一些事情。

那么我们应该怎么做呢？

我们可以添加一个 pregreet 脚本和一个 postgreet 脚本，这是 NPM 的机制，以 pre 和 post 开头的脚本被视为特殊脚本。

<img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcYR41M2b4Gcw0TFhz9okB55GYGvTNZGvrjvZBwyKbHZcvNv4Q6y5AlhnfVsVcjkAkaAsyceBtnPkQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />

![图片](https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcYR41M2b4Gcw0TFhz9okB5580E3CRiaFX88fmWBJ7szXvcqZBmGA9tZkPYNbXIOEUpiatL8d5y3Go5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这种机制经常在项目自动部署时使用。

### **4、使用 npm link 安装一些终端命令**

如果您在项目的 package.json 中定义 bin 属性并将其指向可执行脚本文件。

package.json :

```js
{  
    "name": "npm-test",  
    "bin": {   
        "hello-npm-1": "./build/hello.sh"  
     }
}
```

hello.sh :

```sh
echo "hello npm"
```

然后我们可以使用 npm link 将它安装到 shell 命令中：

![图片](https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcYR41M2b4Gcw0TFhz9okB55NckBm4wyKqibaDGeo6wiatuxZOdKJTQLlkUpcvp6euhf44dibQ7qQ9lgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

图中：

<img src="https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcYR41M2b4Gcw0TFhz9okB553WiaJDK5VxaLKXeib7atvqOkqezAiczicj0dcawQiad8NWaNgzRNLibRvbzg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

这就是在您的计算机上安装 create-react-app 和 vue-cli 的方式。

## 16. 选择第三方 NPM 包的最佳实践

每个开发人员都使用过 `npm install` 安装依赖。截止目前 NPM 平台上已经托管超过 190w 个包了，面对茫茫多的 package，在选择第三方 NPM 包时应该关注些什么？

- 检查开源许可证
- 看贡献频率和下载量
- 权衡包体积大小
- 是否有大型开发团队在进行维护
- 评估安全性

在做选择时，我们最好能根据以上维度产出一份调研文档，并在团队内分享和讨论，最终得出一致的结论。

### 1. 检查开源许可证（License）

开源许可证是一种法律许可。通过它，版权拥有人明确允许，用户可以免费地使用、修改、共享版权软件。

版权法默认禁止共享，也就是说，没有许可证的软件，就等同于保留版权，虽然开源了，用户只能看看源码，不能用，一用就会侵犯版权。所以软件开源的话，必须明确地授予用户开源许可证。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241622320.png" alt="image-20221124162227253" style="zoom:80%;" />

> 可以在 NPM 平台上查看包的 License

License 通常分两大类："CopyLeft（**著佐权**）" 和 "Permissive（**宽松式**）"：

- CopyLeft：如果你使用了这个包，那么你的代码也必须开源。这对一些商业化的项目不太友好，如 GPL 和 LGPL 协议
- Permissive：对包做了最低限度的使用限制，允许闭源，可以说几乎没有限制，但是各自又有一些区别，具体下图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241623137.png" alt="image-20221124162322046" style="zoom:80%;" />

我们可以用 **license-checker**工具来一次性检查项目中的 NPM 包是否都是合规的。

### 2. 看贡献频率和下载量

NPM 平台也可以查看包的每周下载量和趋势图，数字越大意味着使用的人越多。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241623096.png" alt="image-20221124162338036" style="zoom:80%;" />

由于社区里有很多功能类似的包，比如 `moment.js` 和 `dayjs` 这类时间日期库。**NPM trends** 可以同时比较多个包的下载量增长趋势，从而更直观地了解它们的受欢迎程度。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241623984.png" alt="image-20221124162353909" style="zoom:80%;" />

> 另外，GitHub 仓库的 stars、 forks、 commit frequency 和 contributors 等相关指标也可以侧面反映受欢迎程度。

### 3. 权衡包体积大小

对于前端来说，优化性能最直接的手段就是**降低代码包大小**。所以选择第三方包时，也要考虑它的包体积。

**bundlephobia** 可以对包体积进行可视化分析。从下图可以看出，`moment.js` 打包后会有将近 300 kB，gzip 压缩后会有 70kB。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241624776.png" alt="image-20221124162422702" style="zoom:80%;" />

而 `dayjs` 打包后只有 **6 kB**，远小于 `moment.js`。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241624445.png" alt="image-20221124162442374" style="zoom:80%;" />

对于像微信小程序这样对代码包大小有明确限制的项目来说，轻量级的 `dayjs` 是更好的选择。

### 4. 是否有大型团队在进行维护

尽管大部分的 NPM 包都包含较全的文档，但是往往也都存在一些兼容性、JS 异常或性能相关的 issue。因此如果背后有大型团队在进行维护，我们使用起来会更放心。可以关注以下几个方面：

#### Used By 和 Contributors 数量

数量越多意味着你不是早期用户，很多开发者已经帮你趟过水了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241624699.png" alt="image-20221124162459614" style="zoom:80%;" />

#### Contributors 视图

可以直观地看到贡献者的贡献频率，如果很多都频繁贡献，意味着仓库受到社区更多的关注和支持。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241625744.png" alt="image-20221124162515661" style="zoom:80%;" />

#### Community Standards

将仓库与开源社区的规范标准进行比较，达到的标准越多意味着这个仓库越成熟。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241625905.png" alt="image-20221124162532829" style="zoom:80%;" />

### 5. 评估安全性

包安全性是选择 NPM 包的另一个关键因素，在仓库的「**Security**」tab 下可以看到它的安全策略。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241625486.png" alt="image-20221124162547428" style="zoom:80%;" />

如果维护者已经采取了措施来确保安全性，会显示**已激活**。

> 对于项目中已有的 NPM 依赖，可以使用命令 `npm audit` 来进行安全性检查。

**npmgraph** 能够对包进行依赖可视化分析来确保没有安全漏洞，然后再安装到项目当中。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241626780.png" alt="image-20221124162605692" style="zoom:80%;" />





# Node + MySQL

> ①安装操作 MySQL 数据库的第三方模块（mysql）
>
> ②通过 mysql 模块连接到 MySQL 数据库
>
> ③通过 mysql 模块执行 SQL 语句

## 安装和配置mysql模块

### 安装 mysql 模块

```sh
# 两个功能一样，但是mysql2更新
npm install mysql
npm install mysql2
```

### 配置mysql 模块

> 在使用 mysql 模块操作 MySQL 数据库之前，必须先对 mysql 模块进行必要的配置，主要的配置步骤如下：

```js
// 1. 导入 mysql 模块
const mysql = require('mysql2')
// 2. 建立与 MySQL 数据库的连接关系
const db = mysql.createPool({
  host: '127.0.0.1', // 数据库的 IP 地址
  port:'3307',
  user: 'root', // 登录数据库的账号
  password: '123456', // 登录数据库的密码
  database: 'xuexi', // 指定要操作哪个数据库
})
```

### **测试** **mysql** **模块能否正常工作**

> 调用 db.query() 函数，指定要执行的 SQL 语句，通过回调函数拿到执行的结果：

```js
// 测试 mysql 模块能否正常工作
db.query('select 1', (err, results) => {
  // mysql 模块工作期间报错了
  if(err) return console.log(err.message)
  // 能够成功的执行 SQL 语句
  console.log(results)
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071222514.png" alt="image-20221007122214425" style="zoom: 80%;" />

## 增删改查

### 查询数据

> 查询 users 表中所有的数据：

```js
// 查询 users 表中所有的数据
const sqlStr = 'select * from user'
db.query(sqlStr, (err, results) => {
  // 查询数据失败
  if (err) return console.log(err.message)
  // 查询数据成功
  // 注意：如果执行的是 select 查询语句，则执行的结果是数组
  console.log(results)
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071226926.png" alt="image-20221007122602833" style="zoom:80%;" />

### 插入数据

> 向 users 表中新增数据， 其中 username 为 Spider-Man，password 为 pcc321。示例代码如下：

#### 直接插入

```js
// 向 users 表中，新增一条数据，其中 username 的值为 Spider-Man，password 的值为 pcc123
const user = { name: 'Spider-Man2', password: 'pcc4321', gender: '1', phone:'110' }
// 定义待执行的 SQL 语句
const sqlStr = 'insert into user (id,name,password,gender,phone) values (null, ?, ?, ?, ?)'
// 执行 SQL 语句
db.query(sqlStr, [user.name, user.password,user.gender ,user.phone], (err, results) => {
  // 执行 SQL 语句失败了
  if (err) return console.log(err)
  // 成功了
  // 注意：如果执行的是 insert into 插入语句，则 results 是一个对象
  // 可以通过 affectedRows 属性，来判断是否插入数据成功
  if (results.affectedRows === 1) {
    console.log('插入数据成功!')
  }
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071241819.png" alt="image-20221007124154728" style="zoom:80%;" />

#### 简化插入

> 向表中新增数据时，如果数据对象的每个属性和数据表的字段**一一对应**，则可以通过如下方式快速插入数据：

```js
// 演示插入数据的便捷方式
// 要插入表的数据对象
const user = { name: 'Spider-Man2', password: 'pcc4321', gender: '1', phone:'110' }
// 定义待执行的 SQL 语句，其中英文问号表示占位符
const sqlStr = 'insert into user set ?'
// 执行 SQL 语句，直接将对象当成占位符的值
db.query(sqlStr, user, (err, results) => {
  if (err) return console.log(err)
  if (results.affectedRows === 1) {
    console.log('插入数据成功')
  }
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071238631.png" alt="image-20221007123837541" style="zoom:80%;" />

### 更新数据

#### 直接更新

> 可以通过如下方式，更新表中的数据：

```js
// 演示如何更新用户的信息
const user = { id: 18, name: 'zhangsan', password: '000' }
// 定义 SQL 语句
const sqlStr = 'update user set name=?, password=? where id=?'
// 执行 SQL 语句
db.query(sqlStr, [user.name, user.password, user.id], (err, results) => {
  if (err) return console.log(err)
  // 注意：执行了 update 语句之后，执行的结果，也是一个对象，可以通过 affectedRows 判断是否更新成功
  if (results.affectedRows === 1) {
    console.log('更新成功')
  }
})
```

#### 简化更新

> 更新表数据时，如果数据对象的每个属性和数据表的字段**一一对应**，则可以通过如下方式快速更新表数据：

```js
// 演示更新数据的便捷方式
const user = { id: 18, name: 'aaaa', password: '0000' }
// 定义 SQL 语句
const sqlStr = 'update user set ? where id=?'
// 执行 SQL 语句
db.query(sqlStr, [user, user.id], (err, results) => {
  if (err) return console.log(err.message)
  if (results.affectedRows === 1) {
    console.log('更新数据成功')
  }
})
```



### 删除数据

> 在删除数据时，推荐根据 id 这样的唯一标识，来删除对应的数据。示例如下：

```js
// 删除 id 为 15 的用户
const sqlStr = 'delete from user where id=?'
db.query(sqlStr, 15, (err, results) => {
  if (err) return console.log(err)
  // 注意：执行 delete 语句之后，结果也是一个对象，也会包含 affectedRows 属性
  if (results.affectedRows === 1) {
    console.log('删除数据成功')
  }
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071227700.png" alt="image-20221007122758615" style="zoom:80%;" />

### 标记删除

> 使用 DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，**推荐使用**标记删除的形式，来**模拟删除的动作**。所谓的标记删除，就是在表中设置类似于 **status** 这样的**状态字段**，来**标记**当前这条数据是否被删除。
>
> 当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应的 status 字段标记为删除即可。

```sql
alter table user add column status int(1) default 0;
```

```js
// 标记删除，用update代替delete，只是更新数据，并不去删除内容
const sqlStr = 'update user set status=? where id=?'
db.query(sqlStr, [1, 4], (err, results) => {
  if (err) return console.log(err)
  if (results.affectedRows === 1) {
    console.log('标记删除成功')
  }
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202210071232728.png" alt="image-20221007123218616" style="zoom:80%;" />

## MySQL访问示例

### 搭建项目基本结构

在当前文件夹的terminal输入

```sh
npm init -y
```

这样就能在当前文件夹生成package.json文件，可以方便下载和安装依赖

进入package.json，新增字段，就能实现ES6语法使用了

```json
"type": "module"
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202209270929118.png" alt="image-20220927092927045" style="zoom:80%;" />

安装依赖

```sh
npm install express@4.17.1 mysql2@2.2.5
```

### 创建基本的服务器

```js
import express from 'express'
import userRouter from './router/user_router.js'
const app = express()

app.use('/api', userRouter)

app.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```

### 创建 db 数据库操作模块

```js
import mysql from 'mysql2'

const pool = mysql.createPool({
  host: '127.0.0.1',
  port: 3307,
  database: 'xuexi',
  user: 'root',
  password: '123456',
})

export default pool.promise()
```

### 创建 user_ctrl 模块

```js
import db from '../db/index.js'

// 使用 ES6 的按需导出语法，将 getAllUser 方法导出出去
export async function getAllUser(req, res) {
  try {
    const [rows] = await db.query('select * from user')
    res.send({
      status: 0,
      message: '获取用户列表数据成功！',
      data: rows,
    })
  } catch (err) {
    res.send({
      status: 1,
      message: '获取用户列表数据失败！',
      desc: err.message,
    })
  }
}
```

### 创建 user_router 模块

```js
import express from 'express'
import { getAllUser } from '../controller/user_ctrl.js'

const router = new express.Router()
router.get('/user', getAllUser)

export default router
```

### 导入并挂载路由模块

```js
import express from 'express'
import userRouter from './router/user_router.js'
const app = express()

app.use('/api', userRouter)

app.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```

### 访问测试

> 进入app.js，启动app.js，访问http://127.0.0.1/api/user

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.10.30/202209271051978.png" alt="image-20220927105134913" style="zoom:80%;" />

# Node + MongoDB

## MongoDB概述

### 什么是 MongoDB

> MongoDB 是一个基于分布式文件存储的数据库，官方地址 https://www.mongodb.com/
>
> 数据库（DataBase）是按照数据结构来组织、存储和管理数据的应用程序
>
> 数据库的主要作用就是管理数据，对数据进行增（c）、删（d）、改（u）、查（r）

> 相比于纯文件管理数据，数据库管理数据有如下特点：速度更快、扩展性更强、安全性更强

### 核心概念

> 数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存放很多集合
>
> 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档
>
> 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191609300.png" alt="image-20230319160901070" style="zoom:80%;" />

### 应用场景

> 新增：用户注册、发布视频、发布商品、发朋友圈、发评论、发微博、发弹幕
>
> 删除：删除评论、删除商品、删除文章、删除视频、删除微博
>
> 更新：更新个人信息、修改商品价格、修改文章内容
>
> 查询：商品列表、视频列表、朋友圈列表、微博列表、搜索功能

### JSON VS MongoDB

> 大家可以通过 JSON 文件来理解 Mongodb 中的概念。一个 JSON 文件好比是一个数据库，一个 Mongodb 服务下可以有 N 个数据库。JSON 文件中的一级属性的数组值好比是集合
>
> 数组中的对象好比是文档，对象中的属性有时也称之为字段。一般情况下：一个项目使用一个数据库，一个集合会存储同一种类型的数据

```json
{
  "accounts": [
    {
       "id": "3-YLju5f3",
       "title": "买电脑",
       "time": "2023-02-08",
       "type": "-1",
       "account": "5500",
       "remarks": "为了上网课"
    }
],
   "users":[
    {
       "id": 1,
       "name": "zhangsan",
       "age": 18
     },
     {
       "id": 2,
       "name": "lisi",
       "age": 20
      }
   ]
}
```

## 命令行交互

CMD窗口输入mongo，进入命令行

### 数据库命令

```sql
-- 显示所有的数据库
show dbs
-- 切换到指定的数据库，如果数据库不存在会自动创建数据库
use 数据库名
-- 显示当前所在的数据库
db
-- 删除当前数据库
use 库名
db.dropDatabase()
```

### 集合命令

```sql
-- 创建集合
db.createCollection('集合名称')
-- 显示当前数据库中的所有集合
show collections
-- 删除某个集合
db.集合名.drop()
-- 重命名集合
db.集合名.renameCollection('newName')
```

### 文档命令

```sql
-- 插入文档
db.集合名.insert(文档对象);
-- 查询文档，查询条件可以没有，_id 是 mongodb 自动生成的唯一编号，用来唯一标识文档
db.集合名.find(查询条件)
-- 更新文档
db.集合名.update(查询条件,新的文档)
db.集合名.update({name:'张三'},{$set:{age:19}})
-- 删除文档
db.集合名.remove(查询条件)
```

```sql
db.users.insert({name:'任硕',age:22})
db.users.insert({name:'任硕1',age:33})
db.users.find()
db.users.find({age:22})
db.users.update({name:'任硕'},{name:'张三',age:25})
db.users.update({name:'任硕1'},{$set:{age:25}})
db.users.remove({name:'张三'})
```

## Mongoose

> Mongoose 是一个对象文档模型库，官网 http://www.mongoosejs.net/，方便使用代码操作 mongodb 数据库

### 连接数据库

```js
//1. 安装 mongoose
//2. 导入 mongoose
const mongoose = require('mongoose');

//设置 strictQuery 为 true
mongoose.set('strictQuery', true);

//3. 连接 mongodb 服务                        数据库的名称
mongoose.connect('mongodb://127.0.0.1:27017/bilibili');

//4. 设置回调
// 设置连接成功的回调  once 一次   事件回调函数只执行一次
mongoose.connection.once('open', () => {
  console.log('连接成功');
  // app.listen(8080);
});

// 设置连接错误的回调
mongoose.connection.on('error', () => {
  console.log('连接失败');
});

//设置连接关闭的回调
mongoose.connection.on('close', () => {
  console.log('连接关闭');
});

//关闭 mongodb 的连接
setTimeout(() => {
  mongoose.disconnect();
}, 2000)
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191717205.png" alt="image-20230319171744046" style="zoom:80%;" />

### 创建文档并插入数据

```js
//1. 安装 mongoose
//2. 导入 mongoose
const mongoose = require('mongoose');

//设置 strictQuery 为 true
mongoose.set('strictQuery', true);

//3. 连接 mongodb 服务                        数据库的名称
mongoose.connect('mongodb://127.0.0.1:27017/bilibili');

//4. 设置回调
// 设置连接成功的回调  once 一次   事件回调函数只执行一次
mongoose.connection.once('open', () => {
  //5. 创建文档的结构对象
  //设置集合中文档的属性以及属性值的类型
  let BookSchema = new mongoose.Schema({
    name: String,
    author: String,
    price: Number
  });

  //6. 创建模型对象  对文档操作的封装对象
  let BookModel = mongoose.model('books', BookSchema);

  //7. 新增
  BookModel.create({
    name: '西游记',
    author: '吴承恩',
    price: 19.9
  }, (err, data) => {
    //判断是否有错误
    if(err) {
      console.log(err);
      return;
    }
    //如果没有出错, 则输出插入后的文档对象
    console.log(data);
    //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
    mongoose.disconnect();
  });
});

// 设置连接错误的回调
mongoose.connection.on('error', () => {
  console.log('连接失败');
});

//设置连接关闭的回调
mongoose.connection.on('close', () => {
  console.log('连接关闭');
});
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191719869.png" alt="image-20230319171907686" style="zoom:80%;" />

### 字段类型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191623138.png" alt="image-20230319162307955" style="zoom:80%;" />

```js
//1. 安装 mongoose
//2. 导入 mongoose
const mongoose = require('mongoose');

//设置 strictQuery 为 true
mongoose.set('strictQuery', true);

//3. 连接 mongodb 服务                        数据库的名称
mongoose.connect('mongodb://127.0.0.1:27017/bilibili');

//4. 设置回调
// 设置连接成功的回调  once 一次   事件回调函数只执行一次
mongoose.connection.once('open', () => {
  //5. 创建文档的结构对象
  //设置集合中文档的属性以及属性值的类型
  let BookSchema = new mongoose.Schema({
    name: String,
    author: String,
    price: Number,
    is_hot: Boolean,
    tags: Array,
    pub_time: Date,
    test: mongoose.Schema.Types.Mixed // 文档 ID
  });

  //6. 创建模型对象  对文档操作的封装对象
  let BookModel = mongoose.model('books', BookSchema);
  //7. 新增
  BookModel.create({
    name: '西游记',
    author: '吴承恩',
    price: 19.9,
    is_hot: true,
    tags: ['鬼怪','励志','社会'],
    pub_time: new Date(),
    test: new Date()
  }, (err, data) => {
    //判断是否有错误
    if(err) {
      console.log(err);
      return;
    }
    //如果没有出错, 则输出插入后的文档对象
    console.log(data);
    //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
    mongoose.disconnect();
  });
});

// 设置连接错误的回调
mongoose.connection.on('error', () => {
  console.log('连接失败');
}); 

//设置连接关闭的回调
mongoose.connection.on('close', () => {
  console.log('连接关闭');
}); 
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191720500.png" alt="image-20230319172033314" style="zoom:80%;" />

### 字段值验证

Mongoose 有一些内建验证器，可以对字段值进行验证

#### 必填项

```ts
title: {
   type: String,
   required: true // 设置必填项
},
```

#### 默认值

```ts
author: {
   type: String,
   default: '匿名' //默认值
},
```

#### 枚举值

```ts
gender: {
   type: String,
   enum: ['男','女'] //设置的值必须是数组中的
},
```

#### 唯一值

```js
username: {
  type: String,
  unique: true
},
```

> unique 需要重建集合才能有效果，永远不要相信用户的输入

```js
//1. 安装 mongoose
//2. 导入 mongoose
const mongoose = require('mongoose');

//设置 strictQuery 为 true
mongoose.set('strictQuery', true);

//3. 连接 mongodb 服务                        数据库的名称
mongoose.connect('mongodb://127.0.0.1:27017/bilibili');

//4. 设置回调
// 设置连接成功的回调  once 一次   事件回调函数只执行一次
mongoose.connection.once('open', () => {
  //5. 创建文档的结构对象
  //设置集合中文档的属性以及属性值的类型
  let BookSchema = new mongoose.Schema({
    name: {
      type: String,
      required: true, // 表明该属性必须不为空
      unique: true// 设置为独一无二的
    },
    author: {
      type: String,
      default: '匿名'
    },
    //类型
    style: {
      type: String,
      //枚举
      enum: ['言情','城市','志怪','恐怖']
    },
    price: Number
  });

  //6. 创建模型对象  对文档操作的封装对象
  let BookModel = mongoose.model('books', BookSchema);

  //7. 新增
  BookModel.create({
    name: '西游记',
    // author: '吴承恩',
    price: 19.9,
    style: '志怪'
  }, (err, data) => {
    //判断是否有错误
    if(err) {
      console.log(err);
      // console.log('插入失败~~~');
      return;
    }
    //如果没有出错, 则输出插入后的文档对象
    console.log(data);
    //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
    mongoose.disconnect();
  });
});

// 设置连接错误的回调
mongoose.connection.on('error', () => {
  console.log('连接失败');
});

//设置连接关闭的回调
mongoose.connection.on('close', () => {
  console.log('连接关闭');
});
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191721964.png" alt="image-20230319172128779" style="zoom:80%;" />

## CURD

> 数据库的基本操作包括四个，增加（create），删除（delete），修改（update），查（read）

### 准备数据

```js
//1. 安装 mongoose
//2. 导入 mongoose
const mongoose = require('mongoose');

//设置 strictQuery 为 true
mongoose.set('strictQuery', true);

//3. 连接 mongodb 服务                        数据库的名称
mongoose.connect('mongodb://127.0.0.1:27017/bilibili');

//4. 设置回调
// 设置连接成功的回调  once 一次   事件回调函数只执行一次
mongoose.connection.once('open', () => {
  //5. 创建文档的结构对象
  //设置集合中文档的属性以及属性值的类型
  let BookSchema = new mongoose.Schema({
    name: String,
    author: String,
    price: Number,
    is_hot: Boolean
  });

  //6. 创建模型对象  对文档操作的封装对象    mongoose 会使用集合名称的复数, 创建集合
  let BookModel = mongoose.model('novel', BookSchema);

  //7. 新增
  BookModel.insertMany([{
    name: '西游记',
    author: '吴承恩',
    price: 19.9,
    is_hot: true
  }, {
    name: '红楼梦',
    author: '曹雪芹',
    price: 29.9,
    is_hot: true
  }, {
    name: '三国演义',
    author: '罗贯中',
    price: 25.9,
    is_hot: true
  }, {
    name: '水浒传',
    author: '施耐庵',
    price: 20.9,
    is_hot: true
  }, {
    name: '活着',
    author: '余华',
    price: 19.9,
    is_hot: true
  }, {
    name: '狂飙',
    author: '徐纪周',
    price: 68,
    is_hot: true
  }, {
    name: '大魏能臣',
    author: '黑男爵',
    price: 9.9,
    is_hot: false
  },
  {
    name: '知北游',
    author: '洛水',
    price: 59,
    is_hot: false
  },{
    name: '道君',
    author: '跃千愁',
    price: 59,
    is_hot: false
  },{
    name: '七煞碑',
    author: '游泳的猫',
    price: 29,
    is_hot: false
  },{
    name: '独游',
    author: '酒精过敏',
    price: 15,
    is_hot: false
  },{
    name: '大泼猴',
    author: '甲鱼不是龟',
    price: 26,
    is_hot: false
  },
  {
    name: '黑暗王者',
    author: '古羲',
    price: 39,
    is_hot: false
  },
  {
    name: '不二大道',
    author: '文刀手予',
    price: 89,
    is_hot: false
  },
  {
    name: '大泼猴',
    author: '甲鱼不是龟',
    price: 59,
    is_hot: false
  },
  {
    name: '长安的荔枝',
    author: '马伯庸',
    price: 45,
    is_hot: true
  },
  {
    name: '命运',
    author: '蔡崇达',
    price: 59.8,
    is_hot: true
  },
  {
    name: '如雪如山',
    author: '张天翼',
    price: 58,
    is_hot: true
  },
  {
    name: '三体',
    author: '刘慈欣',
    price: 23,
    is_hot: true
  },
  {
    name: '秋园',
    author: '杨本芬',
    price: 38,
    is_hot: true
  },
  {
    name: '百年孤独',
    author: '范晔',
    price: 39.5,
    is_hot: true
  },
  {
    name: '在细雨中呼喊',
    author: '余华',
    price: 25,
    is_hot: true
  },], (err, data) => {
    //判断是否有错误
    if (err) {
      console.log(err);
      return;
    }
    //如果没有出错, 则输出插入后的文档对象
    console.log(data);
    //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
    mongoose.disconnect();
  });

});

// 设置连接错误的回调
mongoose.connection.on('error', () => {
  console.log('连接失败');
});

//设置连接关闭的回调
mongoose.connection.on('close', () => {
  console.log('连接关闭');
});
```

### 增加

插入一条

```js
BookModel.create({
  name: '西游记',
  // author: '吴承恩',
  price: 19.9,
  style: '志怪'
}, (err, data) => {
  //判断是否有错误
  if(err) {
    console.log(err);
    return;
  }
  //如果没有出错, 则输出插入后的文档对象
  console.log(data);
  //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
  mongoose.disconnect();
});
```

批量插入

```js
BookModel.insertMany(
    [
     {
        name: '西游记',
        author: '吴承恩',
        price: 19.9
      },
      {
        name: '西游记1',
        author: '吴承恩1',
        price: 29.9
      }
    ],(err, data) => {
        //判断是否有错误
        if(err) throw err;
        //如果没有出错, 则输出插入后的文档对象
        console.log(data);
        //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
        mongoose.connection.close();
    }
);
```

### 删除

删除一条数据

```js
BookModel.deleteOne({_id: '63f34af50cf203761ede1892'}, (err, data) => {
  if(err){
    console.log('删除失败~~~');
    return;
  }
  console.log(data);
});
```

批量删除

```js
BookModel.deleteMany({is_hot: false}, (err, data) => {
  if(err){
    console.log('删除失败~~~');
    return;
  }
  console.log(data);
});
```

### 更新

更新一条

```js
BookModel.updateOne({name: '红楼梦'}, {price: 9.9}, (err, data) => {
  if(err) throw err;
  //输出 data
  console.log(data);
});
```

批量更新

```js
BookModel.updateMany({author: '余华'}, {is_hot: true}, (err, data) => {
  if(err) throw err;
  console.log(data);
});
```

### 查询

查询一条

```js
BookModel.findOne({name: '狂飙'}, (err, data) => {
  if(err){
    console.log('读取失败~~~');
    return;
  }
  //输出 data 变量的值
  console.log(data);
})
```

根据ID查询

```js
BookModel.findById('63f34af50cf203761ede1896', (err, data) => {
  if (err) {
    console.log('读取失败~~~');
    return;
  }
  //输出 data 变量的值
  console.log(data);
})
```

批量查询

```js
BookModel.find({ author: '余华' }, (err, data) => {
  if (err) {
    console.log('读取失败~~~');
    return;
  }
  //输出 data 变量的值
  console.log(data);
});
```

查询所有

```js
BookModel.find((err, data) => {
  if (err) {
    console.log('读取失败~~~');
    return;
  }
  //输出 data 变量的值
  console.log(data);
})
```

## 条件控制

### 运算符

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303191941435.png" alt="image-20230319194136193" style="zoom:80%;" />

```sql
# id号比3大的所有的记录
db.students.find({id:{$gt:3}}); 
```

```js
//价格小于 20 的图书
BookModel.find({price: {$lt: 20}}, (err, data) => {
  if(err) {
    console.log('读取失败~~');
    return;
  }
  console.log(data);
})
```

### 逻辑运算

```sh
# $or 逻辑或的情况
db.students.find({$or:[{age:18},{age:24}]})
# $and 逻辑与的情况
db.students.find({$and: [{age: {$lt:20}}, {age: {$gt: 15}}]});
```

```js
//曹雪芹 或者 余华的书
BookModel.find({$or: [{author: '曹雪芹'}, {author: '余华'}]}, (err, data) => {
  if (err) {
    console.log('读取失败~~');
    return;
  }
  console.log(data);
})
```

### 运算符+逻辑

```js
//价格大于 30 且小于 70
BookModel.find({$and: [{price: {$gt: 30}}, {price: {$lt: 70}}]}, (err, data) => {
  if (err) {
    console.log('读取失败~~');
    return;
  }
  console.log(data);
})
```

### 正则匹配

```sh
# 条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询
db.students.find({name:/imissyou/});
```

```js
//正则表达式, 搜索书籍名称中带有 `三` 的图书
BookModel.find({name: /三/}, (err, data) => {
  if (err) {
    console.log('读取失败~~');
    return;
  }
  console.log(data);
})
```

```js
// 另一种正则写法，应对一些特殊情况
BookModel.find({name: new RegExp('三')}, (err, data) => {
  if (err) {
    console.log('读取失败~~');
    return;
  }
  console.log(data);
})
```

## 个性化读取

### 字段筛选

```js
// 0:不要的字段，1:要的字段
BookModel.find().select({name: 1, author: 1, _id: 0}).exec((err, data) => {
  if(err) {
    console.log('查询失败~~');
    return;
  }
  console.log(data);
})
```

### 数据排序

```js
//sort 排序，1:升序，-1:倒序
BookModel.find().select({name: 1, price: 1, _id: 0}).sort({price: -1}).exec((err, data) => {
  if(err) {
    console.log('查询失败~~');
    return;
  }
  console.log(data);
})
```

### 数据截取(分页)

```sql
db.getCollection("books").find({}).limit(21)
```

```js
//skip 跳过 limit 限定
BookModel.find().select({name: 1, price: 1, _id: 0}).sort({price: -1}).skip(3).limit(3)
         .exec((err, data) => {
            if(err) {
              console.log('查询失败~~');
              return;
            }
            console.log(data);
})
```

## 代码模块化⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303192144506.png" alt="image-20230319214421416" style="zoom:80%;" />

### config/config.js

```js
//配置文件
module.exports = {
  DBHOST: '127.0.0.1',
  DBPORT: 27017,
  DBNAME: 'bilibili'
}
```

### db/db.js

```js
/**
 * 
 * @param {*} success 数据库连接成功的回调
 * @param {*} error 数据库连接失败的回调
 */
module.exports = function (success, error) {
  //判断 error 为其设置默认值
  if(typeof error !== 'function'){
    error = () => {
      console.log('连接失败~~~');
    }
  }
  //1. 安装 mongoose,导入 mongoose
  const mongoose = require('mongoose');
  //导入config配置文件
  const {DBHOST, DBPORT, DBNAME} = require('../config/config.js');

  //设置 strictQuery 为 true
  mongoose.set('strictQuery', true);

  //3. 连接 mongodb 服务                        数据库的名称
  mongoose.connect(`mongodb://${DBHOST}:${DBPORT}/${DBNAME}`);

  //4. 设置回调
  // 设置连接成功的回调  once 一次   事件回调函数只执行一次
  mongoose.connection.once('open', () => {
    success();
  });

  // 设置连接错误的回调
  mongoose.connection.on('error', () => {
    error();
  });

  //设置连接关闭的回调
  mongoose.connection.on('close', () => {
    console.log('连接关闭');
  });
}
```

### model/BookModel.js

```js
//导入 mongoose
const mongoose = require('mongoose');
//创建文档的结构对象
//设置集合中文档的属性以及属性值的类型
let BookSchema = new mongoose.Schema({
  name: String,
  author: String,
  price: Number
});

//创建模型对象  对文档操作的封装对象
let BookModel = mongoose.model('books', BookSchema);

//暴露模型对象
module.exports = BookModel;
```

### model/MovieModel.js

```js
//导入 mongoose
const mongoose = require('mongoose');

// 创建文档结构
const MovieSchema = new mongoose.Schema({
  title: String,
  director: String
});

//创建模型对象
const MovieModel = mongoose.model('movie', MovieSchema);

//暴露
module.exports = MovieModel;
```

### test.js

```js
//导入 db
const db = require('./db/db');
//导入 MovieModel
const MovieModel = require('./models/MovieModel')
//调用函数
db(() => {
  //电影的模型对象
  MovieModel.create({title: '让子弹飞', director: '姜文'}, (err ,data) => {
    if(err){
      console.log('插入失败~~');
      return;
    }
    console.log('插入成功',data);
  })
})
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303192151158.png" alt="image-20230319215141071" style="zoom:80%;" />

### index.js

```js
//导入 db 文件
const db = require('./db/db');
//导入 mongoose
const mongoose = require('mongoose');
//导入 BookModel
const BookModel = require('./models/BookModel');

// 调用函数
db(() => {
  //7. 新增
  BookModel.create({
    name: '西游记',
    author: '吴承恩',
    price: 19.9
  }, (err, data) => {
    //判断是否有错误
    if(err) {
      console.log(err);
      return;
    }
    //如果没有出错, 则输出插入后的文档对象
    console.log(data);
    //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码)
    mongoose.disconnect();
  });
}, () => {
  console.log('连接失败...');
});
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303192152888.png" alt="image-20230319215240799" style="zoom:80%;" />

## 图形化管理工具

我们可以使用图形化的管理工具来对 Mongodb 进行交互，这里演示两个图形化工具

> - Robo 3T 免费： https://github.com/Studio3T/robomongo/releases
> - Navicat 收费： https://www.navicat.com.cn/

# PM2运行Node

## 为什么使用PM2

在服务器上，我们不会直接跑 node，而会用 pm2 来跑。为什么要用 pm2 呢？它解决了啥问题？

> - 如果你的 node 应用跑的时候突然抛了个错，崩溃了，是不是需要重新跑起来？这时候是不是就需要另一个进程来自动做重启这件事情？
> - node 应用的日志默认输出在控制台，如果想输出到不同的日志文件，是不是可以让另一个进程获取 node 应用的输出，然后写文件来实现？
> - node 是单线程的，而机器是多个 cpu 的，为了充分利用 cpu 的能力，我们会用多个进程来跑 node 应用，这种通用逻辑是不是也可以放到一个单独进程里来实现？
> - node 运行时的 cpu、内存等资源的占用，是不是需要监控？这时候是不是可以让另一个进程来做？

> 线上的 node 应用不只是跑起来就行了，还要做自动重启、日志、多进程、监控这些事情。而这些事情，都可以用 pm2 来做。pm2 是 process manager，进程管理，它是第二个大版本，和前一个版本差异很大，所以叫 pm2.pm2 的主要功能就是**进程管理、日志管理、负载均衡、性能监控**这些。

## 安装 pm2

```
npm install -g pm2
```

然后跑一个 node 应用，我这里跑一个 Nest.js 的应用：直接 node 跑是这样的，日志打印在控制台：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkpbOvN2ib8GQEOJl521HE1sNuFJ50JjTSBEvR9tmF29BCEM0liceC4dIQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 启动并查看日志

而用 pm2 的话，就可以这样跑：

```
pm2 start ./dist/main.js
```

它会把这个 node 进程跑起来，然后管理起来：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkyOVyhu8W8ImU1qBUebiapALYZaUUJtSjZ95EJpQe7PArGh9O0hkvysg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

管理起来之后，就有我们上面说的那些功能了，比如自动重启、日志管理、性能监控等。首先看下日志，执行

```
pm2 logs
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkHHmZMXsNcsVKZvyKNnuC1BIaomiaKFCcp3pk3pJK9qyJCZesKcnLhOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)可以看到 pm2 会把所有进程的日志打印出来，通过前面的“进程id|进程名字”来区分，比如 0|main。而且，它会把它写到日志文件里，在 ~/.pm2/logs 下，以“进程名-out.log”和“进程名-error.log”分别保存不同进程的日志：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk7Y3Txpgoeq07TXzNQrKY58XaxYMiaGKt3ibv0Zicyz2rZDSJUge5ddxOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

比如 main-out.log 里保存了 main 进程的正常日志，而 main-error.log 里保存了它的报错日志：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkGZcrq69WrzunDl7S5qoA32InCW5M0UliaQgtp5g1uQa1WibBKdOc9I2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

我们再跑一个进程试试：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk4U9aWibKBuWd4jOjuCkWuAZX7J9CxAW20ugt6T8z7rvKLfK9GJdbMFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

现在有两个进程了，pm2 logs 可以看到这两个进程的日志：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk3e62gGBkWfMqUJKqv6ZTl2tiagiaZu2eXOs6NBtMRMorib60AfIUxgic2Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

也可以

```
pm2 logs 进程名/进程id
```

这样查看单个进程的日志：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk8ibrLRhVfnzO0y3CyGeCHqvU57WO2RRbGw9ibDpLezYkfX86xkgWuPEQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这就是 pm2 的日志管理的功能。

## 进程管理

进程管理的话就是可以手动启动、重启、停止某个进程，而且崩溃了会自动重启，也可以定时自动重启。

只需要 pm2 start 的时候带上几个选项就好了：

超过 200M 内存自动重启：

```
pm2 start xxx --max-memory-restart 200M
```

从 2s 开始每 3s 重启一次：

```
pm2 start xxx --cron-restart "2/3 * * * * *"
```

当文件内容改变自动重启：

```
pm2 start xxx --watch
```

不自动重启：

```
pm2 start xxx --no-autorestart
```

我们分别试一下：把之前的进程删掉：

```
pm2 delete 0
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkncgxibfsF0whPOBjasLuOnTKhqzBSibxRZMibjCjSuteRLRFUOCTxuMpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

我们指定 1k 内存就重启：

```
pm2 start xxx --max-memory-restart 1K
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkthcZl44NSDqPC643MfXjS9HEqg3JmmKKGIuTjibJSShPtaSV0EaBmsw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

然后在 nest 代码里用超过 1k 的内存：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkAys6LUoCKngC9Jc6jzn9VBDPq4DfKudqxqhOzLKjBIO3GfpzpsVe2w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

先把之前的日志清空，使用 pm2 flush 或者 pm2 flush 进程名|id

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkoMXRN9875D1YJCoDEpbzpBibLvgJQ9NILoWmfnk0FtxDficOruehbibvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

确实清空了：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkCica5icFwo54GbQwyFm59hDMh2YxK4AASoSL6B6mluMhVr5t9HRyunvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

访问下这个 controller：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk8nb8so407RMgWXyibSZFexdpFuktldXuYC8DSfEECVsXW2nu49IDu3g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

查看 main 进程的前 100 行日志：

```
pm2 logs main --lines 100 
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCknd5Wv1rtM27RrK2KMDbib3wpHL9YSTywwzOhnGq7XtV6dg2DR8SLHHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

明显看到重启了。

这是超过内存的自动重启。

崩溃的自动重启、定时自动重启、文件变动自动重启等也是类似 。

我们前面用到的 pm2 start、pm2 stop、pm2 restart、pm2 delete 等就是进程管理的功能。

再就是负载均衡，node 应用是单进程的，而为了充分利用多核 cpu，我们会使用多进程来提高性能。

node 提供的 cluster 模块就是做这个的，pm2 就是基于这个实现了负载均衡。

我们只要启动进程的时候加上 -i num 就是启动 num 个进程做负载均衡的意思。

```
pm2 start app.js -i max 
pm2 start app.js -i 0
```

这俩是启动 cpu 数量的进程。

用多进程的方式跑 nest 应用：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk45X06LVna3SedwNq0G8GWKiahhpPQp1wM2S5jeaQ7icrFBreTsa41hGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到启动了 8 个进程，因为我是 8 核 cpu。

跑起来之后，还可以动态调整进程数，通过 pm2 scale：

```
pm2 scale main 3
```

我把 main 的集群调整为 3 个进程：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkqpZTDhpkwvrcJncKfHJ9K7TAZmlooqmL4NhxeM2QWtSppKTQWXyzPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到 pm2 删除了 5 个，留下了 3 个。

```
pm2 scale main +3
```

我又加了 3 个，现在变成了 6 个：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkSIkaNycTPBT7DEjd5BO7rr4hZZ9KEP3X55kPy226WEXYGnETTBsSoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以动态伸缩进程的数量，pm2 会把请求分配到不同进程上去。

这就是负载均衡功能。

此外，还有个性能监控功能，执行 pm2 monit:

```
pm2 monit
```

![图片](https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkibj0J7SqDk7WwgrJ1EB1L39NefoON9Q8ayYu8ib8FRb3cs0mCyicR1dpw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

可以看到不同进程的 cpu 和内存占用情况。

大概就是这些功能，但是当进程多了之后，难道都要手动通过命令行来启动么？

肯定不会每次都敲一遍。

pm2 支持配置文件的方式启动多个应用。

执行 pm2 ecosystem，会创建一个配置文件：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk3DQzELLRGA0hOTWBQibBB3dLIfOevUc9GibqHs0el96nOjbJ9JnbWSCQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

apps 部分就是配置应用的，scripts 就是应用的启动路径：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkCDAKZcyhVLhcfYTH7wgsAV4le5Wm3tI9m7YHDvfZVib7Q0SWI9kiccEg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

它可以指定的配置非常多，基本就是命令行有啥选项，这里就有啥属性：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkd9QUsibJ4YYuDwXz3N5iaHOlrmswNCwK3fonItFmxHVUklGwCZJiajqDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

然后 pm2 start ecosystem.config.js 就可以批量跑一批应用。

就相当于 pm2 根据配置文件自动执行这些命令，不用我们手动敲了。

这样，我们就可以把启动的选项保存在配置文件里。

最后，还有个 pm2 plus，这个是收费功能，看看就行：

访问 pm2 的网站，登录，创建 bucket：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkqMymH7QLTDsHibfBarnWYFBEzaRcCtG5PBymhVDW8z5aJwpic0GF8kqA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

然后在本地执行 pm2 link xxx xxx，把本地的 pm2 和那个网站关联起来：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCk9b2BGB4UyqQvkSibwEt8icANLcQATibzzccFJ2HaiaQ0P1fWeGL86Zia9WA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

再执行 pm2 plus 就会打开 bucket 对应的网页：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkg7nvQdE9Qg3hu6P8m5tTPia0EduUz5kRXtVnSCecnq7XwS7d5lXGUow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以在线监控你的应用：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCklXVcBj4ADQl5jSVcVuGn4S38Wul8ibkk4BUAHqY7RyvYwj4SzqQpJiaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

下面这些 plus 的功能都是收费的：

![图片](https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGg8AA4INS9BibRB56UcHAgCkCD0tlOiaq0QuA8ZnUddqfWp3eCQDomwQv39F7AwxA3CEZ0E8ibJGNXEQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

一般也不需要用，用免费的本地功能就好了。

服务器上的 node 应用需要用 pm2 的日志管理、进程管理、负载均衡、性能监控等功能。

分别对应 pm2 logs、pm2 start/restart/stop/delte、pm2 start -i、pm2 monit 等命令。

多个应用或者想把启动选项保存下来的时候，可以通过 ecosystem 配置文件，批量启动一系列应用。

不管是出于稳定性、性能还是可观测性等目的，pm2 都是必不可少的。





# 功能实用包

## Lodash高效函数库

Lodash 是一个 JavaScript 实用程序库，它提供了一组用于处理数组、对象、字符串和其他数据类型的函数。Lodash 函数旨在针对性能进行高度优化，它们可以帮助提高 Node.js 应用程序的速度和效率。

```js
const _ = require('lodash');
const arr = [1, 2, 3, 4, 5];
const sum = _.sum(arr);
console.log(sum); // 15

const data = [1, 2, 3, 4, 5];
const filteredData = _.filter(data, num => num % 2 === 0);
console.log(filteredData); // Output: [2, 4]
```

## Node-cache本地缓存

Node-cache 是一个缓存库，使开发人员能够在 Node.js 应用程序中缓存数据。缓存有助于减少数据库查询和 API 调用的次数，从而提高应用程序性能。

```js
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 60 });
cache.set('key', 'value');
const value = cache.get('key');
console.log(value); // 'value'
```

## Moment.js时间

Moment.js 是一个用于解析、操作和格式化日期和时间的 JavaScript 库。Moment.js 使在 Node.js 应用程序中处理日期和时间变得更加容易和高效。

```js
const moment = require('moment');
const date = moment('2022-01-01');
const formattedDate = date.format('MM/DD/YYYY');
console.log(formattedDate); // '01/01/2022'
```

## Redis数据库

Redis 是一种开源内存数据结构存储，可用作数据库、缓存和消息代理。Redis 可以通过实现快速数据检索和存储来帮助提高应用程序性能。

```js
const redis = require('redis');
const client = redis.createClient();
client.set('key', 'value');
client.get('key', function (err, value) {
  console.log(value); // 'value'
});
```

## Nodemailer邮件

Nodemailer 是 Node.js 应用程序的一个模块，使开发人员能够发送电子邮件。Nodemailer 使从 Node.js 应用程序发送电子邮件变得更加容易和高效。

```js
const nodemailer = require('nodemailer');
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: 'your-email@gmail.com',
    pass: 'your-password'
  }
});
const mailOptions = {
  from: 'your-email@gmail.com',
  to: 'recipient-email@gmail.com',
  subject: 'Test email',
  text: 'This is a test email'
};
transporter.sendMail(mailOptions, function (error, info) {
    if (error) {
      console.log(error);
    } else {
      console.log('Email sent: ' + info.response);
    }
});
```

## Sharp图像处理

Sharp 是用于 Node.js 应用程序的高性能图像处理库。Sharp 可用于实时调整大小、裁剪和操作图像，这有助于提高应用程序性能。

```js
const sharp = require('sharp');
sharp('input.jpg')
  .resize(200, 200)
  .toFile('output.jpg', function (err) {
    if (err) {
      console.log(err);
    } else {
      console.log('Image resized and saved');
    }
});
```

## Axios网络请求

Axios 是 Node.js 应用程序的流行 HTTP 客户端。它提供了一个易于使用的 API，用于发出 HTTP 请求和处理响应。凭借其对承诺的内置支持，Axios 可以轻松处理异步请求。

```js
const axios = require('axios');
axios.get('https://api.example.com/data')
  .then(response => console.log(response.data))
  .catch(error => console.error(error));
```

## Morgan日志记录

Morgan 是一个流行的 Node.js 应用程序日志记录中间件。Morgan 可用于记录 HTTP 请求和响应，这可以帮助开发人员调试和优化他们的应用程序。

```js
const express = require('express');
const morgan = require('morgan');
const app = express();
app.use(morgan('combined'));
app.get('/', (req, res) => {
   res.send('Hello World!');
});
app.listen(3000, () => {
  console.log('Server started on port 3000');
});
```

## Node-gzip解压缩

Node-gzip 是一个用于在 Node.js 应用程序中压缩和解压缩数据的模块。压缩可以通过减少通过网络发送的数据大小来帮助提高应用程序性能。

```js
const zlib = require('zlib');
const input = 'Lorem ipsum dolor sit amet';
zlib.gzip(input, function (err, compressed) {
  if (err) {
    console.log(err);
  } else {
    console.log('Compressed data: ' + compressed.toString('base64'));
    zlib.gunzip(compressed, function (err, decompressed) {
      if (err) {
        console.log(err);
      } else {
        console.log('Decompressed data: ' + decompressed.toString());
      }
    });
  }
});
```

## Bcrypt加密

Bcrypt 是 Node.js 应用程序中用于散列密码的流行模块。散列密码有助于提高应用程序安全性和保护用户数据。

```js
const bcrypt = require('bcrypt');
const password = 'mypassword';
bcrypt.hash(password, 10, function (err, hash) {
  if (err) {
    console.log(err);
  } else {
    console.log('Hashed password: ' + hash);
    bcrypt.compare(password, hash, function (err, result) {
      if (err) {
        console.log(err);
      } else {
        console.log('Password match: ' + result);
      }
    });
  }
});
```

































