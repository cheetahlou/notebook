

# 前端必备 HTTP 知识

## HTTP 起源

`HTTP` 是由蒂姆·伯纳斯-李（`TimBerners—Lee`）于1989年在欧洲核子研究组织（`CERN`）所发起

其中最著名的是 1999 年 6 月公布的 **RFC 2616**[1]，定义了 `HTTP` 协议中现今广泛使用的一个版本——`HTTP 1.1`

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNoKHfCsRugWcCZBmt9sgWngfWJG6v5TQFJGNQ1RDNdacfbUM8cfyTKA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## HTTP 是什么

全称：超文本传输协议（`HyperText Transfer Protocol`）

概念：`HTTP` 是一种能够获取像 `HTML`、图片等网络资源的通讯协议（`protocol`）。它是在 `web` 上进行数据交换的基础，是一种 `client-server` 协议

`HTTP`——因特网的多媒体信使 ——《HTTP权威指南》。`HTTP` 在因特网的角色：充当一个信使的角色，干的就是一个跑腿的活，在客户端和服务端之间传递信息，但我们又不能缺少它。`HTTP` 协议是应用层的协议，是与前端开发最息息相关的协议。平时我们遇到的 `HTTP` 请求、 `HTTP` 缓存、`Cookies`、跨域等其实都跟 `HTTP` 息息相关

## HTTP 的基础特性

- 可拓展协议。`HTTP 1.0` 出现的 `HTTP headers` 让协议拓展变得更加的容易。只要服务端和客户端就 `headers` 达成语义一致，新功能就可以被轻松的加入进来
- `HTTP` 是无状态的、有会话的。在同一个连接中，两个执行成功的 `HTTP` 请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用 `HTTP` 的头部扩展，`HTTP Cookies` 就可以解决这个问题。把 `Cookies` 添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。
- `HTTP` 与连接。通过 `TCP`，或者 `TLS`——加密的 `TCP` 连接来发送，理论上任何可靠的传输协议都可以使用。连接是传输层控制的，这从根本上来讲不是 `HTTP` 的范畴。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251051917.png" alt="image-20221025105128871" style="zoom:80%;" />

也就是说，`HTTP` 依赖于面向连接的 `TCP` 进行消息传递，但连接并不是必须的。只需要它是可靠的，或不丢失消息的（至少返回错误）。

`HTTP/1.0` 默认为每一对 `HTTP` 请求/响应都打开一个单独的 `TCP` 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 `TCP` 链接更低效。为此，`HTTP 1.1` 持久连接的概念，底层 `TCP` 连接可以通过 `connection` 头部实现。但 `HTTP 1.1` 在连接上也是不完美的，后面我们会提到。

## 基于 HTTP 的组件系统

`HTTP` 的组件系统包括客户端、`web` 服务器和代理

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251051633.png" alt="image-20221025105144597" style="zoom:80%;" />

### 客户端：user-agent

浏览器，特殊比如是工程师使用的程序，以及 `Web` 开发人员调试应用程序

### Web服务端

由 `Web Server` 来服务并提供客户端所请求的文档。每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是 `response`

### 代理（Proxies）

在浏览器和服务器之间，有很多计算机和其他设备转发了 `HTTP` 消息。它们可能出现在传输层、网络层和物理层上，对于 `HTTP` 应用层而言就是透明的

有如下的一些作用

- 缓存
- 过滤（像防病毒扫描、家长控制）
- 负载均衡
- 认证（对不同的资源进行权限控制）
- 日志管理

## HTTP 报文组成

HTTP 有两种类型的消息：

- 请求——由客户端发送用来触发一个服务器上的动作
- 响应——来自服务器端的应答

`HTTP` 消息由采用 `ASCII` 编码的多行文本构成的。在 `HTTP/1.1` 以及更早的版本中，这些消息通过连接公开的发送。在 `HTTP2.0` 中，消息被分到了多个 `HTTP` 帧中。通过配置文件（用于代理服务器或者服务器），`API`（用于浏览器）或者其他接口提供 `HTTP` 消息

### 典型的 HTTP 会话

- 建立连接 在客户端-服务器协议中，连接是由客户端发起建立的。在 `HTTP` 中打开连接意味着在底层传输层启动连接，通常是 `TCP`。使用 `TCP` 时，`HTTP` 服务器的默认端口号是 `80`，另外还有 `8000` 和 `8080` 也很常用
- 发送客户端请求
- 服务器响应请求

### HTTP 请求和响应

HTTP 请求和响应都包括起始行（`start line`）、请求头（`HTTP Headers`）、空行（`empty line`）以及 `body` 部分，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNgVcSwlONtRwsv3RVibzg9BmF7jg2VdT39ibEp0ZRAsqsCTP5BU9rHSlA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



- 起始行。请求的起始行：请求方法、请求 `Path` 和`HTTP` 版本号 响应的起始行：`HTTP` 版本号、响应状态码以及状态文本描述

下面详细说下请求 `Path`，请求路径（`Path`）有以下几种：

1）一个绝对路径，末尾跟上一个 ' ? ' 和查询字符串。这是最常见的形式，称为 原始形式 (`origin form`)，被 `GET`，`POST`，`HEAD` 和 `OPTIONS` 方法所使用

```
POST / HTTP/1.1
GET /background.png HTTP/1.0
HEAD /test.html?query=alibaba HTTP/1.1
OPTIONS /anypage.html HTTP/1.0
```

2）一个完整的 `URL`。主要在使用 `GET` 方法连接到代理的时候使用

```
GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1
```

3）由域名和可选端口（以':'为前缀）组成的 `URL` 的 `authority component`，称为 `authority form`。仅在使用 `CONNECT` 建立 `HTTP` 隧道时才使用

```
CONNECT developer.mozilla.org:80 HTTP/1.1
```

4）星号形式 (`asterisk form`)，一个简单的星号('*')，配合 `OPTIONS` 方法使用，代表整个服务器。

```
OPTIONS * HTTP/1.1
```

- `Headers` 请求头或者响应头。详见下面的首部。不区分大小写的字符串，紧跟着的冒号 (':') 和一个结构取决于 `header` 的值
- 空行。很多人容易忽略
- `Body`

请求 `Body` 部分：有些请求将数据发送到服务器以便更新数据：常见的的情况是 `POST` 请求（包含 `HTML` 表单数据）。请求报文的 `Body` 一般为两类。一类是通过 `Content-Type` 和 `Content-Length` 定义的单文件 `body`。另外一类是由多 `Body` 组成，通常是和 `HTML Form` 联系在一起的。两者的不同表现在于 `Content-Type`的值。

1）`Content-Type —— application/x-www-form-urlencoded`对于 `application/x-www-form-urlencoded` 格式的表单内容，有以下特点:

I.其中的数据会被编码成以&分隔的键值对

II.字符以URL编码方式编码。

```
// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
"a%3D1%26b%3D2"
```

2)`Content-Type —— multipart/form-data`

请求头中的 `Content-Type` 字段会包含 `boundary`，且 `boundary` 的值有浏览器默认指定。例: `Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`。

数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 `HTTP` 头部描述子包体，如`Content-Type`，在最后的分隔符会加上--表示结束。

```
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```

响应 `Body` 部分：

1）由已知长度的单个文件组成。该类型 `body` 由两个 `header` 定义：`Content-Type` 和 `Content-Length`

2）由未知长度的单个文件组成，通过将 `Transfer-Encoding` 设置为 `chunked` 来使用 `chunks` 编码。

关于 `Content-Length` 在下面 `HTTP 1.0` 中会提到，这个是 `HTTP 1.0` 中新增的非常重要的头部。

### 方法

安全方法：`HTTP` 定义了一组被称为安全方法的方法。`GET` 方法和 `HEAD` 方法都被认为是安全的，这意味着 `GET` 方法和 `HEAD` 方法都不会产生什么动作 —— `HTTP` 请求不会再服务端产生什么结果，但这并不意味着什么动作都没发生，其实这更多的是 `web` 开发者决定的

- `GET`：请求服务器发送某个资源
- `HEAD`：跟 `GET` 方法类似，但服务器在响应中只返回了首部。不会返回实体的主体部分。
- `PUT`：向服务器中写入文档。语义：用请求的主体部分来创建一个由所请求的 `URL` 命名的新文档
- `POST`：用来向服务器中输入数据的。通常我们提交表单数据给服务器。【`POST` 用于向服务器发送数据，`PUT` 方法用于向服务器上的资源（例如文件）中存储数据】
- `TRACE`：主要用于诊断。实现沿通向目标资源的路径的消息环回（`loop-back`）测试 ，提供了一种实用的 `debug` 机制。
- `OPTIONS`：请求 `WEB` 服务器告知其支持的各种功能。可以询问服务器支持哪些方法。或者针对某些特殊资源支持哪些方法。
- `DELETE`：请求服务器删除请求 `URL` 中指定的的资源

### GET 和 POST 的区别

首先要了解下副作用和幂等的概念，副作用指的是对服务器端资源做修改。幂等指发送 `M` 和 `N` 次请求（两者不相同且都大于 1），服务器上资源的状态一致。应用场景上，get是无副作用的，幂等的。post 主要是有副作用的，不幂等的情况

技术上有以下的区分：

- 缓存：`Get` 请求能缓存，`Post` 请求不能
- 安全：`Get` 请求没有 `Post` 请求那么安全，因为请求都在 `URL` 中。且会被浏览器保存历史纪录。`POST` 放在请求体中，更加安全
- 限制：`URL` 有长度限制，会干预 `Get` 请求，这个是浏览器决定的
- 编码：`GET` 请求只能进行 `URL` 编码，只能接收 `ASCII` 字符，而 `POST` 没有限制。`POST` 支持更多的编码类型，而且不对数据类型做限制
- 从 `TCP` 的角度，`GET` 请求会把请求报文一次性发出去，而 `POST` 会分为两个 `TCP` 数据包，首先发 `header` 部分，如果服务器响应 `100(continue)`， 然后发 `body` 部分。(火狐浏览器除外，它的 `POST` 请求只发一个 `TCP` 包)

### 状态码

- 100~199——信息性状态码

  101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。

- 200~299——成功状态码

  200 OK，表示从客户端发来的请求在服务器端被正确处理

  204 No content，表示请求成功，但响应报文不含实体的主体部分

  205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容

  206 Partial Content，进行范围请求

- 300~399——重定向状态码

  301 moved permanently，永久性重定向，表示资源已被分配了新的 URL

  302 found，临时性重定向，表示资源临时被分配了新的 URL

  303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源

  304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况

  307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

- 400~499——客户端错误状态码

  400 bad request，请求报文存在语法错误

  401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息

  403 forbidden，表示对请求资源的访问被服务器拒绝

  404 not found，表示在服务器上没有找到请求的资源

- 500~599——服务器错误状态码

  500 internal sever error，表示服务器端在执行请求时发生了错误

  501 Not Implemented，表示服务器不支持当前请求所需要的某个功能

  503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### 首部

```
HTTP Headers
```

1.通用首部（`General headers`）同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。如 `Date`

2.请求首部（`Request headers`）包含更多有关要获取的资源或客户端本身信息的消息头。如 User-Agent

3.响应首部（`Response headers`）包含有关响应的补充信息

4.实体首部（`Entity headers`）含有关实体主体的更多信息，比如主体长(`Content-Length`)度或其 `MIME` 类型。如 `Accept-Ranges`

详细的 `Header` 见 **HTTP Headers 集合**[2]

## HTTP 的前世今生

`HTTP（HyperText Transfer Protocol）`是万维网（`World Wide Web`）的基础协议。`Tim Berners-Lee` 博士和他的团队在`1989-1991`年间创造出它。【HTTP、网络浏览器、服务器】

在 1991 年发布了 `HTTP 0.9` 版，在 1996 年发布 1.0 版，1997 年是 1.1 版，1.1 版也是到今天为止传输最广泛的版本。2015 年发布了 2.0 版，其极大的优化了 `HTTP/1.1` 的性能和安全性，而 2018 年发布的 3.0 版，继续优化 `HTTP/2`，激进地使用 `UDP` 取代 `TCP` 协议，目前，`HTTP/3` 在 2019 年 9 月 26 日 被 `Chrome`，`Firefox`，和 `Cloudflare` 支持

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNxKRINPCaFYRXHVXO7ibv21VJjwruiczoO8nQwxqptheQSkDhDUC9n7IQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### HTTP 0.9

单行协议，请求由单行指令构成。以唯一可用的方法 `GET` 开头。后面跟的是目标资源的路径

```
GET /mypage.html
```

响应：只包括响应文档本身

```
<HTML>
这是一个非常简单的HTML页面
</HTML>
```

- 没有响应头，只传输 `HTML` 文件
- 没有状态码

### HTTP 1.0

**RFC 1945**[3] 提出了 `HTTP1.0`，**构建更好可拓展性**

- 协议版本信息会随着每个请求发送
- 响应状态码
- 引入了 `HTTP` 头的概念，无论是请求还是拓展，允许传输元数据。使协议变得灵活，更加具有拓展性
- `Content-Type` 请求头，具备了传输除纯文本 `HTML` 文件以外其他类型文档的能力 在响应中，`Content-Type` 标头告诉客户端实际返回的内容的内容类型

媒体类型是一种标准。用来表示文档、文件或者字节流的性质和格式。浏览器通常使用 `MIME` （`Multipurpose Internet Mail Extensions` ）类型来确定如何处理 `URL`，因此 `Web` 服务器在响应头中配置正确的 `MIME` 类型会非常的重要。如果配置不正确，可能会导致网站无法正常的工作。`MIME` 的组成结构非常简单；由类型与子类型两个字符串中间用'/'分隔而组成。

`HTTP` 从 `MIME type` 取了一部分来标记报文 `body` 部分的数据类型，这些类型体现在`Content-Type` 这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用 `Accept` 字段。

这两个字段的取值可以分为下面几类:

```
- text：text/html, text/plain, text/css 等
- image: image/gif, image/jpeg, image/png 等
- audio/video: audio/mpeg, video/mp4 等
- application: application/json, application/javascript, application/pdf, application/octet-stream
```

同时为了约定请求的数据和响应数据的压缩方式、支持语言、字符集等，还提出了以下的 `Header`

1.压缩方式:发送端：`Content-Encoding`（服务端告知客户端，服务器对实体的主体部分的编码方式） 和 接收端：`Accept-Encoding`（用户代理支持的编码方式），值有 gzip: 当今最流行的压缩格式；deflate: 另外一种著名的压缩格式；br: 一种专门为 HTTP 发明的压缩算法

2.支持语言：`Content-Language` 和 `Accept-Language`（用户代理支持的自然语言集）

3.字符集：发送端：`Content-Type` 中，以 `charset` 属性指定。接收端：`Accept-Charset`（用户代理支持的字符集）。

```
// 发送端
Content-Encoding: gzip
Content-Language: zh-CN, zh, en
Content-Type: text/html; charset=utf-8

// 接收端
Accept-Encoding: gzip
Accept-Language: zh-CN, zh, en
Accept-Charset: charset=utf-8
```

虽然  `HTTP1.0` 在 `HTTP 0.9` 的基础上改进了很多，但还是存在这不少的缺点

`HTTP/1.0` 版的主要缺点是，每个 `TCP` 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。`TCP` 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（`slow start`）。

`HTTP` 最早期的模型，也是  `HTTP/1.0` 的默认模型，是短连接。每一个 `HTTP` 请求都由它自己独立的连接完成；这意味着发起每一个 `HTTP` 请求之前都会有一次 `TCP` 握手，而且是连续不断的。

### HTTP 1.1

`HTTP/1.1` 在1997年1月以 **RFC 2068**[4] 文件发布。

`HTTP 1.1` 消除了大量歧义内容并引入了多项技术

- 连接可以复用。长连接：`connection: keep-alive`。`HTTP 1.1` 支持长连接（`PersistentConnection`），在一个 `TCP` 连接上可以传送多个 `HTTP` 请求和响应，减少了建立和关闭连接的消耗和延迟，在 `HTTP1.1` 中默认开启 `Connection：keep-alive`，一定程度上弥补了 `HTTP1.0` 每次请求都要创建连接的缺点。
- 增加了管道化技术（`HTTP Pipelinling`），允许在第一个应答被完全发送完成之前就发送第二个请求，以降低通信延迟。复用同一个 `TCP` 连接期间，即便是通过管道同时发送了多个请求，服务端也是按请求的顺序依次给出响应的；而客户端在未收到之前所发出所有请求的响应之前，将会阻塞后面的请求(排队等待)，这称为"队头堵塞"（`Head-of-line blocking`）。
- 支持响应分块，分块编码传输：`Transfer-Encoding: chunked``Content-length` 声明本次响应的数据长度。`keep-alive` 连接可以先后传送多个响应，因此用 `Content-length` 来区分数据包是属于哪一个响应。使用 `Content-Length` 字段的前提条件是，服务器发送响应之前，必须知道响应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（`Stream`）取代"缓存模式"（`Buffer`）。因此，`HTTP 1.1` 规定可以不使用 `Content-Length` 字段，而使用"分块传输编码"（`Chunked Transfer Encoding`）。只要请求或响应的头信息有 `Transfer-Encoding: chunked` 字段，就表明 `body` 将可能由数量未定的多个数据块组成。每个数据块之前会有一行包含一个 16 进制数值，表示这个块的长度；最后一个大小为 0 的块，就表示本次响应的数据发送完了。
- 引入额外的缓存控制机制。在 `HTTP1.0` 中主要使用 `header` 里的 `If-Modified-Since`,`Expires` 等来做为缓存判断的标准，`HTTP1.1` 则引入了更多的缓存控制策略例如 `Entity tag`, `If-None-Match`，`Cache-Control` 等更多可供选择的缓存头来控制缓存策略。
- `Host` 头。不同的域名配置同一个 `IP` 地址的服务器。`Host` 是 `HTTP 1.1` 协议中新增的一个请求头，主要用来实现虚拟主机技术。

虚拟主机（`virtual hosting`）即共享主机（`shared web hosting`），可以利用虚拟技术把一台完整的服务器分成若干个主机，因此可以在单一主机上运行多个网站或服务。

举个栗子，有一台 `ip` 地址为 `61.135.169.125` 的服务器，在这台服务器上部署着谷歌、百度、淘宝的网站。为什么我们访问 `https://www.google.com` 时，看到的是 `Google` 的首页而不是百度或者淘宝的首页？原因就是 `Host` 请求头决定着访问哪个虚拟主机。

### HTTP 2.0

2015年，`HTTP2.0` 面世。**rfc7540**[5]

- `HTTP/2` 是二进制协议而不是文本协议。先来看几个概念：

- - 帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。
  - 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
  - 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符

`HTTP 2.0` 中的帧将 `HTTP/1.x` 消息分成帧并嵌入到流 (`stream`) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为多路复用 (`multiplexing`) 的过程，它允许更有效的底层 `TCP` 连接。

也就是说，流用来承载消息，消息又是有一个或多个帧组成。二进制传输的方式更加提升了传输性能。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。帧是流中的数据单位。

`HTTP` 帧现在对 `Web` 开发人员是透明的。在 `HTTP/2` 中，这是一个在  `HTTP/1.1` 和底层传输协议之间附加的步骤。`Web` 开发人员不需要在其使用的 `API` 中做任何更改来利用 `HTTP` 帧；当浏览器和服务器都可用时，`HTTP/2` 将被打开并使用。

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNMmtnuGp9WEhPwEkyR5aDKe6TeyzJmMF3v5B6KiaY6Vumw2zVJicvl6ibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 这是一个复用协议。并行的请求能在同一个连接中处理，移除了 `HTTP/1.x` 中顺序和阻塞的约束。多路复用允许同时通过单一的 `HTTP/2` 连接发起多重的请求-响应消息

之前我们提到，虽然 `HTTP 1.1` 有了长连接和管道化的技术，但是还是会存在 队头阻塞。而 `HTTP 2.0` 就解决了这个问题`HTTP/2` 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 `HTTP` 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvN40MZ3yThKr1UPgOojc2ZTXcWUBor3icxCBc3biaZg8L5hMicJ9yYlA8pg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如上图所示，快照捕捉了同一个连接内并行的多个数据流。客户端正在向服务器传输一个 `DATA` 帧（数据流 5），与此同时，服务器正向客户端交错发送数据流 1 和数据流 3 的一系列帧。因此，一个连接上同时有三个并行数据流。

将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 `HTTP 2` 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：1.并行交错地发送多个请求，请求之间互不影响。2.并行交错地发送多个响应，响应之间互不干扰。3.使用一个连接并行发送多个请求和响应。4.消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。5.不必再为绕过 HTTP/1.x 限制而做很多工作(比如精灵图) ...

连接共享，即每一个 `request` 都是是用作连接共享机制的。一个 `request` 对应一个 `id`，这样一个连接上可以有多个 `request`，每个连接的 `request` 可以随机的混杂在一起，接收方可以根据 `request` 的 `id` 将 `request` 再归属到各自不同的服务端请求里面。

`HTTP 1.1` 和 `HTTP 2.0` 的对比，可以参考这个 **网站 demo 演示**[6]

`HTTP 1.1` 演示如下：![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNb1ERhCvQicPiaSPL8D6bZnDblDnds2hEdBmQEIiae6DF0qK0w6HFzI11A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

`HTTP2.0` 演示如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNHic2cibZbaJWMO54Gguyds8rFtAlDvUVmwLYXyjNIjBVBiboicttoqUMibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNtOp2wyzLZuQPgSAWMianTQpFZjL06GEzqy3mIy16VsSrxatPWPu9Neg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 压缩了`headers`。`HTTP1.x` 的 `header` 带有大量信息，而且每次都要重复发送，就造成了性能的损耗。为了减少此开销和提升性能，`HTTP/2` 使用 `HPACK` 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNicZbm31mVLbTvZTrT0XhlTKFTWgmDFhFe8Qicbneiby8DLEjL8oCe87Yg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 服务端推送。其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。服务器向客户端推送资源无需客户端明确地请求，服务端可以提前给客户端推送必要的资源，这样可以减少请求延迟时间，例如服务端可以主动把 `JS` 和 `CSS` 文件推送给客户端，而不是等到 `HTML` 解析到资源时发送请求，这样可以减少延迟时间大致过程如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvN8GKs6xx8gDib3gxlsumSqtQr8u9xwOvCpT2TNOdKwiaWuqOHgfQ2bmTA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### 如何升级你的 HTTP 版本

使用 `HTTP/1.1` 和 `HTTP/2` 对于站点和应用来说是透明的。拥有一个最新的服务器和新点的浏览器进行交互就足够了。只有一小部分群体需要做出改变，而且随着陈旧的浏览器和服务器的更新，而不需 `Web` 开发者做什么，用的人自然就增加了

## HTTPS

`HTTPS` 也是通过 `HTTP` 协议进行传输信息，但是采用了 `TLS` 协议进行了加密

### 对称加密和非对称加密

> 对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。但是因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的

> 非对称加密：公钥大家都知道，可以用公钥加密数据。但解密数据必须使用私钥，私钥掌握在颁发公钥的一方。首先服务端将公钥发布出去，那么客户端是知道公钥的。然后客户端创建一个秘钥，并使用公钥加密，发送给服务端。服务端接收到密文以后通过私钥解密出正确的秘钥

### TLS 握手过程

`TLS` 握手的过程采用的是非对称加密

- `Client Hello`: 客户端发送一个随机值(`Random1`)以及需要的协议和加密方式。
- `Server Hello` 以及 `Certificate`: 服务端收到客户端的随机值，自己也产生一个随机值(`Random2`)，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）
- `Certificate Verify`: 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值(`Random3`)，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
- `Server 生成 secret`: 服务端收到加密过的随机值并使用私钥解密获得第三个随机值(`Random3`)，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

## HTTP 缓存

### 强缓存

强缓存主要是由 `Cache-control` 和 `Expires` 两个 `Header` 决定的

`Expires` 的值和头里面的 `Date` 属性的值来判断是否缓存还有效。`Expires` 是 `Web` 服务器响应消息头字段，在响应 `http` 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。`Expires` 的一个缺点就是，返回的到期时间是服务器端的时间，这是一个绝对的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大。

`Cache-Control` 指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。但是其设置的是一个相对时间。

指定过期时间：`max-age` 是距离请求发起的时间的秒数，比如下面指的是距离发起请求 31536000S 内都可以命中强缓存

```
Cache-Control: max-age=31536000
```

表示没有缓存

```
Cache-Control: no-store
```

有缓存但要重新验证

```
Cache-Control: no-cache
```

私有和公共缓存

`public` 表示响应可以被任何中间人（比如中间代理、`CDN` 等缓存） 而 `private` 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

```
Cache-Control: private
Cache-Control: public
```

验证方式：以下表示一旦资源过期（比如已经超过 `max-age`），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求

```
Cache-Control: must-revalidate
```

`Cache-control` 优先级比 `Expires` 优先级高

以下是一个 `Cache-Control` 强缓存的过程：

- 首次请求，直接从 server 中获取。其中会设置 `max-age=100`
- 第二次请求，`age=10`，小于 100，则命中 `Cache`，直接返回
- 第三次请求，`age=110`，大于 110。强缓存失效，就需要再次请求 `Server`

<img src="https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvN7PwDYajlYQsy8kAzqtEQac5eu7NtGpAGvL4kCEROQuyU34ryhVvoNw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />

### 协商缓存

- `If-Modified-Since——Last-Modified`

`Last-Modified` 表示本地文件最后修改日期，浏览器会在 `request header` 加上 `If-Modified-Since`（上次返回的 `Last-Modified` 的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 `HTTP / 1.1` 出现了 `ETag`

- `If-none-match——ETags`

`Etag` 就像一个指纹，资源变化都会导致 `ETag` 变化，跟最后修改时间没有关系，`ETag` 可以保证每一个资源是唯一的。`If-None-Match` 的 `header` 会将上次返回的 `Etag` 发送给服务器，询问该资源的 `Etag` 是否有更新，有变动就会发送新的资源回来

```
If-none-match`、`ETags` 优先级高于 `If-Modified-Since、Last-Modified
```

第一次请求：

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNKd9HCOXvg9evnZ8Via0v3j9cEeaauXuj2Zyic9uSds4diavSXarAVCO9g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

第二次请求相同网页：

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNDw5BPliaicNNulJDzMINsS4vIUeZuCJ7nGcCfOIXcC96ECk3V70Zmp7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

协商缓存，假如没有改动的话，返回 304 ，改动了返回 200 资源

- 200：强缓存 `Expires/Cache-Control` 失效时，返回新的资源文件
- 200 `(from cache)`: 强缓 `Expires/Cache-Control` 两者都存在，未过期，`Cache-Control` 优先 `Expires` 时，浏览器从本地获取资源成功
- 304 `(Not Modified)`：协商缓存 `Last-modified/Etag` 没有过期时，服务端返回状态码304

现在的200`(from cache)`已经变成了 `disk cache`(磁盘缓存)和 `memory cache`(内存缓存)两种

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNviccmhz1NGPpqCcyVG9NeibNSQOibSZfrkbYQZr6TU1iarHXicUSxeVSFaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### revving 技术

上面提到 `HTTP` 缓存相关，但是很多有时候，我们希望上线之后需要更新线上资源。

`web` 开发者发明了一种被 `Steve Souders` 称之为 `revving` 的技术。不频繁更新的文件会使用特定的命名方式：在 `URL` 后面（通常是文件名后面）会加上版本号。

弊端：更新了版本号，所有引用这些的资源的地方的版本号都要改变

`web` 开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（`js/css`）变动了，只用在高频变动的资源文件（`html`）里做入口的改动。

## Cookies

`HTTP Cookie`（也叫 `Web Cookie` 或浏览器 `Cookie`）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

### 创建 cookie

`Set-Cookie` 响应头部和 `Cookie` 请求头部

```
Set-Cookie: <cookie名>=<cookie值>
```

### 会话期Cookie

会话期Cookie是最简单的 `Cookie`：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 `Cookie` 不需要指定过期时间（`Expires`）或者有效期（`Max-Age`）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 `Cookie` 也会被保留下来，就好像浏览器从来没有关闭一样

### 持久性Cookie

和关闭浏览器便失效的会话期 `Cookie` 不同，持久性 `Cookie` 可以指定一个特定的过期时间（`Expires`）或有效期（`Max-Age`）。

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### Cookie的Secure和HttpOnly 标记

标记为 `Secure` 的 `Cookie` 只应通过被 `HTTPS` 协议加密过的请求发送给服务端。

标记为 `Secure` 的 `Cookie` 只应通过被 `HTTPS` 协议加密过的请求发送给服务端。但即便设置了 `Secure` 标记，敏感信息也不应该通过 `Cookie` 传输，因为 `Cookie` 有其固有的不安全性，`Secure` 标记也无法提供确实的安全保障

通过 `JavaScript` 的 `Document.cookie` `API` 是无法访问带有 `HttpOnly` 标记的 `cookie`。这么做是为了避免跨域脚本攻击（`XSS`）

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

### Cookie的作用域

`Domain` 和 `Path` 标识定义了 `Cookie` 的作用域：即 `Cookie` 应该发送给哪些 `URL`。

`Domain` 标识指定了哪些主机可以接受 `Cookie`。如果不指定，默认为当前的主机（不包含子域名）。如果指定了 `Domain`，则一般包含子域名。

例如，如果设置 `Domain=mozilla.org`，则 `Cookie` 也包含在子域名中（如`developer.mozilla.org`）。

`Path` 标识指定了主机下的哪些路径可以接受 `Cookie`（该 `URL` 路径必须存在于请求 `URL` 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。

例如，设置 `Path=/docs`，则以下地址都会匹配：

```
/docs
/docs/Web/
/docs/Web/HTTP
```

### SameSite Cookies

`SameSite Cookie` 允许服务器要求某个 `cookie` 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击

- `None` 浏览器会在同站请求、跨站请求下继续发送 `cookies`，不区分大小写。【旧版本 `chrome` 默认 `Chrome 80` 版本之前】
- `Strict` 浏览器将只在访问相同站点时发送 `cookie`。
- `Lax` 将会为一些跨站子请求保留，如图片加载或者 `frames` 的调用，但只有当用户从外部站点导航到 `URL` 时才会发送。如 `link` 链接

```
Set-Cookie: key=value; SameSite=Strict
None Strict Lax
```

在新版本的浏览器（`Chrome 80` 之后）中，`SameSite` 的默认属性是 `SameSite=Lax`。换句话说，当 `Cookie` 没有设置 `SameSite` 属性时，将会视作 `SameSite` 属性被设置为 `Lax` —— 这意味着 `Cookies` 将不会在当前用户使用时被自动发送。如果想要指定 `Cookies` 在同站、跨站请求都被发送，那么需要明确指定`SameSite` 为 `None`。因为这一点，我们需要好好排查旧系统是否明确指定 `SameSite`，以及推荐新系统明确指定 `SameSite`，以兼容新旧版本 `Chrome`

更多 `cookie` 相关，可以查看我之前总结的一篇关于 `cookie` 的文章 **前端须知的 Cookie 知识小结**[7]

## HTTP访问控制（CORS）

跨域资源共享（`CORS`）是一种机制，它使用额外的 `HTTP` 头告诉浏览器，让运行在一个 `origin` (`domain`) 上的 `web` 应用被准许访问来自不同源服务器上的指定的资源

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNDFoJrQ5cVQM7F4SKEztgUIFoibfxk6CIqBa1gzuEDNcvsSwQSqanGSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

跨域资源共享标准新增了一组 `HTTP` 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。

### 简单请求

简单请求（不会触发 `CORS` 的预检请求）需要同时满足以下三点：

- 方法是 `GET/HEAD/POST` 之一
- `Content-Type` 的值仅限 `text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded` 三者之一
- `HTTP` 头部不能超过以下字段：`Accept`、`Accept-Language`、`Content-Language``Content-Type`（需要注意额外的限制）`DPR`、`Downlink`、`Save-Data`、`Viewport-Width`、`Width`

以下为一个简单请求的请求报文以及响应报文

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNxicTnyzNjev1XibjnRXJYd3ZO8ULKzBu0GPtVLBjeE1x0ccKw9WoJ7xA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

简化以下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNT4qibNDPb1c87QtWFIJf4mQWibnM7rtoBAzgDR5jOZicOO5zicPNbpUSuw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />

请求首部字段 `Origin` 表明该请求来源于 `http://foo.example`

本例中，服务端返回的 `Access-Control-Allow-Origin: *` 表明，该资源可以被任意外域访问。如果服务端仅允许来自 `http://foo.example` 的访问，该首部字段的内容如下：

```
Access-Control-Allow-Origin: http://foo.example
```

`Access-Control-Allow-Origin` 应当为 * 或者包含由 `Origin` 首部字段所指明的域名。

### 预检请求

规范要求，对那些可能对服务器数据产生副作用的 `HTTP` 请求方法。浏览器必须首先使用 `OPTIONS` 方法发起一个预检请求（`preflight request`），从而获知服务端是否允许该跨域请求。

服务器确认允许之后，才发起实际的 `HTTP` 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 `Cookies` 和 `HTTP` 认证相关数据）

![图片](https://mmbiz.qpic.cn/mmbiz_png/betIP9fVPicP9mOWh8f5hp8VpYXOEAAvNyW8Ug3CAjia0LfZQIBkhH2k9tNNEqCVPswGtTHoSiaboOcnf5ib22YTpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

预检请求中同时携带了下面两个首部字段：

```
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
```

首部字段 `Access-Control-Request-Method` 告知服务器，实际请求将使用 `POST` 方法。首部字段 `Access-Control-Request-Headers` 告知服务器，实际请求将携带两个自定义请求首部字段：`X-PINGOTHER` 与 `Content-Type`。服务器据此决定，该实际请求是否被允许。

预检请求的响应中，包括了以下几个字段

```
Access-Control-Allow-Origin: http://foo.example
// 表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求
Access-Control-Allow-Methods: POST, GET, OPTIONS
// 表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
// 表明该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。
Access-Control-Max-Age: 86400
```

HTTP 请求和响应 一般而言，对于跨域 `XMLHttpRequest` 或 `Fetch` 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 `XMLHttpRequest` 的某个特殊标志位。比如说 `XMLHttpRequest` 的 `withCredentials` 标志设置为 `true`，则可以发送 `cookie` 到服务端。

对于附带身份凭证的请求，服务器不得设置 `Access-Control-Allow-Origin` 的值为“*”。这是因为请求的首部中携带了 `Cookie` 信息，如果 `Access-Control-Allow-Origin` 的值为“*”，请求将会失败。而将 `Access-Control-Allow-Origin` 的值设置为 `http://foo.example`，则请求将成功执行。

`CORS` 涉及到的请求和响应头如下：`HTTP` 响应首部字段

- `Access-Control-Allow-Origin` 允许访问该资源的外域 `URI`。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。
- `Access-Control-Expose-Headers` 头让服务器把允许浏览器访问的头放入白名单
- `Access-Control-Max-Age` 头指定了 `preflight` 请求的结果能够被缓存多久
- `Access-Control-Allow-Credentials` 头指定了当浏览器的 `credentials` 设置为 `true` 时是否允许浏览器读取 `response` 的内容。
- `Access-Control-Allow-Methods` 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 `HTTP` 方法。
- `Access-Control-Allow-Headers` 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。

`HTTP` 请求首部字段

- `Origin` 首部字段表明预检请求或实际请求的源站
- `Access-Control-Request-Method` 首部字段用于预检请求。其作用将实际请求所使用的 HTTP 方法告诉服务器
- `Access-Control-Request-Headers` 首部字段用于预检请求。其作用，将实际请求所携带的首部字段告诉服器



# 前端缓存⭐

## 什么是web缓存？

### web缓存分类

web缓存主要指的是两部分：浏览器缓存和http缓存。其中http缓存是web缓存的核心，是最重要的那一部分

> 浏览器缓存：比如,localStorage,sessionStorage,cookie等等。这些功能主要用于缓存一些必要的数据，比如用户信息。比如需要携带到后端的参数。亦或者是一些列表数据等等。
>
> 

> 不过这里需要注意。像localStorage，sessionStorage这种用户缓存数据的功能，他只能保存5M左右的数据，多了不行。cookie则更少，大概只能有4kb的数据。这篇文章重点讲解的是：前端http缓存

### http缓存

> 官方介绍:Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档。

举个例子

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251100128.png" alt="image-20221025110025062" style="zoom:80%;" />

> 看图，问题就是出在，服务器需要处理http的请求，并且http去传输数据，需要带宽，带宽是要钱买的啊。而我们缓存，就是为了让服务器不去处理这个请求，客户端也可以拿到数据。

> 注意，我们的缓存主要是针对html,css,img等静态资源，常规情况下，我们不会去缓存一些动态资源，因为缓存动态资源的话，数据的实时性就不会不太好，所以我们一般都只会去缓存一些不太容易被改变的静态资源。

## 前端缓存优缺点

先说说，缓存可以解决什么问题。

- **减少不必要的网络传输，节约宽带（就是省钱）**
- **更快的加载页面（就是加速）**
- **减少服务器负载，避免服务器过载的情况出现。（就是减载）**

再说说缺点

- 占内存（有些缓存会被存到内存中）

> 其实日常的开发中，我们最最最最关心的，还是"更快的加载页面";尤其是对于react/vue等SPA（单页面）应用来说，首屏加载是老生常谈的问题。这个时候，缓存就显得非常重要。不需要往后端请求，直接在缓存中读取。速度上，会有显著的提升。是一种提升网站性能与用户体验的有效策略。

## http缓存分类

http缓存又分为两种两种缓存，**强制缓存**和**协商缓存**,我们来深度剖析一下**强制缓存和协商缓存各自的优劣以及他们的使用场景以及使用原理**

**http缓存流程图↓**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251104873.png" alt="image-20221025110424798" style="zoom:80%;" />

## 强制缓存

> 强制缓存，我们简称强缓存。从强制缓存的角度触发，如果浏览器判断请求的目标资源有效命中强缓存，如果命中，则可以直接从内存中读取目标资源，无需与服务器做任何通讯。

### 基于Expires字段实现强缓存(废弃)

在以前，我们通常会使用响应头的`Expires`字段去实现强缓存。

`Expires`字段的作用是，设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回。

比如说将某一资源设置响应头为:Expires:new Date("2022-7-30 23:59:59")；

那么，该资源在2022-7-30 23:59:59 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求。

但是，**`Expires`已经被废弃了**。对于强缓存来说，`Expires`已经不是实现强缓存的首选。

> 因为Expires判断强缓存是否过期的机制是:获取本地时间戳，并对先前拿到的资源文件中的`Expires`字段的时间做比较。来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”

> 是的，`Expires`过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，`Expires`字段几乎不被使用了。现在的项目中，我们并不推荐使用`Expires`，强缓存功能通常使用`cache-control`字段来代替`Expires`字段。

没想到吧，整半天，这个属性是废的。



### 基于Cache-control实现强缓存⭐

`Cache-control`这个字段在http1.1中被增加，`Cache-control`完美解决了`Expires`本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。

#### Cache-control使用分析

`Cache-control`的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒。比如↓

```js
//往响应头中写入需要缓存的时间
res.writeHead(200,{
    'Cache-Control':'max-age=10'
});
```

下图的意思就是，从该资源第一次返回的时候开始，往后的10秒钟内如果该资源被再次请求，则从缓存中读取。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251116513.png" alt="image-20221025111625463" style="zoom:80%;" />

**Cache-Control:max-age=N，N就是需要缓存的秒数。从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。**

`Cache-control`中因为max-age后面的值是一个滑动时间，从服务器第一次返回该资源时开始倒计时。所以也就不需要比对客户端和服务端的时间，解决了`Expires`所存在的巨大漏洞。

#### Cache-control属性

`Cache-control`有**max-age**、**s-maxage**、**no-cache**、**no-store**、**private**、**public**这六个属性。

- **max-age**决定客户端资源被缓存多久。
- **s-maxage**决定代理服务器缓存的时长。
- **no-cache**表示是强制进行协商缓存。
- **no-store**是表示禁止任何缓存策略。
- **public**表示资源即可以被浏览器缓存也可以被代理服务器缓存。
- **private**表示资源只能被浏览器缓存。

#### no-cache和no-store

**no_cache**是`Cache-control`的一个属性。它并不像字面意思一样禁止缓存，实际上，**no-cache**的意思是强制进行协商缓存。如果某一资源的`Cache-control`中设置了**no-cache**，那么该资源会直接跳过强缓存的校验，直接去服务器进行协商缓存。而**no-store**就是禁止所有的缓存策略了。

> 注意，no-cache和no-store是一组互斥属性，这两个属性不能同时出现在`Cache-Control`中。

#### public和private

一般请求是从客户端直接发送到服务端，如下↓

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251117020.png" alt="image-20221025111749967" style="zoom:80%;" />

但有些情况下是例外的：比如，出现代理服务器，如下↓

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251117466.png" alt="image-20221025111759422" style="zoom:80%;" />

而**public**和**private**就是决定资源是否可以在代理服务器进行缓存的属性。

其中，**public**表示资源在客户端和代理服务器都可以被缓存。

**private**则表示资源只能在客户端被缓存，拒绝资源在代理服务器缓存。

如果这两个属性值都没有被设置，则默认为**private**

> 注意，**public**和**private**也是一组互斥属性。他们两个不能同时出现在响应头的`cache-control`字段中。

#### max-age和s-maxage

**max-age**表示的时间资源在客户端缓存的时长，而**s-maxage**表示的是资源在代理服务器可以缓存的时长。

在一般的项目架构中**max-age**就够用。

而**s-maxage**因为是代理服务端的缓存时长，他必须和上面说的**public**属性一起使用（public属性表示资源可以在代理服务器中缓存）。

> 注意，**max-age**和**s-maxage**并不互斥。他们可以一起使用。

那么,Cache-control如何设置多个值呢？用逗号分割，如下↓

```c
Cache-control:max-age=10000,s-maxage=200000,public
```

**强制缓存就是以上这两种方法了。现在我们回过头来聊聊，`Expires`难道就一点用都没有了吗？也不是，虽然`Cache-control是Expires`的完全替代品，但是如果要考虑向下兼容的话，在`Cache-control`不支持的时候，还是要使用`Expires`，这也是我们当前使用的这个属性的唯一理由。**

## 协商缓存

> 温馨提示:协商缓存的内容会有一点点绕。需要仔细阅读。

### 基于last-modified的协商缓存

> 1. 首先需要在服务器端读出文件修改时间，
> 2. 将读出来的修改时间赋给响应头的`last-modified`字段。
> 3. 最后设置`Cache-control:no-cache`

三步缺一不可。如下图↓

<img src="https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYibZsxQFMqcJTwJOyVWalm33JyW3oeiaml7CoSLzOwh6QgD7ujt76eM1w/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />

注意圈出来的三行。

第一行，读出修改时间。

第二行，给该资源响应头的`last-modified`字段赋值修改时间

第三行，给该资源响应头的`Cache-Control`字段值设置为:no-cache.(上文有介绍，Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。)

**还没完。到这里还无法实现协商缓存**

当客户端读取到`last-modified`的时候，会在下次的请求标头中携带一个字段:`If-Modified-Since`。

![图片](https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYt8oGNKRC3jGicar0AaH8nvPBGbGGficPbtJibDag80uWpthYBf4t2CTmg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)image.png

而这个请求头中的`If-Modified-Since`就是服务器第一次修改时候给他的时间，也就是上图中的

![图片](https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYoMuaQT1Eq8acKrgXDcLmuGpB5bQaJ1q6mxpgZ3iclVibia7MbgqLVnqJg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)这一行。

**那么之后每次对该资源的请求，都会带上`If-Modified-Since`这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。**

如图↓

<img src="https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYEialwJnHGHh9fibdz9nAHOWkjxhaicaLZbPQlpBLfFcjXjK9h93jYbmAw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />

这样，就是协商缓存的所有操作了。看到这里，有些小伙伴可能有些迷糊了。

没关系，我们用一张图来解释下协商缓存。

<img src="https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYu6ibh9NBlBcLDusVnCJey7dhRFfjTblgUpZFJoxYOg9puiaTCrWurmqg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />

**使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。**

**1.因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。**

**2.当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件。**

**为了解决上述的这两个问题。从`http1.1`开始新增了一个头信息，`ETag`(Entity 实体标签)**



### 基础ETag的协商缓存

不用太担心，如果你已经理解了上面比较时间戳形式的协商缓存的话，`ETag`对你来说不会有难度。

`ETag`就是将原先协商缓存的比较**时间戳**的形式修改成了比较**文件指纹**。

> 文件指纹:根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。

我们来看一下流程↓

1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的`etag`字段中跟资源一起返回给客户端。

2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的`ETag`也就是文件指纹。并赋给请求头的`if-None-Match`字段，让上一次的文件指纹跟随请求一起回到服务端。

3.服务端拿到请求头中的`is-None-Match`字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的`ETag`中并返回给客户端

代码图例↓

![图片](https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYjwDA1yYnibk4Q92GtwWfVXpzZiaIicGpHMNo6HQl1kPZKfnTfJibBs0yWQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)image.png

流程示例图↓

![图片](https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNY0OOOpia3xjCYuzC3yoOE6ACUibLt2lMLKicgq4YYocdicZ3obnsibT3GaXg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)image.png

> 从校验流程上来说，协商缓存的修改时间比对和文件指纹比对，几乎是一样的。

### ETag也有缺点

- **ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。。如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。**
- **ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。**

> 值得注意的一点是，不同于`cache-control`是`expires`的完全替代方案(说人话:能用`cache-control`就不要用`expiress`)。`ETag`并不是`last-modified`的完全替代方案。而是`last-modified`的补充方案（说人话：项目中到底是用`ETag`还是`last-modified`完全取决于业务场景，这两个没有谁更好谁更坏）。



## 如何设置缓存

### 前端角度

> 你什么都不用干，缓存是缓存在前端，但实际上代码是后端的同学来写的。如果你需要实现前端缓存的话啊，通知后端的同学加响应头就好了。

### 后端角度

> 请参考文章，虽然文章里的后端是使用node.js写的，但我写了详细的注释。对于后端的同学来说。应该不难看懂。

## 哪些文件对应哪些缓存⭐⭐

有哈希值的文件设置强缓存即可。没有哈希值的文件（比如index.html）设置协商缓存

### 有哈希值的文件设置强缓存

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210251127225.png" alt="image-20221025112714179" style="zoom:80%;" />

这是我打完包之后的css文件。大家是否注意到。我划了红线的部分。明显，这绝不是我的文件名。这串和乱码一样的字符串叫`哈希值`。每次打包之后都会生产一串新的`哈希值`并追加到我们的文件名中。哈希值是打包后的文件名的一部分。

我们给css设置强缓存，哪怕缓存1W年。只要我们重新打包，生产新的哈希值。那么文件名就更改了。对于机器来说，更改了文件名的文件，就是一个新的文件。

*举个例子👇*

比如，有一个css文件a1

第一次打包a1.css文件追加哈希值变成了 a1.aaaaa.css,我们给a1.aaaaa.css设置了强缓存1W年。

然后项目改动，我们又打包了一次。打包后生产新的哈希值，a1.aaaaa.css变成了a1.bbbbb.css文件。那么当我们第一次访问a1.bbbbb.css文件的时候是不会被缓存。因为1W年的缓存是给a1.aaaaa.css文件做的。关我a1.bbbbb.css文件什么事？这样我们也就能拿到最新的改动。

其他可以被webpack生成哈希值的文件同理。

### index.html使用协商缓存

既然img/css这些文件都可以用强缓存。通过更改文件名的方式来获取最新的数据，为什么我堂堂index.html就要用协商呢？我给大家看个图

![图片](https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKlBpSDlohKWtVfY1icHaYTNYwqMlLxuItSia26iaVTibt0aszIwkWz8Joic8MQF9mO5ajV0TwgX9K9ibHqg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

因为一般情况下，index.html是不会设置哈希值的。（具体得看自己项目下的dist文件夹）

> 注意：哈希值是需要webpack生成的。不是天生的。不过有些框架会自带（比如我使用的umi.js）,设置缓存前务必看下自己的dist文件。因为如果没有配置的话，你可能所有文件都不带哈希值。

## 总结一下

- http缓存可以减少宽带流量，加快响应速度。
- 关于强缓存，`cache-control`是`Expires`的完全替代方案，在可以使用`cache-control`不要使用`expires`
- 关于协商缓存,`etag`并不是`last-modified`的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。
- 有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。
- 所有带304的资源都是协商缓存，所有标注（从内存中读取/从磁盘中读取）的资源都是强缓存。



# 页面关闭时监控前端上传数据

本文以 **“前端监控上报数据”** 的业务场景，重点解析在 **页面实例关闭** 时，如何将监控数据上传到服务端的解决方案。
其中，涉及到4种方案，分别为：

- 同步XMLHttpRequest
- img.src
- navigator.sendBeacon
- fetch keepalive

## 同步XMLHttpRequest

```js
const data = JSON.stringify({
     time: performance.now()
   });

var xhr = new XMLHttpRequest();

// 第三个参数false，表示当前请求是同步
xhr.open('post', 'http://api.wangxiaokai.vip/test', false);

xhr.setRequestHeader('content-type', 'application/json');

xhr.onreadystatechange = function() {
 // 发送成功后，页面已销毁，所以这里执行不了
}

xhr.send(data);
```

**为什么同步XMLHttpRequest可以在页面关闭时上传数据？**

**同步请求阻止代码的执行**，这会导致屏幕上出现“冻结”和无响应的用户体验。

然而，在新版的chrome（版本号大于80）已经不支持。以下是官方的公告片段：

> Chrome now disallows synchronous calls to `XMLHTTPRequest()` during page dismissal when the page is being navigated away from or is closed by the user. This applies to `beforeunload`, `unload`, `pagehide`, and `visibilitychange`.

详细解释可阅读 **Disallow Synchronous XMLHTTPRequest\(\) in Page Dismissal**[2]

**缺点**

- 用户体验差，会阻塞页面切换
- 只有旧版的浏览器支持
- 无法读取`reponse`的返回值

## img.src

创建一个`<img>`元素，并设置`src`。大部分的浏览器，都会延迟卸载当前页面，优先加载图像。

```js
var data = JSON.stringify({
   time: performance.now()
 });
 
const img = new Image();
img.src = `http://api.wangxiaokai.vip/test?${JSON.stringify(data)}`;
```

### **缺点**

- 数据传输不可靠，有可能浏览器卸载当前页面，直接杀掉图像请求
- 只能发起`GET`请求
- 数据大小有限制

## navigator.sendBeacon

通过`HTTP POST`请求，将少量数据使用`异步`的方式，发送到服务端。

```js
function reportEvent() {
 const url = 'http://api.wangxiaokai.vip/test';
 const data = JSON.stringify({
   time: performance.now()
 });
 
 navigator.sendBeacon(url, data);
}

document.addEventListener('visibilitychange', function() {
 if (document.visiblityState === 'hidden') {
   reportEvent();
 }
});
```

### **发送的时机**

浏览器端自动判断合适的时机进行发送

### **是否会产生阻塞或影响页面性能？**

- 不会产生阻塞，影响当前页面的卸载。
- 不影响下个新页面的加载，不存在性能问题。
- 另外，数据传输可靠。

### **语法**

```js
navigator.sendBeacon(url);
navigator.sendBeacon(url, data);
```

### **参数解析**

- `url`：接收请求的网络地址
- `data`：请求中携带的数据，数据格式可选：`ArrayBuffer`，`ArrayBufferView`，`Blob`，`DomString`，`FormData`，`URLSearchParams`

### **返回值**

当浏览器将数据成功**加入传输队列**时，`sendBeacon`方法会返回`true`，否则返回`false`。

> 注意返回值的时机：成功加入传输队列，而不是服务端的处理成功后的返回。

### **缺点**

- 只能发起`POST`请求
- 无法自定义请求头参数
- 数据大小有限制 （Chrome限制大小为`64kb`）
- 只能在window事件`visibilitychange`和`beforeunload`中使用，其他事件中回调，会丢失数据。

### 兼容性

![图片](https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQSSSpguQyeH8Z7iaDrp4LrM69p9gR5RUUv9NyIqQoKdMhPR3huiaunKGtWAicLWaYM8eoGNPTherJL0A/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

## fetch keepalive

MDN web docs的描述如下 ：

> The `keepalive` option can be used to allow the request to outlive the page. Fetch with the `keepalive` flag is a replacement for the **`Navigator.sendBeacon()`**[3] API.

标记`keepalive`的`fetch`请求允许在页面卸载后执行。

```js
const url = 'http://api.wangxiaokai.vip/test';
const data = JSON.stringify({
   time: performance.now()
 });
 
fetch(url, {
 method: 'POST',
 body: data,
 headers: {
  'Content-Type': 'application/json'
 },
 keepalive: true,
});
```



# 前端开发者的专业度自查 100 条

- 在需求早期沟通阶段，就能够快速、初略评估出技术路线、工作量、风险点，乃至研发排期
- 能够有效识别需求优先级，评估价值
- 对不合理的需求会说 NO
- 接受任何需求信息、变更，及时同步给必要的相关人士
- 无论大小工作，都做系分，大需求大系分，小需求小系分，不限体裁，注重实效
- 主动组织系分评审会，知道该邀请哪些相关人士参加
- 掌握必要的绘图技能，一图胜千言
- 规范制定前后端接口定义
- 使用规范的脚手架
- 使用规范的研发流程
- 代码目录清晰合理，无无效文件
- 代码中无 lint 错误
- 无错别字，无拼写错误，无多余文字
- 变量命名字斟句酌，反复推敲
- 代码实现惜字如金，通俗易懂
- 代码是给别人看的
- 足够的注释
- 代码中有必要的单测
- 不提交无效文件、临时代码、半成品代码
- 撰写优质的 commit msg
- 撰写端到端自测用例，并自己完成自测
- 撰写完备、清晰的提测邮件
- 主动协助测试同学，提供必要帮助
- 撰写发布计划，评估发布风险
- 灰度发布，关注相关监控指标，用户舆情
- 做线上回归自测
- 及时通知相关方业务发布进展
- 确保自己的业务功能有有效的监控报警、反馈渠道
- 能够有效识别会议优先级，评估价值
- 参加必须参加的会议
- 不参加不必须的会议
- 参加的会议全情投入，积极思索，主动发言，拒绝打酱油
- 做会议纪要
- 分享会议纪要给与会人员
- 不参加的会议如有必要，仍主动索取相关会议信息
- 善用钉钉等同步交流工具，掌握同步交流的技巧
- 善用语雀、github 等异步交流工具，掌握异步交流的技巧
- 认真做 code review，写 comments，不做【一键通过侠】
- 会熟练并习惯使用 3-4 种任务、项目管理工具
- 有自驱力
- 有好奇心
- 有同理心
- 有不屈的意志
- 有灵活的身段
- 有幽默的语言
- 熟练掌握 1-2 门喜闻乐见的游戏
- 接受别人交代的任务或需求，会用自己的语言组织并复述，双方意见一致
- 做事情事事有回响，件件有进展
- 一杆到底，责无旁贷
- 交代别人的事，确保对方能够用自己的语言组织并复述，双方意见一致
- 关注进度，不做甩手掌柜
- 对二手信息、二手需求保持警惕，尽量访问一手信息，追本溯源
- 会用正确的姿势鼓励人
- 会用正确的姿势赞美人
- 会用正确的姿势批评人
- 会及时有效的帮助人
- 认真写周报
- 认真写项目总结、复盘
- 认真做年度规划、季度规划
- 定期自我反思
- 技术上的沉淀写成文章，并分享给别人
- 业务上的沉淀写成文章，并分享给别人
- 自己的所思所考写成文章，并分享给别人
- 保持对前沿动态的敏感度、好奇心
- 远离网红
- 不要只懂一点点后端，至少两点点
- 不要只懂一点点架构，至少两点点
- 看书
- 《代码整洁之道》一定要看
- 坚持系统性、持续性的学习
- 掌握必要的方法论
- 有端到端的、全链路的意识和视野
- 为端到端的、全链路的结果负责
- 主动参加必要的业务规划会议或索取必要的信息
- 主动、定期与业务 KP 进行单独沟通
- 对业务的细节了如指掌
- 对业务的规划了然于胸
- 对业务有自己的独立见解
- 对业务发展能够提出自己的有价值建议
- 在业务的高压下，可以坚守职业的底线
- 在业务的发展中，可以发现技术的机会
- 读开源好代码
- 善用各种各样的工具、脚本提升自己的产能
- 自己研发各种各样的工具、脚本
- 分享自己研发各种各样的工具、脚本
- 【真正】喜欢的技术或东西，挤时间也要做，不用【业务忙】做挡箭牌
- 业务结果是给公司的，能力成长是给自己的，共同进步是给大家的
- 我为人人，才能人人为我
- 大家好才是真的好
- 写文档，结构清晰，提供挈领
- 写文档，排版整齐，干净利落
- 写文档，拒绝任何错别字，拒绝任何错别字，拒绝任何错别字
- 要谦虚
- 要正直
- 工作开心
- 信任你的同事
- 笑脸接客
- 以礼待人

# 程序员做不好哪些事情容易被开除

## 看不懂需求和代码

首先要说明的是，看不懂别人写的业务代码是很正常的，因为这块代码要做什么、它的背景是什么，你完全不知道，可能已经被人改了几十次了，逻辑分支早已混乱不堪，你一个新人看不懂很正常。

还有就是新人刚开始工作的时候，可能会有需求理解不到位、需求漏做、拖延上线等等问题，这些都很常见。

那么，新人怎么才能快速理解需求并且写好代码呢？这里分两方面来说。

### 1、如何更好的理解需求

**首先是做好沟通**，一些基本的概念性问题，你可以先问问有没有相关的文档可以看，然后再自己去网上搜一搜，最后可以选择去问问产品经理或者项目经理；

如果实在是一些历史包袱比较重的需求，建议你让产品经理或者项目经理把整个来龙去脉给你讲明白。

**可能有的人会羞于问问题，其实大家讨厌的不是提问的人，而是讨厌伸手党和重复问一个问题的人，没有人会讨厌认真的人。**

**然后是，做好需求的拆分。** 刚入职的人一定要做好需求功能点的拆分，比如说让你做一个网页，那你可以拆分好这个页面分为哪几个部分，有哪些可以封装成组件，又有哪些部分是可能你搞不定需要去github找的，这些问题都想清楚了，写代码的思路会非常清晰，也不容易发生需求漏做和排期不准确的情况。

### 2、如何更好的写代码

可能自己平时做练习的时候很简单，但是到了公司里面一个项目就几万行代码，看起来很费劲，写起来更费劲，这里有几个技巧可以借鉴。

**首先是把握好主脉路即可，放弃细枝末节。**

代码千千万，如果一行一行的看那肯定是看到下个月也看不完，我们看项目重点看这几部分（以前端项目为例）：

1. 项目的依赖
2. 项目如何启动
3. 项目的入口文件
4. 项目的路由文件
5. 项目的状态管理文件
6. ...

这几部分看完了，基本上一个项目的大致你就明白了

**然后是，debug是熟悉项目最快的方式**

如果你想快速熟悉一个项目，那么我觉得最快的方式就是你去解决几个bug，因为解决bug是一种主动的、带着问题去看项目的一种方式，在解决bug的过程中你不得不深入某些逻辑分支，你也不得不去做调试、看日志等等，不知不觉中，你就熟悉了项目。

总之，理解好需求、写好代码，是不会被开除的第一步。

## GIT不熟练

git这个问题应该是个经典问题，群里的小伙伴最近找到工作的，多多少少都问过我git相关的东西

git用的不熟练，可能会遇到以下问题：

1. 仓库都给你半天了，你代码还没拉下来，耽误项目进度
2. 写好的代码推不到仓库里去，耽误项目进度
3. 和同事在同一个需求上开发，多分支出现冲突不知道怎么解决，耽误别人的工作时间，甚至把别人写的代码弄没了
4. 不会合并代码，或者合代码的时候出错

这些git使用问题，看你自己做自己的项目或者在培训班做项目的时候，很难遇到，但是工作中你需要的别人配合了，你们是一个小团队做协同开发，不懂git或者git命令不熟练，那你的工作很难做得好。

所以，git不熟练可能会被开除，那你至少应该熟练掌握哪些git知识才能避免试用期就被开除呢？

我觉得有以下这些：

1. 如何配置ssh key
2. 如何clone仓库
3. 如何新建并切换分支
4. 如何保存本地的代码并且提交commit到自己的分支
5. 如何push commit到远程仓库
6. 如何向主分支提交pr
7. 如何merge代码，注意这里你需要了解一下merge和rebase的区别
8. 如何解决代码冲突

当然了这些问题也不是说你一下子就能全都掌握的，感兴趣可以进群讨论，总之熟练的掌握git你将更好的工作，避免被开除。

## 不懂联调

这个问题也很常见，大部分人工作前都是单打独斗，真正在工作中和后端联调的时候，开始慌了，其实注意以下几点就好了（以前端为例）。

找后端要联调环境地址

> 所谓联调就是，后端在某个服务器上面起一个服务，然后你去调用ta的接口，来验证整个流程是否可以走通。联调的时候首先是需要后端给你一个联调环境的地址，然后你把请求发送到联调服务器上去，就是这么简单。

优先调主流程

> 联调的时候不要把时间浪费在细枝末节上，尽量多把时间花费在主流程的调通上，比如说你做了一个保存的功能，那最重要的就是保存流程的走通，至于什么选项多了少了之类的，都不重要。

接口质量太差，可以找后端battle

> 有时候联调的时候发现后端的接口10个里面有5个都是不通的，一调就报500错误，那你就别浪费时间了，让后端自己用postman把接口调通了再给你。

职场里面虽然大家都应该保持和气，但是必要的battle还是需要的。做好联调，避免被开除。

## 不懂怎么上线

不同公司的上线流程不一样，很多大公司的上线流程基本都可视化了，就用鼠标点一点就上线了，这里着重讲讲在小公司该怎么办（以前端为例），好像群里有粉丝反馈这里不会。

1. 首先你需要把项目打包好
2. 把打包后的文件上传到服务器的指定文件夹
3. 配置好接口的转发，一般是配置nginx
4. 重启server

这里面你需要这些知识：

1. 基本的linux命令，比如上传文件到指定服务器等等
2. 基本的nginx知识，比如配置文件、重启等等
3. 掌握好这些知识，也可以避免被开除。

# 接私活平台⭐

## 什么样的私活不能接 

1、没有第三方担保的个人对个人的尽量不要接，双方都没保障，出了问题很大的可能撕破脸皮不了了之。

2、一上来就直接说给我开发一个什么软件，不说具体需求，没有需求文档的都不靠谱，这样的项目不要接。

3、尽量442收费方式，即开工收40%项目款，项目中期收40%项目款，项目结束收20%项目款。一开始不给钱的，尽量不要接，这一点一定要记住，否则很容易付出了劳动得不到应得的收入。

不给完钱，不交完整代码。你的成果就是代码，如果没给完钱，就把代码交给了对方，也容易被坑到。

## 国内远程工作平台，接单平台

### 1、CODING 码市

**官方网站：https://mart.coding.net**

著名的Coding旗下的互联网软件外包服务平台，平台以外包为主。



### 2、 开源众包

**官方网站：https://zb.oschina.net/projects/list.html**

开源中国的众包平台，主要是以众包为主。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241743703.png" alt="image-20221124174327567" style="zoom:80%;" />

**什么是软件众包**

目前软件众包分为简单任务和复杂任务，简单软件众包的任务可以由个人来承担，比较复杂的软件可以同时协同多人完成的任务

它的流程是：首先发包人对任务进行细分，分解到最小后，然后分包出去，按照各自的能力和知识水平领包，最后完成任务，发包人通过审核通过之后，项目才算完成。

### 3、猪八戒

**官方网站：https://zbj.com**

找兼职的地方，主要是入门级项目，不适合专业程序员，上面各类需求发布都有不限于软件开发行业，更适合新手。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x7RXV2owe3IFUL0XHShicWORot1Xr4arqm1b9ibZ0IBXr5zxLYFWSib98RoxmE6PvoKmXF2BfSH6PNrg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)



### 4、程序员客栈

**官方网站：https://www.proginn.com**

程序员，产品经理，设计师等互联网相关人员，都能在上面找到适合自己的项目。支持自由、远程和兼职工作，还可以按需雇佣，工作模式非常多 。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241744495.png" alt="image-20221124174402359" style="zoom:80%;" />

### 5、英选

**官方网站：http://linktion.cn**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241744658.png" alt="image-20221124174422555" style="zoom:80%;" />

虽然是外部平台，当他们还是针对外部项目的一些长期令人诟病的问题进行了一些优化，如下图：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241744812.png" alt="image-20221124174437747" style="zoom:80%;" />

### 6. 开发邦

**官方网站：http://www.kaifabang.com**

特点：服务范围明确，IT开发项目垂直度高，能吸引到一部分需求明确的客户。

微信搜索公众号：前端技术编程，回复：前端 领取资料 。

平台也致力于利用互联网软件技术为客户提高效率、降低成本、提升效能、优化管理。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241744105.png" alt="image-20221124174453996" style="zoom:80%;" />

### 7、猿急送

**官方网站：https://www.yuanjisong.com/**

平台特点：追求高质量的雇主和工程师，汇聚了知名互联网公司的技术、设计、产品大牛，通过实际坐班、远程等方式，一对一为创业公司解决问题，提高创业效率。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241745078.png" alt="image-20221124174509980" style="zoom:80%;" />

### 8、人人开发

**官方网站：http://rrkf.com**

基于可视化快速开发平台 - 捷得(Joget)/捷得云(Joget Cloud)(PaaS),集众多开发者资源,为企业提供企业管理软件服务

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x7RXV2owe3IFUL0XHShicWORiahwy1xfU8oeQhw6EIMvobchkficicr20vHvm24LicFYKociaGEwxGqNMpg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241745936.png" alt="image-20221124174535851" style="zoom:80%;" />

## 国外远程工作平台

### 1、 Freelancer

**官方网站：https://www.freelance.com/**

工作类型主要覆盖了程序开发到市场营销、广告、会计等一系列的可以远程的工作。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211241745288.png" alt="image-20221124174550147" style="zoom:80%;" />

### 2、Stackoverflow

**官方网站：https://stackoverflow.com/jobs**

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/WwPkUCFX4x7RXV2owe3IFUL0XHShicWORTLL4b6fUgynx9yOQicQhgWQHRPkXVicEPksl3qyam5YkzD722Nj9KhBA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)



Stackoverflow 是程序员非常热爱的一个社区，但是其本身就为程序员提供了远程工作的服务，Stackoverflow Jobs 里有远程职位的筛选，这里有丰富的远程技术职位。相Freelancer 更容易被程序员接受。

## 双方信息对称很重要，诚信为本

1、一些私活多数是远程工作，这要求双方在需求沟通过程中信息能对称，特别作为乙方的程序员，需要培养自己良好的沟通能力，这样能减少因需求不明确导致的设计频繁修改，项目延期等问题，提高项目交付效率，建立信任关系。

2、目前程序员私活的市场现状是僧多肉少，在接单过程中很可能遇到同行竞争压价（一些工作室长期接单，积累大量框架模板，能比个人快很多的速度交付，通过降低开发成本，压低市场价格，另外一方面后续他们也会通过一些手段赚取客户更多，比如：收取相对高额的售后费用，骗取基于创业的小白缴纳一些系统加盟费之类的。

最好选择一到二个平台长期经营，能在本地找到长期合作方建立信任关系是最好。

**写在最后**

接私活会占用你大量的业余时间，所以是否应该接私活，自己一定要慎重考虑一下，毕竟，业余时间也是提升你自己的时间。也不是说不要接，可以尽可能的接一些能对自己有提升的项目，比如该项目中大部分东西你都没问题，但是小部分技术，还需要自己去学习一下，才可以搞定。这种项目其实是最好的，既赚了外快，也提升了自己。不建议接那种对自己没有挑战的私活，可以把业余时间放到提升自己技术上面，从而为以后找到更好的工作。



# SPA vs MPA vs PWA

今天来看三个重要的概念：SPA、MPA、PWA。

## 1. 单页面应用程序（SPA）

> SPA 全称为 Single-Page Application，表示单页面应用程序。在单页面应用程序中，我们不会为每个路径创建多个 HTML 文件，而是使用 JavaScript 为同一页面上的不同路径呈现不同的组件。当从浏览器请求单页面应用程序时，就会下载一个bundle.js文件，该文件包含所有请求网站的已编译 JavaScript 代码。使用这种方法，浏览器会通过使用 HTML5 History API 根据用户选择的路径呈现单个页面。

> 如果网站使用了延迟加载，那么可能会有多个bundle.js文件会根据请求的路径进行下载。因此，除了特殊情况，否则不会重新加载页面（再次从服务器请求）。如果想维护应用程序的状态，这一点是非常重要的，因为重新刷新页面就会重置应用程序的状态。

#### ☀ SPA 优点

- **提高页面加载速度，从而获得更好的用户体验：**它们通常只加载一次。加载后，页面渲染取决于浏览器的速度。
- **更少的服务器负载：**渲染逻辑在浏览器中执行。服务器和客户端之间只发送相关数据。
- **缓存：**只向服务器发送一次请求，返回的响应会被缓存，也可以离线使用SPA。
- **调试：** React 和 Vue 等 SPA 框架提供了调试工具，这使开发人员的开发调试更加轻松。
- **代码可重用性：**开发人员可以重用代码，这使得开发效率更高。
- **转场动画：**容易实现。
- **页面间数据传递**：因为在一个页面内，所以页面之间数据传递很容易

#### ☀ SPA 缺点

- **搜索引擎优化 (SEO) 较差：**搜索引擎具有可以解析 JavaScript 的爬虫，但它们很难爬取异步内容。加载初始页面后，不知道还有其他数据的爬虫将停止爬取，从而导致 SEO 效率低。
- **内存泄漏：**事件监听器占用大量空间。使用 SPA 在客户端很容易引入内存泄漏，如果将事件侦听器添加到全局对象，而没有在卸载组件时删除它们，就会产生内存泄漏。如果不想导致内存泄漏，则需要清理事件侦听器、定时器等。
- **安全性：**与 MPA 相比，SPA更容易受到跨站点脚本攻击（XSS）。

## 2. 多页面应用程序（MPA）

MPA 全称 Multi-Page Application，表示多页面应用程序。多页面应用程序由多个 HTML 文件组成，每当请求页面时就会下载这些文件。我们在地址栏输入的每个新的 URL 或单击的每个超链接时都会向服务器发送一个新请求，并下载一个新的页面。在这种方法中，服务器完成了较为繁重的工作。因此，如果用户的网络连接较差，每个页面可能需要很长时间才能加载出来。

#### ☀ MPA 优点

- **搜索引擎优化（SEO）更好：**单页可以只有有限数量的关键字，但多页应用程序可以为多个页面提供相同数量的关键字，这为爬虫提供了更多关于网站的信息.
- **良好的可扩展性：**可以持续添加功能，不断扩展。但在 SPA 中，随着不断添加功能，bundle.js 将会不断增长，因此要么减少内容，要么进行延迟加载。
- **内存泄漏很少见：**服务器端很有可能出现内存泄漏，但客户端内存泄漏很少见，因为浏览器将为每个导航链接加载不同的脚本。

#### ☀MPA 缺点

- **加载速度慢：**它们不断地为每个请求加载新页面（即使 UI 发生了细微的变化，页面也必须重新加载）。如果客户端的网络连接不好或服务器速度慢，加载速度就会下降，最终导致用户体验不佳。
- **开发效率低：**代码可重用性较低，文件较大，前端与后端的耦合更紧密。这些因素会使开发效率低。
- **增加服务器负载：**与服务器的每次交互都包含一个需要渲染的 UI 包。
- **转场动画：**无法实现。
- **页面间数据传递**：依赖URL、Cookie、或者localStorage等，实现麻烦。

## 3. 渐进式应用程序（PWA）

PWA 全称 Progressive Web Apps，表示渐进式应用程序。渐进式应用程序可以在独立的窗口中运行，而不是在浏览器的选项卡中运行。简单的说，它们是一种web应用程序，类似于本地应用程序，可以安装在手机、平板电脑或者笔记本电脑上。下载后，用户可以通过屏幕上的图标访问该应用。这种应用还可以向用户发送推送消息和通知。渐进式应用程序可以是 单页面应用（SPA）也可以是多页面应用（MPA）。

想要申请 PWA 应用，必须满足三个条件：

1. **安全上下文 (HTTPS)：** 安全上下文是为用户身份验证和机密性定义的最低标准。PWA 的许多 API 和许多功能（如地理定位）只有在应用程序通过安全网络提供服务时才可用。
2. **Service Worker：** Service Worker 是在后台运行并控制浏览器如何处理网络请求和内容缓存的脚本。PWA 通过服务工作者提供离线服务。
3. **清单文件：**这是一个 JSON 文件，用于保存 PWA 所需的应用程序信息，例如应用程序的名称、启动 URL、多种尺寸的图标和主题颜色。

与原生移动应用程序相比，渐进式 Web 应用程序更小。研究表明它们有助于增加流量和用户参与度，并降低跳出率，这主要归功于它的离线可用性。



# 必备基础英文单词

在前端开发过程中，掌握一些常见英语词汇是必要的，今天跟大家分享一些前端常见的英语词汇，供大家参考使用。

## 导航类

```
导航：nav
标题：title
摘要：summary
菜单：menu
子菜单：submenu
主导航：mainbav
子导航：subnav
顶导航：topnav
边导航：sidebar
左导航：leftsidebar
右导航：rightsidebar
```

## 页面结构布局

```
容器：container
页头：header
内容：content/container
页尾：footer
导航：nav
侧栏：sidebar
栏目：column
页面主体：main
左右中：left right center
页面外围控制整体布局宽度：wrapper
```

## 功能

```
标志：logo
滚动：scroll
广告：banner
登录：login
注册：regsiter
搜索：search
图标：icon
注释：note
指南：guild
状态：status
服务：service
按钮：btn
热点：hot
新闻：news
下载：download
版权：copyright
投票：vote
标签页：tab
登录条：loginbar
面包屑：breadCrumb
当前的：current
小技巧：tips
功能区：shop
文章列表：list
提示信息：msg
合作伙伴：partner
友情链接：friendlink
```

## CSS 英文释译

```
线：line
行：row
宽 ：width
高：height
外边界：margin
内边界：padding
边框：border
行高：line-height
背景：background
颜色：color
顶部：top
标题：title
字体：font
身体：body
大小：size
列表：list
文本：text
样式：style
对齐：align
图像：image
修饰：decoration
资源：source
宽度：width
穿过：through
高度：height
缩进：indent
斜体：italic
链接：link
加粗：bold
斜体：italic
加重：weight
加粗：bold
输入：input
主体：main
下面的：under
重复：repeat
填充：padding
位置：position
正常：normal
父级 parent
子级：children
隐藏：hidden
显示：visible
溢出：overflow
列表：list
样式 style
导航：nav
显示类型：display
广告图片：banner
页眉：header
```

## 文件命名

```
主要的：master
模块：module
重置：reset
基本共用：base/common
布局，版面：layout
主题：themes
专栏：columns
文字：font
表单：forms
补丁：mend
打印：print
混入：mixins
组件：components
静态资源：public/static
路由：router
页面/视图: pages/views
配置: config
```

## 其他

```
broswer 浏览器（客户端）
html 超文本标记语言
css 层叠样式表
javascript 语言名字(类似python/php/c…)
title 标题
body 身体
head 头
div 盒子(类似收纳箱)
font 字体
width 宽
height 高
background 背景
color 颜色
ul (Unordered List) 无序列表
ol (Ordered List) 有序列表
li (List Item) 列表项
dl (Definition List) 自定义列表
form 表单
action 地址
method 方法
input 输入框
text 文本
password 密码
radio 单选
checkbox 多选
select 下拉菜单
option 选项
padding 内边距
margin 外边距
border 边线
solid 直线
dashed 虚线
dotted 点线
overflow 溢出
hidden 隐藏
visibility 可见度
table 表格
thead 表头
tbody 表格内容
tr (table row) 行
td/th (table data, table headline)列
rowspan 合并行
colspan 合并列
collapse 合并
position 定位
relative 绝对定位
absolute 相对定位
fixed 固定定位
static 静态定位
script 脚本
string 字符串
number 数字
boolean 布尔
undefined 未定义
null 空(None)
function 函数
document 文档
get 获取
element 元素
by 通过
id id
tagName 标签名
window 窗口
object 对象
array 数字(类似python中的list列表)
setInterval 定时器
clearInterval 清除定时器
$ 美元符号
next 下一个
prev 前一个（previous）
parent 父母/双亲
children 孩子
click 点击
mouseleave 鼠标移开
mouseenter 鼠标进入
animate 动画
slide 滑动
fade 渐进
show 显示
hide 隐藏
test 测试
stopProperation 阻止冒泡
preventDefault 阻止默认行为
dom document object model 文档对象模型
ajax 啊甲克斯
type 类型
url 统一资源定位符
data 数据
dataTpye 数据类型
success 成功
error 失败
done 成功
fail 失败
mustache 胡子
computed 计算
watch 监听
filters 过滤器
mounted 挂载，生成
axios vue中的ajax
let 变量
const 常量
```

# 前端字符编码

在开发过程中经常会遇到各种各样的编码，常见的有 UTF－8、Unicode、Base64 等，但前端世界远不止这三种编码，本文就来介绍前端常见的编码以及其使用方式。

## ASCII

我们知道，计算机只能理解二进制，二进制语言是面向机器的语言，直接来自计算机的指令系统，由 0 和 1 组成。它使用整数来编码数字（0-9）、大写字母（A-Z）、小写字母（A-Z）以及分号（；）、感叹号（！）等。例如，97 用于表示“a”，33用于表示“！”，这样就可以方便地存储在内存中。

互联网的早期只有英文字母，所以不需要担心任何其他字符，ASCII 就可以适用于这种情况的字符编码，例如 bits 对应的二进制如下：

```
01100010 01101001 01110100 01110011
   b        i        t        s
```

ASCII  全称为 American Standard Code for Information Interchange，即“美国信息交换标准代码”，是基于拉丁字母的一套电脑编码系统。ASCII 至今为止共定义了 128 个字符：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCxh0GuwlImdZKYDG6nE4lrJVxKMic2icrOaicRW8WPbhrV4TZSZ4cSxFLg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

ASCII 可以分为两类：

- **可显示字符**：编号范围是32-126（0x20-0x7E），共 95 个字符：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCb3Kx63icQYOJUgAvcanec4yCpURyUuUAVW5iatnuk63lVPsVVQzJUQUg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- **控制字符**：编号范围是0-31和127（0x00-0x1F和0x7F），共 33 个字符：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCE9CU1TrMyic4HkUBEscMiaZUqYX08WvKIlVW0kAj3TkcQEbIYywAR6gw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

可以看到，ASCII 码实际上是一种映射，是从二进制字符到字母数字字符的映射。所以当计算机收到以下二进制文件时：

```
01001000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100
```

使用 ASCII 码进行映射，上面的二进制编码可以翻译成“Hello world”。

“K” 在ASCII 中是75，可以将它转化为二进制，将 75 除以 2，然后继续，直到得到 0。如果除法不准确，则加 1 作为余数：

```
75 / 2 = 37 + 1
37 / 2 = 18 + 1
18 / 2 =  9 + 0
9 / 2 =   4 + 1
4 / 2 =   2 + 0
2 / 2 =   1 + 0
1 / 2 =   0 + 1
```

现在，提取“余数”并以相反的顺序放入它们：

```
1101001 => 1001011 
```

因此，在 ASCII 中，“K”在二进制中被编码为 1001011。

ASCII 的主要缺点是它只能表示 256 个不同的字符，因为它只能使用 8 位。ASCII 不能用于对世界各地发现的许多类型的字符进行编码。但是如果想在计算机上使用中文、俄语、日语时，就需要一个不同的编码标准。Unicode 进一步扩展为 UTF-8、UTF-16、UTF-32以对各种类型的字符进行编码。因此，**ASCII 和 Unicode 之间的主要区别就是用于编码的位数**。下面就来看看 Unicode 的概念以及使用方式。

## Unicode

Unicode 是另一种字符编码，它仍然是：位查找 -> 字符，由 Unicode Consortium 维护，其负责制定国际使用的软件标准。IT 行业将 Unicode 标准化以对计算机和其他电子和通信设备中的字符进行编码和表示。

Unicode 由许多代码点组成（将来自世界各地的大量字符映射到所有计算机都可以引用的键），代码点的集合称为字符集，这就是 Unicode。开发 Unicode 的目标是通过一种独特的方式将世界上任何语言的任何字符或符号转换成唯一的数字。可以在 unicode.org 上查找任何 Unicode 字符的编号，包括表情符号！

Unicode 看起来像这样：

```
U+0048：拉丁文大写字母 H
U+0065：拉丁文小写字母 e
U+006C：拉丁文小写字母 l
U+006C：拉丁文小写字母 l
U+006F：拉丁文小写字母 o
U+0020：空格 [SP]
U+0057：拉丁文大写字母 W
U+006F：拉丁文小写字母 o
U+0072：拉丁文小写字母 r
U+006C：拉丁文小写字母 l
U+0064：拉丁文小写字母 d
```

可以使用以下格式在 JavaScript 字符串中添加 unicode 序列 \uXXXX：

```
const s1 = '\u00E9' //é
```

可以通过组合两个 unicode 序列来创建一个序列：

```
const s2 = '\u0065\u0301' //é
```

虽然两个字符串的结果都是 é，但它们是两个不同的字符串，并且长度也不相同：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwC20IJGI4ricIK4HwIUrL4ZeGA7w81AZxWMibibPT4rr1NwvER2BFtTDENg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

ASCII 和 Unicode 是两种流行的编码方案。ASCII 编码符号、数字、字母等，而 Unicode 编码来自不同语言、字母、符号等的特殊文本，可以说 **ASCII 是 Unicode 编码方案的一个子集**。它们两个的区别如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCAyqP88SEdhhAB4kqzFQcOQWYwU5KgLdD5A3cgic8oib7frYSoULh8k8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## UTF-8、UTF-16、UTF-32

### 基本概念

**UTF 是 Unicode 编码方式的一种**。UTF 编码由 Unicode 标准定义，能够对需要的每个 Unicode 代码点进行编码。Unicode 编码方案根据用于对字符进行编码的位数进行分类。目前使用的 Unicode 编码方案有 UTF-7、UTF-8、UTF-16 和 UTF-32 ，分别使用 7 位、8 位、16 位和 32 位来表示字符。

那如何知道文件将使用哪种编码呢？有一种称为字节顺序标记(BOM，即 Byte Order Mark) 的东西，也称为编码签名。BOM是文件开头的一个两字节标记，用于标识文件是采用哪种格式的编码。

UTF-8 在互联网上使用最多，在 HTML5 中也被指定为文档的首选编码，所以下面将主要介绍 UTF-8。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwC4FakB00mRFrBjrl1xYnKnjHML1Kgg0MLIs3dpUlicDtnq23xSZHccPw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

UTF-8 将 0-127 的所有 Unicode 代码点编码为 1 个字节（与ASCII相同）。这意味着如果使用 ASCII 对程序进行编码，而用户使用 UTF-8，将不会有任何错误。1993年创建 UTF-8 时，很多数据都是 ASCII 格式的，所以通过兼容 UTF-8，在使用前不需要对数据进行转换。本质上，ASCII 格式的文件可以被视为 UTF-8 格式，而且可以正常工作。

### 工作原理

下面来详细看看 UTF-8 是如何工作的，以及为什么它会根据被编码的字符具有不同的长度。

UTF-8 以**动态方式**存储数字。Unicode 列表中的第一个占用 1 个字节，最后一个最多占用 4 个字节，如果处理的是英文文件，大多数字符可能只占用 1 个字节，与 ASCII 中的相同。**这是通过用不同的字节数覆盖 Unicode 中的不同范围来实现的**。

例如，要编码原始 ASCII 表中的字符（0-127），只需要 7 位，因为 27= 128。因此，可以将所有内容存储在 8 位的 1 字节中，并且仍然剩余一个空闲空间。而对于下一个范围（128-2047），就需要 11 bits，因为211＝2048，在 UTF-8 中就是 2 个字节。![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCzvTIZoWdfHuKFWEKF0BXHsPT2ge8PqYoWbdwFYK3BdDuZCZenRWAsA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)计算机在读取 UTF-8 中以 0 开头的内容时，就知道只需要读取一个字节并显示 Unicode 中 0-127 范围内的正确字符即可。如果遇到两个 1，就需要读取 2 个字节，范围为128-2047，3 个 1 在一起表示需要读取三个字节。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCrFQW4EriasoPwae44eKYd8jecnjFhgHwc4CsKmVznKCaO1KkG1guB5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### UTF-16、UTF-32

世界范围内使用的大量字符是无法全部使用 8 位表示法进行编码，导致在 Unicode 编码下产生了 UTF-16 和 UTF-32 编码格式。在解释这些编码格式之前，先来看看平面的概念：

> Unicode 编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。

UTF-16 是 Unicode 编码集的一种编码形式，把 Unicode 字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。

**UTF-16 编码规则：**

- 编号在 U+0000—U+FFFF 的字符（常用字符集），直接用两个字节表示。
- 编号在 U+10000—U+10FFFF 之间的字符，需要用四个字节表示。

那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？

UTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。

辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。

因此，当我们遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。

以 “**𡠀**” 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：

- 首先计算超出部分的结果：0x21800 - 0x10000
- 将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：0001000110 0000000000
- 将得到的两个10位二进制数分别对应到两个区间中
- U+D800 对应的二进制数为 1101100000000000， 将0001000110填充在它的后10 个二进制位，得到 1101100001000110，转成 16 进制数为 0xD846。同理，低位为 0xDC00，所以这个字的UTF-16 编码为 0xD846 0xDC00

UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。比如“马” 字的 Unicode 编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的 UTF-32 编码。

### 指定编码方式

如果没有显式指定编码方式，浏览器假定任何程序的源代码都是用本地字符集编写的，这会因国家/地区而异，可能会出现意料之外的情况。因此，给 JavaScript 文档设置字符集非常重要。那该如何指定 UTF 编码呢？

如果使用 HTTP（或 HTTPS）获取文件，则 `Content-Type` 标头可以指定编码标准：

```
Content-Type: application/javascript; charset=utf-8
```

如果没有设置，可以检查 `script` 标签的 `charset` 属性：

```
<script src="./app.js" charset="utf-8">
```

如果未设置，可以将它嵌入到 `<head>` 的顶部。

```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
</head>
```

注意，这两种情况下的 `charset` 属性都不区分大小。

虽然 JavaScript 源文件可以是任何类型的编码，但 JavaScript 会在执行之前在内部将其转换为 UTF-16。正如 ECMAScript 标准所说，JavaScript 字符串都是 UTF-16 序列：

> 当 String 包含实际文本数据时，每个元素都被视为单个 UTF-16 代码单元。

## Base64

### 基本概念

Base64 也称为 Base64 内容传输编码。Base64 是将二进制数据编码为 ASCII 文本。但它只使用了 64 个字符，再加上大多数字符集中存在的一个填充字符。所以它是一种仅使用可打印字符表示二进制数据的方法。Base64 常用于在通常处理文本数据的场景，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。

Base64 编码用于通过不能正确处理二进制数据的介质传输数据。因此，对数据进行 Base64 编码以确保数据完整，无需通过此介质进行任何修改。base 64 编码结果形式如下：

```
OWRjNGJjMDY5MzVmNGViMGExZTdkMzNjOGMwZTI3ZWI==
```

### Base64 编码

Base64 编码会将每 3 个字节的数据翻译成 4 个编码字符。它将从左到右开始扫描，然后选择代表 3 个字符的数据的前 3 个字节。这 3 个字节将是 24 位。现在它将把这 24 位分成四部分，每部分 6 位。然后每个 6 位组将在下表中进行索引以得到映射的字符：

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCrI4OrpqXxqbalqt9IIicTIPuf5ZmAYjpeDyYpGY7t9ic6BDYVpRvPfcw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

比如，有以下字符串：

```
ab@
```

它的位表示将是：

```
   a          b        @
01100001  01100010  01000000
```

这些总共 24 位将被分为 4 组，每组 6 位：

```
011000 010110 001001 000000
```

它的数字表示为：

```
  24    22     9      0
011000 010110 001001 000000
```

使用上面的数字索引到 base64 表中，映射结果如下：

- 24 → Y
- 22 → W
- 9 → J
- 0 → A

所以，这个字符串的base64编码就是：

```
YWJA
```

那如果输入的字符串不是 3 的倍数怎么办？这种情况下，就会使用填充字符`=`**。**假设字符串有 4 个字符

```
ab@c
```

它的位表示将是：

```
   a          b        @        c
01100001  01100010  01000000 01100011
```

前三个字节将组合在一起。最后的字节将用 4 个额外的 0 填充，以使总位可以被 6 整除：

```
011000 010110 001001 000000 011000 110000
  24     22     9      0      24     48
```

使用上面的数字索引到 base64 表中，映射结果如下：

- 24 → Y
- 22 → W
- 9 → J
- 0 → A
- 24 → Y
- 48 → w

结果如下：

```
YWJAYw==
```

这里，每两个额外的 0 由 = 字符表示。由于添加了 4 个额外的零，因此最后有两个 =。

### Base64 解码

说完了 Base64 编码，下面来尝试将 base64 编码的字符串解码为原始字符串。以以下 Base64 字符串为例：

```
YWJAY2Q=
```

将其分组为 4 个字符一组：

```
YWJA 
Y2Q=
```

现在从每个组中删除最后的 = 字符。对于剩余的字符串，将其转换为上表中相应的位表示形式。

```
  Y      W       J      A     
011000 010110 001001 000000

  Y      2      Q
011000 110110 010000
```

现在将其分组为一组 8 位，保留尾随的 0：

```
01100001  01100010  01000000 
01100011  01100100
```

现在对于上面的每个字节，根据 ASCII 表分配字符：

```
01100001  01100010  01000000
   a          b         @   

01100011  01100100
   c          d
```

因此最终的字符串就是：**ab@cd**

### 填充

那为什么要将 Base64 编码后的字符串分成 4 个一组进行解码呢？就是因为填充`=`。填充 `=` 对于 base64 编码是否有必要呢，因为在解码时又丢弃了填充。主要考虑两种情况：

- 发送单个字符的字符串时不需要填充；
- 发送多个字符的字符串的 base64 编码时，填充就很重要。如果连接未填充的字符串，则将无法获得原始字符串，因为有关添加的字节的信息将丢失。

来看下面的例子：![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCoZnGXV9n9Vq6jog4mkDtBFSjBjia85aIF2lzDrbROa4ib5YgicunWgBibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**当发送连接时没有填充，** 合并的 Base64 字符串将是：YQYmMZGVm，尝试解码它时，会得到如下字符串，这是不正确的：

```
a&1
```

**当使用填充发送连接时，** 合并的 Base64 字符串将是：YQ==YmM=ZGVm，尝试解码它时，会得到以下字符串，这是正确的：

```
abcdef
```

所以，当传输多个字符时，填充是很有必要的。

因为基本上 Base64 在填充的情况下会将 3 个字节编码为 4 个 ASCII 字符。四个 ASCII 字符中的每一个都将作为 1 个字节通过网络发送。因此，最终的尺寸总是比原来的尺寸大 33.33%。因此，如果字符串的原始大小为 n 个字节，则经过 base64 编码后的大小将为：

```
n * 4/3
```

## JavaScript 编解码

最后来看看 JavaScript 中提供的关于编解码的方法。

### UTF-8

URL 只能包含标准的 ASCII 字符，所以必须对其他特殊字符进行编码。在 JavaScript 中，可以通过了以下方法对 URL 来做 UTF-8 编码与解码：

- `encodeURI`、`decodeURI`
- `encodeURIComponent`、`decodeURIComponent`

这里的编码指的就是将二进制数据转换为 ASCII 格式的方式，解码反之亦然，即将 ASCII 格式转换回原始内容。

那 `encodeURI` 和 `encodeURIComponent` 有什么区别呢？

- encodeURI 用于**编码完整的 URL**：

```
encodeURI('https://domain.com/path to a document.pdf');

// 结果：'https://domain.com/path%20to%20a%20document.pdf'
```

- `encodeURIComponent` 用于编码 URI 组件，例如查询字符串：

```
`http://domain.com/?search=${encodeURIComponent('name=zhang san&age=19')}`;

// 结果：'http://domain.com/?search=name%3Dzhang%20san%26age%3D19'
```

需要注意，有 11 个字符不能使用 `encodeURI` 编码，而需要使用 `encodeURIComponent` 进行编码：

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMP7j88v55Rtkg5yesQibtHwCp7K7rkCnPk3xl3q5Y2yQWlFicrggRyauDcCToF5X9UHROf04qCICPaQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

另外，decodeURI 和 decodeURIComponent 是对分别由 encodeURI 和 encodeURIComponent 编码的字符串进行解码的方法。

```
decodeURI('https://domain.com/path%20to%20a%20document.pdf');

// 结果：'https://domain.com/path to a document.pdf'

`http://domain.com/?search=${decodeURIComponent('name%3Dzhang%20san%26age%3D19')}`;

// 结果：'http://domain.com/?search=name=zhang san&age=19'
```

需要注意，`encodeURIComponent` 不编码 `- _ . ! ~ * ' ( )`。如果要对这些字符进行编码，则必须将它们替换为相应的 UTF-8 字符序列：

```
const encode = (str) =>
    encodeURIComponent(str)
        .replace(/\-/g, '%2D')
        .replace(/\_/g, '%5F')
        .replace(/\./g, '%2E')
        .replace(/\!/g, '%21')
        .replace(/\~/g, '%7E')
        .replace(/\*/g, '%2A')
        .replace(/\'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29');
```

解码函数如下所示：

```
const decode = (str) =>
    decodeURIComponent(
        str
            .replace(/\\%2D/g, '-')
            .replace(/\\%5F/g, '_')
            .replace(/\\%2E/g, '.')
            .replace(/\\%21/g, '!')
            .replace(/\\%7E/g, '~')
            .replace(/\\%2A/g, '*')
            .replace(/\\%27/g, "'")
            .replace(/\\%28/g, '(')
            .replace(/\\%29/g, ')')
    );
```

### Base64

在JavaScript 中，可以使用 `btoa()`（binary to ASCII）和 `atob()`（ASCII to binary）方法来做 Base64 的编码和解码。主要是用于 Data URIs。

下面来对字符串 HelloWorld 做 Base64 的编码与解码：

```
const encodedData = btoa('HelloWorld'); // "SGVsbG9Xb3JsZA=="
const decodedData = atob(encodedData); // "HelloWorld"
```

由于ASCII 无法表示中文，因此要先做 UTF-8 编码，然后再做Base64 编码；解码方式为先做 Base64 解码，再做UTF-8 解码：

```
const encodedData = btoa(encodeURI('你好')); //  "JUU0JUJEJUEwJUU1JUE1JUJE"
const decodedData = decodeURI(atob(encodedData)); // "你好"
```



# 品牌设计趋势

在品牌设计方面存在一个悖论。趋势一直在变化，但品牌必须保持不变，保留其本质、价值和形象。

一方面，品牌必须保持可识别性。另一方面，它不能过时。为了向全世界传播其信息，品牌必须说语言并满足其受众的期望。如果它不这样做，观众就会消失。一个品牌必须保持令人兴奋、易于理解、情感亲近和与时俱进。这就是为什么即使是最古老、最受尊敬的品牌也会顺应潮流、与时俱进。

趋势不是目标，而是达到目的的手段。

了解这一点的设计师将始终能够找到正确的方法，无论是创建新的视觉识别还是品牌重塑。

让我们来看看在 2021 年已经证明其价值并将在 2022 年自信地保持的网页设计趋势。所有这些都只是品牌交流所用视觉语言的特征。

新词和表达方式无时无刻不在出现，语音和发音变化，但语言的核心保持不变。同样的规则也适用于设计。有希望的趋势结合了新旧。通过吸收过去所能提供的最好的东西，他们将其带入未来。

那么，到 2022 年，品牌将携带什么？

## 1、极简主义

极简主义设计已不仅仅是一种简单的趋势。在一个充斥着信息和视觉效果的世界里，这是必不可少的。

在混乱中创造秩序，消除所有干扰，强调基本要素——所有这些对于品牌塑造至关重要。

简单的形状保证了更容易的感知、更好的记忆和更快的识别。简单和简洁集中精力和力量。

## 2、多彩极简主义

具有有限调色板的传统极简主义正逐渐被新的、丰富多彩的变化所取代。它保留了清晰简洁的形状和含义，但通过鲜艳的色彩在视觉上更加丰富。从本质上讲，它是两种设计的融合，其中传统的组合被明亮的色彩和元素所增强。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211032622.png" alt="image-20230221103239143" style="zoom: 50%;" />

## 3、黑暗主题

应用程序、网站、社交媒体平台和操作系统越来越多地提供黑暗方案。它很受用户欢迎。

请注意，品牌设计在黑暗模式下看起来非常不同。熟悉的调色板可能不适用于黑色背景。为了达到与灯光方案相同的效果，需要调整颜色。一些品牌在意识形态上反对黑暗计划。但其余的可以利用其引人注目的效果：对比、生动活泼的亮点、深度印象、优雅和威望。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211032906.png" alt="image-20230221103225774" style="zoom: 50%;" />

## 4、几何设计

几何风格在创造视觉识别方面表现出真正的希望。它用精确的线条和简单的形状说话。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211032069.png" alt="image-20230221103208990" style="zoom:50%;" />

几何设计同样适用于主要元素（例如徽标）和背景（装饰品、图案等）。元素可以无休止地组合和重新组合，以达到酷炫的效果和共同的视觉节奏。几何设计更容易坚持标志性风格。

## 5、柔和的颜色

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211031396.png" alt="image-20230221103154020" style="zoom:50%;" />

柔和的色彩一如既往地流行。它们令人赏心悦目，令人放松，给人以宁静祥和的印象。薄荷色调使设计看起来清新干净。柔和的色调象征着舒适和安全。这正是一些企业所需要的。

紫色色调在 2021 年特别流行。它们与柔和的色彩相得益彰，营造出宁静的氛围，因此它们无处不在。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211031800.png" alt="image-20230221103138605" style="zoom: 50%;" />

## 6、 经典风格

对于将自己定位为传统、稳定、地位和声望的守护者的公司来说，与经典风格永远相关。这些品牌更喜欢比例严格、形状精确和优雅简约的设计。经典标志是几何形状、字母组合和装饰品的令人印象深刻的组合。有时它代表公司的名称。

经典的衬线字体又回来了，并且经常与非经典风格相结合。这些字体唤起了怀旧的感觉和“良好的旧可靠性”，这解释了它们的复兴。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211031437.png" alt="image-20230221103120100" style="zoom:50%;" />

## 7、自然设计

这种趋势不仅与自然、环境和健康有关；它关乎所有事物的自然性：自然的色彩、非舞台化的照片、品牌和人物的坦率真实故事。渐变也很受欢迎，因为它们使图像更加壮观和有效。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211031825.png" alt="image-20230221103108579" style="zoom:50%;" />

## 8、插图

插图越来越多地进入品牌设计。它们吸引注意力，唤起积极的情绪，帮助与用户交流，并营造更轻松的氛围。这是讲述品牌故事的一种简单、高效且令人难忘的方式。插图使品牌独特、有趣且更人性化。

说明性图标和符号增加了真实性并增加了识别度。这是一个由来已久的趋势。耐克、苹果和星巴克几十年来一直在追随它，而且不会很快停止。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302211030025.png" alt="image-20230221103052791" style="zoom:50%;" />

## 9、动画标志

拥有一个动画标志越来越成为一种必需品，而不是一种趋势。像这样的标志会立即吸引观众的注意力并保留一段时间，这对于记忆至关重要。动画徽标在移动设备上看起来不错。具有动画图形的页面可以更快地吸引观众。

动画可用于通过扩展静态徽标中包含的想法来讲述品牌故事。只需几秒钟，您就可以展示品牌的活动、工作原则，甚至价值观。成功的例子有 LinkedIn 和 FedEx。

































































