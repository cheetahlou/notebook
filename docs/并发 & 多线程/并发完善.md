











# Java创建线程

## 前言

创建线程有几种方式？这个问题的答案应该是可以脱口而出的吧

- 继承 Thread 类
- 实现 Runnable 接口

但这两种方式创建的线程是属于”三无产品“：

- 没有参数
- 没有返回值
- 没办法抛出异常

Runnable 接口是 JDK1.0 的核心产物

用着 “三无产品” 总是有一些弊端，其中没办法拿到返回值是最让人不能忍的，于是 Callable 就诞生了



## Thread和Runnable

thread示例

```java
public static void s1() {
    Thread t1 = new Thread(() ->{
        System.out.println("t1 start");
    });
    t1.setName("t1");
    t1.start();
}
```

Runnable示例

```java
public static void s2() {
    Thread t2 = new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println("t2 start");
        }
    });
    t2.start();
}
```



## Callable(好用)

又是 Doug Lea 大师，又是 Java 1.5 这个神奇的版本

Callable 是一个泛型接口，里面只有一个 `call()` 方法，**该方法可以返回泛型值 V** ，使用起来就像这样：

 `Callable 只能在 ExecutorService中使用`

```java
public static void t1() throws Exception {
    //创建线程
    Callable<String> callable = () -> {
        // Perform some computation
        Thread.sleep(2000);
        return "Return some result";
    };
    //获取返回数据
    String call = callable.call();
    System.out.println(call);
}
```

二者都是函数式接口，里面都仅有一个方法，使用上又是如此相似，除了有无返回值，Runnable 与 Callable 就点差别吗？

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121901019.png" alt="image-20220512190106939" style="zoom:80%;" />



## Future

> Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。
>
> Future只是一个接口，FutureTask是实现了RunnableFuture

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206241133686.png" alt="image-20220624113317629" style="zoom:80%;" />

总的来说Future提供了三种功能：

- `判断任务是否完成`
- `取消任务`
- `获取返回结果`

> Future呈现的是异步计算的结果。Future中的方法提供了检查计算是否已经完成，并且等待计算的结果，还能够重新获取计算记得结果。当计算已经完成的时候只能使用get()方法获取结果，如果有需要的话，可以一直阻塞等待结果，直到结果已经准备好了。通过cancel()方法可以取消执行。还提供了了其他方法来确定任务是否正常完成或者被取消。一旦一个计算已经完成的话，那么计算是不能够被取消的。如果是为了实现可以去掉任务但是不需要返回结果的话，那么就可以使用future，将返回结果设置成null就可以了。

### API方法

Future 又是一个接口，里面只有五个方法：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121907834.png" alt="image-20220512190751758" style="zoom: 67%;" />

从方法名称上相信你已经能看出这些方法的作用

```java
// 取消任务
boolean cancel(boolean mayInterruptIfRunning);

// 获取任务执行结果
V get() throws InterruptedException, ExecutionException;

// 获取任务执行结果，带有超时时间限制
V get(long timeout, TimeUnit unit) throws InterruptedException,                             ExecutionException,  TimeoutException;

// 判断任务是否已经取消
boolean isCancelled();

// 判断任务是否已经结束
boolean isDone();
```

### 示例

```java
public static void s2() throws Exception {
    //线程池
    ExecutorService executorService = Executors.newSingleThreadExecutor();
    //线程池启动
    Future<String> future = executorService.submit(new Callable<String>() {
        @Override
        public String call() {
            return "Hello from Callable";
        }
    });
    // 获取返回结果，避免超时可以给超时时间
    String result = future.get();
    log.info("主线程获取到 Future 结果: {}", result);
    executorService.shutdown();
}
```

> 使用get()，程序将停止往下执行，一直等待结果，直到有返回值，下面的程序才能得到继续的执行。如果不希望因为get一直等待下去的话，可以使用get(long timeout, TimeUnit unit)方法，通过这个方法可以设置等待时间，如果在定时时间内没有得到返回结果的话，将会抛出超时的异常，这种用法用来做远程调用设置超时的场景中。

示例2

```java
public static void t1() throws Exception {
    // 创建线程池
    ExecutorService executorService = Executors.newSingleThreadExecutor();

    // 使用 Callable ，可以获取返回值
    Callable<String> callable = () -> {
        log.info("进入 Callable 的 call 方法");
        // 模拟子线程任务，在此睡眠 2s，
        // 小细节：由于 call 方法会抛出 Exception，
        // 这里不用像使用 Runnable 的run 方法那样 try/catch 了
        Thread.sleep(5000);
        return "Hello from Callable";
    };
    log.info("提交 Callable 到线程池");

    Future<String> future = executorService.submit(callable);

    log.info("主线程继续执行");

    log.info("主线程等待获取 Future 结果");
    // Future.get() blocks until the result is available
    String result = future.get();
    log.info("主线程获取到 Future 结果: {}", result);

    executorService.shutdown();
}
```

程序运行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121914428.png" alt="image-20220512191446348" style="zoom:80%;" />

### 判断是否执行完成

如果你运行上述示例代码，主线程调用 future.get() 方法会阻塞自己，直到子任务完成。我们也可以使用 Future 方法提供的 `isDone` 方法，它可以用来检查 task 是否已经完成了，我们将上面程序做点小修改：

这段代码放在 future.get()前面

```java
// 如果子线程没有结束，则睡眠 1s 重新检查
while(!future.isDone()) {
   System.out.println("子线程任务还没有结束...");
   Thread.sleep(1000);
}
```

来看运行结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121916408.png" alt="image-20220512191656322" style="zoom:80%;" />

如果子程序运行时间过长，或者其他原因，我们想 cancel 子程序的运行，则我们可以使用 Future 提供的 cancel 方法，继续对程序做一些修改

```java
while(!future.isDone()) {
   System.out.println("子线程任务还没有结束...");
   Thread.sleep(1000);
   double elapsedTimeInSec = (System.nanoTime() - startTime)/1000000000.0;
   // 如果程序运行时间大于 1s，则取消子线程的运行
   if(elapsedTimeInSec > 1) {
      future.cancel(true);
   }
}
```

来看运行结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121939478.png" alt="image-20220512193937398" style="zoom:80%;" />

为什么调用 cancel 方法程序会出现 CancellationException 呢？是因为调用 get() 方法时，明确说明了：

> 调用 get() 方法时，如果计算结果被取消了，则抛出 CancellationException （具体原因，你会在下面的源码分析中看到）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121940078.png" alt="image-20220512193959986" style="zoom:80%;" />

### 判断线程是否取消

有异常不处理是非常不专业的，所以我们需要进一步修改程序，以更友好的方式处理异常

```java
// 通过 isCancelled 方法判断程序是否被取消，如果被取消，则打印日志，如果没被取消，则正常调用 get() 方法
if (!future.isCancelled()){
   log.info("子线程任务已完成");
   String result = future.get();
   log.info("主线程获取到 Future 结果: {}", result);
}else {
   log.warn("子线程任务被取消");
}
```

查看程序运行结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121940856.png" alt="image-20220512194058771" style="zoom:80%;" />

相信到这里你已经对 `Future` 的几个方法有了基本的使用印象，但 `Future` 是接口，其实使用 `ExecutorService.submit()` 方法返回的一直都是 `Future` 的实现类 `FutureTask`

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121940767.png" alt="image-20220512194043683" style="zoom:80%;" />

接下来我们就进入这个核心实现类一探究竟



## FutureTask(推荐)

### 简述

#### 概述

> Future是一个接口，是无法生成一个实例的，所以又有了FutureTask。FutureTask实现了RunnableFuture接口，RunnableFuture接口又实现了Runnable接口和Future接口。`所以FutureTask既可以被当做Runnable来执行，也可以被当做Future来获取Callable的返回结果。`
>

同样先来看类结构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121944297.png" alt="image-20220512194422215" style="zoom:50%;" />

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

很神奇的一个接口，`FutureTask` 实现了 `RunnableFuture` 接口，而  `RunnableFuture` 接口又分别实现了 `Runnable` 和 `Future` 接口，所以可以推断出 `FutureTask` 具有这两种接口的特性：

- 有 `Runnable` 特性，所以可以用在 `ExecutorService` 中配合线程池使用
- 有 `Future` 特性，`所以可以从中获取到执行结果`

#### 优缺点

- `get()阻塞，一旦调用get()方法，不管是否计算完成，都会导致阻塞（所以一般get方法放到最后）`
- `isDone()轮询，利用if(futureTask.isDone())的方式使得他在结束之后才get(),但是也会消耗cpu`

#### 应用场景

`回调通知`

- 前面的isDone()方法耗费cpu资源，一般应该还是利用回调函数，在Future结束时自动调用该回调函数。应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知

`创建异步任务`

- Future+线程池配合

`多个任务前后依赖可以组合处理（水煮鱼）`

- 想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值，将两个或多个异步计算合成一个异步计算，这几个异步计算相互独立，同时后面这个又依赖前一个处理的结果
- 比如买鱼-加料-烹饪

`对计算速度选最快完成的（并返回结果）`

`当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果。`



### FutureTask+线程池

- **future**+**线程池**异步多线程任务配合，能显著提高程序的执行效率。
- 方案一，3个任务1个main线程处理，大概**1130ms**
- 方案二，3个任务3个线程，利用线程池（假如每次new一个Thread，太浪费资源，会有GC这些工作），大概**1400毫秒**。

```java
public static void s2() throws Exception {
    // 创建线程池
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    // 创建FutureTask
    FutureTask<String> ft3 = new FutureTask<>(new Callable<String>() {
        @Override
        public String call() throws Exception {
            return "hello";
        }
    });
    // 提交线程
    executorService.submit(ft3);
    log.info("ft3.get() = {}", ft3.get());
    // 如果在指定时间内，还没获取到结果，就直接返回null
    log.info("ft3.get() = {}", ft3.get(3, TimeUnit.SECONDS));
    // 任务是否结束
    log.info("ft3.isDone() = {}", ft3.isDone());
    // 关闭线程池
    executorService.shutdown();
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011339361.png" alt="image-20220601133942278" style="zoom:80%;" />

> ExecutorService的execute是没有返回值的，使用这种用法需要注意的是FutureTask的get方法会一直等待结果的返回，如果get的调用顺序在execute之前的话，那么程序将会停止在get这里。

这个方法是整合线程池，比直接毫秒睡眠快

```java
public static void m0() throws Exception {
    //3个任务，目前开启多个异步任务线程来处理，请问耗时多少？
    ExecutorService threadPool = Executors.newFixedThreadPool(3);
    long startTime = System.currentTimeMillis();
    FutureTask<String> futureTask1 = new FutureTask<String>(() -> {
        try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) {
            e.printStackTrace(); }
        return "task1 over";
    });
    threadPool.submit(futureTask1);

    FutureTask<String> futureTask2 = new FutureTask<String>(() -> {
        try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) {
            e.printStackTrace(); }
        return "task2 over";
    });
    threadPool.submit(futureTask2);

    System.out.println(futureTask1.get());
    System.out.println(futureTask2.get());

    try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { 
        e.printStackTrace(); }

    long endTime = System.currentTimeMillis();
    System.out.println("m0-costTime: "+(endTime - startTime) +" 毫秒");

    System.out.println(Thread.currentThread().getName()+"\t -----end");
    threadPool.shutdown();
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206251052478.png" alt="image-20220625105238434" style="zoom:67%;" />



### FutureTask+Thread

>  get容易导致阻塞，一般建议放在程序后面，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，容易程序堵塞。
> 假如我不愿意等待很长时间，我希望过时不候，可以自动离开. futureTask.get(3,TimeUnit.SECONDS)

#### 案例一

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况

```java
public static void a1() {
    // 创建任务对象
    FutureTask<Integer> task3 = new FutureTask<>(() -> {
        log.info("hello");
        return 100;
    });
    // 参数1 是任务对象; 参数2 是线程名字，推荐
    new Thread(task3, "t3").start();
    // 主线程阻塞，同步等待 task 执行完毕的结果
    Integer result = null;
    try {
       result = task3.get();
    } catch (Exception e) {
        e.printStackTrace();
    }
    log.info("结果是:{}", result);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206241509422.png" alt="image-20220624150917378" style="zoom:80%;" />

#### 案例二

```java
public static void t1() throws Exception {
    FutureTask<String> futureTask = new FutureTask<>(() -> {
        // 该线程进入辣
        System.out.println(Thread.currentThread().getName()+"\t -----come in");
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "task over";
    });
    Thread t1 = new Thread(futureTask, "t1");
    t1.start();

    System.out.println(Thread.currentThread().getName()+"\t ----忙其它任务了");

    while(true) {
        // 判断任务是否完成
        if(futureTask.isDone()) {
            System.out.println(futureTask.get());
            break;
        }else{
            //暂停毫秒
            try {
                TimeUnit.MILLISECONDS.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("正在处理中，不要再催了，越催越慢 ，再催熄火");
        }
    }
    // 获取任务返回值
    System.out.println(futureTask.get());
    // 超过这个时间，就不要了
    System.out.println(futureTask.get(3,TimeUnit.SECONDS));
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206251045198.png" alt="image-20220625104523142" style="zoom:67%;" />





### 烧水泡茶经典案例

我是想说，使用 FutureTask 来演练烧水泡茶经典程序

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121954849.png" alt="image-20220512195457759" style="zoom: 80%;" />

如上图：

- 洗水壶 1 分钟
- 烧开水 15 分钟
- 洗茶壶 1 分钟
- 洗茶杯 1 分钟
- 拿茶叶 2 分钟

最终泡茶

让我心算一下，如果串行总共需要 20 分钟，但很显然在烧开水期间，我们可以洗茶壶/洗茶杯/拿茶叶

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205121955836.png" alt="image-20220512195548758" style="zoom:80%;" />

这样总共需要 16 分钟，节约了 4分钟时间，烧水泡茶尚且如此，在现在高并发的时代，4分钟可以做的事太多了，学会使用 Future 优化程序是必然（**其实优化程序就是寻找关键路径，关键路径找到了，非关键路径的任务通常就可以和关键路径的内容并行执行了**）

```java
public static void t1() throws Exception {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    // 创建线程1的FutureTask
    FutureTask<String> ft1 = new FutureTask<String>(new T1Task());
    // 创建线程2的FutureTask
    FutureTask<String> ft2 = new FutureTask<String>(new T2Task());
    // 提交线程池
    executorService.submit(ft1);
    executorService.submit(ft2);
    log.info(ft1.get() + ft2.get());
    log.info("开始泡茶");
    executorService.shutdown();
}

static class T1Task implements Callable<String> {
    @Override
    public String call() throws Exception {
        log.info("T1:洗水壶...");
        TimeUnit.SECONDS.sleep(1);
        log.info("T1:烧开水...");
        TimeUnit.SECONDS.sleep(15);
        return "T1:开水已备好";
    }
}

static class T2Task implements Callable<String> {
    @Override
    public String call() throws Exception {
        log.info("T2:洗茶壶...");
        TimeUnit.SECONDS.sleep(1);
        log.info("T2:洗茶杯...");
        TimeUnit.SECONDS.sleep(2);
        log.info("T2:拿茶叶...");
        TimeUnit.SECONDS.sleep(1);
        return "T2:福鼎白茶拿到了";
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205122004330.png" alt="image-20220512200436246" style="zoom:80%;" />

上面的程序是主线程等待两个 FutureTask 的执行结果，线程1 烧开水时间更长，线程1希望在水烧开的那一刹那就可以拿到茶叶直接泡茶，怎么半呢？

![图片](https://mmbiz.qpic.cn/mmbiz_png/N1knSK6wthpHiaSon4otJ5E95vUwnTiaBhlSZ5P4UJzWZ40bXuTRCdylEnSkI8g2YXzfEFeO4ReNwNPEqJK9mQvw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

那只需要在线程 1 的FutureTask 中获取 线程 2 FutureTask 的返回结果就可以了，我们稍稍修改一下程序：

```java
public static void t1() throws Exception {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    // 修改处：调换顺序，传入参数
    // 创建线程2的FutureTask
    FutureTask<String> ft2 = new FutureTask<String>(new T2Task());
    // 创建线程1的FutureTask
    FutureTask<String> ft1 = new FutureTask<String>(new T1Task(ft2));

    executorService.submit(ft1);
    executorService.submit(ft2);
    log.info(ft1.get() + ft2.get());
    log.info("开始泡茶");
    executorService.shutdown();
}
```

```java
// 修改处
static class T1Task implements Callable<String> {
    private final FutureTask<String> ft2;
    public T1Task(FutureTask<String> ft2) {
        this.ft2 = ft2;
    }
    @Override
    public String call() throws Exception {
        log.info("T1:洗水壶...");
        TimeUnit.SECONDS.sleep(1);

        log.info("T1:烧开水...");
        TimeUnit.SECONDS.sleep(15);

        String t2Result = ft2.get();
        log.info("T1 拿到T2的 {}， 开始泡茶", t2Result);
        return "T1: 上茶！！！";
    }
}
```

来看程序运行结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205122055784.png" alt="image-20220512205538700" style="zoom: 80%;" />

知道这个变化后我们再回头看 ExecutorService 的三个 submit 方法：

```java
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
<T> Future<T> submit(Callable<T> task);
```

你会发现，和我们改造烧水泡茶的程序思维是相似的，可以传进去一个 result，result 相当于主线程和子线程之间的桥梁，通过它主子线程可以共享数据

第二个方法参数是 Runnable 类型参数，即便调用 get() 方法也是返回 null，所以仅是可以用来断言任务已经结束了，类似 Thread.join()

第三个方法参数是 Callable 类型参数，通过get() 方法可以明确获取 call() 方法的返回值

到这里，关于 Future 的整块讲解就结束了，还是需要简单消化一下的



# 线程常用方法

## 查看进程线程的方法

### windows

- 任务管理器可以查看进程和线程数，也可以用来杀死进程 
- tasklist 查看进程 
- taskkill 杀死进程 

### linux 

- ps -fe 查看所有进程 
- ps -fT -p  查看某个进程（PID）的所有线程 
- kill 杀死进程 top 按大写 H 切换是否显示线程
-  top -H -p  查看某个进程（PID）的所有线程 

### Java 

- jps 命令查看所有 Java 进程 
- jstack  查看某个 Java 进程（PID）的所有线程状态 
- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）



## 线程运行原理

### 栈与栈帧

Java Virtual Machine Stacks （Java 虚拟机栈） 

我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。 

- `每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 `
- `每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 `

### 线程上下文切换

因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 

- 线程的 cpu 时间片用完 
- 垃圾回收 
- 有更高优先级的线程需要运行 
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 
- Context Switch 频繁发生会影响性能

`使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。`

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205161634128.png" alt="image-20220516163420087" style="zoom:80%;" />

> 为了让用户感觉多个线程是在同时执行的，` CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。`
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205161634627.png" alt="image-20220516163441596" style="zoom:80%;" />



## Thread 类 API

### 完整API

| 方法                                        | 说明                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| public void start()                         | `启动一个新线程`，Java虚拟机调用此线程的 run 方法            |
| public void run()                           | `线程启动后调用该方法`                                       |
| public void setName(String name)            | `给当前线程取名字`                                           |
| public void getName()                       | `获取当前线程的名字`<br />线程存在默认名称：子线程是 Thread-索引，主线程是 main |
| public static Thread currentThread()        | `获取当前线程`对象，代码在哪个线程中执行                     |
| public static void sleep(long time)         | `让当前线程休眠多少毫秒再继续执行`<br />**Thread.sleep(0)** : 让操作系统立刻重新进行一次 CPU 竞争 |
| public static native void yield()           | 提示线程调度器`让出当前线程对 CPU 的使用`                    |
| public final int getPriority()              | `返回此线程的优先级`                                         |
| public final void setPriority(int priority) | `更改此线程的优先级，常用 1 5 10`                            |
| public void interrupt()                     | `中断这个线程，异常处理机制`                                 |
| public static boolean interrupted()         | `判断当前线程是否被打断，清除打断标记`                       |
| public boolean isInterrupted()              | `判断当前线程是否被打断，不清除打断标记`                     |
| public final void join()                    | `等待这个线程结束`                                           |
| public final void join(long millis)         | `等待这个线程死亡 millis 毫秒，0 意味着永远等待`             |
| public final native boolean isAlive()       | `线程是否存活（还没有运行完毕）`                             |
| public final void setDaemon(boolean on)     | `将此线程标记为守护线程或用户线程`                           |

#### start 与 run

直接调用 run 是在主线程中执行了 run，没有启动新的线程 

使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码

### sleep和yield

sleep 

1. `调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） `

2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 
3. `睡眠结束后的线程未必会立刻得到执行 `
4. `建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 `

yield 

1. `调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 `
2. `具体的实现依赖于操作系统的任务调度器`

### 线程优先级 

- 线程优先级会提示（hint）调度器优先调度该线程，`但它仅仅是一个提示，调度器可以忽略它 `
- 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 `cpu 闲时，优先级几乎没作用`

### join

> 如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法



### 守护线程

> 默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守 护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。

Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）

在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。

> 那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。

```java
public static void a1() {
    log.debug("开始运行...");
    Thread t1 = new Thread(() -> {
        log.debug("开始运行...");
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("运行结束...");
    }, "daemon");
    // 设置该线程为守护线程
    t1.setDaemon(true);
    t1.start();
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    log.debug("运行结束...");
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206241549365.png" alt="image-20220624154908322" style="zoom:67%;" />

`可以发现，主线程结束后，守护线程没结束就寄了`



## 线程6种状态

在Java中，线程共有六种状态：

| 状态         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| NEW          | `初始状态：线程被创建，但还没有调用start()方法`              |
| RUNNABLE     | `运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”` |
| BLOCKED      | `阻塞状态：表示线程阻塞于锁`                                 |
| WAITING      | `等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）` |
| TIME_WAITING | `超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的` |
| TERMINATED   | `终止状态：表示当前线程已经执行完毕`                         |

线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205161633893.png" alt="image-20220516163302853" style="zoom:80%;" />

### 新建状态（New）

我们可以通过实现`Runnable`接口或继承`Thread`声明一个线程类，`new`一个实例后，线程就进入了新建状态。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021526465.png" alt="image-20220702152636400" style="zoom:50%;" />

> 一个刚诞生的线程，处于新建状态。

### 就绪状态（Ready）

线程对象创建成功后，调用该线程的`start()`函数，线程进入就绪状态，该状态的线程进入可运行线程池中，等待获取`C P U`的使用权。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021527662.png" alt="image-20220702152750575" style="zoom:50%;" />

> 线程表示，我已经准备好了，此时我是就绪状态，快选我吧~

### 运行状态（Running)

此时线程调度程序正在从**可运行线程池**中选择一个线程，该线程进入运行状态。

换句话说，线程获取到了`C P U`时间片。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021528265.png" alt="image-20220702152842189" style="zoom:67%;" />

还没完呢，当线程时间片用完或调用的`yield()`函数，该线程回到就绪状态。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021528953.png" alt="image-20220702152857868" style="zoom: 67%;" />

> 作为一名运气好的线程，我进入了运行状态，但是运气用完了，我还得回到就绪状态。

### 终止状态（Terminated）

线程继续运行，直到执行结束或执行过程中因异常意外终止都会使线程进入终止状态。

线程一旦终止，就不能复生，这是不可逆的过程。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021529469.png" alt="image-20220702152926390" style="zoom:67%;" />

> 线程的人生迎来了终点，可能一帆风顺过完一生，也可能英年早逝令人惋惜。

### 等待状态（Waiting）

运行状态的线程执行wait()、join()、LockSupport.park()任意函数，该线程进入等待状态。

其中`wait()`与`join()`函数会让J V M把该线程放入锁等待队列。

处于这种状态的线程不会被分配C P U执行时间，它们要等待被**主动唤醒**，否则会一直处于等待状态。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021529237.png" alt="image-20220702152946141" style="zoom: 67%;" />

如果我们要唤醒线程怎么办呢？

执行`LockSupport.unpark(t)`函数唤醒指定线程，该线程回到就绪状态。

而通过`notify()、notifyAll()、join线程执行完毕`方式，会唤醒锁等待队列的线程，出队的线程回到就绪状态。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021531620.png" alt="image-20220702153145519" style="zoom:67%;" />

> 线程的人生迎来了劫难，听信小人之言，跑去菲律宾做打工，结果被黑工厂扣下，只希望警察叔叔能早日解救我出去。

### 超时等待状态（Timed waiting）

超时等待与等待状态一样，唯一的区别就是多了超时机制，不会一直等待被其他线程主动唤醒，而是到达指定时间后会**自动唤醒**。

以下函数会触发进入超时等待状态

- **wait(long)**
- **join(long)**
- **LockSupport.parkNanos(long)**
- **LockSupport.parkUtil(long)**
- **sleep(long)**

其中`wait(long)、join(long)`函数会让J V M把线程放入锁等待队列。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021521205.png" alt="image-20220702152159097" style="zoom: 55%;" />

后面的唤醒剧情就和等待状态如出一辙，就多了超时时间到了，自动唤醒的动作。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021523214.png" alt="image-20220702152304100" style="zoom:55%;" />

> 从菲律宾回国后的线程，也做起了违法的勾当，最终被警察抓捕，好在只判了5年，熬一熬就可以出来了。

### 阻塞状态（Blocked）

运行状态的线程获取同步锁失败或发出`I/O`请求，该线程进入阻塞状态。

如果是获取同步锁失败`J V M`还会把该线程放入锁的同步队列。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021520913.png" alt="image-20220702152002791" style="zoom:55%;" />

同步锁被释放时，锁的同步队列会出队所有线程，进入就绪状态。

`I/O`处理完毕时，该线程重新回到就绪状态。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021521589.png" alt="image-20220702152119468" style="zoom:55%;" />

> 出狱后的线程，后面的人生一直都是磕磕碰碰，就没顺利过，大家要引以为戒。

### 小结

相信读者大大们跟着阿星的思路来，已经掌握了线程状态的知识，以后面试官问这类问题，也可以吊打一番，最后放一张简化的线程转换图为本文画上句号。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021518621.png" alt="image-20220702151823522" style="zoom: 50%;" />



# CompletableFuture(异步编程)

[异步编程利器：CompletableFuture详解 (qq.com)](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247490456&idx=1&sn=95836324db57673a4d7aea4fb233c0d2&chksm=cf21c4b1f8564da72dc7b39279362bcf965b1374540f3b339413d138599f7de59a5f977e3b0e&token=1260947715&lang=zh_CN&scene=21#wechat_redirect)

## 前言

我们知道Future的有局限性，它没法直接对多个任务进行链式、组合等处理，需要借助并发工具类才能完成，实现逻辑比较复杂。

> 而CompletableFuture是对Future的扩展和增强。CompletableFuture实现了Future接口，并在此基础上进行了丰富的扩展，完美弥补了Future的局限性，同时CompletableFuture实现了对任务编排的能力。借助这项能力，可以轻松地组织不同任务的运行顺序、规则以及方式。

从某种程度上说，这项能力是它的核心能力。而在以往，虽然通过`CountDownLatch`等工具类也可以实现任务的编排，但需要复杂的逻辑处理，不仅耗费精力且难以维护。

从它的源代码中，我们可以看到，CompletableFuture直接提供了几个便捷的静态方法入口。其中有`run`和`supply`两组。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221450255.png" alt="image-20220722145035157" style="zoom:67%;" />

run的参数是Runnable，而supply的参数是Supplier。前者没有返回值，而后者有，否则没有什么两样。

这两组静态函数，都提供了传入自定义线程池的功能。如果你用的不是外置的线程池，那么它就会使用默认的ForkJoin线程池。默认的线程池，大小和用途你是控制不了的，所以还是建议自己传递一个。

典型的代码，写起来是这个样子。

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(()->{
 return "test";
});
String result = future.join();
```

拿到CompletableFuture后，你就可以做更多的花样。

## Future短板

Future是Java5新加的一个接口，它提供了一种`异步并行计算`的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过future把这个任务放到异步线程中执行。主线程继续处理其他任务，处理完成再通过Future获取计算结果。

> 不能手动完成计算

假设你使用 Future 运行子线程调用远程 API 来获取某款产品的最新价格，服务器由于洪灾宕机了，此时如果你想手动结束计算，而是想返回上次缓存中的价格，这是 Future 做不到的

> 调用 get() 方法会阻塞程序

Future 不会通知你它的完成，它提供了一个get()方法，程序调用该方法会阻塞直到结果可用为止，没有办法利用回调函数附加到Future，并在Future的结果可用时自动调用它

> 不能链式执行

烧水泡茶中，通过构造函数传参做到多个任务的链式执行，万一有更多的任务，或是任务链的执行顺序有变，对原有程序的影响都是非常大的

> 整合多个 Future 执行结果方式笨重

假设有多个 Future 并行执行，需要在这些任务全部执行完成之后做后续操作，Future 本身是做不到的，需要借助工具类 `Executors` 的方法

> 没有异常处理



## 走进CompletableFuture

我们还是基于以上Future的例子，改用CompletableFuture 来实现

```java
public class FutureTest {

    public static void main(String[] args) throws Exception {
        UserInfoService userInfoService = new UserInfoService();
        MedalService medalService = new MedalService();
        long userId =666L;
        long startTime = System.currentTimeMillis();

        //调用用户服务获取用户基本信息
        CompletableFuture<UserInfo> completableUserInfoFuture = CompletableFuture
            .supplyAsync(() -> userInfoService.getUserInfo(userId));
        //模拟主线程其它操作耗时
        Thread.sleep(300); 
        //调用获取勋章信息
        CompletableFuture<MedalInfo> completableMedalInfoFuture = CompletableFuture
            .supplyAsync(() -> medalService.getMedalInfo(userId)); 
        //获取个人信息结果
        UserInfo userInfo = completableUserInfoFuture.get(2,TimeUnit.SECONDS);
        MedalInfo medalInfo = completableMedalInfoFuture.get();//获取勋章信息结果
        System.out.println("总共用时" + (System.currentTimeMillis() - startTime) + "ms");

    }
}
```

> 可以发现，使用CompletableFuture，代码简洁了很多。CompletableFuture的supplyAsync方法，提供了异步执行的功能，线程池也不用单独创建了。实际上，它CompletableFuture使用了默认线程池是**ForkJoinPool.commonPool**。
>

> CompletableFuture提供了几十种方法，辅助我们的异步任务场景。这些方法包括**创建异步任务、任务异步回调、多个任务组合处理**等方面。我们一起来学习吧
>









# CAS

## CAS了解

> CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。
>
> CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。
>
> 只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。

```java
AtomicInteger atomicInteger = new AtomicInteger(5);
System.out.println(atomicInteger.compareAndSet(5, 2022)+"\t"+atomicInteger.get());
System.out.println(atomicInteger.compareAndSet(5, 2022)+"\t"+atomicInteger.get());
atomicInteger.getAndIncrement();
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206251559220.png" alt="image-20220625155934170" style="zoom:67%;" />



## CAS底层原理

CAS这个理念 ，落地就是Unsafe类

CAS 主要包括两个操作：`Compare`和`Swap`，有人可能要问了：两个操作能保证是原子性吗？可以的。

CAS 是一种`系统原语`，原语属于操作系统用语，原语由若干指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，由操作系统硬件来保证。

> 在 Intel 的 CPU 中，使用 cmpxchg 指令。

回到 Java 语言，JDK 是在 1.5 版本后才引入 CAS 操作，在`sun.misc.Unsafe`这个类中定义了 CAS 相关的方法。

> 它是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门 ，基于该类可以直接操作特定内存的数据 。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。
>
> 注意Unsafe类中的所有方法都是修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 

> CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令 。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语 ，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。
> 

## AtomicReference

```java
@Getter
@ToString
@AllArgsConstructor
class User {
    String userName;
    int    age;
}
```

```java
AtomicReference<User> atomicReference = new AtomicReference<>();

User z3 = new User("z3",22);
User li4 = new User("li4",28);

atomicReference.set(z3);

System.out.println(atomicReference.compareAndSet(z3, 
                                                 li4)+"\t"+atomicReference.get().toString());
System.out.println(atomicReference.compareAndSet(z3, 
                                                 li4)+"\t"+atomicReference.get().toString());
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206251602155.png" alt="image-20220625160211098" style="zoom:67%;" />



## CAS 有什么问题？如何解决？

CAS的经典三大问题：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205162218913.png" alt="image-20220516221816846" style="zoom: 67%;" />

### ABA 问题

并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。

如果是整形还好，不会影响最终结果，但如果是对象的引用类型包含了多个变量，引用没有变实际上包含的变量已经被修改，这就会造成大问题。

如何解决？思路其实很简单，在变量前加版本号，每次变量更新了就把版本号加一，结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061732496.png" alt="image-20220706173209428" style="zoom:50%;" />

> 怎么解决ABA问题？

- 加版本号

> 每次修改变量，都在这个变量的版本号上加1，这样，刚刚A->B->A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。
>
> Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。

```java
static AtomicInteger atomicInteger = new AtomicInteger(100);
static AtomicStampedReference<Integer> stampedReference = new 
                                       AtomicStampedReference<>(100,1);

public static void main(String[] args)
{
    new Thread(() -> {
        int stamp = stampedReference.getStamp();
        System.out.println(Thread.currentThread().getName()+"\t"+"首次版本号："+stamp);

        //暂停500毫秒,保证后面的t4线程初始化拿到的版本号和我一样
        try { TimeUnit.MILLISECONDS.sleep(500); } catch (Exception e) {}

        stampedReference.compareAndSet(100,101,stampedReference.getStamp(),
                                       stampedReference.getStamp()+1);
        System.out.println(Thread.currentThread().getName()+"\t"+
                           "2次流水号："+stampedReference.getStamp());

        stampedReference.compareAndSet(101,100,stampedReference.getStamp(),
                                       stampedReference.getStamp()+1);
        System.out.println(Thread.currentThread().getName()+"\t"+
                           "3次流水号："+stampedReference.getStamp());

    },"t3").start();

    new Thread(() -> {
        int stamp = stampedReference.getStamp();
        System.out.println(Thread.currentThread().getName()+"\t"+"首次版本号："+stamp);

        //暂停1秒钟线程,等待上面的t3线程，发生了ABA问题
        try { TimeUnit.SECONDS.sleep(1); } catch (Exception e) {}

        boolean b = stampedReference.compareAndSet(100, 2022, stamp, stamp + 1);

        System.out.println(b+"\t"+stampedReference.getReference()+"\t"+
                           stampedReference.getStamp());

    },"t4").start();
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206251557186.png" alt="image-20220625155718127" style="zoom:67%;" />



### 循环性能开销

自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销

> 怎么解决循环性能开销问题？

在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋

### 只能保证一个变量的原子操作

`CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的`

> 怎么解决只能保证一个变量的原子操作问题？

- 可以考虑改用锁来保证操作的原子性
- 可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。

# volatile 关键字

volatile 是 Java 并发编程的重要组成部分，也是常见的面试题之一，**它的主要作用有两个：保证内存的可见性和禁止指令重排序**。下面我们具体来看这两个功能。

## 内存可见性

说到内存可见性问题就不得不提 Java 内存模型，Java 内存模型（Java Memory Model）简称为 JMM，主要是用来屏蔽不同硬件和操作系统的内存访问差异的，因为在不同的硬件和不同的操作系统下，内存的访问是有一定的差异得，这种差异会导致相同的代码在不同的硬件和不同的操作系统下有着不一样的行为，而 Java 内存模型就是解决这个差异，统一相同代码在不同硬件和不同操作系统下的差异的。

Java 内存模型规定：所有的变量（实例变量和静态变量）都必须存储在主内存中，每个线程也会有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291838804.png" alt="image-20220629183801716" style="zoom: 33%;" />

然而，Java 内存模型会带来一个新的问题，那就是内存可见性问题，也就是当某个线程修改了主内存中共享变量的值之后，其他线程不能感知到此值被修改了，它会一直使用自己工作内存中的“旧值”，这样程序的执行结果就不符合我们的预期了，这就是内存可见性问题，我们用以下代码来演示一下这个问题：

```java
private static boolean flag = false;
public static void main(String[] args) {
    Thread t1 = new Thread(new Runnable() {
        @Override
        public void run() {
            while (!flag) {

            }
            System.out.println("终止执行");
        }
    });
    t1.start();
    Thread t2 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("设置 flag=true");
            flag = true;
        }
    });
    t2.start();
}
```

以上代码我们预期的结果是，在线程 1 执行了 1s 之后，线程 2 将 flag 变量修改为 true，之后线程 1 终止执行，然而，因为线程 1 感知不到 flag 变量发生了修改，也就是内存可见性问题，所以会导致线程 1 会永远的执行下去，最终我们看到的结果是这样的：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291837418.png" alt="image-20220629183747353" style="zoom:67%;" />

如何解决以上问题呢？只需要给变量 flag 加上 volatile 修饰即可，具体的实现代码如下：

```java
private volatile static boolean flag = false;
public static void main(String[] args) {
    Thread t1 = new Thread(new Runnable() {
        @Override
        public void run() {
            while (!flag) {

            }
            System.out.println("终止执行");
        }
    });
    t1.start();
    Thread t2 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("设置 flag=true");
            flag = true;
        }
    });
    t2.start();
}
```

以上程序的执行结果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291837587.png" alt="image-20220629183723524" style="zoom:67%;" />

## 禁止指令重排序

指令重排序是指编译器或 CPU 为了优化程序的执行性能，而对指令进行重新排序的一种手段。

指令重排序的实现初衷是好的，但是在多线程执行中，如果执行了指令重排序可能会导致程序执行出错。指令重排序最典型的一个问题就发生在单例模式中，比如以下问题代码：

```java
public class Singleton {
    private Singleton() {}
    private static Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) { // ①
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // ②
                }
            }
        }
        return instance;
    }
}
```

以上问题发生在代码 ② 这一行“instance = new Singleton();”，这行代码**看似只是一个创建对象的过程，然而它的实际执行却分为以下 3 步：**

1. **创建内存空间。**
2. **在内存空间中初始化对象 Singleton。**
3. **将内存地址赋值给 instance 对象（执行了此步骤，instance 就不等于 null 了）。**

**如果此变量不加 volatile，那么线程 1 在执行到上述代码的第 ② 处时就可能会执行指令重排序，将原本是 1、2、3 的执行顺序，重排为 1、3、2。但是特殊情况下，线程 1 在执行完第 3 步之后，如果来了线程 2 执行到上述代码的第 ① 处，判断 instance 对象已经不为 null，但此时线程 1 还未将对象实例化完，那么线程 2 将会得到一个被实例化“一半”的对象，从而导致程序执行出错，这就是为什么要给私有变量添加 volatile 的原因了。**

要使以上单例模式变为线程安全的程序，需要给 instance 变量添加 volatile 修饰，它的最终实现代码如下：

```java
public class Singleton {
    private Singleton() {}
    // 使用 volatile 禁止指令重排序
    private static volatile Singleton instance = null; // 【主要是此行代码发生了变化】
    public static Singleton getInstance() {
        if (instance == null) { // ①
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // ②
                }
            }
        }
        return instance;
    }
}
```

## 总结

> volatile 是 Java 并发编程的重要组成部分，它的主要作用有两个：`保证内存的可见性和禁止指令重排序`。volatile 常使用在一写多读的场景中，比如 CopyOnWriteArrayList 集合，它在操作的时候会把全部数据复制出来对写操作加锁，修改完之后再使用 setArray 方法把此数组赋值为更新后的值，使用 volatile 可以使读线程很快的告知到数组被修改，不会进行指令重排，操作完成后就可以对其他线程可见了。

# Unsafe类

## 前言

几乎每个使用 Java开发的工具、软件基础设施、高性能开发库都在底层使用了sun.misc.Unsafe，比如Netty、Cassandra、Hadoop、Kafka等。

Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。但Unsafe类在sun.misc包下，不属于Java标准。

很早之前，在阅读并发编程相关类的源码时，看到Unsafe类，产生了一个疑惑：既然是并发编程中用到的类，为什么命名为Unsafe呢？

深入了解之后才知道，这里的Unsafe并不是说线程安全与否，而是指：该类对于普通的程序员来说是”危险“的，一般应用开发者不会也不应该用到此类。

因为Unsafe类功能过于强大，提供了一些可以绕开JVM的更底层功能。它让Java拥有了像C语言的指针一样操作内存空间的能力，能够提升效率，但也带来了指针的问题。官方并不建议使用，也没提供文档支持，甚至计划在高版本中去掉该类。

但对于开发者来说，了解该类提供的功能更有助于我们学习CAS、并发编程等相关的知识，还是非常有必要学习和了解的。

## Unsafe的构造

Unsafe类是"final"的，不允许继承，且构造函数是private，使用了单例模式来通过一个静态方法getUnsafe()来获取。

```java
private Unsafe() {
}

@CallerSensitive
public static Unsafe getUnsafe() {
    Class var0 = Reflection.getCallerClass();
    if (!VM.isSystemDomainLoader(var0.getClassLoader())) {
        throw new SecurityException("Unsafe");
    } else {
        return theUnsafe;
    }
}
```

在getUnsafe方法中对单例模式中的对象创建做了限制，如果是普通的调用会抛出一个SecurityException异常。只有由主类加载器加载的类才能调用这个方法。

那么，如何获得Unsafe类的对象呢？通常采用反射机制：

```java
public static Unsafe getUnsafe() throws IllegalAccessException {
  Field unsafeField = Unsafe.class.getDeclaredFields()[0];
  unsafeField.setAccessible(true);
  return (Unsafe) unsafeField.get(null);
}
```

当获得Unsafe对象之后，就可以”为所欲为“了。下面就来看看，通过Unsafe方法，我们可以做些什么。

## Unsafe的主要功能

可先从根据下图从整体上了解一下Unsafe提供的功能：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291843646.png" alt="image-20220629184300552" style="zoom:80%;" />

下面挑选重要的功能进行讲解。

## 一、内存管理

Unsafe的内存管理功能主要包括：普通读写、volatile读写、有序写入、直接操作内存等分配内存与释放内存的功能。

### 普通读写

Unsafe可以读写一个类的属性，即便这个属性是私有的，也可以对这个属性进行读写。

```java
// 获取内存地址指向的整数
public native int getInt(Object var1, long var2);

// 将整数写入指定内存地址
public native void putInt(Object var1, long var2, int var4);
```

getInt用于从对象的指定偏移地址处读取一个int。putInt用于在对象指定偏移地址处写入一个int。其他原始类型也提供有对应的方法。

另外，Unsafe的getByte、putByte方法提供了直接在一个地址上进行读写的功能。

### volatile读写

普通的读写无法保证可见性和有序性，而volatile读写就可以保证可见性和有序性。

```java
// 获取内存地址指向的整数，并支持volatile语义
public native int getIntVolatile(Object var1, long var2);

// 将整数写入指定内存地址，并支持volatile语义
public native void putIntVolatile(Object var1, long var2, int var4);
```

volatile读写要保证可见性和有序性，相对普通读写更加昂贵。

### 有序写入

有序写入只保证写入的有序性，不保证可见性，就是说一个线程的写入不保证其他线程立马可见。

```java
// 将整数写入指定内存地址、有序或者有延迟的方法
public native void putOrderedInt(Object var1, long var2, int var4);
```

而与volatile写入相比putOrderedXX写入代价相对较低，putOrderedXX写入不保证可见性，但是保证有序性，所谓有序性，就是保证指令不会重排序。

### 直接操作内存

Unsafe提供了直接操作内存的能力：

```java
// 分配内存
public native long allocateMemory(long var1);
// 重新分配内存
public native long reallocateMemory(long var1, long var3);
// 内存初始化
public native void setMemory(long var1, long var3, byte var5);
// 内存复制
public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);
// 清除内存
public native void freeMemory(long var1);
```

对应操作内存，也提供了一些获取内存信息的方法：

```java
// 获取内存地址
public native long getAddress(long var1);

public native int addressSize();

public native int pageSize();
```

值得注意的是：利用copyMemory方法可以实现一个通用的对象拷贝方法，无需再对每一个对象都实现clone方法，但只能做到对象浅拷贝。

## 二、非常规对象实例化

通常，我们通过new或反射来实例化对象，而Unsafe类提供的allocateInstance方法，可以直接生成对象实例，且无需调用构造方法和其他初始化方法。

这在对象反序列化的时候会很有用，能够重建和设置final字段，而不需要调用构造方法。

```java
// 直接生成对象实例，不会调用这个实例的构造方法
public native Object allocateInstance(Class<?> var1) throws InstantiationException;
```

## 三、类加载

通过以下方法，可以实现类的定义、创建等操作。

```java
// 方法定义一个类，用于动态地创建类
public native Class<?> defineClass(String var1, byte[] var2, int var3, int var4, 
                                   ClassLoader var5, 
                                   ProtectionDomain var6);

//  动态的创建一个匿名内部类
public native Class<?> defineAnonymousClass(Class<?> var1, byte[] var2, Object[] var3);

// 判断是否需要初始化一个类
public native boolean shouldBeInitialized(Class<?> var1);

// 保证已经初始化过一个类
public native void ensureClassInitialized(Class<?> var1);
```

## 四、偏移量相关

Unsafe提供以下方法获取对象的指针，通过对指针进行偏移，不仅可以直接修改指针指向的数据（即使它们是私有的），甚至可以找到JVM已经认定为垃圾、可以进行回收的对象。

```java
// 获取静态属性Field在对象中的偏移量，读写静态属性时必须获取其偏移量
public native long staticFieldOffset(Field var1);
// 获取非静态属性Field在对象实例中的偏移量，读写对象的非静态属性时会用到这个偏移量
public native long objectFieldOffset(Field var1);
// 返回Field所在的对象
public native Object staticFieldBase(Field var1);
// 返回数组中第一个元素实际地址相对整个数组对象的地址的偏移量
public native int arrayBaseOffset(Class<?> var1);
// 计算数组中第一个元素所占用的内存空间
public native int arrayIndexScale(Class<?> var1);
```

## 五、数组操作

数组操作提供了以下方法：

```java
// 获取数组第一个元素的偏移地址
public native int arrayBaseOffset(Class<?> var1);
// 获取数组中元素的增量地址
public native int arrayIndexScale(Class<?> var1);
```

arrayBaseOffset与arrayIndexScale配合起来使用，就可以定位数组中每个元素在内存中的位置。

由于Java的数组最大值为Integer.MAX_VALUE，使用Unsafe类的内存分配方法可以实现超大数组。实际上这样的数据就可以认为是C数组，因此需要注意在合适的时间释放内存。

## 六、线程调度

线程调度相关方法如下：

```java
// 唤醒线程
public native void unpark(Object var1);
// 挂起线程
public native void park(boolean var1, long var2);
// 用于加锁，已废弃
public native void monitorEnter(Object var1);
// 用于加锁，已废弃
public native void monitorExit(Object var1);
// 用于加锁，已废弃
public native boolean tryMonitorEnter(Object var1);
```

通过park方法将线程进行挂起， 线程将一直阻塞到超时或中断条件出现。unpark方法可以终止一个挂起的线程，使其恢复正常。

整个并发框架中对线程的挂起操作被封装在LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。

## 七、CAS操作

Unsafe类的CAS操作可能是使用最多的方法。它为Java的锁机制提供了一种新的解决办法，比如AtomicInteger等类都是通过该方法来实现的。compareAndSwap方法是原子的，可以避免繁重的锁机制，提高代码效率。

```java
public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, 
                                                 Object var5);

public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);

public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);
```

CAS一般用于乐观锁，它在Java中有广泛的应用，ConcurrentHashMap，ConcurrentLinkedQueue中都有用到CAS来实现乐观锁。

## 八、内存屏障

JDK8新引入了用于定义内存屏障、避免代码重排的方法：

```java
// 保证在这个屏障之前的所有读操作都已经完成
public native void loadFence();

// 保证在这个屏障之前的所有写操作都已经完成
public native void storeFence();

// 保证在这个屏障之前的所有读写操作都已经完成
public native void fullFence();
```

## 九、其他

当然，Unsafe类中还提供了大量其他的方法，比如上面提到的CAS操作，以AtomicInteger为例，当我们调用getAndIncrement、getAndDecrement等方法时，本质上调用的就是Unsafe的getAndAddInt方法。

```java
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

public final int getAndDecrement() {
    return unsafe.getAndAddInt(this, valueOffset, -1);
}
```

在实践的过程中，如果阅读其他框架或类库实现，当发现用到Unsafe类，可对照该类的整体功能，结合应用场景进行分析，即可大概了解其功能。

## 小结

经过本文的分析，想必大家在阅读源码时，再遇到Unsafe类的调用，一定大概猜出它是用来干什么的。使用Unsafe类的主要目的大多数情况下是`为了提升运行效率、增强功能。但同时也面临着出错、内存管理等风险`。只有深入了解，且有必要的情况下才建议使用。



# ThreadLocal

## 基本语法

`ThreadLocal` 原本设计是为了解决并发时，线程共享变量的问题，但由于过度设计，如弱引用和哈希碰撞，从而导致它的理解难度大和使用成本高等问题。当然，如果稍有不慎还是导致脏数据、内存溢出、共享变量更新等问题，但即便如此，**ThreadLocal 依旧有适合自己的使用场景，以及无可取代的价值**，比如本文要介绍了这两种使用场景，除了 `ThreadLocal` 之外，还真没有合适的替代方案。

ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。

`ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝`，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205161639509.png" alt="image-20220516163915469" style="zoom: 67%;" />

- 创建

创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。

```java
//创建一个ThreadLocal变量
public static ThreadLocal<String> localVariable = new ThreadLocal<>();
```

- 写入

线程可以在任何地方使用localVariable，写入变量。

```java
localVariable.set("鄙人三某”);
```

- 读取

线程在任何地方读取的都是它写入的变量。

```java
localVariable.get();
```

完整实例

```java
//创建一个ThreadLocal变量
public static ThreadLocal<String> local = new ThreadLocal<>();

public static void t1() {
    //设置线程变量
    local.set("鄙人三某");
    //获取线程变量
    String s = local.get();
    //鄙人三某
    System.out.println(s);
    //移除线程变量
    local.remove();
}
```

## 应用场景

### 使用场景1：本地变量

我们以多线程格式化时间为例，来演示 `ThreadLocal` 的价值和作用，当我们在多个线程中格式化时间时，通常会这样操作。

#### ① 2个线程格式化

当有 2 个线程进行时间格式化时，我们可以这样写：

```java
import java.text.SimpleDateFormat;
import java.util.Date;

publicclass Test {
    public static void main(String[] args) throws InterruptedException {
        // 创建并启动线程1
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 得到时间对象
                Date date = new Date(1 * 1000);
                // 执行时间格式化
                formatAndPrint(date);
            }
        });
        t1.start();
        // 创建并启动线程2
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                // 得到时间对象
                Date date = new Date(2 * 1000);
                // 执行时间格式化
                formatAndPrint(date);
            }
        });
        t2.start();
    }

    /**
     * 格式化并打印结果
     * @param date 时间对象
     */
    private static void formatAndPrint(Date date) {
        // 格式化时间对象
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("mm:ss");
        // 执行格式化
        String result = simpleDateFormat.format(date);
        // 打印最终结果
        System.out.println("时间：" + result);
    }
}
```

以上程序的执行结果为：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061826761.png" alt="image-20220706182600681" style="zoom:50%;" />

上面的代码因为创建的线程数量并不多，所以我们可以给每个线程创建一个私有对象 `SimpleDateFormat` 来进行时间格式化。

#### ② 10个线程格式化

当线程的数量从 2 个升级为 10 个时，我们可以使用 `for` 循环来创建多个线程执行时间格式化，具体实现代码如下：

```java
import java.text.SimpleDateFormat;
import java.util.Date;

publicclass Test {
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            // 创建线程
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    // 得到时间对象
                    Date date = new Date(finalI * 1000);
                    // 执行时间格式化
                    formatAndPrint(date);
                }
            });
            // 启动线程
            thread.start();
        }
    }
    /**
     * 格式化并打印时间
     * @param date 时间对象
     */
    private static void formatAndPrint(Date date) {
        // 格式化时间对象
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("mm:ss");
        // 执行格式化
        String result = simpleDateFormat.format(date);
        // 打印最终结果
        System.out.println("时间：" + result);
    }
}
```

以上程序的执行结果为：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061826024.png" alt="image-20220706182616936" style="zoom:33%;" />

从上述结果可以看出，虽然此时创建的线程数和 `SimpleDateFormat` 的数量不算少，但程序还是可以正常运行的。

#### ③ 1000个线程格式化

然而当我们将线程的数量从 10 个变成 1000 个的时候，我们就不能单纯的使用 `for` 循环来创建 1000 个线程的方式来解决问题了，因为这样频繁的新建和销毁线程会造成大量的系统开销和线程过度争抢 `CPU` 资源的问题。

所以经过一番思考后，**我们决定使用线程池来执行这 1000 次的任务，因为线程池可以复用线程资源，无需频繁的新建和销毁线程，也可以通过控制线程池中线程的数量来避免过多线程所导致的 \**`CPU`\** 资源过度争抢和线程频繁切换所造成的性能问题**，而且我们可以将 `SimpleDateFormat` 提升为全局变量，从而避免每次执行都要新建 `SimpleDateFormat` 的问题，于是我们写下了这样的代码：

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

publicclass App {
    // 时间格式化对象
    privatestatic SimpleDateFormat simpleDateFormat = new SimpleDateFormat("mm:ss");

    public static void main(String[] args) throws InterruptedException {
        // 创建线程池执行任务
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10, 60,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>(1000));
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            // 执行任务
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    // 得到时间对象
                    Date date = new Date(finalI * 1000);
                    // 执行时间格式化
                    formatAndPrint(date);
                }
            });
        }
        // 线程池执行完任务之后关闭
        threadPool.shutdown();
    }

    /**
     * 格式化并打印时间
     * @param date 时间对象
     */
    private static void formatAndPrint(Date date) {
        // 执行格式化
        String result = simpleDateFormat.format(date);
        // 打印最终结果
        System.out.println("时间：" + result);
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnY2iawDewptg1JIwwT1L8bUjLSHhoZUdpnEba98alKD3Wtk5OdjkrIENg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

当我们怀着无比喜悦的心情去运行程序的时候，却发现意外发生了，这样写代码竟然会出现线程安全的问题。从上述结果可以看出，程序的打印结果竟然有重复内容的，正确的情况应该是没有重复的时间才对。

> PS：所谓的**线程安全问题是指：在多线程的执行中，程序的执行结果与预期结果不相符的情况**。

### a) 线程安全问题分析

为了找到问题所在，我们尝试查看 `SimpleDateFormat` 中 `format` 方法的源码来排查一下问题，`format` 源码如下：

```java
private StringBuffer format(Date date, StringBuffer toAppendTo,
                                FieldDelegate delegate) {
    // 注意此行代码
    calendar.setTime(date);

    boolean useDateFormatSymbols = useDateFormatSymbols();

    for (int i = 0; i < compiledPattern.length; ) {
        int tag = compiledPattern[i] >>> 8;
        int count = compiledPattern[i++] & 0xff;
        if (count == 255) {
            count = compiledPattern[i++] << 16;
            count |= compiledPattern[i++];
        }

        switch (tag) {
            case TAG_QUOTE_ASCII_CHAR:
                toAppendTo.append((char)count);
                break;

            case TAG_QUOTE_CHARS:
                toAppendTo.append(compiledPattern, i, count);
                i += count;
                break;

            default:
                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);
                break;
        }
    }
    return toAppendTo;
}
```

从上述源码可以看出，在执行 `SimpleDateFormat.format` 方法时，会使用 `calendar.setTime` 方法将输入的时间进行转换，那么我们想想一下这样的场景：

1. **线程 1 执行了 \**`calendar.setTime(date)`\** 方法，将用户输入的时间转换成了后面格式化时所需要的时间；**
2. **线程 1 暂停执行，线程 2 得到 \**`CPU`\** 时间片开始执行；**
3. **线程 2 执行了 \**`calendar.setTime(date)`\** 方法，对时间进行了修改；**
4. **线程 2 暂停执行，线程 1 得出 \**`CPU`\** 时间片继续执行，因为线程 1 和线程 2 使用的是同一对象，而时间已经被线程 2 修改了，所以此时当线程 1 继续执行的时候就会出现线程安全的问题了。**

正常的情况下，程序的执行是这样的：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061827452.png" alt="image-20220706182706265" style="zoom:50%;" />

非线程安全的执行流程是这样的：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061827552.png" alt="image-20220706182726414" style="zoom: 50%;" />

### b) 解决线程安全问题：加锁

当出现线程安全问题时，我们想到的第一解决方案就是加锁，具体的实现代码如下：

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

publicclass App {
    // 时间格式化对象
    privatestatic SimpleDateFormat simpleDateFormat = new SimpleDateFormat("mm:ss");

    public static void main(String[] args) throws InterruptedException {
        // 创建线程池执行任务
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10, 60,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>(1000));
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            // 执行任务
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    // 得到时间对象
                    Date date = new Date(finalI * 1000);
                    // 执行时间格式化
                    formatAndPrint(date);
                }
            });
        }
        // 线程池执行完任务之后关闭
        threadPool.shutdown();
    }

    /**
     * 格式化并打印时间
     * @param date 时间对象
     */
    private static void formatAndPrint(Date date) {
        // 执行格式化
        String result = null;
        // 加锁
        synchronized (App.class) {
            result = simpleDateFormat.format(date);
        }
        // 打印最终结果
        System.out.println("时间：" + result);
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYNgb43GiaYBJ1lNI5WZqueibdlnFGjlOrMkvRQN61BHrj4PbMtCqsVpfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从上述结果可以看出，使用了 `synchronized` 加锁之后程序就可以正常的执行了。

加锁的缺点

**加锁的方式虽然可以解决线程安全的问题，但同时也带来了新的问题，当程序加锁之后，所有的线程必须排队执行某些业务才行，这样无形中就降低了程序的运行效率了**。

有没有既能解决线程安全问题，又能提高程序的执行速度的解决方案呢？

答案是：有的，这个时候 `ThreadLocal`就要上场了。

### c) 解决线程安全问题：ThreadLocal

#### 1.ThreadLocal 介绍

`ThreadLocal` 从字面的意思来理解是线程本地变量的意思，也就是说它是线程中的私有变量，每个线程只能使用自己的变量。

以上面线程池格式化时间为例，当线程池中有 10 个线程时，`SimpleDateFormat` 会存入 `ThreadLocal` 中，它也只会创建 10 个对象，即使要执行 1000 次时间格式化任务，依然只会新建 10 个 `SimpleDateFormat` 对象，每个线程调用自己的 `ThreadLocal` 变量。

#### 2.ThreadLocal 基础使用

`ThreadLocal` 常用的核心方法有三个：

1. **set 方法：用于设置线程独立变量副本。**没有 set 操作的 ThreadLocal 容易引起脏数据。
2. **get 方法：用于获取线程独立变量副本。**没有 get 操作的 ThreadLocal 对象没有意义。
3. **remove 方法：用于移除线程独立变量副本。**没有 remove 操作容易引起内存泄漏。

ThreadLocal 所有方法如下图所示：


![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnY2PFPZsKOopdDs7pRNGd0icyVKOvaibuK63LFicj3mXLGX4icIhXsbqFMKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

官方说明文档：https://docs.oracle.com/javase/8/docs/api/

ThreadLocal 基础用法如下：

```java
/**
 * @公众号：Java中文社群
 */
publicclass ThreadLocalExample {
    // 创建一个 ThreadLocal 对象
    privatestatic ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public static void main(String[] args) {
        // 线程执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                System.out.println(threadName + " 存入值：" + threadName);
                // 在 ThreadLocal 中设置值
                threadLocal.set(threadName);
                // 执行方法，打印线程中设置的值
                print(threadName);
            }
        };
        // 创建并启动线程 1
        new Thread(runnable, "MyThread-1").start();
        // 创建并启动线程 2
        new Thread(runnable, "MyThread-2").start();
    }

    /**
     * 打印线程中的 ThreadLocal 值
     * @param threadName 线程名称
     */
    private static void print(String threadName) {
        try {
            // 得到 ThreadLocal 中的值
            String result = threadLocal.get();
            // 打印结果
            System.out.println(threadName + " 取出值：" + result);
        } finally {
            // 移除 ThreadLocal 中的值（防止内存溢出）
            threadLocal.remove();
        }
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYNLeD3aDnhkHtEGGOanAzwdjqe2OyzGf2NN2PQZK1sWzUkz7KgPqPyg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从上述结果可以看出，每个线程只会读取到属于自己的 `ThreadLocal` 值。

#### 3.ThreadLocal 高级用法

##### ① 初始化：initialValue

```java
publicclass ThreadLocalByInitExample {
    // 定义 ThreadLocal
    privatestatic ThreadLocal<String> threadLocal = new ThreadLocal(){
        @Override
        protected String initialValue() {
            System.out.println("执行 initialValue() 方法");
            return"默认值";
        }
    };

    public static void main(String[] args) {
        // 线程执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // 执行方法，打印线程中数据（未设置值打印）
                print(threadName);
            }
        };
        // 创建并启动线程 1
        new Thread(runnable, "MyThread-1").start();
        // 创建并启动线程 2
        new Thread(runnable, "MyThread-2").start();
    }

    /**
     * 打印线程中的 ThreadLocal 值
     * @param threadName 线程名称
     */
    private static void print(String threadName) {
        // 得到 ThreadLocal 中的值
        String result = threadLocal.get();
        // 打印结果
        System.out.println(threadName + " 得到值：" + result);
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYYTZDWKup9cPw8AbIia8WGibF1sUtuvo12AI4icpZ3gDy0iaTJjmsibaNj2Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

当使用了 `#threadLocal.set` 方法之后，`initialValue` 方法就不会被执行了，如下代码所示：

```java
publicclass ThreadLocalByInitExample {
    // 定义 ThreadLocal
    privatestatic ThreadLocal<String> threadLocal = new ThreadLocal() {
        @Override
        protected String initialValue() {
            System.out.println("执行 initialValue() 方法");
            return"默认值";
        }
    };

    public static void main(String[] args) {
        // 线程执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                System.out.println(threadName + " 存入值：" + threadName);
                // 在 ThreadLocal 中设置值
                threadLocal.set(threadName);
                // 执行方法，打印线程中设置的值
                print(threadName);
            }
        };
        // 创建并启动线程 1
        new Thread(runnable, "MyThread-1").start();
        // 创建并启动线程 2
        new Thread(runnable, "MyThread-2").start();
    }

    /**
     * 打印线程中的 ThreadLocal 值
     * @param threadName 线程名称
     */
    private static void print(String threadName) {
        try {
            // 得到 ThreadLocal 中的值
            String result = threadLocal.get();
            // 打印结果
            System.out.println(threadName + "取出值：" + result);
        } finally {
            // 移除 ThreadLocal 中的值（防止内存溢出）
            threadLocal.remove();
        }
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYJcXibUu5BVFNZ7N44ACqO0RHfe7yRC0IZUNNjforsuibjXXAT2zAjbHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



##### 为什么 set 之后，初始化代码就不执行了？

要理解这个问题，需要从 `ThreadLocal.get()` 方法的源码中得到答案，因为初始化方法 `initialValue` 在 `ThreadLocal` 创建时并不会立即执行，而是在调用了 `get` 方法只会才会执行，测试代码如下：

```java
import java.util.Date;

publicclass ThreadLocalByInitExample {
    // 定义 ThreadLocal
    privatestatic ThreadLocal<String> threadLocal = new ThreadLocal() {
        @Override
        protected String initialValue() {
            System.out.println("执行 initialValue() 方法 " + new Date());
            return"默认值";
        }
    };
    public static void main(String[] args) {
        // 线程执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // 得到当前线程名称
                String threadName = Thread.currentThread().getName();
                // 执行方法，打印线程中设置的值
                print(threadName);
            }
        };
        // 创建并启动线程 1
        new Thread(runnable, "MyThread-1").start();
        // 创建并启动线程 2
        new Thread(runnable, "MyThread-2").start();
    }

    /**
     * 打印线程中的 ThreadLocal 值
     * @param threadName 线程名称
     */
    private static void print(String threadName) {
        System.out.println("进入 print() 方法 " + new Date());
        try {
            // 休眠 1s
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 得到 ThreadLocal 中的值
        String result = threadLocal.get();
        // 打印结果
        System.out.println(String.format("%s 取得值：%s %s",
                threadName, result, new Date()));
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYtbkoib5ACxia0xnhnPAO6FhCBqN8Yvwn7ZkHAyIOQrwN2lZV7VjR3v3A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从上述打印的时间可以看出：`initialValue` 方法并不是在 `ThreadLocal` 创建时执行的，而是在调用 `Thread.get` 方法时才执行的。

接下来来看 `Threadlocal.get` 源码的实现：

```java
public T get() {
    // 得到当前的线程
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    // 判断 ThreadLocal 中是否有数据
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            // 有 set 值，直接返回数据
            return result;
        }
    }
    // 执行初始化方法【重点关注】
    return setInitialValue();
}
private T setInitialValue() {
    // 执行初始化方法【重点关注】
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
```

从上述源码可以看出，当 `ThreadLocal` 中有值时会直接返回值 `e.value`，只有 `Threadlocal` 中没有任何值时才会执行初始化方法 `initialValue`。

##### 注意事项—类型必须保持一致

注意在使用 `initialValue` 时，返回值的类型要和 `ThreadLoca` 定义的数据类型保持一致，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnY4uZKYv5FJiao4PzHPgGIJ2wib3kDAJwRGV2fDExm7ThHlhczcMkyfY0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果数据不一致就会造成 `ClassCaseException` 类型转换异常，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYTdVFGysOn5wZGK8zSNtXYElwuqEeKKojrJovJYlPPLDsp6gc97vmOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



##### ② 初始化2：withInitial

```java
import java.util.function.Supplier;

publicclass ThreadLocalByInitExample {
    // 定义 ThreadLocal
    privatestatic ThreadLocal<String> threadLocal =
            ThreadLocal.withInitial(new Supplier<String>() {
                @Override
                public String get() {
                    System.out.println("执行 withInitial() 方法");
                    return"默认值";
                }
            });
    public static void main(String[] args) {
        // 线程执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                // 执行方法，打印线程中设置的值
                print(threadName);
            }
        };
        // 创建并启动线程 1
        new Thread(runnable, "MyThread-1").start();
        // 创建并启动线程 2
        new Thread(runnable, "MyThread-2").start();
    }

    /**
     * 打印线程中的 ThreadLocal 值
     * @param threadName 线程名称
     */
    private static void print(String threadName) {
        // 得到 ThreadLocal 中的值
        String result = threadLocal.get();
        // 打印结果
        System.out.println(threadName + " 得到值：" + result);
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnY5CNNhMaKoUNv0VBCibyeInLuAdSQIcNnv0vSaDwDvXNl2uAL8RGK6bA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

通过上述的代码发现，`withInitial` 方法的使用好和 `initialValue` 好像没啥区别，那为啥还要造出两个类似的方法呢？客官莫着急，继续往下看。

##### ③ 更简洁的 withInitial 使用

`withInitial` 方法的优势在于可以更简单的实现变量初始化，如下代码所示：

```java
publicclass ThreadLocalByInitExample {
    // 定义 ThreadLocal
    privatestatic ThreadLocal<String> threadLocal = ThreadLocal.withInitial(() -> "默认值");
    public static void main(String[] args) {
        // 线程执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                String threadName = Thread.currentThread().getName();
                // 执行方法，打印线程中设置的值
                print(threadName);
            }
        };
        // 创建并启动线程 1
        new Thread(runnable, "MyThread-1").start();
        // 创建并启动线程 2
        new Thread(runnable, "MyThread-2").start();
    }

    /**
     * 打印线程中的 ThreadLocal 值
     * @param threadName 线程名称
     */
    private static void print(String threadName) {
        // 得到 ThreadLocal 中的值
        String result = threadLocal.get();
        // 打印结果
        System.out.println(threadName + " 得到值：" + result);
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYHJtJMJKRelvPcK9AM23xd53zGjoSxPsMHQXThK2BtdKKjlUqsH7C9g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



#### 4.ThreadLocal 版时间格式化

了解了 `ThreadLocal` 的使用之后，我们回到本文的主题，接下来我们将使用 `ThreadLocal` 来实现 1000 个时间的格式化，具体实现代码如下：

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

publicclass MyThreadLocalByDateFormat {
    // 创建 ThreadLocal 并设置默认值
    privatestatic ThreadLocal<SimpleDateFormat> dateFormatThreadLocal =
            ThreadLocal.withInitial(() -> new SimpleDateFormat("mm:ss"));

    public static void main(String[] args) {
        // 创建线程池执行任务
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 10, 60,
                TimeUnit.SECONDS, new LinkedBlockingQueue<>(1000));
        // 执行任务
        for (int i = 0; i < 1000; i++) {
            int finalI = i;
            // 执行任务
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    // 得到时间对象
                    Date date = new Date(finalI * 1000);
                    // 执行时间格式化
                    formatAndPrint(date);
                }
            });
        }
        // 线程池执行完任务之后关闭
        threadPool.shutdown();
        // 线程池执行完任务之后关闭
        threadPool.shutdown();
    }
    /**
     * 格式化并打印时间
     * @param date 时间对象
     */
    private static void formatAndPrint(Date date) {
        // 执行格式化
        String result = dateFormatThreadLocal.get().format(date);
        // 打印最终结果
        System.out.println("时间：" + result);
    }
}
```

以上程序的执行结果为：

![图片](https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCshWenyX9BSlolPWUyFpmYnYNgb43GiaYBJ1lNI5WZqueibdlnFGjlOrMkvRQN61BHrj4PbMtCqsVpfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

从上述结果可以看出，使用 `ThreadLocal` 也可以解决线程并发问题，并且避免了代码加锁排队执行的问题。

### 使用场景2：跨类传递数据

除了上面的使用场景之外，我们还可以**使用 \**`ThreadLocal`\** 来实现线程中跨类、跨方法的数据传递**。比如登录用户的 `User` 对象信息，我们需要在不同的子系统中多次使用，如果使用传统的方式，我们需要使用方法传参和返回值的方式来传递 `User` 对象，然而这样就无形中造成了类和类之间，甚至是系统和系统之间的相互耦合了，所以此时我们可以使用 `ThreadLocal` 来实现 `User` 对象的传递。

确定了方案之后，接下来我们来实现具体的业务代码。我们可以先在主线程中构造并初始化一个 `User` 对象，并将此 `User` 对象存储在 `ThreadLocal` 中，存储完成之后，我们就可以在同一个线程的其他类中，如仓储类或订单类中直接获取并使用 `User` 对象了，具体实现代码如下。

主线程中的业务代码：

```java
publi cclass ThreadLocalByUser {
    public static void main(String[] args) {
        // 初始化用户信息
        User user = new User("Java");
        // 将 User 对象存储在 ThreadLocal 中
        UserStorage.setUser(user);
        // 调用订单系统
        OrderSystem orderSystem = new OrderSystem();
        // 添加订单（方法内获取用户信息）
        orderSystem.add();
        // 调用仓储系统
        RepertorySystem repertory = new RepertorySystem();
        // 减库存（方法内获取用户信息）
        repertory.decrement();
    }
}
```

`User` 实体类：

```java
/**
 * 用户实体类
 */
class User {
    public User(String name) {
        this.name = name;
    }
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

`ThreadLocal` 操作类：

```java
/**
 * 用户信息存储类
 */
class UserStorage {
    // 用户信息
    publicstatic ThreadLocal<User> USER = new ThreadLocal();

    /**
     * 存储用户信息
     * @param user 用户数据
     */
    public static void setUser(User user) {
        USER.set(user);
    }
}
```

订单类：

```java
/**
 * 订单类
 */
class OrderSystem {
    /**
     * 订单添加方法
     */
    public void add() {
        // 得到用户信息
        User user = UserStorage.USER.get();
        // 业务处理代码（忽略）...
        System.out.println(String.format("订单系统收到用户：%s 的请求。",
                user.getName()));
    }
}
```

仓储类：

```java
/**
 * 仓储类
 */
class RepertorySystem {
    /**
     * 减库存方法
     */
    public void decrement() {
        // 得到用户信息
        User user = UserStorage.USER.get();
        // 业务处理代码（忽略）...
        System.out.println(String.format("仓储系统收到用户：%s 的请求。",
                user.getName()));
    }
}
```

以上程序的最终执行结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207061825248.png" alt="image-20220706182514152" style="zoom:67%;" />

从上述结果可以看出，当我们在主线程中先初始化了 `User` 对象之后，订单类和仓储类无需进行任何的参数传递也可以正常获得 `User` 对象了，从而**实现了一个线程中，跨类和跨方法的数据传递**。

### 总结

使用 `ThreadLocal` 可以创建线程私有变量，所以不会导致线程安全问题，同时使用 `ThreadLocal` 还可以避免因为引入锁而造成线程排队执行所带来的性能消耗；再者使用 `ThreadLocal` 还可以实现一个线程内跨类、跨方法的数据传递。







# Lock锁(重点)

## lock简介

我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在Lock接口出现之前，java程序主要是靠synchronized关键字实现锁功能的，而java SE5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。``虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性``。通常使用显示使用lock的形式如下：

```java
Lock lock = new ReentrantLock();
lock.lock();
try{
	.......
}finally{
	lock.unlock();
}
```

需要注意的是``synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁``。







## 死锁及排查

### 死锁

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205162210990.png" alt="image-20220516221003931" style="zoom:80%;" />

那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205162210491.png" alt="image-20220516221018433" style="zoom:80%;" />

- 互斥条件：`指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用`。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
- 请求并持有条件：`指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有`，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。
- 不可剥夺条件`：指线程获取到的资源在自己使用完之前不能被其它线程抢占`，只有在自己使用完毕后才由自己释放该资源。
- 环路等待条件：`指在发生死锁时，必然存在一个线程——资源的环形链`，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。

该如何避免死锁呢？答案是**至少破坏死锁发生的一个条件**。

- 其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？
- 对于“请求并持有”这个条件，可以一次性请求所有的资源。
- 对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
- 对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。



### 那死锁问题怎么排查呢？

可以使用jdk自带的命令行工具排查：

1. 使用jps查找运行的Java进程：jps -l
2. 使用jstack查看线程堆栈信息：jstack -l  进程id

基本就可以看到死锁的信息。

还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的`检测到死锁`按钮，将会看到线程的死锁信息。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205162208420.png" alt="image-20220516220854340" style="zoom:80%;" />



# synchronized(锁)

> synchronized 是 Java 语言中处理并发问题的一种常用手段，它也被我们亲切的称之为“Java 内置锁”，由此可见其地位之高。然而 synchronized 却有着多种用法，当它修饰不同对象时，其意义也是不同的，下面我们一起来看。

## synchronized 用法

synchronized 可以用来修饰**普通方法、静态方法和代码块**。

### ① 修饰普通方法

```java
/**
 * synchronized 修饰普通方法
 */
public synchronized void method() {
    // .......
}
```

当 synchronized 修饰普通方法时，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象。

### ② 修饰静态方法

```java
/**
 * synchronized 修饰静态方法
 */
public static synchronized void staticMethod() {
    // .......
}
```

当 synchronized 修饰静态的方法时，其作用的范围是整个方法，作用对象是调用这个类的所有对象。

### ③ 修饰代码块

为了减少锁的粒度，我们可以选择在一个方法中的某个部分使用 synchronized 来修饰（一段代码块），从而实现对一个方法中的部分代码进行加锁，实现代码如下：

```java
public void classMethod() throws InterruptedException {
    // 前置代码...
    
    // 加锁代码
    synchronized (SynchronizedExample.class) {
        // ......
    }
    
    // 后置代码...
}
```

以上代码在执行时，被修饰的代码块称为同步语句块，其作用范围是大括号“{}”括起来的代码块，作用的对象是调用这个代码块的对象。

但以上代码，除了可以加锁 class 之外，还可以加锁 this，具体示例如下：

```java
public void classMethod() throws InterruptedException {
    // 前置处理代码...
    synchronized (this) {
        // ......
    }
    // 后置处理代码...
}
```

那问题来了，使用 synchronized 加锁 this 和 class 的区别是什么？不都是加锁同一个类吗？

答案还真不是，加锁 this 和 class 区别还是很大的。下面我们通过以下 4 个示例，来看二者之间的区别。

## 1.加锁 class 共享一个类实例

首先，我们创建 5 个线程，调用同一个对象下 synchronized 加锁的 class 代码，具体示例如下：

```java
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class SynchronizedExample {

    public static void main(String[] args) {
        // 创建当前类实例
        final SynchronizedExample example = new SynchronizedExample();
        // 创建 5 个线程执行任务
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 调用 synchronized 修饰的 class 方法
                        example.classMethod();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }

    /**
     * synchronized 修饰的 class 方法
     * @throws InterruptedException
     */
    public void classMethod() throws InterruptedException {
        synchronized (SynchronizedExample.class) {
            System.out.println(String.format("当前执行线程:%s,执行时间:%s",
                    Thread.currentThread().getName(), new Date()));
            TimeUnit.SECONDS.sleep(1);
        }
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011248492.png" alt="image-20220601124802412" style="zoom:80%;" />

从上述结果可以看出，这 5 个线程共享的是同一把锁。

## 2.加锁 class 创建多个实例

接下来，我们创建 5 个线程，调用不同对象下 synchronized 加锁的 class 代码，具体示例如下：

```java
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class SynchronizedExample {

    public static void main(String[] args) {
        // 创建 5 个线程执行任务
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 创建类实例
                        SynchronizedExample example = new SynchronizedExample();
                        // 调用 synchronized 修饰的 class 方法
                        example.classMethod();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
    
    /**
     * synchronized 修饰的 class 方法
     * @throws InterruptedException
     */
    public void classMethod() throws InterruptedException {
        synchronized (SynchronizedExample.class) {
            System.out.println(String.format("当前执行线程:%s,执行时间:%s",
                    Thread.currentThread().getName(), new Date()));
            TimeUnit.SECONDS.sleep(1);
        }
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011248369.png" alt="image-20220601124848270" style="zoom:80%;" />

从上述结果可以看出，虽然是不同的对象，但它们使用的仍然是同一把锁。

## 3.加锁 this 共享一个类实例

接下来，我们创建 5 个线程，调用 synchronized 加锁 this 的示例。首先我们这 5 个线程调用同一个对象的加锁方法，示例代码如下：

```java
import java.util.Date;
import java.util.concurrent.TimeUnit;

publicclass SynchronizedExample {

    public static void main(String[] args) {
        // 创建当前类实例
        final SynchronizedExample example = new SynchronizedExample();
        // 创建 5 个线程执行任务
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 调用 synchronized 修饰的 this 方法
                        example.thisMethod();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
    
    /**
     * synchronized 修饰的 this 方法
     * @throws InterruptedException
     */
    public void thisMethod() throws InterruptedException {
        synchronized (this) {
            System.out.println(String.format("当前执行线程:%s,执行时间:%s",
                    Thread.currentThread().getName(), new Date()));
            TimeUnit.SECONDS.sleep(1);
        }
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011249641.png" alt="image-20220601124923543" style="zoom:80%;" />

从上述结果可以看出，以上线程使用的都是同一把锁。

## 4.加锁 this 创建多个类实例

最后一个示例最为特殊，我们使用 synchronized 加锁 this，让这 5 个线程调用各自创建对象的方法，具体示例如下：

```java
import java.util.Date;
import java.util.concurrent.TimeUnit;

publicclass SynchronizedExample {

    public static void main(String[] args) {
        // 创建 5 个线程执行任务
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 创建（多个）类实例
                        SynchronizedExample example = new SynchronizedExample();
                        // 调用 synchronized 修饰的 this 方法
                        example.thisMethod();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
    
    /**
     * synchronized 修饰的 this 方法
     * @throws InterruptedException
     */
    public void thisMethod() throws InterruptedException {
        synchronized (this) {
            System.out.println(String.format("当前执行线程:%s,执行时间:%s",
                    Thread.currentThread().getName(), new Date()));
            TimeUnit.SECONDS.sleep(1);
        }
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011249918.png" alt="image-20220601124956821" style="zoom:80%;" />

从上述结果可以看出，当使用 synchronized 加锁 this 时，如果线程调用的不是同一个对象，那么这些线程之间使用的锁都是自己独立的锁，这个结果就和 synchronized 加锁 class 的结果完全不同了。

## 总结

通过以上 4 个示例我们可以得出结论，当**使用 synchronized 加锁 class 时，无论共享一个对象还是创建多个对象，它们用的都是同一把锁**，而**使用 synchronized 加锁 this 时，只有同一个对象会使用同一把锁，不同对象之间的锁是不同的**。



## synchronized 的核心优化

[synchronized 中的 4 个优化，你知道几个？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247497091&idx=1&sn=43fb8bcd58b4f8b84ade9e7142205293&chksm=fbcf98bbccb811adce31875ac027a149c4c0cb3d9618166a11b11efed89dbf70d4c21ac1b1ac&scene=178&cur_album_id=1856147161684475909#rd)

synchronized 在 JDK 1.5 时性能是比较低的，然而在后续的版本中经过各种优化迭代，它的性能也得到了前所未有的提升，上一篇中我们谈到了锁膨胀对 synchronized 性能的提升，然而它也只是“众多” synchronized 性能优化方案中的一种，那么我们本文就来盘点一下 synchronized 的核心优化方案。

synchronized 核心优化方案主要包含以下 4 个：

1. 锁膨胀
2. 锁消除
3. 锁粗化
4. 自适应自旋锁

### 1.锁膨胀

我们先来回顾一下锁膨胀对 synchronized 性能的影响，所谓的锁膨胀是指 synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011242461.png" alt="image-20220601124253361" style="zoom:80%;" />

JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。

> PS：至于为什么不需要用户态到内核态的转换？请移步到锁膨胀的那篇文章：[《synchronized 优化手段之锁膨胀机制》](http://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247497021&idx=1&sn=a4c9e9af10ea9dbc4e6295ceb6e986a0&chksm=fbcf9805ccb81113bc2e7835645e6249bed9abe6bb96fb0eb511f0fe8dfdd67fa983503f4d0b&scene=21#wechat_redirect)。

### 2.锁消除

很多人都了解 synchronized 中锁膨胀的机制，但对接下来的 3 项优化却知之甚少，这样会在面试中错失良机，那么我们本文就把这 3 项优化单独拎出来讲一下吧。

锁消除指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。

锁消除的依据是逃逸分析的数据支持，如 StringBuffer 的 append() 方法，或 Vector 的 add() 方法，在很多情况下是可以进行锁消除的，比如以下这段代码：

```java
public String method() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < 10; i++) {
        sb.append("i:" + i);
    }
    return sb.toString();
}
```

以上代码经过编译之后的字节码如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011243994.png" alt="image-20220601124328893" style="zoom:80%;" />

从上述结果可以看出，之前我们写的线程安全的加锁的 StringBuffer 对象，在生成字节码之后就被替换成了不加锁不安全的 StringBuilder 对象了，原因是 StringBuffer 的变量属于一个局部变量，并且不会从该方法中逃逸出去，所以此时我们就可以使用锁消除（不加锁）来加速程序的运行。

### 3.锁粗化

**锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁**。

我只听说锁“细化”可以提高程序的执行效率，也就是将锁的范围尽可能缩小，这样在锁竞争时，等待获取锁的线程才能更早的获取锁，从而提高程序的运行效率，但锁粗化是如何提高性能的呢？

没错，锁细化的观点在大多数情况下都是成立了，但是一系列连续加锁和解锁的操作，也会导致不必要的性能开销，从而影响程序的执行效率，比如这段代码：

```java
public String method() {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 10; i++) {
        // 伪代码：加锁操作
        sb.append("i:" + i);
        // 伪代码：解锁操作
    }
    return sb.toString();
}
```

这里我们不考虑编译器优化的情况，**如果在 for 循环中定义锁，那么锁的范围很小，但每次 for 循环都需要进行加锁和释放锁的操作，性能是很低的；但如果我们直接在 for 循环的外层加一把锁，那么对于同一个对象操作这段代码的性能就会提高很多**，如下伪代码所示：

```java
public String method() {
    StringBuilder sb = new StringBuilder();
    // 伪代码：加锁操作
    for (int i = 0; i < 10; i++) {
        sb.append("i:" + i);
    }
    // 伪代码：解锁操作
    return sb.toString();
}
```

**锁粗化的作用：如果检测到同一个对象执行了连续的加锁和解锁的操作，则会将这一系列操作合并成一个更大的锁，从而提升程序的执行效率**。

### 4.自适应自旋锁

自旋锁是指通过自身循环，尝试获取锁的一种方式，伪代码实现如下：

```java
// 尝试获取锁
while(!isLock()){
    
}
```

**自旋锁优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的**，所以**通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销**。

但是，如果长时间自旋还获取不到锁，那么也会造成一定的资源浪费，所以我们通常会给自旋设置一个固定的值来避免一直自旋的性能开销。然而对于 synchronized 关键字来说，它的自旋锁更加的“智能”，synchronized 中的自旋锁是自适应自旋锁，这就好比之前一直开的手动挡的三轮车，而经过了 JDK 1.6 的优化之后，我们的这部“车”，一下子变成自动挡的兰博基尼了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202206011244867.png" alt="image-20220601124415683" style="zoom:80%;" />

自适应自旋锁是指，**线程自旋的次数不再是固定的值，而是一个动态改变的值，这个值会根据前一次自旋获取锁的状态来决定此次自旋的次数**。比如上一次通过自旋成功获取到了锁，那么这次通过自旋也有可能会获取到锁，所以这次自旋的次数就会增多一些，而如果上一次通过自旋没有成功获取到锁，那么这次自旋可能也获取不到锁，所以为了避免资源的浪费，就会少循环或者不循环，以提高程序的执行效率。简单来说，**如果线程自旋成功了，则下次自旋的次数会增多，如果失败，下次自旋的次数会减少。**

总结

本文我们介绍了 4 种优化 synchronized 的方案，其中锁膨胀和自适应自旋锁是 synchronized 关键字自身的优化实现，而锁消除和锁粗化是 JVM 虚拟机对 synchronized 提供的优化方案，这些优化方案最终使得 synchronized 的性能得到了大幅的提升，也让它在并发编程中占据了一席之地。



# ReentrantLock(可重入锁)

[ReentrantLock 中的 4 个坑！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247497141&idx=1&sn=5b1a86743eace289cd4a7a197e5f6b6e&chksm=fbcf988dccb8119b7b1415454cfe9cadaddc80cec7dccca2b0b51484795da298db0932bb97f0&scene=178&cur_album_id=1856147161684475909#rd)

JDK 1.5 之前 synchronized 的性能是比较低的，但在 JDK 1.5 中，官方推出一个重量级功能 Lock，一举改变了 Java 中锁的格局。JDK 1.5 之前当我们谈到锁时，只能使用内置锁 synchronized，但如今我们锁的实现又多了一种显式锁 Lock。

## Lock 简介

Lock 是一个顶级接口，它的所有方法如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151608236.png" alt="image-20220515160805150" style="zoom: 50%;" />

它的子类列表如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151608646.png" alt="image-20220515160826555" style="zoom:67%;" />

**我们通常会使用 ReentrantLock 来定义其实例**，它们之间的关联如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151608704.png" alt="image-20220515160852632" style="zoom:67%;" />

> PS：Sync 是同步锁的意思，FairSync 是公平锁，NonfairSync 是非公平锁。

## 注意事项

本文介绍了 Java 中的显式锁 Lock 及其子类 ReentrantLock 的使用和注意事项，Lock 在 Java 中占据了锁的半壁江山，但在使用时却要注意 4 个问题：

> 1. `默认情况下 ReentrantLock 为非公平锁而非公平锁；`
> 2. `加锁次数和释放锁次数一定要保持一致，否则会导致线程阻塞或程序异常；`
> 3. `加锁操作一定要放在 try 代码之前，这样可以避免未加锁成功又释放锁的异常；`
> 4. `释放锁一定要放在 finally 中，否则会导致线程阻塞`





## ReentrantLock 使用

学习任何一项技能都是先从使用开始的，所以我们也不例外，咱们先来看下 ReentrantLock 的基础使用：

```java
public class LockExample {
    // 创建锁对象
    privatefinal ReentrantLock lock = new ReentrantLock();
    public void method() {
        // 加锁操作
        lock.lock();
        try {
            // 业务代码......
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

ReentrantLock 在创建之后，有两个关键性的操作：

- 加锁操作：lock()
- 释放锁操作：unlock()

## ReentrantLock 重点操作

### 1.ReentrantLock 默认为非公平锁

> 很多人会认为（尤其是新手朋友），ReentrantLock 默认的实现是公平锁，其实并非如此，ReentrantLock 默认情况下为非公平锁（这主要是出于性能方面的考虑），比如下面这段代码：
>

```java
// 创建锁对象
private static final ReentrantLock lock = new ReentrantLock();
// 创建线程池
private static final ExecutorService executor = Executors.newFixedThreadPool(3);

public static void t1() {
    for (int i = 0; i < 6; i++) {
        executor.submit(() -> {
            // 加锁
            lock.lock();
            try {
                // 打印执行线程的名字
                System.out.println("线程:" + Thread.currentThread().getName());
            } finally {
                // 释放锁
                lock.unlock();
                // 释放线程池
                executor.shutdown();
            }
        });
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151615544.png" alt="image-20220515161513435" style="zoom:67%;" />

从上述执行的结果可以看出，`ReentrantLock 默认情况下为非公平锁。因为线程的名称是根据创建的先后顺序递增的，所以如果是公平锁，那么线程的执行应该是有序递增的`，但从上述的结果可以看出，线程的执行和打印是无序的，这说明 ReentrantLock 默认情况下为非公平锁。

> 想要将 ReentrantLock 设置为公平锁也很简单，只需要在创建 ReentrantLock 时，设置一个 true 的构造参数就可以了，如下代码所示：
>

```java
private static final ReentrantLock lock = new ReentrantLock(true);
```

> 从上述结果可以看出，当我们显式的给 ReentrantLock 设置了 true 的构造参数之后，ReentrantLock 就变成了公平锁，线程获取锁的顺序也变成有序的了。
>

其实从 ReentrantLock 的源码我们也可以看出它究竟是公平锁还是非公平锁，ReentrantLock 部分源码实现如下：

```java
public ReentrantLock() {
     sync = new NonfairSync();
 }
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

从上述源码中可以看出，默认情况下 ReentrantLock 会创建一个非公平锁，如果在创建时显式的设置构造参数的值为 true 时，它就会创建一个公平锁。



### 2.在 finally 中释放锁

**使用 ReentrantLock 时一定要记得释放锁，否则就会导致该锁一直被占用，其他使用该锁的线程则会永久的等待下去**，所以我们在使用 ReentrantLock 时，一定要在 finally 中释放锁，这样就可以保证锁一定会被释放。

#### 反例

```java
import java.util.concurrent.locks.ReentrantLock;

public class LockExample {
    // 创建锁对象
    private static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        // 加锁操作
        lock.lock();
        System.out.println("Hello,ReentrantLock.");
        // 此处会报异常,导致锁不能正常释放
        int number = 1 / 0;
        // 释放锁
        lock.unlock();
        System.out.println("锁释放成功!");
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151620036.png" alt="image-20220515162026950" style="zoom:80%;" />

从上述结果可以看出，`当出现异常时锁未被正常释放，这样就会导致其他使用该锁的线程永久的处于等待状态`。

#### 正例

```java
import java.util.concurrent.locks.ReentrantLock;

publicclass LockExample {
    // 创建锁对象
    privatestaticfinal ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        // 加锁操作
        lock.lock();
        try {
            System.out.println("Hello,ReentrantLock.");
            // 此处会报异常
            int number = 1 / 0;
        } finally {
            // 释放锁
            lock.unlock();
            System.out.println("锁释放成功!");
        }
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151621503.png" alt="image-20220515162106400" style="zoom:80%;" />

从上述结果可以看出，虽然方法中出现了异常情况，但并不影响 ReentrantLock 锁的释放操作，这样其他使用此锁的线程就可以正常获取并运行了。

### 3.锁不能被释放多次

`lock 操作的次数和 unlock 操作的次数必须一一对应，且不能出现一个锁被释放多次的情况`，因为这样就会导致程序报错。

#### 反例

一次 lock 对应了两次 unlock 操作，导致程序报错并终止执行，示例代码如下：

```java
import java.util.concurrent.locks.ReentrantLock;

publicclass LockExample {
    // 创建锁对象
    privatestaticfinal ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        // 加锁操作
        lock.lock();
        
        // 第一次释放锁
        try {
            System.out.println("执行业务 1~");
            // 业务代码 1......
        } finally {
            // 释放锁
            lock.unlock();
            System.out.println("锁释锁");
        }

        // 第二次释放锁
        try {
            System.out.println("执行业务 2~");
            // 业务代码 2......
        } finally {
            // 释放锁
            lock.unlock();
            System.out.println("锁释锁");
        }
        // 最后的打印操作
        System.out.println("程序执行完成.");
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151621751.png" alt="image-20220515162136665" style="zoom:80%;" />

> 从上述结果可以看出，执行第 2 个 unlock 时，程序报错并终止执行了，导致异常之后的代码都未正常执行。
>

### 4.lock 不要放在 try 代码内

> 在使用 ReentrantLock 时，需要注意不要将加锁操作放在 try 代码中，这样会导致未加锁成功就执行了释放锁的操作，从而导致程序执行异常。
>

#### 反例

```java
public class LockExample {
    // 创建锁对象
    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        try {
            // 此处异常
            int num = 1 / 0;
            // 加锁操作
            lock.lock();
        } finally {
            // 释放锁
            lock.unlock();
            System.out.println("锁释锁");
        }
        System.out.println("程序执行完成.");
    }
}
```

以上程序的执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151622632.png" alt="image-20220515162212546" style="zoom:80%;" />

从上述结果可以看出，如果将加锁操作放在 try 代码中，可能会导致两个问题：

1. 未加锁成功就执行了释放锁的操作，从而导致了新的异常；
2. 释放锁的异常会覆盖程序原有的异常，从而增加了排查问题的难度。

# 为什么非公平锁的性能更高？

在 Java 中 synchronized 和 ReentrantLock 默认使用的都是非公平锁，而它们采用非公平锁的原因都是一致的，都是为了提升程序的性能。那为什么非公平锁就能提升性能呢？接下来我们一起来看。

## 非公平锁

非公平锁：每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，任何线程在某时刻都有可能直接获取并拥有锁。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207021855218.png" alt="image-20220702185528110" style="zoom:50%;" />

这就好比磊哥去加油，到了加油站之后发现前面有人在加，于是我就在车里刷起了抖音，过了一会，前面的车加完油走了，但磊哥没注意到，还在车里愉快的刷着抖音。然而此时加油站又来了一辆车，发现有空闲的油枪，于是就抢先在磊哥之前把油加了。这里的油枪就是锁，没有按照到达的先后顺序得到油枪，这就是非公平锁。



## 公平锁

公平锁：每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207022120296.png" alt="image-20220702212025180" style="zoom:50%;" />

这就好像上高速排队过收费站一样，所有的车要排队等待通行，最先来的车最先通过收费站。



## 性能对比

公平锁和非公平锁的性能测试结果如下，以下测试数据来自于《Java并发编程实战》：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207022120479.png" alt="image-20220702212055386" style="zoom:50%;" />

从上述结果可以看出，使用非公平锁的吞吐率（单位时间内成功获取锁的平均速率）要比公平锁高很多。

## 性能分析

以上测试数据虽然说明了结果，但并不能说明为什么非公平锁的性能会更高？所以，接下来，我们通过分析公平锁和非公平的执行流程，来得到这个问题的答案。

### **公平锁执行流程**

获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。

#### 用户态 & 内核态

用户态（User Mode）：当进程在执行用户自己的代码时，则称其处于用户运行态。内核态（Kernel Mode）：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态，此时处理器处于特权级最高的内核代码中执行。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207022121397.png" alt="image-20220702212117195" style="zoom:50%;" />

##### 为什么分内核态和用户态？

假设没有内核态和用户态之分，程序就可以随意读写硬件资源了，比如随意读写和分配内存，这样如果程序员一不小心将不适当的内容写到了不该写的地方，很可能就会导致系统崩溃。

而有了用户态和内核态的区分之后，程序在执行某个操作时会进行一系列的验证和检验之后，确认没问题之后才可以正常的操作资源，这样就不会担心一不小心就把系统搞坏的情况了，也就是**有了内核态和用户态的区分之后可以让程序更加安全的运行，但同时两种形态的切换会导致一定的性能开销。**

### 非公平锁执行流程

当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。

比如前几天磊哥去一个小营业厅办理网络移机的业务，去了之后发现前面有人在办业务，于是磊哥就告诉前面（办理业务）的小姐姐，“我门口休息一下，您等会办理完业务，麻烦去门口叫一下我”，小姐姐人也比较好，一口就答应下来了。

但在小姐姐办完业务之后叫我，和我回到柜台办理业务之间，是有一段空闲时间的，这和等待队列中的线程被唤醒和恢复执行之间是有一段空闲时间是一样的，而在这个空闲的时间中，营业厅又来了一个老李头来交话费，等老李交完话费，我恰好也刚回来可以直接办理业务了，这样就是一个“三赢”的局面。

老李头不用排在我后面等着缴话费，我也不用等老李头交完话费再办理移机，而且在单位时间内提高了营业员办理业务的效率，她也能早早的回家，这就是所谓的“三赢”。**在更短的时间内执行更多的任务，这就是非公平锁的优势**。



## 总结

本文我们介绍了公平锁和非公平锁的定义以及执行流程，从二者执行流程的细节可以看出，非公平锁因为不用按（顺）序执行，所以后来的锁也可以直接尝试获得锁，没有了阻塞和恢复执行的步骤，所以它的性能会更高。



# synchronized和ReentrantLock区别

[synchronized和ReentrantLock的5个区别！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247501078&idx=1&sn=ef12b96e907eb7a6d13ff794709f327b&chksm=fbcfa82eccb82138d6d04a0fe0e0c18d03d1373f5a6c3b8212a1cd331760b4278b0f6fa5ef3b&mpshare=1&scene=23&srcid=0518IKaKhU2xISNnX1yx2vfk&sharer_sharetime=1652869726190&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 区别1：用法不同

**synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。**

### synchronized 基础使用

使用 synchronized 修饰代码块：

```java
public void method() {
    // 加锁代码
    synchronized (this) {
        // ...
    }
}
```

### ReentrantLock 基础使用

ReentrantLock 在使用之前需要先创建 ReentrantLock 对象，然后使用 lock 方法进行加锁，使用完之后再调用 unlock 方法释放锁，具体使用如下：

```java
public class LockExample {
    // 创建锁对象
    private final ReentrantLock lock = new ReentrantLock();
    public void method() {
        // 加锁操作
        lock.lock();
        try {
            // ...
        } finally {
            // 释放锁
            lock.unlock();
        }
    }
}
```

## 区别2：获取锁和释放锁方式不同

**synchronized 会自动加锁和释放锁**，`当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁`，如下图所示：

```java
public void t1() {
    int count = 0;
    // 自动加锁
    synchronized (this) {
        count++;
    // 自动释放锁
    }
    System.out.println(count);
}
```

**而 ReentrantLock 需要手动加锁和释放锁**，如下图所示：

```java
public static void t1() {
    int count = 0;
    // 加锁
    lock.lock();
    try {
        count++;
    } finally {
        // 解锁
        lock.unlock();
    }
    System.out.println(count);
}
```

> PS：在使用 ReentrantLock 时要特别小心，unlock 释放锁的操作一定要放在 finally 中，否者有可能会出现锁一直被占用，从而导致其他线程一直阻塞的问题。

## 区别3：锁类型不同

**synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。**默认情况下 ReentrantLock 为非公平锁，这点查看源码可知：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205182207145.png" alt="image-20220518220706070" style="zoom:80%;" />

使用 new ReentrantLock(true) 可以创建公平锁，查看源码可知：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205182207384.png" alt="image-20220518220721320" style="zoom:80%;" />



## 区别4：响应中断不同

**ReentrantLock 可以使用 lockInterruptibly 获取锁并响应中断指令，而 synchronized 不能响应中断，也就是如果发生了死锁，使用 synchronized 会一直等待下去，而使用 ReentrantLock 可以响应中断并释放锁，从而解决死锁的问题**，比如以下 ReentrantLock 响应中断的示例：

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockInterrupt {
    static Lock lockA = new ReentrantLock();
    static Lock lockB = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {
        // 线程 1：先获取 lockA 再获取 lockB
        Thread t1 = new Thread(() -> {
            try {
                // 先获取 LockA
                lockA.lockInterruptibly();
                // 休眠 10 毫秒
                TimeUnit.MILLISECONDS.sleep(100);
                // 获取 LockB
                lockB.lockInterruptibly();
            } catch (InterruptedException e) {
                System.out.println("响应中断指令");
            } finally {
                // 释放锁
                lockA.unlock();
                lockB.unlock();
                System.out.println("线程 1 执行完成。");
            }
        });
        // 线程 2：先获取 lockB 再获取 lockA
        Thread t2 = new Thread(() -> {
            try {
                // 先获取 LockB
                lockB.lockInterruptibly();
                // 休眠 10 毫秒
                TimeUnit.MILLISECONDS.sleep(100);
                // 获取 LockA
                lockA.lockInterruptibly();
            } catch (InterruptedException e) {
                System.out.println("响应中断指令");
            } finally {
                // 释放锁
                lockB.unlock();
                lockA.unlock();
                System.out.println("线程 2 执行完成。");
            }
        });
        t1.start();
        t2.start();
        TimeUnit.SECONDS.sleep(1);
        // 线程1：执行中断
        t1.interrupt();
    }
}
```

以上程序的执行结果如下所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205182207540.png" alt="image-20220518220751466" style="zoom:80%;" />



## 区别5：底层实现不同

**synchronized 是 JVM 层面通过监视器（Monitor）实现的，而 ReentrantLock 是通过 AQS（AbstractQueuedSynchronizer）程序级别的 API 实现。**synchronized 通过监视器实现，可通过观察编译后的字节码得出结论，如下图所示：其中 monitorenter 表示进入监视器，相当于加锁操作，而 monitorexit 表示退出监视器，相当于释放锁的操作。ReentrantLock 是通过 AQS 实现，可通过观察 ReentrantLock 的源码得出结论



## 小结

synchronized 和 ReentrantLock 都是 Java 中提供的可重入锁，二者的主要区别有以下 5 个：

> 1. 用法不同：synchronized 可以用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用于代码块。
> 2. 获取锁和释放锁的机制不同：synchronized 是自动加锁和释放锁的，而 ReentrantLock 需要手动加锁和释放锁。
> 3. 锁类型不同：synchronized 是非公平锁，而 ReentrantLock 默认为非公平锁，也可以手动指定为公平锁。
> 4. 响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。
> 5. 底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。

# Atomic 原子类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212061007648.png" alt="image-20221206100704454" style="zoom:50%;" />

## LongAccumulator

> LongAccumulator 可以理解为 LongAdder 的增强版，它的功能要比 LongAdder 要更强大，或者说，LongAdder 只是 LongAccumulator 的一个实现而已。

> 比如：LongAdder 只能进行数字的简单加减（只能是 1），而 LongAccumulator 提供了自定义的函数式接口，可以根据规则进行累加，不管是加减多少，或者是乘除多少，或者取最大值，想怎么弄，规则自己定。

### 实战测试

#### 1、实现 LongAdder

首先，栈长用 LongAccumulator 来实现 LongAdder 同样的功能。

**定义一个累加规则的 LongAccumulator：**

```java
private static LongAccumulator longAccumulatorAdd = 
               new LongAccumulator((left, right) -> left + right, 0);
```

这里使用了 Lambda 表达式，这也是 Java 8 引进的新语法，不懂的可以关注公众号：Java技术栈，看我之前写的系列 Java 8+ 教程，菜单栏中都整理好了，这里就不展开介绍了。

**使用 LongAccumulator 进行累加：**

```java
private static void add(LongAccumulator longAccumulator, long number) throws InterruptedException {
    long start = System.currentTimeMillis();
    ExecutorService es = Executors.newFixedThreadPool(MAX_POOL_SIZE);
    for (int i = 0; i < MAX_POOL_SIZE; i++) {
        es.execute(() -> {
            for (int j = 0; j < MAX_LOOP_SIZE; j++) {
                longAccumulator.accumulate(number);
            }
        });
    }
    es.shutdown();
    es.awaitTermination(5, TimeUnit.MINUTES);
    System.out.printf("LongAccumulator %s*%s +%s 结果：%s，耗时：%sms.\n",
            MAX_POOL_SIZE,
            MAX_LOOP_SIZE,
            number,
            longAccumulator.get(),
            (System.currentTimeMillis() - start));
    longAccumulator.reset();
}
```

**测试一下：**

```java
/**
 * @author: 栈长
 * @from: 公众号Java技术栈
 */
public static void main(String[] args) throws InterruptedException {
	// 和 LongAdder 一致
    add(longAccumulatorAdd, 1);
    
    // 每次累加2
    add(longAccumulatorAdd, 2);
}
```

第一次调用方法实现了和 LongAdder 一样的功能，第二次调用方法是每次累加 2，这个是 LongAdder 所办不到的。

**输出结果：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212061016559.png" alt="image-20221206101614463" style="zoom:80%;" />

一个很奇怪的现象是，为什么累加 2 还要更快？？

#### 2、实现求最大值

这次实现一个自定义规则的运算，求所有值的最大值。

**定义一个取最大值规则的 LongAccumulator：**

```java
private static LongAccumulator longAccumulatorMax = new LongAccumulator(Long::max, 50);
```

这里使用了方法引用，这也是 Java 8 引进的新语法，不懂的可以关注公众号：Java技术栈，看我之前写的系列 Java 8+ 教程，菜单栏中都整理好了，这里就不展开介绍了。

**使用 LongAccumulator 进行取最大值：**

```java
private static void max(LongAccumulator longAccumulator) throws InterruptedException {
    int MAX_POOL_SIZE = 10;
    long start = System.currentTimeMillis();
    ExecutorService es = Executors.newFixedThreadPool(MAX_POOL_SIZE);
    for (int i = 0; i < MAX_POOL_SIZE; i++) {
        int finalI = i;
        es.execute(() -> {
            longAccumulator.accumulate(finalI * 10);
        });
    }
    es.shutdown();
    es.awaitTermination(5, TimeUnit.MINUTES);
    System.out.printf("LongAccumulator 求最大值结果：%s，耗时：%sms.\n",
            longAccumulator.get(),
            (System.currentTimeMillis() - start));
    longAccumulator.reset();
}
```

**测试一下：**

```java
/**
 * @author: 栈长
 * @from: 公众号Java技术栈
 */
public static void main(String[] args) throws InterruptedException {
    // 和 LongAdder 一致
    add(longAccumulatorAdd, 1);

    // 每次累加2
    add(longAccumulatorAdd, 2);

    // 求最大值
    max(longAccumulatorMax);
}
```

初始值为 50，循环中的最大值应该是 9 * 10 = 90，来看下测试结果：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212061021220.png" alt="image-20221206102140125" style="zoom:80%;" />

没毛病，结果输出正常。

当然，求最大值远远不会用到这个类，这里只是演示下这个自定义规则而已，你可以求乘积，更复杂的判断运算等其他自定义规则的运算，有了自定义规则，那它所能实现的功能远比 LongAdder 要强大，并且其性能也是旗鼓相当的。

### 总结

> 好了，总结下，LongAccumulator 有一个初始值，并且提供了一个自定义规则的函数式接口参数，功能要比 LongAdder 更强大，可以理解为 LongAdder 是 LongAccumulator 的一个实现，或者是 LongAccumulator 是 LongAdder 的增加版。

**一句话总结就是：**

> 简单递增、递减 1 用 LongAdder 就够了，复杂的累积运算用 LongAccumulator。
>
> 所以，怎么解决 count++ 的线程安全性问题？还有没有其他方案？

**栈长最终总结下：**

> - 累加方法加 synchronized/ Lock 同步锁；
> - 使用 AtomicInteger/ AtomicLong 原子类；
> - **使用 LongAdder 原子类（推荐使用）；**
> - **使用 LongAccumulator 原子类（推荐使用）；**

本文实战源代码完整版已经上传：

> https://github.com/javastacks/javastack



# 读写锁

> 读写锁（Readers-Writer Lock）顾名思义是一把锁分为两部分：读锁和写锁，其中读锁允许多个线程同时获得，因为读操作本身是线程安全的，而写锁则是互斥锁，不允许多个线程同时获得写锁，并且写操作和读操作也是互斥的。总结来说，读写锁的特点是：`读读不互斥、读写互斥、写写互斥`

## 1.读写锁使用

在 Java 语言中，读写锁是使用 ReentrantReadWriteLock 类来实现的，其中：

> - ReentrantReadWriteLock.ReadLock 表示读锁，它提供了 lock 方法进行加锁、unlock 方法进行解锁。
> - ReentrantReadWriteLock.WriteLock 表示写锁，它提供了 lock 方法进行加锁、unlock 方法进行解锁。

它的基础使用如下代码所示：

```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 获得读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
// 获得写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
```

```java
// 读锁使用
readLock.lock();
try {
    // 业务代码...
} finally {
    readLock.unlock();
}
```

```java
// 写锁使用
writeLock.lock();
try {
    // 业务代码...
} finally {
    writeLock.unlock();
}
```



### 1.1 读读不互斥

多个线程可以同时获取到读锁，称之为读读不互斥，如下代码所示：

```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
// 创建一个线程
Thread t1 = new Thread(() -> {
    readLock.lock();
    try {
        System.out.println("[t1]得到读锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t1]释放读锁.");
        readLock.unlock();
    }
});
t1.start();
// 创建一个线程
Thread t2 = new Thread(() -> {
    readLock.lock();
    try {
        System.out.println("[t2]得到读锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t2]释放读锁.");
        readLock.unlock();
    }
});
t2.start();
```

以上程序执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291834526.png" alt="image-20220629183440456" style="zoom:67%;" />

### 1.2 读写互斥

读锁和写锁同时使用是互斥的（也就是不能同时获得），这称之为读写互斥，如下代码所示：

```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建读锁
final ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();
// 创建写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
// 使用读锁
Thread t1 = new Thread(() -> {
    readLock.lock();
    try {
        System.out.println("[t1]得到读锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t1]释放读锁.");
        readLock.unlock();
    }
});
t1.start();
// 使用写锁
Thread t2 = new Thread(() -> {
    writeLock.lock();
    try {
        System.out.println("[t2]得到写锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t2]释放写锁.");
        writeLock.unlock();
    }
});
t2.start();
```

以上程序执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291834130.png" alt="image-20220629183455069" style="zoom:67%;" />

### 1.3 写写互斥

多个线程同时使用写锁也是互斥的，这称之为写写互斥，如下代码所示：

```java
// 创建读写锁
final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建写锁
final ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();
Thread t1 = new Thread(() -> {
    writeLock.lock();
    try {
        System.out.println("[t1]得到写锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t1]释放写锁.");
        writeLock.unlock();
    }
});
t1.start();

Thread t2 = new Thread(() -> {
    writeLock.lock();
    try {
        System.out.println("[t2]得到写锁.");
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println("[t2]释放写锁.");
        writeLock.unlock();
    }
});
t2.start();
```

以上程序执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.23/202206291835562.png" alt="image-20220629183527495" style="zoom:67%;" />

## 2.优点分析

1. 提高了程序执行性能：多个读锁可以同时执行，相比于普通锁在任何情况下都要排队执行来说，读写锁提高了程序的执行性能。
2. 避免读到临时数据：读锁和写锁是互斥排队执行的，这样可以保证了读取操作不会读到写了一半的临时数据。

## 3.适用场景

读写锁适合多读少写的业务场景，此时读写锁的优势最大。

## 总结

读写锁是一把锁分为两部分：读锁和写锁，其中读锁允许多个线程同时获得，而写锁则是互斥锁。它的完整规则是：读读不互斥、读写互斥、写写互斥。它适用于多读的业务场景，使用它可以有效的提高程序的执行性能，也能避免读取到操作了一半的临时数据。





# 多线程顺序打印

第一篇打算总结下阿里最喜欢问的多个线程顺序打印问题，我遇到的是机试，直接写出运行。同类型的题目有很多，比如：

1. 三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串
2. 两个线程交替打印 0~100 的奇偶数
3. 通过 N 个线程顺序循环打印从 0 至 100
4. 多线程按顺序调用，A->B->C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次
5. 用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D...169

其实这类题目考察的都是线程间的通信问题，基于这类题目，做一个整理，方便日后手撕面试官，文明的打工人，手撕面试题。

## 1.使用锁

我们以第一题为例：三个线程分别打印 A，B，C，要求这三个线程一起运行，打印 n 次，输出形如“ABCABCABC....”的字符串。

思路：使用一个取模的判断逻辑 C%M ==N，题为 3 个线程，所以可以按取模结果编号：0、1、2，他们与 3 取模结果仍为本身，则执行打印逻辑。

```java
public class PrintABCUsingLock {

    private int times; // 控制打印次数
    private int state;   // 当前状态值：保证三个线程之间交替打印
    private Lock lock = new ReentrantLock();

    public PrintABCUsingLock(int times) {
        this.times = times;
    }

    private void printLetter(String name, int targetNum) {
        for (int i = 0; i < times; ) {
            lock.lock();
            if (state % 3 == targetNum) {
                state++;
                i++;
                System.out.print(name);
            }
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        PrintABCUsingLock loopThread = new PrintABCUsingLock(1);

        new Thread(() -> {
            loopThread.printLetter("B", 1);
        }, "B").start();
        
        new Thread(() -> {
            loopThread.printLetter("A", 0);
        }, "A").start();
        
        new Thread(() -> {
            loopThread.printLetter("C", 2);
        }, "C").start();
    }
}
```

main 方法启动后，3 个线程会抢锁，但是 state 的初始值为 0，所以第一次执行 if 语句的内容只能是 线程 A，然后还在 for 循环之内，此时 ，只有 线程 B 才满足 ，所以第二个执行的是 B，同理只有 线程 C 才满足 ，所以第三个执行的是 C，执行完 ABC 之后，才去执行第二次 for 循环，所以要把 i++ 写在 for 循环里边，不能写成 这样。`state = 1``1% 3 == 1``2% 3 == 2``for (int i = 0; i < times;i++)`

## 2.使用等待/通知

其实遇到这类型题目，好多同学可能会先想到的就是 join（），或者 wati/notify 这样的思路。算是比较传统且万能的解决方案。也有些面试官会要求不能使用这种方式。

思路：还是以第一题为例，我们用对象监视器来实现，通过 和 方法来实现等待、通知的逻辑，A 执行后，唤醒 B，B 执行后唤醒 C，C 执行后再唤醒 A，这样循环的等待、唤醒来达到目的。`wait``notify()`

```java
public class PrintABCUsingWaitNotify {

    private int state;
    private int times;
    private static final Object LOCK = new Object();

    public PrintABCUsingWaitNotify(int times) {
        this.times = times;
    }

    public static void main(String[] args) {
        PrintABCUsingWaitNotify printABC = new PrintABCUsingWaitNotify(10);
        new Thread(() -> {
            printABC.printLetter("A", 0);
        }, "A").start();
        new Thread(() -> {
            printABC.printLetter("B", 1);
        }, "B").start();
        new Thread(() -> {
            printABC.printLetter("C", 2);
        }, "C").start();
    }

    private void printLetter(String name, int targetState) {
        for (int i = 0; i < times; i++) {
            synchronized (LOCK) {
                while (state % 3 != targetState) {
                    try {
                        LOCK.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                state++;
                System.out.print(name);
                LOCK.notifyAll();
            }
        }
    }
}
```

同样的思路，来解决下第 2 题：两个线程交替打印奇数和偶数

使用对象监视器实现，两个线程 A、B 竞争同一把锁，只要其中一个线程获取锁成功，就打印 ++i，并通知另一线程从等待集合中释放，然后自身线程加入等待集合并释放锁即可。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101037570.png" alt="image-20220710103702473" style="zoom:50%;" />

```java
public class OddEvenPrinter {

    private Object monitor = new Object();
    private final int limit;
    private volatile int count;

    OddEvenPrinter(int initCount, int times) {
        this.count = initCount;
        this.limit = times;
    }

    public static void main(String[] args) {

        OddEvenPrinter printer = new OddEvenPrinter(0, 10);
        new Thread(printer::print, "odd").start();
        new Thread(printer::print, "even").start();
    }

    private void print() {
        synchronized (monitor) {
            while (count < limit) {
                try {
                    System.out.println(String.format("线程[%s]打印数字:%d", 
                                                     Thread.currentThread().getName(), 
                                                     ++count));
                    monitor.notifyAll();
                    monitor.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //防止有子线程被阻塞未被唤醒，导致主线程不退出
            monitor.notifyAll();
        }
    }
}
```

同样的思路，来解决下第 5 题：用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D...169

```java
public class NumAndLetterPrinter {
    private static char c = 'A';
    private static int i = 0;
    static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> printer(), "numThread").start();
        new Thread(() -> printer(), "letterThread").start();
    }

    private static void printer() {
        synchronized (lock) {
            for (int i = 0; i < 26; i++) {
                if (Thread.currentThread().getName() == "numThread") {
                    //打印数字1-26
                    System.out.print((i + 1));
                    // 唤醒其他在等待的线程
                    lock.notifyAll();
                    try {
                        // 让当前线程释放锁资源，进入wait状态
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else if (Thread.currentThread().getName() == "letterThread") {
                    // 打印字母A-Z
                    System.out.print((char) ('A' + i));
                    // 唤醒其他在等待的线程
                    lock.notifyAll();
                    try {
                        // 让当前线程释放锁资源，进入wait状态
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
            lock.notifyAll();
        }
    }
}
```

## 3.使用锁/条件

还是以第一题为例，使用 Condition 来实现，其实和 wait/notify 的思路一样。

> Condition 中的 方法相当于 Object 的 方法，Condition 中的 方法相当于Object 的 方法，Condition 中的 相当于 Object 的 方法。`await()``wait()``signal()``notify()``signalAll()``notifyAll()`
>
> 不同的是，Object 中的 方法是和（synchronized关键字）捆绑使用的;而 Condition 是需要与捆绑使用的。`wait(),notify(),notifyAll()``"同步锁"``"互斥锁"/"共享锁"`

```java
public class PrintABCUsingLockCondition {

    private int times;
    private int state;
    private static Lock lock = new ReentrantLock();
    private static Condition c1 = lock.newCondition();
    private static Condition c2 = lock.newCondition();
    private static Condition c3 = lock.newCondition();

    public PrintABCUsingLockCondition(int times) {
        this.times = times;
    }

    public static void main(String[] args) {
        PrintABCUsingLockCondition print = new PrintABCUsingLockCondition(10);
        new Thread(() -> {
            print.printLetter("A", 0, c1, c2);
        }, "A").start();
        new Thread(() -> {
            print.printLetter("B", 1, c2, c3);
        }, "B").start();
        new Thread(() -> {
            print.printLetter("C", 2, c3, c1);
        }, "C").start();
    }

    private void printLetter(String name, int targetState, Condition current, Condition next) {
        for (int i = 0; i < times; ) {
            lock.lock();
            try {
                while (state % 3 != targetState) {
                    current.await();
                }
                state++;
                i++;
                System.out.print(name);
                next.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}
```

使用 Lock 锁的多个条件 可以实现精准唤醒，所以碰到那种多个线程交替打印不同次数的题就比较容易想到，比如解决第四题：多线程按顺序调用，A->B->C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次

代码就不贴了，思路相同。

> 以上几种方式，其实都会存在一个锁的抢夺过程，如果抢锁的的线程数量足够大，就会出现很多线程抢到了锁但不该自己执行，然后就又解锁或 wait() 这种操作，这样其实是有些浪费资源的。

## 4.使用信号量

> 在信号量上我们定义两种操作：信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。
>
> 1. acquire（获取） 当一个线程调用 acquire 操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。
> 2. release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。

先看下如何解决第一题：三个线程循环打印

```java
public class PrintABCUsingSemaphore {
    private int times;
    private static Semaphore semaphoreA = new Semaphore(1); // 只有A 初始信号量为1,第一次获取到的只能是A
    private static Semaphore semaphoreB = new Semaphore(0);
    private static Semaphore semaphoreC = new Semaphore(0);

    public PrintABCUsingSemaphore(int times) {
        this.times = times;
    }

    public static void main(String[] args) {
        PrintABCUsingSemaphore printer = new PrintABCUsingSemaphore(1);
        new Thread(() -> {
            printer.print("A", semaphoreA, semaphoreB);
        }, "A").start();

        new Thread(() -> {
            printer.print("B", semaphoreB, semaphoreC);
        }, "B").start();

        new Thread(() -> {
            printer.print("C", semaphoreC, semaphoreA);
        }, "C").start();
    }

    private void print(String name, Semaphore current, Semaphore next) {
        for (int i = 0; i < times; i++) {
            try {
                System.out.println("111" + Thread.currentThread().getName());
                current.acquire();  // A获取信号执行,A信号量减1,当A为0时将无法继续获得该信号量
                System.out.print(name);
                next.release();    // B释放信号，B信号量加1（初始为0），此时可以获取B信号量
                System.out.println("222" + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

如果题目中是多个线程循环打印的话，一般使用信号量解决是效率较高的方案，上一个线程持有下一个线程的信号量，通过一个信号量数组将全部关联起来，这种方式不会存在浪费资源的情况。

接着用信号量的方式解决下第三题：通过 N 个线程顺序循环打印从 0 至 100

```java
public class LoopPrinter {

    private final static int THREAD_COUNT = 3;
    static int result = 0;
    static int maxNum = 10;

    public static void main(String[] args) throws InterruptedException {
        final Semaphore[] semaphores = new Semaphore[THREAD_COUNT];
        for (int i = 0; i < THREAD_COUNT; i++) {
            //非公平信号量，每个信号量初始计数都为1
            semaphores[i] = new Semaphore(1);
            if (i != THREAD_COUNT - 1) {
                System.out.println(i+"==="+semaphores[i].getQueueLength());
                //获取一个许可前线程将一直阻塞, for 循环之后只有 syncObjects[2] 没有被阻塞
                semaphores[i].acquire();
            }
        }
        for (int i = 0; i < THREAD_COUNT; i++) {
            // 初次执行，上一个信号量是 syncObjects[2]
            final Semaphore lastSemphore = i == 0 ? semaphores[THREAD_COUNT - 1] : 
            semaphores[i - 1];
            final Semaphore currentSemphore = semaphores[i];
            final int index = i;
             new Thread(() -> {
                try {
                    while (true) {
                        // 初次执行，让第一个 for 循环没有阻塞的 syncObjects[2] 先获得令牌阻塞了
                        lastSemphore.acquire();
                        System.out.println("thread" + index + ": " + result++);
                        if (result > maxNum) {
                            System.exit(0);
                        }
                        // 释放当前的信号量，syncObjects[0] 信号量此时为 1，
                        // 下次 for 循环中上一个信号量即为syncObjects[0]
                        currentSemphore.release();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

## 5.使用锁支持

LockSupport 是 JDK 底层的基于 来实现的类，用来创建锁和其他同步工具类的基本线程阻塞原语。它的静态方法和可以分别实现阻塞当前线程和唤醒指定线程的效果，所以用它解决这样的问题会更容易一些。`sun.misc.Unsafe``unpark()``park()`

（在 AQS 中，就是通过调用 和 来实现线程的阻塞和唤醒的。）`LockSupport.park( )``LockSupport.unpark()`

```java
public class PrintABCUsingLockSupport {

    private static Thread threadA, threadB, threadC;

    public static void main(String[] args) {
        threadA = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                // 打印当前线程名称
                System.out.print(Thread.currentThread().getName());
                // 唤醒下一个线程
                LockSupport.unpark(threadB);
                // 当前线程阻塞
                LockSupport.park();
            }
        }, "A");
        threadB = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                // 先阻塞等待被唤醒
                LockSupport.park();
                System.out.print(Thread.currentThread().getName());
                // 唤醒下一个线程
                LockSupport.unpark(threadC);
            }
        }, "B");
        threadC = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                // 先阻塞等待被唤醒
                LockSupport.park();
                System.out.print(Thread.currentThread().getName());
                // 唤醒下一个线程
                LockSupport.unpark(threadA);
            }
        }, "C");
        threadA.start();
        threadB.start();
        threadC.start();
    }
}
```

理解了思路，解决其他问题就容易太多了。

比如，我们再解决下第五题：用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D...169

```java
public class NumAndLetterPrinter {

    private static Thread numThread, letterThread;

    public static void main(String[] args) {
        letterThread = new Thread(() -> {
            for (int i = 0; i < 26; i++) {
                System.out.print((char) ('A' + i));
                LockSupport.unpark(numThread);
                LockSupport.park();
            }
        }, "letterThread");

        numThread = new Thread(() -> {
            for (int i = 1; i <= 26; i++) {
                System.out.print(i);
                LockSupport.park();
                LockSupport.unpark(letterThread);
            }
        }, "numThread");
        numThread.start();
        letterThread.start();
    }
}
```



## 写在最后

好了，以上就是常用的五种实现方案，多练习几次，手撕没问题。

当然，这类问题，解决方式不止是我列出的这些，还会有 join、CountDownLatch、也有放在队列里解决的，思路有很多，面试官想考察的其实只是对多线程的编程功底，其实自己练习的时候，是个很好的巩固理解 JUC 的过程。



# Java中的5大队列

通过前面文章的学习《[一文详解「队列」，手撸队列的3种方法！](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247490542&idx=1&sn=3d04d030c29ec110ae775248b50a7b2d&scene=21#wechat_redirect)》我们知道了队列（Queue）是先进先出（FIFO）的，并且我们可以用数组、链表还有 List 的方式来实现自定义队列，那么本文我们来系统的学习一下官方是如何实现队列的。

Java 中的队列有很多，例如：`ArrayBlockingQueue`、`LinkedBlockingQueue`、`PriorityQueue`、`DelayQueue`、`SynchronousQueue` 等，那它们的作用是什么？又是如何分类的呢？

其实 Java 中的这些队列可以从不同的维度进行分类，例如可以从阻塞和非阻塞进行分类，也可以从有界和无界进行分类，而本文将从队列的功能上进行分类，例如：优先队列、普通队列、双端队列、延迟队列等。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101018070.png" alt="image-20220710101856963" style="zoom:50%;" />


虽然本文的重点是从功能上对队列进行解读，但其它分类也是 Java 中的重要概念，所以我们先来了解一下它们。

## 阻塞队列和非阻塞队列

阻塞队列（Blocking Queue）提供了可阻塞的 `put` 和 `take` 方法，它们与可定时的 `offer` 和 `poll` 是等价的。如果队列满了 `put` 方法会被阻塞等到有空间可用再将元素插入；如果队列是空的，那么 `take` 方法也会阻塞，直到有元素可用。当队列永远不会被充满时，`put` 方法和 `take` 方法就永远不会阻塞。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101019158.png" alt="image-20220710101917081" style="zoom:67%;" />
我们可以从队列的名称中知道此队列是否为阻塞队列，阻塞队列中包含 `BlockingQueue` 关键字，比如以下这些：

- ArrayBlockingQueue
- LinkedBlockingQueue
- PriorityBlockingQueue
- .......

### 阻塞队列功能演示

接下来我们来演示一下当阻塞队列的容量满了之后会怎样，示例代码如下：

```java
import java.util.Date;
import java.util.concurrent.ArrayBlockingQueue;

public class BlockingTest {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个长度为 5 的阻塞队列
        ArrayBlockingQueue q1 = new ArrayBlockingQueue(5);
        
        // 新创建一个线程执行入列
        new Thread(() -> {
            // 循环 10 次
            for (int i = 0; i < 10; i++) {
                try {
                    q1.put(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(new Date() + " | ArrayBlockingQueue Size:" + q1.size());
            }
            System.out.println(new Date() + " | For End.");
        }).start();

        // 新创建一个线程执行出列
        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    // 休眠 1S
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (!q1.isEmpty()) {
                    try {
                        q1.take(); // 出列
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
```

以上代码的执行结果如下：

> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:1
>
> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:2
>
> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:3
>
> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:4
>
> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:5
>
> Mon Oct 19 20:16:13 CST 2020 | ArrayBlockingQueue Size:5
>
> Mon Oct 19 20:16:14 CST 2020 | ArrayBlockingQueue Size:5
>
> Mon Oct 19 20:16:15 CST 2020 | ArrayBlockingQueue Size:5
>
> Mon Oct 19 20:16:16 CST 2020 | ArrayBlockingQueue Size:5
>
> Mon Oct 19 20:16:17 CST 2020 | ArrayBlockingQueue Size:5
>
> Mon Oct 19 20:16:17 CST 2020 | For End.

从上述结果可以看出，当 `ArrayBlockingQueue` 队列满了之后就会进入阻塞，当过了 1 秒有元素从队列中移除之后，才会将新的元素入列。

### 非阻塞队列

非阻塞队列也就是普通队列，它的名字中不会包含 `BlockingQueue` 关键字，并且它不会包含 `put` 和 `take` 方法，当队列满之后如果还有新元素入列会直接返回错误，并不会阻塞的等待着添加元素，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101020489.png" alt="image-20220710102000411" style="zoom:50%;" />

非阻塞队列的典型代表是 `ConcurrentLinkedQueue` 和 `PriorityQueue`。

## 有界队列和无界队列

**有界队列**：是指有固定大小的队列，比如设定了固定大小的 `ArrayBlockingQueue`，又或者大小为 0 的 `SynchronousQueue`。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101020364.png" alt="image-20220710102017288" style="zoom:67%;" />

**无界队列**：指的是没有设置固定大小的队列，但其实如果没有设置固定大小也是有默认值的，只不过默认值是 Integer.MAX_VALUE，当然实际的使用中不会有这么大的容量（超过 Integer.MAX_VALUE），所以从使用者的角度来看相当于 “无界”的。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101020493.png" alt="image-20220710102035421" style="zoom:67%;" />

##  按功能分类

接下来就是本文的重点了，我们以功能来划分一下队列，它可以被分为：普通队列、优先队列、双端队列、延迟队列、其他队列等，接下来我们分别来看。

### 1.普通队列

普通队列（Queue）是指实现了先进先出的基本队列，例如 `ArrayBlockingQueue` 和 `LinkedBlockingQueue`，其中 `ArrayBlockingQueue` 是用数组实现的普通队列，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101021666.png" alt="image-20220710102112588" style="zoom:50%;" />

而 `LinkedBlockingQueue` 是使用链表实现的普通队列，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101021711.png" alt="image-20220710102137638" style="zoom:67%;" />

####  常用方法

普通队列中的常用方法有以下这些：

- offer()：添加元素，如果队列已满直接返回 false，队列未满则直接插入并返回 true；
- poll()：删除并返回队头元素，当队列为空返回 null；
- add()：添加元素，此方法是对 offer 方法的简单封装，如果队列已满，抛出 IllegalStateException 异常；
- remove()：直接删除队头元素；
- put()：添加元素，如果队列已经满，则会阻塞等待插入；
- take()：删除并返回队头元素，当队列为空，则会阻塞等待；
- peek()：查询队头元素，但不会进行删除；
- element()：对 peek 方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出 NoSuchElementException 异常。

注意：**一般情况下 offer() 和 poll() 方法配合使用，put() 和 take() 阻塞方法配合使用，add() 和 remove() 方法会配合使用，程序中常用的是 offer() 和 poll() 方法，因此这两个方法比较友好，不会报错**。

接下来我们以 `LinkedBlockingQueue` 为例，演示一下普通队列的使用：

```java
import java.util.concurrent.LinkedBlockingQueue;

static class LinkedBlockingQueueTest {
    public static void main(String[] args) {
        LinkedBlockingQueue queue = new LinkedBlockingQueue();
        queue.offer("Hello");
        queue.offer("Java");
        queue.offer("中文社群");
        while (!queue.isEmpty()) {
            System.out.println(queue.poll());
        }
    }
}
```

以上代码的执行结果如下：

> Hello
>
> Java
>
> 中文社群

### 2.双端队列

双端队列（Deque）是指队列的头部和尾部都可以同时入队和出队的数据结构，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101022151.png" alt="image-20220710102221074" style="zoom:67%;" />

接下来我们来演示一下双端队列 `LinkedBlockingDeque` 的使用：

```java
import java.util.concurrent.LinkedBlockingDeque;

/**
  * 双端队列示例
  */
static class LinkedBlockingDequeTest {
    public static void main(String[] args) {
        // 创建一个双端队列
        LinkedBlockingDeque deque = new LinkedBlockingDeque();
        deque.offer("offer"); // 插入首个元素
        deque.offerFirst("offerFirst"); // 队头插入元素
        deque.offerLast("offerLast"); // 队尾插入元素
        while (!deque.isEmpty()) {
            // 从头遍历打印
            System.out.println(deque.poll());
        }
    }
}
```

以上代码的执行结果如下：

> offerFirst
>
> offer
>
> offerLast

### 3.优先队列

优先队列（PriorityQueue）是一种特殊的队列，它并不是先进先出的，而是优先级高的元素先出队。

优先队列是根据二叉堆实现的，二叉堆的数据结构如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101023194.png" alt="image-20220710102327113" style="zoom:50%;" />

二叉堆分为两种类型：一种是最大堆一种是最小堆。以上展示的是最大堆，**在最大堆中，任意一个父节点的值都大于等于它左右子节点的值。**

> 因为优先队列是基于二叉堆实现的，因此它可以将优先级最好的元素先出队。

接下来我们来演示一下优先队列的使用：

```java
import java.util.PriorityQueue;

public class PriorityQueueTest {
    // 自定义的实体类
    static class Viper {
        private int id; // id
        private String name; // 名称
        private int level; // 等级

        public Viper(int id, String name, int level) {
            this.id = id;
            this.name = name;
            this.level = level;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getLevel() {
            return level;
        }

        public void setLevel(int level) {
            this.level = level;
        }
    }
    public static void main(String[] args) {
  PriorityQueue queue = new PriorityQueue(10, new Comparator<Viper>() {
            @Override
            public int compare(Viper v1, Viper v2) {
                // 设置优先级规则（倒序，等级越高权限越大）
                return v2.getLevel() - v1.getLevel();
            }
        });
        // 构建实体类
        Viper v1 = new Viper(1, "Java", 1);
        Viper v2 = new Viper(2, "MySQL", 5);
        Viper v3 = new Viper(3, "Redis", 3);
        // 入列
        queue.offer(v1);
        queue.offer(v2);
        queue.offer(v3);
        while (!queue.isEmpty()) {
            // 遍历名称
            Viper item = (Viper) queue.poll();
            System.out.println("Name：" + item.getName() +
                               " Level：" + item.getLevel());
        }
    }
}
```

以上代码的执行结果如下：

> Name：MySQL Level：5
>
> Name：Redis Level：3
>
> Name：Java Level：1

从上述结果可以看出，**优先队列的出队是不考虑入队顺序的，它始终遵循的是优先级高的元素先出队**。

### 4.延迟队列

延迟队列（DelayQueue）是基于优先队列 `PriorityQueue` 实现的，它可以看作是一种以时间为度量单位的优先的队列，当入队的元素到达指定的延迟时间之后方可出队。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207101026839.png" alt="image-20220710102616759" style="zoom:67%;" />
我们来演示一下延迟队列的使用：

```java
import lombok.Getter;
import lombok.Setter;
import java.text.DateFormat;
import java.util.Date;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;

public class CustomDelayQueue {
    // 延迟消息队列
    private static DelayQueue delayQueue = new DelayQueue();
    public static void main(String[] args) throws InterruptedException {
        producer(); // 调用生产者
        consumer(); // 调用消费者
    }

    // 生产者
    public static void producer() {
        // 添加消息
        delayQueue.put(new MyDelay(1000, "消息1"));
        delayQueue.put(new MyDelay(3000, "消息2"));
    }

    // 消费者
    public static void consumer() throws InterruptedException {
        System.out.println("开始执行时间：" +
                DateFormat.getDateTimeInstance().format(new Date()));
        while (!delayQueue.isEmpty()) {
            System.out.println(delayQueue.take());
        }
        System.out.println("结束执行时间：" +
                DateFormat.getDateTimeInstance().format(new Date()));
    }

    static class MyDelay implements Delayed {
        // 延迟截止时间（单位：毫秒）
        long delayTime = System.currentTimeMillis();
        // 借助 lombok 实现
        @Getter
        @Setter
        private String msg;

        /**
         * 初始化
         * @param delayTime 设置延迟执行时间
         * @param msg       执行的消息
         */
        public MyDelay(long delayTime, String msg) {
            this.delayTime = (this.delayTime + delayTime);
            this.msg = msg;
        }

        // 获取剩余时间
        @Override
        public long getDelay(TimeUnit unit) {
            return unit.convert(delayTime - System.currentTimeMillis(), 
            TimeUnit.MILLISECONDS);
        }

        // 队列里元素的排序依据
        @Override
        public int compareTo(Delayed o) {
            if (this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)) {
                return 1;
            } else if (this.getDelay(TimeUnit.MILLISECONDS) < 
            o.getDelay(TimeUnit.MILLISECONDS)) {
                return -1;
            } else {
                return 0;
            }
        }
        @Override
        public String toString() {
            return this.msg;
        }
    }
}
```

以上代码的执行结果如下：

> 开始执行时间：2020-10-20 20:17:28
>
> 消息1
>
> 消息2
>
> 结束执行时间：2020-10-20 20:17:31

从上述结束执行时间和开始执行时间可以看出，消息 1 和消息 2 都正常实现了延迟执行的功能。

### 5.其他队列

在 Java 的队列中有一个比较特殊的队列 `SynchronousQueue`，它的特别之处在于它内部没有容器，每次进行 `put()` 数据后（添加数据），必须等待另一个线程拿走数据后才可以再次添加数据，它的使用示例如下：

```java
import java.util.concurrent.SynchronousQueue;

public class SynchronousQueueTest {

    public static void main(String[] args) {
        SynchronousQueue queue = new SynchronousQueue();

        // 入队
        new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                try {
                    System.out.println(new Date() + "，元素入队");
                    queue.put("Data " + i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }).start();

        // 出队
        new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                    System.out.println(new Date() + "，元素出队：" + queue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}
```

以上代码的执行结果如下：

> Mon Oct 19 21:00:21 CST 2020，元素入队
>
> Mon Oct 19 21:00:22 CST 2020，元素出队：Data 0
>
> Mon Oct 19 21:00:22 CST 2020，元素入队
>
> Mon Oct 19 21:00:23 CST 2020，元素出队：Data 1
>
> Mon Oct 19 21:00:23 CST 2020，元素入队
>
> Mon Oct 19 21:00:24 CST 2020，元素出队：Data 2

从上述结果可以看出，当有一个元素入队之后，只有等到另一个线程将元素出队之后，新的元素才能再次入队。

# 并行调用模板⭐

## 1. 一个串行调用的例子

如果让你设计一个APP首页查询的接口，它需要查用户信息、需要查`banner`信息、需要查标签信息等等。一般情况，小伙伴会实现如下：

```java
public AppHeadInfoResponse queryAppHeadInfo(AppInfoReq req) {
    //查用户信息
    UserInfoParam userInfoParam = buildUserParam(req);
    UserInfoDTO userInfoDTO = userService.queryUserInfo(userInfoParam);
    //查banner信息
    BannerParam bannerParam = buildBannerParam(req);
    BannerDTO bannerDTO = bannerService.queryBannerInfo(bannerParam);
    //查标签信息
    LabelParam labelParam = buildLabelParam(req);
    LabelDTO labelDTO = labelService.queryLabelInfo(labelParam);
    //组装结果
    return buildResponse(userInfoDTO,bannerDTO,labelDTO);
}
```

这段代码会有什么问题嘛？其实这是一段挺正常的代码，但是这个方法实现中，查询用户、banner、标签信息，**是串行的。**如果查询用户信息耗时`200ms`，查询banner信息`100ms`，查询标签信息`200ms`的话，耗时就是`500ms`啦。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211221721251.png" alt="image-20221122172130130" style="zoom:80%;" />

其实为了优化性能，我们可以修改为**并行调用**的方式，耗时可以降为`200ms`，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211221721250.png" alt="image-20221122172154126" style="zoom:67%;" />

## 2. CompletionService实现并行调用

对于上面的例子，**如何实现并行调用呢？**

有小伙伴说，可以使用`Future+Callable`实现多个任务的并行调用。但是线程池执行批量任务时，返回值用`Future的get()`获取是阻塞的，如果前一个任务执行比较耗时的话，`get（）`方法会阻塞，形成排队等待的情况。

而`CompletionService`是对定义`ExecutorService`进行了包装，可以一边生成任务,一边获取任务的返回值。让这两件事分开执行,任务之间不会互相阻塞，可以获取最先完成的任务结果。

> `CompletionService`的实现原理比较简单，底层通过FutureTask+阻塞队列，实现了任务先完成的话，可优先获取到。也就是说任务执行结果按照完成的先后顺序来排序，先完成可以优先获取到。内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，你调用`CompletionService`的poll或take方法即可获取到一个已经执行完成的Future，进而通过调用Future接口实现类的`get`方法获取最终的结果。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202211221722183.png" alt="image-20221122172210068" style="zoom:80%;" />

接下来，我们来看下，如何用`CompletionService`，实现并行查询APP首页信息哈。思考步骤如下：

1. 我们先把查询用户信息的任务，放到线程池，如下：

```java
ExecutorService executor = Executors.newFixedThreadPool(10);
//查询用户信息
CompletionService<UserInfoDTO> userDTOCompletionService = new ExecutorCompletionService<UserInfoDTO>(executor);
Callable<UserInfoDTO> userInfoDTOCallableTask = () -> {
      UserInfoParam userInfoParam = buildUserParam(req);
      return userService.queryUserInfo(userInfoParam);
  };
userDTOCompletionService.submit(userInfoDTOCallableTask);
```

1. 如果想把查询`banner`信息的任务，也放到这个线程池的话，发现不好放了，因为返回类型不一样，一个是`UserInfoDTO`，另外一个是`BannerDTO`。那这时候，我们把泛型声明为Object即可，因为所有对象都是继承于Object的。如下：

```java
ExecutorService executor = Executors.newFixedThreadPool(10);

//查询用户信息
CompletionService<Object> baseDTOCompletionService = new 
    ExecutorCompletionService<Object>(executor);
Callable<Object> userInfoDTOCallableTask = () -> {
    UserInfoParam userInfoParam = buildUserParam(req);
    return userService.queryUserInfo(userInfoParam);
};

//banner信息任务
Callable<Object> bannerDTOCallableTask = () -> {
    BannerParam bannerParam = buildBannerParam(req);
    return bannerService.queryBannerInfo(bannerParam);
};

//提交用户信息任务
baseDTOCompletionService.submit(userInfoDTOCallableTask);
//提交banner信息任务
baseDTOCompletionService.submit(bannerDTOCallableTask);
```

这里会有个问题，就是获取**返回值的时候**，我们不知道哪个`Object`是用户信息的DTO，哪个是`BannerDTO`？**怎么办呢？**这时候，我们可以在参数里面做个扩展嘛，即参数声明为一个基础对象BaseRspDTO，再搞个泛型放Object数据的，然后基础对象BaseRspDTO有个区分是UserDTO还是BannerDTO的**唯一标记属性key**。代码如下：

```java
public class BaseRspDTO<T extends Object> {

    //区分是DTO返回的唯一标记，比如是UserInfoDTO还是BannerDTO
    private String key;
    //返回的data
    private T data;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}

//并行查询App首页信息
public AppHeadInfoResponse parallelQueryAppHeadPageInfo(AppInfoReq req) {

    long beginTime = System.currentTimeMillis();
    System.out.println("开始并行查询app首页信息，开始时间：" + beginTime);

    ExecutorService executor = Executors.newFixedThreadPool(10);
    CompletionService<BaseRspDTO<Object>> baseDTOCompletionService = 
        new ExecutorCompletionService<BaseRspDTO<Object>>(executor);

    //查询用户信息任务
    Callable<BaseRspDTO<Object>> userInfoDTOCallableTask = () -> {
        UserInfoParam userInfoParam = buildUserParam(req);
        UserInfoDTO userInfoDTO = userService.queryUserInfo(userInfoParam);
        BaseRspDTO<Object> userBaseRspDTO = new BaseRspDTO<Object>();
        userBaseRspDTO.setKey("userInfoDTO");
        userBaseRspDTO.setData(userInfoDTO);
        return userBaseRspDTO;
    };

    //banner信息查询任务
    Callable<BaseRspDTO<Object>> bannerDTOCallableTask = () -> {
        BannerParam bannerParam = buildBannerParam(req);
        BannerDTO bannerDTO = bannerService.queryBannerInfo(bannerParam);
        BaseRspDTO<Object> bannerBaseRspDTO = new BaseRspDTO<Object>();
        bannerBaseRspDTO.setKey("bannerDTO");
        bannerBaseRspDTO.setData(bannerDTO);
        return bannerBaseRspDTO;
    };

    //label信息查询任务
    Callable<BaseRspDTO<Object>> labelDTODTOCallableTask = () -> {
        LabelParam labelParam = buildLabelParam(req);
        LabelDTO labelDTO = labelService.queryLabelInfo(labelParam);
        BaseRspDTO<Object> labelBaseRspDTO = new BaseRspDTO<Object>();
        labelBaseRspDTO.setKey("labelDTO");
        labelBaseRspDTO.setData(labelDTO);
        return labelBaseRspDTO;
    };

    //提交用户信息任务
    baseDTOCompletionService.submit(userInfoDTOCallableTask);
    //提交banner信息任务
    baseDTOCompletionService.submit(bannerDTOCallableTask);
    //提交label信息任务
    baseDTOCompletionService.submit(labelDTODTOCallableTask);

    UserInfoDTO userInfoDTO = null;
    BannerDTO bannerDTO = null;
    LabelDTO labelDTO = null;

    try {
        //因为提交了3个任务，所以获取结果次数是3
        for (int i = 0; i < 3; i++) {
            Future<BaseRspDTO<Object>> baseRspDTOFuture = 
                baseDTOCompletionService.poll(1, TimeUnit.SECONDS);
            BaseRspDTO baseRspDTO = baseRspDTOFuture.get();
            if ("userInfoDTO".equals(baseRspDTO.getKey())) {
                userInfoDTO = (UserInfoDTO) baseRspDTO.getData();
            } else if ("bannerDTO".equals(baseRspDTO.getKey())) {
                bannerDTO = (BannerDTO) baseRspDTO.getData();
            } else if ("labelDTO".equals(baseRspDTO.getKey())) {
                labelDTO = (LabelDTO) baseRspDTO.getData();
            }
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }

    System.out.println("结束并行查询app首页信息,总耗时：" + 
                       (System.currentTimeMillis() - beginTime));
    return buildResponse(userInfoDTO, bannerDTO, labelDTO);
}
```

到这里为止，一个基于`CompletionService`实现并行调用的例子已经实现啦。是不是很开心，哈哈。

## 3. 抽取通用的并行调用方法

我们回过来观察下第2小节，查询app首页信息的demo：`CompletionService`实现了并行调用。不过大家有没有什么其他优化想法呢？比如,假设别的业务场景，也想通过并行调用优化，那是不是也得搞一套类似第2小节的代码。**所以，****我们是不是可以抽取一个通用的并行方法，让别的场景也可以用，对吧？这就是后端思维啦**！

基于第2小节的代码，我们如何抽取通用的并行调用方法呢。

首先，这个通用的并行调用方法，**不能跟业务相关的属性挂钩**，所以方法的入参应该有哪些呢？

> 方法的入参，可以有`Callable`。因为并行，肯定是多个Callable任务的。所以，入参应该是一个`Callable`的数组。再然后，基于上面的APP首页查询的例子，`Callable`里面得带`BaseRspDTO`泛型，对吧？因此入参就是`List<Callable<BaseRspDTO<Object>>> list`。

那并行调用的出参呢？你有多个`Callable`的任务，是不是得有多个对应的返回，因此，你的出参可以是`List<BaseRspDTO<Object>>`。我们抽取的通用并行调用模板，就可以写成酱紫：

```java
public List<BaseRspDTO<Object>> executeTask(List<Callable<BaseRspDTO<Object>>> taskList) {
        
        List<BaseRspDTO<Object>> resultList = new ArrayList<>();
        //校验参数
        if (taskList == null || taskList.size() == 0) {
            return resultList;
        }
        
        ExecutorService executor = Executors.newFixedThreadPool(10);
        CompletionService<BaseRspDTO<Object>> baseDTOCompletionService = 
            new ExecutorCompletionService<BaseRspDTO<Object>>(executor);
        //提交任务
        for (Callable<BaseRspDTO<Object>> task : taskList) {
            baseDTOCompletionService.submit(task);
        }

        try {
            //遍历获取结果
            for (int i = 0; i < taskList.size(); i++) {
                Future<BaseRspDTO<Object>> baseRspDTOFuture = 
                    baseDTOCompletionService.poll(2, TimeUnit.SECONDS);
                resultList.add(baseRspDTOFuture.get());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        return resultList;
    }
}
```

既然我们是抽取通用的并行调用方法，那以上的方法是否还有**哪些地方需要改进**的呢？

- 第一个可以优化的地方，就是`executor线程池`，比如有些业务场景想用`A线程池`，有些业务想用`B线程池`，那么，这个方法，就不通用啦，对吧。我们可以把线程池以参数的形式提供出来，给调用方自己控制。
- 第二个可以优化的地方，就是`CompletionService`的`poll`方法获取时，超时时间是写死的。因为不同业务场景，超时时间要求可能不一样。所以，超时时间也是可以以参数形式放出来，给调用方自己控制。

我们再次优化一下这个通用的并行调用模板，代码如下：

```java
public List<BaseRspDTO<Object>> executeTask(List<Callable<BaseRspDTO<Object>>> taskList, 
                                            long timeOut, ExecutorService executor) {
        
    List<BaseRspDTO<Object>> resultList = new ArrayList<>();
    //校验参数
    if (taskList == null || taskList.size() == 0) {
        return resultList;
    }
    if (executor == null) {
        return resultList;
    }
    if (timeOut <= 0) {
        return resultList; 
    }
        
    //提交任务
    CompletionService<BaseRspDTO<Object>> baseDTOCompletionService = 
        new ExecutorCompletionService<BaseRspDTO<Object>>(executor);
    for (Callable<BaseRspDTO<Object>> task : taskList) {
        baseDTOCompletionService.submit(task);
    }

    try {
        //遍历获取结果
        for (int i = 0; i < taskList.size(); i++) {
          Future<BaseRspDTO<Object>> baseRspDTOFuture = 
              baseDTOCompletionService.poll(timeOut, TimeUnit.SECONDS);
          resultList.add(baseRspDTOFuture.get());
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }
    return resultList;
}
```

以后别的场景也需要用到并行调用的话，直接调用你的这个方法即可，是不是有点小小的成就感啦，哈哈。

## 4. 代码思考以及设计模式应用

我们把抽取的那个公用的并行调用方法，应用到`App首页信息查询`的例子，代码如下：

```java
public AppHeadInfoResponse parallelQueryAppHeadPageInfo1(AppInfoReq req) {

        long beginTime = System.currentTimeMillis();
        System.out.println("开始并行查询app首页信息，开始时间：" + beginTime);
        //用户信息查询任务
        Callable<BaseRspDTO<Object>> userInfoDTOCallableTask = () -> {
            UserInfoParam userInfoParam = buildUserParam(req);
            UserInfoDTO userInfoDTO = userService.queryUserInfo(userInfoParam);
            BaseRspDTO<Object> userBaseRspDTO = new BaseRspDTO<Object>();
            userBaseRspDTO.setKey("userInfoDTO");
            userBaseRspDTO.setData(userInfoDTO);
            return userBaseRspDTO;
        };

        //banner信息查询任务
        Callable<BaseRspDTO<Object>> bannerDTOCallableTask = () -> {
            BannerParam bannerParam = buildBannerParam(req);
            BannerDTO bannerDTO = bannerService.queryBannerInfo(bannerParam);
            BaseRspDTO<Object> bannerBaseRspDTO = new BaseRspDTO<Object>();
            bannerBaseRspDTO.setKey("bannerDTO");
            bannerBaseRspDTO.setData(bannerDTO);
            return bannerBaseRspDTO;
        };

        //label信息查询任务
        Callable<BaseRspDTO<Object>> labelDTODTOCallableTask = () -> {
            LabelParam labelParam = buildLabelParam(req);
            LabelDTO labelDTO = labelService.queryLabelInfo(labelParam);
            BaseRspDTO<Object> labelBaseRspDTO = new BaseRspDTO<Object>();
            labelBaseRspDTO.setKey("labelDTO");
            labelBaseRspDTO.setData(labelDTO);
            return labelBaseRspDTO;
        };

        List<Callable<BaseRspDTO<Object>>> taskList = new ArrayList<>();
        taskList.add(userInfoDTOCallableTask);
        taskList.add(bannerDTOCallableTask);
        taskList.add(labelDTODTOCallableTask);
        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<BaseRspDTO<Object>> resultList = parallelInvokeCommonService
            .executeTask(taskList, 3, executor);
        if (resultList == null || resultList.size() == 0) {
            return new AppHeadInfoResponse();
        }

        UserInfoDTO userInfoDTO = null;
        BannerDTO bannerDTO = null;
        LabelDTO labelDTO = null;

        //遍历结果
        for (int i = 0; i < resultList.size(); i++) {
            BaseRspDTO baseRspDTO = resultList.get(i);
            if ("userInfoDTO".equals(baseRspDTO.getKey())) {
                userInfoDTO = (UserInfoDTO) baseRspDTO.getData();
            } else if ("bannerDTO".equals(baseRspDTO.getKey())) {
                bannerDTO = (BannerDTO) baseRspDTO.getData();
            } else if ("labelDTO".equals(baseRspDTO.getKey())) {
                labelDTO = (LabelDTO) baseRspDTO.getData();
            }
        }

        System.out.println("结束并行查询app首页信息,总耗时：" + 
                           (System.currentTimeMillis() - beginTime));
        return buildResponse(userInfoDTO, bannerDTO, labelDTO);
    }
```

基于以上代码，小伙伴们，**是否还有其他方面的优化想法呢**？比如这几个`Callable`查询任务，我们是不是也可以抽取一下？让代码更加简洁。

> 二话不说，现在我们直接建一个`BaseTaskCommand`类，实现`Callable`接口，把查询用户信息、查询banner信息、label标签信息的查询任务放进去。

代码如下：

```java
public class BaseTaskCommand implements Callable<BaseRspDTO<Object>> {

    private String key;
    private AppInfoReq req;
    private IUserService userService;
    private IBannerService bannerService;
    private ILabelService labelService;

    public BaseTaskCommand(String key, AppInfoReq req, IUserService userService, 
                           IBannerService bannerService, ILabelService labelService) {
        this.key = key;
        this.req = req;
        this.userService = userService;
        this.bannerService = bannerService;
        this.labelService = labelService;
    }

    @Override
    public BaseRspDTO<Object> call() throws Exception {

        if ("userInfoDTO".equals(key)) {
            UserInfoParam userInfoParam = buildUserParam(req);
            UserInfoDTO userInfoDTO = userService.queryUserInfo(userInfoParam);
            BaseRspDTO<Object> userBaseRspDTO = new BaseRspDTO<Object>();
            userBaseRspDTO.setKey("userInfoDTO");
            userBaseRspDTO.setData(userInfoDTO);
            return userBaseRspDTO;
        } else if ("bannerDTO".equals(key)) {
            BannerParam bannerParam = buildBannerParam(req);
            BannerDTO bannerDTO = bannerService.queryBannerInfo(bannerParam);
            BaseRspDTO<Object> bannerBaseRspDTO = new BaseRspDTO<Object>();
            bannerBaseRspDTO.setKey("bannerDTO");
            bannerBaseRspDTO.setData(bannerDTO);
            return bannerBaseRspDTO;
        } else if ("labelDTO".equals(key)) {
            LabelParam labelParam = buildLabelParam(req);
            LabelDTO labelDTO = labelService.queryLabelInfo(labelParam);
            BaseRspDTO<Object> labelBaseRspDTO = new BaseRspDTO<Object>();
            labelBaseRspDTO.setKey("labelDTO");
            labelBaseRspDTO.setData(labelDTO);
            return labelBaseRspDTO;
        }
        
        return null;
    }


    private UserInfoParam buildUserParam(AppInfoReq req) {
        return new UserInfoParam();
    }

    private BannerParam buildBannerParam(AppInfoReq req) {
        return new BannerParam();
    }

    private LabelParam buildLabelParam(AppInfoReq req) {
        return new LabelParam();
    }
}
```

以上这块代码，构造函数还是有**比较多的参数**，并且`call()`方法中，有多个`if...else...`,如果新增一个条件分支（**比如查询浮层信息**），那又得在`call`方法里修改了，并且**BaseTaskCommand的构造器也要修改了**。

> 大家是否有印象，当程序中出现多个if...else...时，我们就可以考虑使用**策略模式+工厂模式**优化。

我们声明多个策略实现类，把条件分支里的实现，搬到策略类，如下：

```java
public interface IBaseTask {

    //返回每个策略类的key，如是usetInfoDTO还是bannerDTO，还是labelDTO
    String getTaskType();

    BaseRspDTO<Object> execute(AppInfoReq req);
    
}
  
//用户信息策略类
@Service
public class UserInfoStrategyTask implements IBaseTask {

    @Autowired
    private IUserService userService;
    
    @Override
    public String getTaskType() {
        return "userInfoDTO";
    }

    @Override
    public BaseRspDTO<Object> execute(AppInfoReq req) {
        UserInfoParam userInfoParam = userService.buildUserParam(req);
        UserInfoDTO userInfoDTO = userService.queryUserInfo(userInfoParam);
        BaseRspDTO<Object> userBaseRspDTO = new BaseRspDTO<Object>();
        userBaseRspDTO.setKey(getTaskType());
        userBaseRspDTO.setData(userBaseRspDTO);
        return userBaseRspDTO;
    }
}

/**
  * banner信息策略实现类
  **/
@Service
public class BannerStrategyTask implements IBaseTask {

    @Autowired
    private IBannerService bannerService;

    @Override
    public String getTaskType() {
        return "bannerDTO";
    }

    @Override
    public BaseRspDTO<Object> execute(AppInfoReq req) {
        BannerParam bannerParam = bannerService.buildBannerParam(req);
        BannerDTO bannerDTO = bannerService.queryBannerInfo(bannerParam);
        BaseRspDTO<Object> bannerBaseRspDTO = new BaseRspDTO<Object>();
        bannerBaseRspDTO.setKey(getTaskType());
        bannerBaseRspDTO.setData(bannerDTO);
        return bannerBaseRspDTO;
    }
}
  
...
```

然后这几个策略实现类，怎么交给`spring`管理呢？我们可以实现`ApplicationContextAware`接口，把策略的实现类注入到一个`map`，然后根据请求方不同的策略请求类型(即userInfoDTO还是bannerDTO等），去实现不同的策略类调用。其实这类似于工厂模式的思想。代码如下：

```java
/**
  * 策略工厂类
  **/
@Component
public class TaskStrategyFactory implements ApplicationContextAware {

    private Map<String, IBaseTask> map = new ConcurrentHashMap<>();

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) 
        throws BeansException {
        Map<String, IBaseTask> tempMap = applicationContext.getBeansOfType(IBaseTask.class);
        tempMap.values().forEach(iBaseTask -> {
            map.put(iBaseTask.getTaskType(), iBaseTask);
        });
    }

    public BaseRspDTO<Object> executeTask(String key, AppInfoReq req) {
        IBaseTask baseTask = map.get(key);
        if (baseTask != null) {
            System.out.println("工厂策略实现类执行");
            return baseTask.execute(req);
        }
        return null;
    }
}
```

有了策略工厂类`TaskStrategyFactory`，我们再回来优化下`BaseTaskCommand`类的代码。它的构造器已经不需要多个`IUserService userService, IBannerService bannerService, ILabelService labelService`啦，只需要传入策略工厂类`TaskStrategyFactory`即可。同时策略也不需要多个`if...else...`判断了，用策略工厂类`TaskStrategyFactory`代替即可。优化后的代码如下：

```java
public class BaseTaskCommand implements Callable<BaseRspDTO<Object>> {

    private String key;
    private AppInfoReq req;
    private TaskStrategyFactory taskStrategyFactory;

    public BaseTaskCommand(String key, AppInfoReq req, 
                           TaskStrategyFactory taskStrategyFactory) {
        this.key = key;
        this.req = req;
        this.taskStrategyFactory = taskStrategyFactory;
    }

    @Override
    public BaseRspDTO<Object> call() throws Exception {
        return taskStrategyFactory.executeTask(key, req);
    }
}  
```

因此整个`app首页信息并行`查询，就可以优化成这样啦，如下：

```java
public AppHeadInfoResponse parallelQueryAppHeadPageInfo2(AppInfoReq req) {
    long beginTime = System.currentTimeMillis();
    System.out.println("开始并行查询app首页信息（最终版本），开始时间：" + beginTime);
    List<Callable<BaseRspDTO<Object>>> taskList = new ArrayList<>();
    //用户信息查询任务
    taskList.add(new BaseTaskCommand("userInfoDTO", req, taskStrategyFactory));
    //banner查询任务
    taskList.add(new BaseTaskCommand("bannerDTO", req, taskStrategyFactory));
    //标签查询任务
    taskList.add(new BaseTaskCommand("labelDTO", req, taskStrategyFactory));

    ExecutorService executor = Executors.newFixedThreadPool(10);
    List<BaseRspDTO<Object>> resultList = parallelInvokeCommonService
        .executeTask(taskList, 3, executor);

    if (resultList == null || resultList.size() == 0) {
        return new AppHeadInfoResponse();
    }

    UserInfoDTO userInfoDTO = null;
    BannerDTO bannerDTO = null;
    LabelDTO labelDTO = null;

    for (BaseRspDTO<Object> baseRspDTO : resultList) {
        if ("userInfoDTO".equals(baseRspDTO.getKey())) {
            userInfoDTO = (UserInfoDTO) baseRspDTO.getData();
        } else if ("bannerDTO".equals(baseRspDTO.getKey())) {
            bannerDTO = (BannerDTO) baseRspDTO.getData();
        } else if ("labelDTO".equals(baseRspDTO.getKey())) {
            labelDTO = (LabelDTO) baseRspDTO.getData();
        }
    }

    System.out.println("结束并行查询app首页信息（最终版本）,总耗时：" + (System.currentTimeMillis() - beginTime));
    return buildResponse(userInfoDTO, bannerDTO, labelDTO);
  }
```

## 5. 思考总结

以上代码整体优化下来，已经很简洁啦。那还有没有别的优化思路呢。

> 其实还是有的，比如，把唯一标记的`key`定义为枚举，而不是写死的字符串`"userInfoDTO"、"bannerDTO"，"labelDTO"`。还有，除了`CompletionService`，有些小伙伴喜欢用`CompletableFuture`实行并行调用，大家可以自己动手操戈写一写。

本文大家学到了哪些知识呢？

1. 如何优化接口性能？某些场景下，可以使用并行调用代替串行。
2. 如何实现并行调用呢？可以使用`CompletionService`。
3. 学到的后端思维是？日常开发中，要学会抽取通用的方法、或者工具。
4. 策略模式和工厂模式的应用

本文的话，设计模式这块还不是很详细，下一篇，给大家讲讲，我是如何在现有代码基础上，抽取设计模式的哈。然后，如果大家**需要本文的完整代码的话**，可以关注这个公众号：**程序员田螺**，回复：**并行源代码**，即可免费获取哈。



# 并发应用

## 限流

> 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机 线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现） 用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好， 注意下面的实现中线程数和数据库连接数是相等的

我（Semaphore）实现证书控制手段有两种，一种公平模式和非公平模式，当然为了执行的性能考虑，默认情况下我采取的是非公平的方式**，具体实现可见源码：

```java
public Semaphore(int permits) {
    sync = new NonfairSync(permits); // 非公平模式
}
```

### 关于公平模式和非公平模式

所谓的公平模式就是以调用 acquire() 的先后顺序来决定获取许可证的顺序的，公平模式遵循先进先出（FIFO）原则；而非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。

显然使用非公平的模式性能更高，因为它会把许可证发放给刚好准备好的线程，而不用再根据先后顺序去“叫号”了。

### 使用公平模式

当然，你可以手动选择使用公平模式来运行 Semaphore，Semaphore 提供了两个构造函数，源码如下：

```java
public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}
public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}
```

如果想用公平模式就可以使用第二个构造函数 Semaphore(int permits, boolean fair)，将 fair 值设置为 true 就是公平模式来获取证书了。

### 案例

接下来，咱们使用代码的方式来演示 Semaphore 的使用。我们以停车场的限流为例，**假设整个停车场只有 2 个车位（车位虽少，但足矣说明问题），但来停车的却有 5 辆车，显然车位不够用了，此时需要保证停车场最多只能有 2 辆车**，接下来咱们使用 Semaphore 来实现车辆的限流功能，具体实现代码如下：

```java
public class T1 {
    // 创建信号量
    static Semaphore semaphore = new Semaphore(2);
    // 公平模式
    //static Semaphore semaphore = new Semaphore(2,true);

    public static void main(String[] args) {

        // 创建 5 个固定的线程数
        ExecutorService threadPool = Executors.newFixedThreadPool(5);

        // 定义执行任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                // 拿到当前线程的名称
                String tname = Thread.currentThread().getName();
                System.out.printf("老司机：%s，停车场外排队，时间：%s%n",
                        tname, new Date());
                try {
                    // 执行此行，让所有线程先排队等待进入停车场
                    Thread.sleep(100);
                    // 执行阻塞
                    semaphore.acquire();
                    System.out.printf("老司机：%s，已进入停车场，时间：%s%n",
                            tname, new Date());
                    Thread.sleep(1000);
                    System.out.printf("老司机：%s，离开停车场，时间：%s%n",
                            tname, new Date());
                    // 释放锁
                    semaphore.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        // 执行任务 1
        threadPool.submit(runnable);
        // 执行任务 2
        threadPool.submit(runnable);
        // 执行任务 3
        threadPool.submit(runnable);
        // 执行任务 4
        threadPool.submit(runnable);
        // 执行任务 5
        threadPool.submit(runnable);
        // 等线程池任务执行完之后关闭
        threadPool.shutdown();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5.13/202205151559189.png" alt="image-20220515155924089" style="zoom: 67%;" />

从上述的结果我们可以看出，当有 5 辆车同时需要进入停车场时，因为停车场的停车位只有 2 个，所以停车场最多只能容纳 2 辆车。此时我们通过 Semaphore 的 acquire 方法（阻塞等待）和 release 方法（颁发一个证书）顺利的实现了限流的功能，让停车场的车辆数始终控制在 2 辆车以下（等于或小于 2 辆车）。



## 定时器

定期执行 如何让每周四 18:00:00 定时执行任务

```java
public static void a1() {
    // 获得当前时间
    LocalDateTime now = LocalDateTime.now();
    // 获取本周四 18:00:00.000
    LocalDateTime thursday =
            now.with(DayOfWeek.THURSDAY)
               .withHour(18).withMinute(0).withSecond(0).withNano(0);
    // 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000
    if(now.compareTo(thursday) >= 0) {
        thursday = thursday.plusWeeks(1);
    }
    // 计算时间差，即延时执行时间
    long initialDelay = Duration.between(now, thursday).toMillis();
    // 计算间隔时间，即 1 周的毫秒值
    long oneWeek = 7 * 24 * 3600 * 1000;
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
    System.out.println("开始时间：" + new Date());
    executor.scheduleAtFixedRate(() -> {
        System.out.println("执行时间：" + new Date());
    }, initialDelay, oneWeek, TimeUnit.MILLISECONDS);
}
```



# 代码改成多线程的9大问题⭐⭐

[麻了，代码改成多线程，竟有9大问题 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247497280&idx=1&sn=16987a9419dc19f82f27f43523af0751&chksm=c0e82ea8f79fa7be6367189470168c0d45bfd52302b1fba873aec39c81949ba2f883d37d9336&mpshare=1&scene=23&srcid=0814v4PBux1TPQrAmCRtlbr6&sharer_sharetime=1660477152800&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 前言

很多时候，我们为了提升接口的性能，会把之前`单线程同步`执行的代码，改成`多线程异步`执行。

比如：查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。

如果查询用户信息接口，`同步调用`三个接口获取数据，会非常耗时。

这就非常有必要把三个接口调用，改成`异步调用`，最后`汇总结果`。

再比如：注册用户接口，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。

该用户注册接口包含的业务逻辑比较多，如果在接口中同步执行这些代码，该接口响应时间会非常慢。

这时就需要把业务逻辑梳理一下，划分：`核心逻辑`和`非核心逻辑`。这个例子中的核心逻辑是：写用户表和分配权限，非核心逻辑是：配置用户导航页和发通知消息。

显然`核心逻辑`必须在接口中`同步执行`，而`非核心逻辑`可以`多线程异步`执行。

等等。

需要使用多线程的业务场景太多了，使用多线程异步执行的好处不言而喻。

但我要说的是，如果多线程没有使用好，它也会给我们带来很多意想不到的问题，不信往后继续看。

今天跟大家一起聊聊，代码改成多线程调用之后，带来的9大问题。

## 1.获取不到返回值

如果你通过直接继承`Thread`类，或者实现`Runnable`接口的方式去创建`线程`。

那么，恭喜你，你将没法获取该线程方法的返回值。

使用线程的场景有两种：

1. 不需要关注线程方法的返回值。
2. 需要关注线程方法的返回值。

大部分业务场景是不需要关注线程方法返回值的，但如果我们有些业务需要关注线程方法的返回值该怎么处理呢？

查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。

如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208151825356.png" alt="image-20220815182527262" style="zoom:50%;" />

在Java8之前可以通过实现`Callable`接口，获取线程返回结果。

Java8以后通过`CompleteFuture`类实现该功能。我们这里以CompleteFuture为例：

```java
public UserInfo getUserInfo(Long id) throws InterruptedException, ExecutionException {
    final UserInfo userInfo = new UserInfo();
    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -> {
        getRemoteUserAndFill(id, userInfo);
        return Boolean.TRUE;
    }, executor);

    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -> {
        getRemoteBonusAndFill(id, userInfo);
        return Boolean.TRUE;
    }, executor);

    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -> {
        getRemoteGrowthAndFill(id, userInfo);
        return Boolean.TRUE;
    }, executor);
    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();

    userFuture.get();
    bonusFuture.get();
    growthFuture.get();

    return userInfo;
}
```

> 温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。

此外，`Fork/join`框架也提供了执行任务并返回结果的能力。

## 2.数据丢失

我们还是以注册用户接口为例，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。

其中：写用户表和分配权限功能，需要在一个事务中同步执行。而剩余的配置用户导航页和发通知消息功能，使用多线程异步执行。

表面上看起来没问题。

但如果前面的写用户表和分配权限功能成功了，用户注册接口就直接返回成功了。

但如果后面异步执行的配置用户导航页，或发通知消息功能失败了，怎么办？

如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208151826926.png" alt="image-20220815182610806" style="zoom: 50%;" />

该接口前面明明已经提示用户成功了，但结果后面又有一部分功能在多线程异步执行中失败了。

这时该如何处理呢？

没错，你可以做`失败重试`。

但如果重试了一定的次数，还是没有成功，这条请求数据该如何处理呢？如果不做任何处理，该数据是不是就丢掉了？

为了防止数据丢失，可以用如下方案：

1. 使用mq异步处理。在分配权限之后，发送一条mq消息，到mq服务器，然后在mq的消费者中使用多线程，去配置用户导航页和发通知消息。如果mq消费者中处理失败了，可以自己重试。
2. 使用job异步处理。在分配权限之后，往任务表中写一条数据。然后有个job定时扫描该表，然后配置用户导航页和发通知消息。如果job处理某条数据失败了，可以在表中记录一个重试次数，然后不断重试。但该方案有个缺点，就是实时性可能不太高。

## 3.顺序问题

如果你使用了多线程，就必须接受一个非常现实的问题，即`顺序问题`。

假如之前代码的执行顺序是：a,b,c，改成多线程执行之后，代码的执行顺序可能变成了：a,c,b。（这个跟cpu调度算法有关）

例如：

```java
public static void main(String[] args) {
    Thread thread1 = new Thread(() -> System.out.println("a"));
    Thread thread2 = new Thread(() -> System.out.println("b"));
    Thread thread3 = new Thread(() -> System.out.println("c"));

    thread1.start();
    thread2.start();
    thread3.start();
}
```

执行结果：

```
a
c
b
```

那么，来自灵魂的一问：如何保证线程的顺序呢？

即线程启动的顺序是：a,b,c，执行的顺序也是：a,b,c。

如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208151827528.png" alt="image-20220815182703438" style="zoom:50%;" />

### **3.1 join**

`Thread`类的`join`方法它会让主线程等待子线程运行结束后，才能继续运行。

列如：

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new Thread(() -> System.out.println("a"));
    Thread thread2 = new Thread(() -> System.out.println("b"));
    Thread thread3 = new Thread(() -> System.out.println("c"));

    thread1.start();
    thread1.join();
    thread2.start();
    thread2.join();
    thread3.start();
}
```

执行结果永远都是：

```c
a
b
c
```

### **3.2 newSingleThreadExecutor**

我们可以使用JDK自带的`Excutors`类的`newSingleThreadExecutor`方法，创建一个`单线程`的`线程池`。

例如：

```java
 public static void main(String[] args)  {
    ExecutorService executorService = Executors.newSingleThreadExecutor();

    Thread thread1 = new Thread(() -> System.out.println("a"));
    Thread thread2 = new Thread(() -> System.out.println("b"));
    Thread thread3 = new Thread(() -> System.out.println("c"));

    executorService.submit(thread1);
    executorService.submit(thread2);
    executorService.submit(thread3);

    executorService.shutdown();
}
```

执行结果永远都是：

```
a
b
c
```

使用`Excutors`类的`newSingleThreadExecutor`方法创建的单线程的线程池，使用了`LinkedBlockingQueue`作为队列，而此队列按 `FIFO`（先进先出）排序元素。

添加到队列的顺序是a,b,c，则执行的顺序也是a,b,c。

### **3.3 CountDownLatch**

`CountDownLatch`是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。

例如：

```java
public class ThreadTest {

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch1 = new CountDownLatch(0);
        CountDownLatch latch2 = new CountDownLatch(1);
        CountDownLatch latch3 = new CountDownLatch(1);

        Thread thread1 = new Thread(new TestRunnable(latch1, latch2, "a"));
        Thread thread2 = new Thread(new TestRunnable(latch2, latch3, "b"));
        Thread thread3 = new Thread(new TestRunnable(latch3, latch3, "c"));

        thread1.start();
        thread2.start();
        thread3.start();
    }
}

class TestRunnable implements Runnable {

    private CountDownLatch latch1;
    private CountDownLatch latch2;
    private String message;

    TestRunnable(CountDownLatch latch1, CountDownLatch latch2, String message) {
        this.latch1 = latch1;
        this.latch2 = latch2;
        this.message = message;
    }

    @Override
    public void run() {
        try {
            latch1.await();
            System.out.println(message);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        latch2.countDown();
    }
}
```

执行结果永远都是：

```
a
b
c
```

此外，使用`CompletableFuture`的`thenRun`方法，也能多线程的执行顺序，在这里就不一一介绍了。

## 4.线程安全问题

既然使用了线程，伴随而来的还会有线程安全问题。

假如现在有这样一个需求：用多线程执行查询方法，然后把执行结果添加到一个list集合中。

代码如下：

```java
List<User> list = Lists.newArrayList();
 dataList.stream()
     .map(data -> CompletableFuture
          .supplyAsync(() -> query(list, data), asyncExecutor)
         ));
CompletableFuture.allOf(futureArray).join();
```

使用`CompletableFuture`异步多线程执行query方法：

```java
public void query(List<User> list, UserEntity condition) {
   User user = queryByCondition(condition);
   if(Objects.isNull(user)) {
      return;
   }
   list.add(user);
   UserExtend userExtend = queryByOther(condition);
   if(Objects.nonNull(userExtend)) {
      user.setExtend(userExtend.getInfo());
   }
}
```

在query方法中，将获取的查询结果添加到list集合中。

结果list会出现线程安全问题，有时候会少数据，当然也不一定是必现的。

这是因为`ArrayList`是`非线程安全`的，没有使用`synchronized`等关键字修饰。

如何解决这个问题呢？

答：使用`CopyOnWriteArrayList`集合，代替普通的`ArrayList`集合，CopyOnWriteArrayList是一个线程安全的机会。

只需一行小小的改动即可：

```java
List<User> list Lists.newCopyOnWriteArrayList();
```

> 温馨的提醒一下，这里创建集合的方式，用了google的collect包。

## 5.ThreadLocal获取数据异常

我们都知道`JDK`为了解决线程安全问题，提供了一种用空间换时间的新思路：`ThreadLocal`。

它的核心思想是：共享变量在每个`线程`都有一个`副本`，每个线程操作的都是自己的副本，对另外的线程没有影响。

例如：

```java
@Service
public class ThreadLocalService {
    private static final ThreadLocal<Integer> threadLocal = new ThreadLocal<>();

    public void add() {
        threadLocal.set(1);
        doSamething();
        Integer integer = threadLocal.get();
    }
}
```

ThreadLocal在普通中线程中，的确能够获取正确的数据。

但在真实的业务场景中，一般很少用`单独的线程`，绝大多数，都是用的`线程池`。

那么，在线程池中如何获取`ThreadLocal`对象生成的数据呢？

如果直接使用普通ThreadLocal，显然是获取不到正确数据的。

我们先试试`InheritableThreadLocal`，具体代码如下：

```java
private static void fun1() {
    InheritableThreadLocal<Integer> threadLocal = new InheritableThreadLocal<>();
    threadLocal.set(6);
    System.out.println("父线程获取数据：" + threadLocal.get());

    ExecutorService executorService = Executors.newSingleThreadExecutor();

    threadLocal.set(6);
    executorService.submit(() -> {
        System.out.println("第一次从线程池中获取数据：" + threadLocal.get());
    });

    threadLocal.set(7);
    executorService.submit(() -> {
        System.out.println("第二次从线程池中获取数据：" + threadLocal.get());
    });
}
```

执行结果：

```apl
父线程获取数据：6
第一次从线程池中获取数据：6
第二次从线程池中获取数据：6
```

由于这个例子中使用了单例线程池，固定线程数是1。

第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。

之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。

因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。

那么，这该怎么办呢？

答：使用`TransmittableThreadLocal`，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。

可以通过如下pom文件引入该jar包：

```xml
<dependency>
   <groupId>com.alibaba</groupId>
   <artifactId>transmittable-thread-local</artifactId>
   <version>2.11.0</version>
   <scope>compile</scope>
</dependency>
```

代码调整如下：

```java
private static void fun2() throws Exception {
    TransmittableThreadLocal<Integer> threadLocal = new TransmittableThreadLocal<>();
    threadLocal.set(6);
    System.out.println("父线程获取数据：" + threadLocal.get());

    ExecutorService ttlExecutorService = TtlExecutors
                    .getTtlExecutorService(Executors.newFixedThreadPool(1));

    threadLocal.set(6);
    ttlExecutorService.submit(() -> {
        System.out.println("第一次从线程池中获取数据：" + threadLocal.get());
    });

    threadLocal.set(7);
    ttlExecutorService.submit(() -> {
        System.out.println("第二次从线程池中获取数据：" + threadLocal.get());
    });

}
```

执行结果：

```java
父线程获取数据：6
第一次从线程池中获取数据：6
第二次从线程池中获取数据：7
```

我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。

nice。

如果你仔细观察这个例子，你可能会发现，代码中除了使用`TransmittableThreadLocal`类之外，还使用了`TtlExecutors.getTtlExecutorService`方法，去创建`ExecutorService`对象。

这是非常重要的地方，如果没有这一步，`TransmittableThreadLocal`在线程池中共享数据将不会起作用。

创建`ExecutorService`对象，底层的submit方法会`TtlRunnable`或`TtlCallable`对象。

以TtlRunnable类为例，它实现了`Runnable`接口，同时还实现了它的run方法：

```java
public void run() {
    Map<TransmittableThreadLocal<?>, Object> copied = (Map)this.copiedRef.get();
    if (copied != null && (!this.releaseTtlValueReferenceAfterRun || this.copiedRef
                           .compareAndSet(copied, (Object)null))) {
        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);

        try {
            this.runnable.run();
        } finally {
            TransmittableThreadLocal.restoreBackup(backup);
        }
    } else {
        throw new IllegalStateException("TTL value reference is released after run!");
    }
}
```

这段代码的主要逻辑如下：

1. 把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。
2. 执行真正的run方法，可以获取到父类最新的ThreadLocal数据。
3. 从备份的数据中，恢复当时的ThreadLocal数据。

如果你想进一步了解ThreadLocal的工作原理，可以看看我的另一篇文章《[ThreadLocal夺命11连问](https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247494889&idx=1&sn=db15e438326c8e297eef739ec190971b&chksm=c0e83401f79fbd17143734d5dbb509f020553772e162d5895de8c8039d79a3cff8633bcf4bb8&token=1106409335&lang=zh_CN&scene=21#wechat_redirect)》

## 6.OOM问题

众所周知，使用多线程可以提升代码执行效率，但也不是绝对的。

对于一些耗时的操作，使用多线程，确实可以提升代码执行效率。

但线程不是创建越多越好，如果线程创建多了，也可能会导致`OOM`异常。

例如：

```java
Caused by: 
java.lang.OutOfMemoryError: unable to create new native thread
```

在`JVM`中创建一个线程，默认需要占用`1M`的内存空间。

如果创建了过多的线程，必然会导致内存空间不足，从而出现OOM异常。

除此之外，如果使用线程池的话，特别是使用固定大小线程池，即使用`Executors.newFixedThreadPool`方法创建的线程池。

该线程池的`核心线程数`和`最大线程数`是一样的，是一个固定值，而存放消息的队列是`LinkedBlockingQueue`。

该队列的最大容量是`Integer.MAX_VALUE`，也就是说如果使用固定大小线程池，存放了太多的任务，有可能也会导致OOM异常。

```java
java.lang.OutOfMemeryError:Java heap space
```

## 7.CPU使用率飙高

不知道你有没有做过excel数据导入功能，需要将一批excel的数据导入到系统中。

每条数据都有些业务逻辑，如果单线程导入所有的数据，导入效率会非常低。

于是改成了多线程导入。

如果excel中有大量的数据，很可能会出现CPU使用率飙高的问题。

我们都知道，如果代码出现死循环，cpu使用率会飚的很多高。因为代码一直在某个线程中循环，没法切换到其他线程，cpu一直被占用着，所以会导致cpu使用率一直高居不下。

而多线程导入大量的数据，虽说没有死循环代码，但由于多个线程一直在不停的处理数据，导致占用了cpu很长的时间。

也会出现cpu使用率很高的问题。

那么，如何解决这个问题呢？

答：使用`Thread.sleep`休眠一下。

在线程中处理完一条数据，休眠10毫秒。

当然CPU使用率飙高的原因很多，多线程处理数据和死循环只是其中两种，还有比如：频繁GC、正则匹配、频繁序列化和反序列化等。

后面我会写一篇介绍CPU使用率飙高的原因的专题文章，感兴趣的小伙伴，可以关注一下我后续的文章。

## 8.事务问题

在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？

例如：

```java
@Slf4j
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;
    @Autowired
    private RoleService roleService;

    @Transactional
    public void add(UserModel userModel) throws Exception {
        userMapper.insertUser(userModel);
        new Thread(() -> {
            roleService.doOtherThing();
        }).start();
    }
}

@Service
public class RoleService {

    @Transactional
    public void doOtherThing() {
        System.out.println("保存role表数据");
    }
}
```

从上面的例子中，我们可以看到`事务方法`add中，调用了事务方法doOtherThing，但是`事务方法`doOtherThing是在另外一个`线程`中调用的。

这样会导致两个方法不在同一个线程中，获取到的`数据库连接`不一样，从而是两个不同的`事务`。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。

如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是`数据源`，value是`数据库连接`。

```java
private static final ThreadLocal<Map<Object, Object>> resources =
        new NamedThreadLocal<>("Transactional resources");
```

我们说的`同一个事务`，其实是指`同一个数据库连接`，只有拥有同一个数据库连接才能同时`提交`和`回滚`。如果在不同的`线程`，拿到的`数据库连接`肯定是不一样的，所以是不同的事务。

> 所以不要在事务中开启另外的线程，去处理业务逻辑，这样会导致事务失效。

## 9.导致服务挂掉

使用多线程会导致服务挂掉，这不是危言耸听，而是确有其事。

假设现在有这样一种业务场景：在mq的消费者中需要调用订单查询接口，查到数据之后，写入业务表中。

本来是没啥问题的。

突然有一天，mq生产者跑了一个批量数据处理的job，导致mq服务器上堆积了大量的消息。

此时，mq消费者的处理速度，远远跟不上mq消息的生产速度，导致的结果是出现了大量的消息堆积，对用户有很大的影响。

为了解决这个问题，mq消费者改成`多线程`处理，直接使用了`线程池`，并且`最大线程数`配置成了20。

这样调整之后，消息堆积问题确实得到了解决。

但带来了另外一个更严重的问题：订单查询接口并发量太大了，有点扛不住压力，导致部分节点的服务直接挂掉。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208151835519.png" alt="image-20220815183546413" style="zoom:67%;" />

为了解决问题，不得不临时加服务节点。

> 在mq的消费者中使用多线程，调用接口时，一定要评估好接口能够承受的最大访问量，防止因为压力过大，而导致服务挂掉的问题。









































