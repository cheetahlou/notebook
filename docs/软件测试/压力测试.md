

# 后端接口测试内容⭐⭐

## 前言

本文主要分为两个部分：

**第一部分：** 主要从问题出发，引入接口测试的相关内容并与前端测试进行简单对比，总结两者之前的区别与联系。但该部分只交代了怎么做和如何做？并没有解释为什么要做？

**第二部分：** 主要介绍为什么要做接口测试，并简单总结接口持续集成和接口质量评估相关内容。

## 第一部分⭐

**首先，在做接口测试的过程中，经常有后端开发会问：**

1. 后端接口都测试什么？怎么测的？

2. 后端接口测试一遍 ，前端也测试一遍，是不是重复测试了？

于是，为了向开发解释上述问题，普及基本的测试常识，特意梳理了接口测试的相关内容以及其与前端测试的区别，使开发团队与测试团队在测试这件上达成基本的共识，提高团队协作效率，从而更好的保证产品质量。

然后，我们试着回答上面的问题：

### 问题1：后端接口都测试什么？

回答这个问题，我们可以从接口测试活动内容的角度下手，看一下面这张图，基本反应了当前我们项目后端接口测试的主要内容：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207291625019.png" alt="image-20220729162552877" style="zoom: 60%;" />

### 问题2：我们怎么做接口测试？

由于我们项目前后端调用主要是基于http协议的接口，所以测试接口时主要是通过工具或代码模拟http请求的发送与接收。工具有很多如：`postman`、`jmeter`、`soupUI`、`java+httpclient`、`robotframework+httplibrary`等。

### 问题3：后端接口测试一遍 ，前端也测试一遍，是不是重复测试了？

#### 0、测试内容

回答这个问题，我们可以直接对比接口测试和app端测试活动的内容，如下图为app测试时需要覆盖或考虑内容：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207291626626.png" style="zoom:60%;" />

从上面这两张图对比可以看出，两个测试活动中相同的部分有**功能测试、边界分析测试和性能测试**，其它部分由于各自特性或关注点不同需要进行特殊的测试，在此不做讨论。接下来我们针对以上三部分相同的内容再进行分析：

#### **1、基本功能测试**

由于是针对基本业务功能进行测试，所以这部分是两种测试重合度最高的一块，开发同学通常所指的也主要是这部分的内容。

#### **2、边界分析测试**

在基本功能测试的基础上考虑输入输出的边界条件，这部分内容也会有重复的部分（比如业务规则的边界）。但是，前端的输入输出很多时候都是提供固守的值让用户选择（如下拉框），在这种情况下测试的边界范围就非常有限，但接口测试就不存在这方面的限制，相对来说接口可以覆盖的范围更广，同样的，接口出现问题的概率也更高。

#### **3、性能测试**

这个比较容易区分，虽然都需要做性能测试，但关注点确大不相同。App端性能主要关注与手机相关的特性，如手机cpu、内存、流量、fps等。而接口性能主要关注接口响应时间、并发、服务端资源的使用情况等。两种测试时的策略和方法都有很大区别，所以这部分内容是需要分开单独进行测试的，理论上来说这也是不同的部分。

综论：

1、接口测试和app测试的活动有部分重复的内容，主要集中在业务功能测试方面。除此之外，针对各自特性的测试都不一样，需要分别进行有针对性的测试，才能确保整个产品的质量。

2、接口测试可以关注于服务器逻辑验证，而UI测试可以关注于页面展示逻辑及界面前端与服务器集成验证

## 第二部分

### 1、什么是接口测试？

接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。

### 2、为什么要做接口测试?

a) 如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，接口测试可以提供这种情况下的解决方案。

b)  接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。

c)  现在很多系统前后端架构是分离的，从安全层面来说：

1、只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。

2、前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。

### 3、接口测试持续集成

对接口测试而言，持续集成自动化是核心内容，通过持自动化的手段我们才能做到低成本高收益。目前我们已经实现了接口自动化，主要应用于回归阶段，后续还需要加强自动化的程度，包括但不限于下面的内容：

a) 流程方面：在回归阶段加强接口异常场景的覆盖度，并逐步向系统测试，冒烟测试阶段延伸，最终达到全流程自动化。

b) 结果展示：更加丰富的结果展示、趋势分析，质量统计和分析等

c) 问题定位：报错信息、日志更精准，方便问题复现与定位。

d) 结果校验：加强自动化校验能力，如数据库信息校验。

e) 代码覆盖率：不断尝试由目前的黑盒向白盒下探，提高代码覆盖率。

f) 性能需求：完善性能测试体系，通过自动化的手段监控接口性能指标是否正常。

### 4、接口测试质量评估标准

a) 业务功能覆盖是否完整

b) 业务规则覆盖是否完整

c) 参数验证是否达到要求（边界、业务规则）

d) 接口异常场景覆盖是否完整

e) 接口覆盖率是否达到要求

f)  代码覆盖率是否达到要求

g) 性能指标是否满足要求

h) 安全指标是否满足要求



# 系统性能

**系统性能**是对整个计算机系统的性能的研究，包括主要**硬件**组件和**软件**组件。所有数据路径上和从存储设备到应用软件上所发生的事情都包括在内，因为这些都有可能影响性能。对于分布式系统来说，这意味着多台服务器和多个应用。如果你还没有关于你的环境的一张示意图，用来显示数据的路径，赶紧找一张或者自己画一张。它可以帮助你理解所有组件的关系，并确保你不会只见树木不见森林。

系统性能的典型目标是通过**减少延时**和**降低计算成本**来改善终端用户的体验。降低成本可以通过消除低效之处、提高系统吞吐量和进行常规性能调优来实现。

## 系统性能概念

下面是系统性能的一些重要概念

### 延时

`对于某些环境，延时是被唯一关注的性能焦点`。而对于其他环境，它会是除了吞吐量以外，数一数二的分析要点。

作为延时的一个例子，图 2.3 显示了如 HTTP GET 请求的网络传输，其响应时间被分成连接延时和数据传输时间两部分。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230952587.png" alt="image-20220723095204542" style="zoom:80%;" />

延时是操作执行之前所花的等待时间。在这个例子里，操作是网络服务的数据传输请求。在这个操作发生之前，系统必须等待建立网络连接，这就是这个操作的延时。**响应时间包括了延时和操作时间。**

因为延时可以在不同点测量，所以通常会指明延时测量的对象。例如，网站的载入时间由三个从不同点测得的不同时间组成 ：**DNS 延时、TCP 连接延时和 TCP 数据传输时间。**DNS 延时指的是整个 DNS 操作的时间，TCP 连接延时仅仅指的是初始化时间（TCP 握手）。

由于延时是一个时间上的指标，因此可能有**多种计算方法。**性能问题可以用延时来进行量化和评级，因为是用相同的单位来表达的（时间）。通过考量所能减少或移除的延时，预计的加速也可以被计算出来。这两者不能用 IOPS 指标很准确地描述出来。

时间的量级和缩写列在了表 2.1 中，可作为参考。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230949152.png" alt="image-20220723094957082" style="zoom:80%;" />

如果可能，其他的指标也会转化为延时或者时间，这样就可以进行比较了。如果必须在 100 个网络 I/O 和 50 个磁盘 I/O 之间做出选择，怎样才能知道哪个性能更好？这是一个复杂的选择，因为其中包含了很多因素 ：**网络跳数、网络丢包率和重传率、I/O 的大小、随机或顺序的 I/O、磁盘类型**，等等。但是如果你比较的是 100ms 的网络 I/O 延时和 50ms 的磁盘 I/O 延时，那差别就很明显了！

### 时间量级

我们可以对时间进行量化的比较，同时最好**对时间和各种来源的延时的合理预期有本能的认识。**系统各组件的操作的时间量级差别巨大，表 2.2 中提供的延时示例，从访问 3.5GHz 的 CPU 寄存器的延时开始，阐释了各种操作时间量级的差别。表中所示的是发生单次操作的时间均值，等比放大为一个假想的系统，将 1 个 CPU 周期的 0.3ns（十亿分之一秒的三分之一 1）放大为现实生活中的 1 秒。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230950677.png" alt="image-20220723095025620" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230950160.png" alt="image-20220723095041082" style="zoom:67%;" />

正如你所见，1 个 CPU 周期的时间是很短暂的。0.5 米差不多是你的眼睛到这个页面的距离，光线走过这段距离需要的时间大约是 1.7ns。在这段时间里，现代的 CPU 已经执行了 5 个 CPU 周期，处理了若干个指令。

### 权衡

你应该知道某些性能权衡关系。图 2.4 展示的是**好 / 快 / 便宜**“择其二”的权衡关系，右图所示的是对应于 IT 项目的术语。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230951018.png" alt="image-20220723095112973" style="zoom:80%;" />

许多 IT 项目选择了及时和成本低，留下了性能问题在以后解决。当早期的决定阻碍了性能提高的可能性时，这样的选择会变得有问题，例如，选择了非最优的存储架构，或者使用的编程语言或操作系统缺乏完善的性能分析工具。

一个常见的性能调优的权衡是在 **CPU 与内存之间**，因为内存能用于缓存数据结果，降低 CPU 的使用率。在有着充足 CPU 资源的现代系统里，交换可以反向进行 ：CPU 可以压缩数据来降低内存的使用。

### 调优的影响

性能调优实施在越靠近工作执行的地方效果最显著。对于工作负载驱动的应用程序，这意味着调优性能的地方就在应用程序本身。表 2.3 展示了一个软件栈的例子，说明了性能调优的各种可能。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230953637.png" alt="image-20220723095311565" style="zoom:80%;" />

对应用程序层级进行调优，可能通过**消除或减少数据库查询**获得很大的性能提升（例如，20 倍）。在存储设备层级进行调优，可以**精简或提高存储 I/O**，但是性能提升的重要部分在更高层级的操作系统栈代码，所以对存储设备层级的调优对应用程序性能的提升有限，是百分比量级的（例如，20%）。

在应用程序层级寻求性能的巨大提升，还有一个理由。如今许多环境都致力于特性和功能的快速部署，按每周或每天将软件的变更推入生产环境。 因此，应用程序的开发和测试倾向于**关注正确性**，在部署前留给性能测量和优化的时间很少甚至没有。之后当性能成为问题时，才会去做这些与性能相关的事情。

虽然发生在应用程序层级的调优效果最显著，但这个层级不一定是观测效果最显著的层级。数据库查询缓慢最好从其所花费的 CPU 时间、文件系统和所执行的磁盘 I/O 方面来考查。使用操作系统工具，这些都是可以观测到的。

### 合适的层级

不同的公司和环境对性能有着不同的需求。你可能加入过这样的公司，其分析标准要比你之前所见过的严格得多，甚至可能听都没听过。或者是这样的公司，你觉得很基本的分析被认为很高端甚至从未使用过（这是好消息 ：事情简单轻松！）

这并不意味着某些公司做的是对的，某些做的是错的。这取决于性能技术投入的投资回报率（ROI）。拥有大型数据中心或大型云环境的组织可能会雇用一个性能工程师团队来分析所有的事情，包括内核内部和 CPU 性能计数器，并频繁使用各种跟踪工具。他们还可能对性能进行正式建模，并对未来的增长进行准确预测。对于每年在计算上有数百万花费的环境来说，雇用这样一个性能团队是值得的，因为他们进行的优化就是**投资回报**。小型创业公司的计算开支不大，可能只进行表面的检查，利用第三方监测方案来检查性能和提供警报。

### 何时停止分析

做性能分析时的一个挑战是**如何知道何时停止**。有这么多的工具，有这么多的东西要检查！

当我教性能课程时（最近我又开始教了），我给我的学生一个有三个原因的性能问题，我发现有些学生在找到一个原因后就停止了，有些则是两个，有些则是三个。有些学生则继续努力，试图为性能问题找到更多的原因。谁的做法是正确的？说你应该在找到所有三个原因后就停止，可能很容易，但对于现实生活中的问题，你并不知道原因的数量。

**这里有三种情况，你可以考虑停止分析**，并提供了一些个人的例子。

当你已经解释了大部分性能问题的时候。一个 Java 应用程序消耗的 CPU 资源是原来的 3 倍。我发现的第一个问题是异常堆栈消耗了 CPU。然后我量化了这些堆栈的时间，发现它们只占整个 CPU 占用的 12%。如果这个数字接近 66%，我就可以停止分析了。但在这种情况下，在 12% 的情况下，我需要继续寻找。

当潜在的投资回报率低于分析的成本的时候。我所处理的一些性能问题可以带来每年数千万美元的收益。对于这些问题，我可以证明花几个月的时间（工程成本）进行分析是合理的。其他的性能问题，比如说微服务，可能是以数百美元计算的，甚至不值得花 1 个小时的工程时间来分析它们。例外情况可能包括 ：当我没有更好的事情可做时（这在实践中从未发生过），或者如果我怀疑这可能是日后更大问题的隐患，值得在问题扩大之前进行调试时。

当其他地方有更大的投资回报率的时候。即使前两种情况没有得到满足，其他地方有更大的投资回报时经常需要优先考虑。如果你是全职的性能工程师，根据潜在的投资回报率对不同的问题进行有选择的分析可能是一项日常工作。

## 性能推荐的时间点

环境的性能特性会随着时间改变，更多的用户、新的硬件、升级的软件或固件都是变化的因素。一种环境，受限于速度 10Gb/s 的网络基础设施，当升级到 100Gb/s 时，很可能会发现磁盘或 CPU 的性能变得紧张。

性能推荐，尤其是可调优的参数值，仅仅在一段特定时间内有效。一周内从性能专家那里得到的好建议，可能到了下一周，经过一次软件或硬件升级，或者用户增多后就无效了。

在网上搜索找到的调优参数值对于某些情况可能能快速见效。但如果对于你的系统或者工作负载并不合适，它们也可能会对性能有所损害，或者合适过一次，就不再合适了，或者只是作为软件的某个 bug 修复升级之前暂时的应急措施。这和从别人的医药箱里拿药吃很像，那些药可能不适合你，或者可能已经过期，或者只适合短期服用。

如果仅仅是出于要了解有哪些参数可调以及哪些参数在过去是需要调整的，那么浏览这些性能建议是有用的。针对你的系统和工作负载，这项工作就变成了考虑这些参数是不是要调，以及调整成什么值。如果其他人不需要调整那个值，或者调整了但并未将经验分享出来，那么你有可能漏掉了重要的参数。

## 负载与架构

应用程序性能差可能是因为软件配置和硬件的问题，也就是它的**架构和实现**问题。另外，应用程序性能差还可能是由于有太多负载，而导致了排队和长延时。负载和架构见图 2.5。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230953602.png" alt="image-20220723095348548" style="zoom:80%;" />

如果对架构的分析显示只是工作任务在排队，处理任务没有任何问题，那么问题就可能出在施加的负载太多上。在云计算环境里，这是需要引入更多的服务器实例来处理任务的征兆。

**举个例子，**架构的问题可能是一个单线程的应用程序在单个 CPU 上忙碌，从而导致请求排队，但是其他的 CPU 却是可用且空闲的。在这个例子里，性能就被应用程序的单一线程架构限制住了。架构的另一个问题可能是一个程序的多个线程争夺一个锁，这样只有一个线程可以向前推进，而其他线程在等待。

负载的问题可能会是一个多线程程序在所有的 CPU 上都忙碌，但是请求依然排队的情况。在这个例子里，性能可能被限制于 CPU 的性能，或者说是负载超出了 CPU 所能处理的范围。



## 缓存

**缓存被频繁使用来提高性能。**缓存是将较慢的存储层的结果存放在较快的存储层中。

把磁盘的块缓存在主存（RAM）中就是一例。

一般使用的都是多级缓存。CPU 通常利用多级硬件缓存作为主缓存（L1、L2 和L3），开始是一个非常快但是很小的缓存（L1），后续的 L2 和 L3 逐渐增加了缓存容量和访问延时。这是一个在密度和延时之间经济上的权衡。缓存的级数和大小的选择以CPU 芯片内可用空间为准，确保达到最优的性能。

一个了解缓存性能的重要指标是每个缓存的命中率—所需数据在缓存中被找到的次数（hits，命中）与总访问次数（hits+misses）的比例。

**命中率 = 命中次数 /（命中次数 + 失效次数）**

**命中率越高越好**，更高的命中率意味着更多的数据能成功地从较快的介质中访问获得。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207230954508.png" alt="image-20220723095435470" style="zoom:80%;" />

98% 和 99% 之间的性能差异要比 10% 和 11% 之间的性能差异大很多。由于缓存命中和失效之间的速度差异（两个存储层级），导致了这是一条非线性曲线。两个存储层级速度差异越大，曲线越陡峭。

## 已知的未知

已知的已知、已知的未知、未知的未知在性能领域是很重要的概念。下面是详细的解释，并提供了系统性能分析的例子。

**已知的已知 ：**有些东西你知道。你知道你应该检查性能指标，你也知道它的当前值。举个例子，你知道你应该检查 CPU 使用率，而且你也知道当前均值是10%。

**已知的未知 ：**有些东西你知道你不知道。你知道你可以检查一个指标或者判断一个子系统是否存在，但是你还没去做。举个例子，你知道你能用剖析检查是什么致使 CPU 忙碌，但你还没去做这件事。

**未知的未知 ：**有些东西你不知道你不知道。举个例子，你可能不知道设备中断可以消耗大量 CPU 资源，因此你对此并不做检查。在性能领域，“`你知道的越多，你不知道的也就越多`”。这和学习系统是一样的原理：你了解的越多，你就能意识到未知的未知越多，然后这些未知的未知会变成你可以去查看的已知的未知。



# 性能指标

性能指标是由系统、应用程序，或者其他工具选定的统计数据，用于测量感兴趣的活动。性能指标用于性能分析和监测，可以由命令行提供数据，也可以由可视化工具提供图表。

## 吞吐量

在了解`qps`、`tps`、`rt`、并发数之前，首先我们应该明确一个系统的吞吐量到底代表什么含义，一般来说，系统吞吐量指的是系统的抗压、负载能力，`代表一个系统每秒钟能承受的最大用户访问量`。

一个系统的吞吐量通常由`qps`（tps）、并发数来决定，每个系统对这两个值都有一个相对极限值，只要某一项达到最大值，系统的吞吐量就上不去了。

## QPS每秒处理查询的次数

系统每秒内处理查询的次数

`Queries Per Second`，每秒查询数，即是每秒能够响应的查询次数，注意这里的查询是指用户发出请求到服务器做出响应成功的次数，简单理解可以认为查询=请求`request`。

`qps`=每秒钟`request`数量

Hits Per Second - HPS：用户每秒点击次数，也就是每秒向后台发送的请求次数

## TPS每秒处理的事务数

`Transactions Per Second` 的缩写，每秒处理的事务数。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

针对单接口而言，`TPS`可以认为是等价于`QPS`的，比如访问一个页面`/index.html`，是一个`TPS`，而访问/index.html页面可能请求了3次服务器比如`css`、`js`、`index`接口，产生了3个`QPS`。

## RT响应时间

> 响应时间，用户从客户端发起一个请求开始计算，到客户端接收到服务端的响应结束，整个过程所耗费的时间。
>

- `Response Time`缩写，简单理解为系统从输入到输出的时间间隔，宽泛的来说，他代表从客户端发起请求到服务端接受到请求并响应所有数据的时间差。一般取平均响应时间。

- MaxRT：最大响应时间，指用户发出请求到服务端返回响应的最大时间。
- MiniRT：最少响应时间，指用户发出请求到服务端返回响应的最少时间。
- 90%响应时间：将所有用户的响应时间进行升序排序，取 90 % 的位置。



## 并发数

简而言之，系统能同时处理的请求/事务数量。

计算方式

QPS` = 并发数 / `RT` 或者 并发数= `QPS` * `RT

举个栗子：

假设公司每天早上9点到10点1个小时内都有员工要上厕所，公司有3600个员工，平均每个员工上厕所时间为10分钟，我们来计算一下。

`QPS`   = 3600/(60*60)  1

`RT`   = 10*60       600秒

`并发数` = 1 * 600      600

这样就意味着如果想达到最好的蹲坑体验，公司需要600个坑位来满足员工需求，否则的话上厕所就要排队等待了。

## 性能思考

按照 `QPS` = `并发数` / `RT` 公式，假设我们现在是单线程的场景，那么 `QPS` 公式应该是这样：`QPS`= 1/RT，实际上 `RT` 应该= `CPU time` + `CPU wait time`，如果将线程数提高到2，那么`QPS` = 2/(CPU time + CPU wait time)，那么是否意味着我们只要单纯提高线程数就能提高QPS呢？

## 最佳线程数计算

假设CPU time是49ms，CPU wait time是200ms，那么QPS=1000ms/249ms=4.01，这里200ms的wait时间我们可以认为CPU一直处于等待状态啥也没干，理论上来说200ms还可以接受200/49≈4个请求，不考虑上下文切换和其他开销的话，可以认为总线程数=(200+49)/49=5，如果再考虑上CPU多核和利用率的问题，我们大致可以认为：最佳线程数=RT/CPU Time * CPU核心数 * CPU利用率

那么最大 `QPS`公式推导为：

最大 `QPS` = 最佳线程数*单线程 `QPS`=（RT/CPU Time \* CPU核心数 \* CPU利用率）*（1/RT) = CPU核心数*CPU利用率/CPU time

那么这样是否意味着我们只要不停增加CPU核心数就能无限提高QPS呢

## 阿姆达尔定律Amdahl

![图片](https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aPzN4vtT0ia5LtL2JMArXEDFh26VYR3FpeeibTzII5DdRibuPzAE7cPSKzBA08viaqZJ4iaG0qQWAKQ0tA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

G.M.Amdahl在1967年提出了Amdahl’s law，针对并行处理的scalability给出了一个模型，指出使用并行处理的提速由问题的可并行的部分所决定。我们可以简单理解为程序通过额外的计算资源，理论上能获得的加速值。

par为并行计算所占的比例，p为并行处理节点个数

假设你想从望京去顺义，坐一辆车需要3小时，虽然现在有3辆车，你也不能1小时就到。这里无法并行，所有Par=0%，p=3，加速比还是等于1，并没有提高速度。

## 古斯塔夫森定律Gustafson

![图片](https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aPzN4vtT0ia5LtL2JMArXEDFw6ibV0ichHyUugoAynjicyADichwQagiaSbhyIlScdlMAYvvTVn96Xce88Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

斯塔夫森定律又被称为扩展的 `加速比`(scaled speedup)，他说明处理器个数、串行比例和加速比之间的关系，只是和阿姆达尔定律侧重角度有所不同。

按照阿姆达尔定律和QPS计算公式，在`CPUtime` 和 `CPU` 利用率不变的情况下，增加 `CPU核心数`就能增加最大`QPS`，在 `par` 不为0即并行的时候，增加并行数量 p 就能提升效率，但是实际上随着请求数量的增加，带来大量的上下文的切换、gc和锁变化。qps更高，产生对象越多，`gc`越频繁，cpu time和利用率都受到影响，尤其在串行的时候，锁自旋、自适应、偏向等等也成为影响par的因素。

## 性能测试关注点

为了提升达到最好的性能，我们需要不断的进行性能测试，调整小城池大小，找到最合适的参数来达到提高性能的目的。性能测试关注点：

- 吞吐量：每秒钟系统能处理的请求数、任务数。
- 响应时间：服务处理一个请求或一个任务的耗时。
- 错误率：一批请求中结果出过错的请求所占比例。

## 性能指标观测⭐⭐

### 网络配置如何看？

要想知道网络的配置和状态，我们可以使用 `ifconfig` 或者 `ip` 命令来查看。

这两个命令功能都差不多，不过它们属于不同的软件包，`ifconfig` 属于 `net-tools` 软件包，`ip` 属于 `iproute2` 软件包，我的印象中 `net-tools` 软件包没有人继续维护了，而 `iproute2` 软件包是有开发者依然在维护，所以更推荐你使用 `ip` 工具。

学以致用，那就来使用这两个命令，来查看网口 `eth0` 的配置等信息：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208091717712.png" alt="image-20220809171751617" style="zoom:67%;" />

虽然这两个命令输出的格式不尽相同，但是输出的内容基本相同，比如都包含了 IP 地址、子网掩码、MAC 地址、网关地址、MTU 大小、网口的状态以及网路包收发的统计信息，下面就来说说这些信息，它们都与网络性能有一定的关系。

第一，网口的连接状态标志。其实也就是表示对应的网口是否连接到交换机或路由器等设备，如果 `ifconfig` 输出中看到有 `RUNNING`，或者 `ip` 输出中有 `LOWER_UP`，则说明物理网路是连通的，如果看不到，则表示网口没有接网线。

第二，MTU 大小。默认值是 `1500` 字节，其作用主要是限制网络包的大小，如果 IP 层有一个数据报要传，而且数据帧的长度比链路层的 MTU 还大，那么 IP 层就需要进行分片，即把数据报分成干片，这样每一片就都小于 MTU。事实上，每个网络的链路层 MTU 可能会不一样，所以你可能需要调大或者调小 MTU 的数值。

第三，网口的 IP 地址、子网掩码、MAC 地址、网关地址。这些信息必须要配置正确，网络功能才能正常工作。

第四，网路包收发的统计信息。通常有网络收发的字节数、包数、错误数以及丢包情况的信息，如果 `TX`（发送） 和 `RX`（接收） 部分中 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，则说明网络发送或者接收出问题了，这些出错统计信息的指标意义如下：

- *errors* 表示发生错误的数据包数，比如校验错误、帧同步错误等；
- *dropped* 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer（这个缓冲区是在内核内存中，更具体一点是在网卡驱动程序里），但因为系统内存不足等原因而发生的丢包；
- *overruns* 表示超限数据包数，即网络接收/发送速度过快，导致 Ring Buffer 中的数据包来不及处理，而导致的丢包，因为过多的数据包挤压在 Ring Buffer，这样 Ring Buffer 很容易就溢出了；
- *carrier* 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；
- *collisions* 表示冲突、碰撞数据包数；

`ifconfig` 和 `ip` 命令只显示的是网口的配置以及收发数据包的统计信息，而看不到协议栈里的信息，那接下来就来看看如何查看协议栈里的信息。

------

### socket 信息如何查看？

我们可以使用 `netstat` 或者 `ss`，这两个命令查看 socket、网络协议栈、网口以及路由表的信息。

虽然 `netstat` 与 `ss` 命令查看的信息都差不多，但是如果在生产环境中要查看这类信息的时候，尽量不要使用 `netstat` 命令，因为它的性能不好，在系统比较繁忙的情况下，如果频繁使用 `netstat` 命令则会对性能的开销雪上加霜，所以更推荐你使用性能更好的 `ss` 命令。

从下面这张图，你可以看到这两个命令的输出内容：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208091718129.png" alt="image-20220809171817063" style="zoom:67%;" />

可以发现，输出的内容都差不多， 比如都包含了 socket 的状态（*State*）、接收队列（*Recv-Q*）、发送队列（*Send-Q*）、本地地址（*Local Address*）、远端地址（*Foreign Address*）、进程 PID 和进程名称（*PID/Program name*）等。

接收队列（*Recv-Q*）和发送队列（*Send-Q*）比较特殊，在不同的 socket 状态。它们表示的含义是不同的。

当 socket 状态处于 `Established`时：

- *Recv-Q* 表示 socket 缓冲区中还没有被应用程序读取的字节数；
- *Send-Q* 表示 socket 缓冲区中还没有被远端主机确认的字节数；

而当 socket 状态处于 `Listen` 时：

- *Recv-Q* 表示全连接队列的长度；
- *Send-Q* 表示全连接队列的最大长度；

在 TCP 三次握手过程中，当服务器收到客户端的 SYN 包后，内核会把该连接存储到半连接队列，然后再向客户端发送 SYN+ACK 包，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其增加到全连接队列 ，等待进程调用 `accept()` 函数时把连接取出来。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208091718862.png" alt="image-20220809171839778" style="zoom:50%;" />

也就说，全连接队列指的是服务器与客户端完了 TCP 三次握手后，还没有被 `accept()` 系统调用取走连接的队列。

那对于协议栈的统计信息，依然还是使用 `netstat` 或 `ss`，它们查看统计信息的命令如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208091719923.png" alt="image-20220809171900847" style="zoom:67%;" />

`ss` 命令输出的统计信息相比 `netsat` 比较少，`ss` 只显示已经连接（*estab*）、关闭（*closed*）、孤儿（*orphaned*） socket 等简要统计。

而 `netstat` 则有更详细的网络协议栈信息，比如上面显示了 TCP 协议的主动连接（*active connections openings*）、被动连接（*passive connection openings*）、失败重试（*failed connection attempts*）、发送（*segments send out*）和接收（*segments received*）的分段数量等各种信息。

------

### 网络吞吐率和 PPS 如何查看？

可以使用 `sar` 命令当前网络的吞吐率和 PPS，用法是给 `sar` 增加 `-n` 参数就可以查看网络的统计信息，比如

- sar -n DEV，显示网口的统计数据；
- sar -n EDEV，显示关于网络错误的统计数据；
- sar -n TCP，显示 TCP 的统计数据

比如，我通过 `sar` 命令获取了网口的统计信息：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208091719973.png" alt="image-20220809171936903" style="zoom:67%;" />

它们的含义：

- `rxpck/s` 和 `txpck/s` 分别是接收和发送的 PPS，单位为包 / 秒。
- `rxkB/s` 和 `txkB/s` 分别是接收和发送的吞吐率，单位是 KB/ 秒。
- `rxcmp/s` 和 `txcmp/s` 分别是接收和发送的压缩数据包数，单位是包 / 秒。

对于带宽，我们可以使用 `ethtool` 命令来查询，它的单位通常是 `Gb/s` 或者 `Mb/s`，不过注意这里小写字母 `b` ，表示比特而不是字节。我们通常提到的千兆网卡、万兆网卡等，单位也都是比特（*bit*）。如下你可以看到， eth0 网卡就是一个千兆网卡：

```
$ ethtool eth0 | grep Speed
  Speed: 1000Mb/s
```

------

### 连通性和延时如何查看？

要测试本机与远程主机的连通性和延时，通常是使用 `ping` 命令，它是基于 ICMP 协议的，工作在网络层。

比如，如果要测试本机到 `192.168.12.20` IP 地址的连通性和延时：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208091719968.png" alt="image-20220809171922889" style="zoom:67%;" />

显示的内容主要包含  `icmp_seq`（ICMP 序列号）、`TTL`（生存时间，或者跳数）以及 `time` （往返延时），而且最后会汇总本次测试的情况，如果网络没有丢包，`packet loss` 的百分比就是 0。

不过，需要注意的是，`ping` 不通服务器并不代表 HTTP 请求也不通，因为有的服务器的防火墙是会禁用 ICMP 协议的。





# 性能监控

[48张图|手摸手教你性能监控、压测和调优 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247495751&idx=1&sn=dcaa50097b5cac9f85b292df20280e20&chksm=fbcf9d7fccb814699550645081b8776c12dc369d0b18bf3342ac8795d0b1bb6e94151e49ef76&mpshare=1&scene=23&srcid=0511fdLZpWUw8EeMF54TGdLm&sharer_sharetime=1652228096399&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## jconsole

jconsole 和 jvisualvm 是 Java JDK 的两个小工具，用来监控内存泄漏、跟踪垃圾回收、执行时的内存情况、对 CPU 进行分析、线程的分析。都可以通过命令行启动，而且可以监控本地和远程应用。而 jvisualvm 是升级版的 jconsole。我们先来看下 jconsole 的使用。

首先用 cmd 命令行的方式启动 jconsole。

### 启动 jconsole

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112010233.png" alt="image-20220511201027195" style="zoom:80%;" />



### 选择监控哪个应用

然后选择，看准名字选择

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112006720.png" alt="image-20220511200626668" style="zoom:80%;" />



### 结果概览

从监控界面上有 6 个菜单，首先看到的是概览功能，上面有堆内存使用量、线程数、类的使用情况、CPU 占用率，都是用趋势图来表示的，能很方便的看出当前性能的概览。

注意：这些监控都是实时的，用jmeter进行多线程访问测试，发现能正常波动。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112009958.png" alt="image-20220511200924901" style="zoom:80%;" />

### 内存

下面是内存的使用情况，可以从下图中看到有个下拉框，里面可以选择不同的内存维度，然后下面的图标和柱状图也会跟着选择的维度而展示不同。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112014612.png" alt="image-20220511201440553" style="zoom:80%;" />

下面是线程的使用情况，可以看到线程峰值和活动线程的总数量，目前看到的峰值是59，活动线程数是 57。下半部分可以看到具体是哪些线程，以及线程的堆栈信息，非常详细。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112015659.png" alt="image-20220511201518598" style="zoom:80%;" />

下面是线程的使用情况，可以看到线程峰值和活动线程的总数量，目前看到的峰值是59，活动线程数是 57。下半部分可以看到具体是哪些线程，以及线程的堆栈信息，非常详细。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112015883.png" alt="image-20220511201542820" style="zoom:80%;" />



### 类

下面是类的加载和卸载情况，已加载类总数是 10679，而已卸载的类是 1 个，所以当前已加装当前类的总数是 10679 - 1 = 10678 个。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112016027.png" alt="image-20220511201615972" style="zoom:80%;" />

### VM 概要

我们再来看下VM（虚拟机）的情况。如下图所示，可以看到虚拟机情况，线程、类、堆的概要信息，以及 VM 的参数，是不是很方便呀~

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112016038.png" alt="image-20220511201647981" style="zoom:80%;" />



### MBean 信息

接下来我们来看下 MBean 信息。对于 MBean，可能很多同学不知道是啥，下面做个解释：

MBean就是一种规范的JavaBean，通过集成和实现一套标准的Bean接口，这种叫MBean。MBean可以用来干嘛？就是可以有一套JDK级别的对外的服务接口。比如，你写了一个JVM允许状态辅助查询的Bean,你希望别人下载一个Jconsole就可以看到你写的杰作。那你就可以考虑用MBean规范来实现。很多垃圾收集器算法Bean就这么干的（说的就是这个类sun.management.MemoryImpl）。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112017744.png" alt="image-20220511201711692" style="zoom:80%;" />



##  jvisualvm

jvisualvm 比 jconsole 更强大，界面展示的信息更丰富。还可以安装插件，太赞了。

`现在jdk里不带了，要自己下载，还是英文版本`

### 启动 jvisualvm 和概述

启动方式和 jconsole 一样，也是通过 cmd 命令行启动。还是选择微服务，然后选择第一个菜单栏：概述。可以看到 JVM 的版本，启动参数等信息。



### 监视

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112045920.png" alt="image-20220511204553854" style="zoom:80%;" />

### 线程

再来查下线程的情况。可以看到有 5 种状态的线程：

- 运行：正在运行的线程。
- 休眠：休眠状态的线程。
- 等待：等待执行的线程。
- 驻留：线程里面的空闲线程。
- 监视：阻塞的线程，正在等待锁。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112047845.png" alt="image-20220511204713784" style="zoom:80%;" />

### 抽样器

另外我们也可以抽样器对 CPU 或内存进行抽样。如下图所示，对内存进行抽样。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112047722.png" alt="image-20220511204731667" style="zoom:80%;" />

### 插件的使用

#### 安装Visual GC 插件

安装步骤：工具->插件->可用插件->Visual GC->安装。安装完成后，重启就可以使用插件功能了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112048990.png" alt="image-20220511204826932" style="zoom:80%;" />

安装完成后，就可以看到

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112048591.png" alt="image-20220511204841540" style="zoom:80%;" />

下图是实时监控垃圾回收的情况。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112048824.png" alt="image-20220511204857763" style="zoom:80%;" />



# 性能测试

[48张图|手摸手教你性能监控、压测和调优 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247495751&idx=1&sn=dcaa50097b5cac9f85b292df20280e20&chksm=fbcf9d7fccb814699550645081b8776c12dc369d0b18bf3342ac8795d0b1bb6e94151e49ef76&mpshare=1&scene=23&srcid=0511fdLZpWUw8EeMF54TGdLm&sharer_sharetime=1652228096399&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## 网关的性能测试

现在我想对 Passjava 系统的 question 微服务的接口进行一个压测，该如何进行呢？

首先我们来看下 passjava 的架构是怎么样的，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112059430.png" alt="image-20220511205907380" style="zoom:80%;" />

客户端分为手机端和 PC 端，http 请求先经过 API Gateway，然后再转发到 question 微服务。其中涉及到了中间件：Gateway 网关。

我们来对 Gateway 网关进行压力测试。

网关的端口号是 8060，我们配置下 JMeter。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112059762.png" alt="image-20220511205924716" style="zoom:80%;" />

配置每秒发送 200 个请求，一直循环执行，直到手动停止压测。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112059928.png" alt="image-20220511205938892" style="zoom:80%;" />

可以看下执行结果，吞吐量在 2422 个每秒，还是比较高的。

吞吐量：2422/s 。

90% 响应时间：142 毫秒。

99% 响应时间：281 毫秒。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112059667.png" alt="image-20220511205954618" style="zoom:80%;" />

我们再来看看垃圾回收的情况，Eden 区垃圾回收用时 2.7 s，用时太长了吧，看看这里怎么能优化下。

通常的优化方向是增大新生代堆内存配置。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112100094.png" alt="image-20220511210009027" style="zoom:80%;" />



## 对微服务的性能测试

根据上面的架构原理图，我们知道客户端请求都是经过 Gateway 转发了一次的，如果我们想单独看下微服务的性能该怎么测试呢？下面我来演示下如何测试 passjava-question 微服务的性能。

首先需要在 passjava-question 微服务中添加一个测试方法：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112058803.png" alt="image-20220511205843763" style="zoom:80%;" />

有两种方式测试这个 api 是否添加正确。

第一种用 postman 测试下这个请求是否能正确响应，返回 “test” 则表示响应正确。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112058149.png" alt="image-20220511205822096" style="zoom:80%;" />

第二种通过浏览器进行测试。浏览器地址栏输入以下链接后，回车，看下浏览器窗口是否显示 “test”，是则表示响应正确。

然后我们需要用 Jmeter 压测工具来测试这个微服务下的 api 的性能究竟如何。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112057996.png" alt="image-20220511205744948" style="zoom:80%;" />

吞吐量：3542/s 。

90% 响应时间：100 毫秒。

99% 响应时间：152 毫秒。



## 对网关+微服务的性能测试

如果我们想对这个整个请求链路进行性能测试该怎么做？

首先请求需要先经过网关，然后由网关转发到微服务。在之前的文章中，我已经将网关配置好了，所以要想通过网关转发到 test 请求，只需要对请求路径稍作修改即可，如下所示：

```apl
:8060/api/question/v1/admin/question/test
```

然后在浏览器输入该网址，返回 “test” 即表示响应正确。

然后我们还是用 Jmeter 压测工具测试下 test api 的性能。测试结果如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112056702.png" alt="image-20220511205624653" style="zoom:80%;" />

从结果可以看到：

吞吐量：982/s 。

90% 响应时间：437 毫秒。

99% 响应时间：790毫秒。

这里做个横向对比：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112056385.png" alt="image-20220511205644340" style="zoom:80%;" />

说明微服务 api 经过网关转发一次后，性能至少下降了一半。可以得出结果：中间件越多，性能损失越大，大部分损失都是网络交互导致的。可以通过增强网络通信质量来减少网络的延迟。



## 对数据库查询进行优化

一般情况下，出现性能问题更多的是业务中查询数据库的耗时。接下来看下如何优化数据的查询。

下面是一个查询问题列表的 api：通过问题类型 type 字段过滤问题列表。api 路径如下：

```apl
:11000/question/v1/admin/question/list?type=5
```

这个 api 的代码如下，很容易看懂。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112053805.png" alt="image-20220511205307757" style="zoom:80%;" />

我们加些测试代码：统计查询数据库的耗时。如下所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112053576.png" alt="image-20220511205331524" style="zoom:80%;" />

然后重启 passjava-question 服务，再次测试这个 api，耗时 43 ms

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112053595.png" alt="image-20220511205352548" style="zoom:80%;" />

怎么对查询进行优化呢？很容易想到加索引，我们来试下加在 question 表加索引后的效果。给 type 字段加上普通索引，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112054241.png" alt="image-20220511205408184" style="zoom:80%;" />

我们再来看下加了索引后的耗时情况：耗时 18 ms，确实比之前的 43 ms 快了很多。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112054249.png" alt="image-20220511205428199" style="zoom:80%;" />



## 优化垃圾回收

我们可以通过 jvisulavm工具查看垃圾回收的情况，Eden 区频繁发生 GC，短时间（1分钟）内共造成了 480 次 stop the world。另外从压测工具中也可以看到，吞吐量为 275/s。

原因是 Eden 区的内存分配得太小了，只有 32 M，我们来调大一点。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112052684.png" alt="image-20220511205204604" style="zoom:67%;" />



### 增大 Eden 区大小

通过在 IDEA 工具中配置以下参数，调整堆内存最大为 1024 M，新生代内存为 512 M。

```apl
-Xmx1024m -Xms1024m -Xmn512m
```

然后可以观察到在相当长的短时间（1分钟）内只进行了 92 次垃圾回收，说明垃圾回收的频率降低了。应用程序的性能也提升了。另外从压测工具中也可以看到，吞吐量为 347/s，吞吐量也有较大提升。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112051755.png" alt="image-20220511205131666" style="zoom:80%;" />



## 总结

本文通过压测工具 Jmeter 讲解压测如何实施，然后用性能监控工具 jconsole 和 jvisualvm 来监控 Java 应用程序的性能，以及如何用工具来优化开源项目 passjava 的性能，并且非常详细地介绍了每一步以及执行结果，通过对比的方式，更加清晰地知道如何做性能优化。

下面是对系统性能的常规优化手段：

- 中间件较多时，优化网络通信质量。
- 数据库查询耗时时，需要对查询进行优化，比如添加索引。
- 模板的渲染速度，可以通过设置模板缓存。
- 静态资源的获取，可以通过 Nginx 动静分离来解决。（下期再讲）
- 日志太多，需要减少不必要的打 log 操作。



# ab压力测试

[(41条消息) CentOS7 ab压力测试安装与解释_u011415782的专栏-CSDN博客_centos 安装ab](https://blog.csdn.net/u011415782/article/details/78501799)

[AB-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/709108?spm=a2c6h.14164896.0.0.75dd735bcbQthB)

Apache Benchmark(简称ab) 是Apache安装包中自带的压力测试工具 ，简单易用

安装

```
yum -y install httpd-tools
```

ab测试的命令参数：ab 或 ab -help

```apl
ab [可选的参数选项] 需要进行压力测试的url
```

可选参数

此外，我们再根据上面的用法介绍界面来详细了解每个参数选项的作用。

- -n	即requests，用于**指定压力测试总共的执行次数(重要)**。
- -c	即concurrency，用于**指定的并发数(重要)**。
- -t	即timelimit，等待响应的最大时间(单位：秒)。
- -b	即windowsize，TCP发送/接收的缓冲大小(单位：字节)。
- -p	即postfile，发送POST请求时需要上传的文件，此外还必须设置-T参数。
- -u	即putfile，发送PUT请求时需要上传的文件，此外还必须设置-T参数。
- -T	即content-type，用于设置Content-Type请求头信息，例如：application/x-www-form-urlencoded，默认值为text/plain。
- -v	即verbosity，指定打印帮助信息的冗余级别。
- -w	以HTML表格形式打印结果。
- -i	使用HEAD请求代替GET请求。
- -x	插入字符串作为table标签的属性。
- -y	插入字符串作为tr标签的属性。
- -z	插入字符串作为td标签的属性。
- -C	添加cookie信息，例如："Apache=1234"(可以重复该参数选项以添加多个)。
- -H	添加任意的请求头，例如："Accept-Encoding: gzip"，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。
- -A	添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。
- -P	添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。
- -X	指定使用的和端口号，例如:"126.10.10.3:88"。
- -V	打印版本号并退出。
- -k	使用HTTP的KeepAlive特性。
- -d	不显示百分比。
- -S	不显示预估和警告信息。
- -g	输出结果信息到gnuplot格式的文件中。
- -e	输出结果信息到CSV格式的文件中。
- -r	指定接收到错误信息时不退出程序。
- -h	显示用法信息，其实就是ab -help。



## ab的使用

```apl
-- 模拟并发请求100次，总共请求10000次
ab -c 100 -n 10000 待测试网站（建议完整路径）
```

例子

```apl
ab -c 1000 -n 5000 http://192.168.1.107:8080/admin/getAll
ab -c 1000 -n 5000 http://192.168.1.107:8080/admin/getById/5
```

内容解释(重要)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220223183636494.png" alt="image-20220223183636494" style="zoom: 67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220223190731363.png" alt="image-20220223190731363" style="zoom:67%;" />



访问量过大时，会出现无法访问的情况

```apl
ab -c 10000 -n 50000 http://192.168.1.107:8080/admin/getById/5
```

出现问题：socket: Too many open files (24)

简单解释：并发访问量过大 服务器拒绝访问，理论上通过系统配置，可以有更好的承受能力

## 注意事项

- 测试机与被测试机要分开
- **不要对线上的服务器做压力测试**
- 观察测试工具ab所在机器，以及被测试的前端机的CPU、内存、网络等都不超过最高限度的75%



# JMH方法测试⭐⭐

[别再写 main 方法测试了，太 Low！这才是专业 Java 测试方法！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247497533&idx=1&sn=d3006585823f12d06d91a45572623928&chksm=fc2c4b35cb5bc223b3f666cb57ca0588b23029dee636909914f6ef53f5176906f6a68f7083c3&mpshare=1&scene=23&srcid=0415atVRusxiIhlcRjiOwxOw&sharer_sharetime=1650024558451&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

https://blog.csdn.net/ZYC88888/article/details/113741316

[测试和性能监控神器 JMH & Arthas (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247529973&idx=2&sn=1a8a2d6f097971073adaa875d0fe2b7b&chksm=ebd54ad9dca2c3cfcb24757948ab12498052a639b0e49934a4514decb7a5c70c8bac2029ea7b&mpshare=1&scene=23&srcid=1030ASdZU5RZ23YfDRH95OBE&sharer_sharetime=1667105118966&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

## JMH 初见

if 快还是 switch 快？HashMap 的初始化 size 要不要指定，指定之后性能可以提高多少？各种序列化方法哪个耗时更短？

无论出自何种原因需要进行性能评估，量化指标总是必要的。在大部分场合，简单地回答谁快谁慢是远远不够的，如何将程序性能量化呢？这就需要我们的主角 JMH 登场了！

基于JMH可以对很多工具和框架进行测试，比如日志框架性能对比、BeanCopy性能对比 等，更多的example可以参考官方给出的[JMH samples](https://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/)

> JMH，全称 Java Microbenchmark Harness (微基准测试框架），是专门用于Java代码微基准测试的一套测试工具API，是由 OpenJDK/Oracle 官方发布的工具。何谓 Micro Benchmark 呢？简单地说就是在 method 层面上的 benchmark，精度可以精确到微秒级。
>

### JMH 注意点

Java的基准测试需要注意的几个点：

> - 测试前需要预热。
> - 防止无用代码进入测试方法中。
> - 并发测试。
> - 测试结果呈现。

### JMH的使用场景

这里面我们需要注意的是，JMH所测试的方法约简单越好，依赖越少越好，最适合的场景就是，测试两个集合put，get性能，例如ArrayList与LinkedList的对比等

> 1. 定量分析某个热点函数的优化效果
> 2. 想定量地知道某个函数需要执行多长时间，以及执行时间和输入变量的相关性
> 3. 对比一个函数的多种实现方式

### 依赖引入

因为 JMH 是 JDK9 自带的，如果是 JDK9 之前的版本需要加入如下依赖（目前 JMH 的最新版本为 `1.35`）：

```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.35</version>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.35</version>
</dependency>
```

### 创建一个 JMH 测试类

接下来，创建一个 JMH 测试类，用来判断 `+` 和 `StringBuilder.append()` 两种字符串拼接哪个耗时更短

```java
@BenchmarkMode(Mode.AverageTime)
@Warmup(iterations = 3, time = 1)
@Measurement(iterations = 5, time = 5)
@Threads(4)
@Fork(1)
@State(value = Scope.Benchmark)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class StringConnectTest {

    @Param(value = {"10", "50", "100"})
    private int length;

    @Benchmark
    public void testStringAdd(Blackhole blackhole) {
        String a = "";
        for (int i = 0; i < length; i++) {
            a += i;
        }
        blackhole.consume(a);
    }

    @Benchmark
    public void testStringBuilderAdd(Blackhole blackhole) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append(i);
        }
        blackhole.consume(sb.toString());
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(StringConnectTest.class.getSimpleName())
                .result("result.json")
                .resultFormat(ResultFormatType.JSON).build();
        new Runner(opt).run();
    }
}
```

其中需要测试的方法用 `@Benchmark` 注解标识，这些注解的具体含义将在下面介绍。在 main() 函数中，首先对测试用例进行配置，使用 Builder 模式配置测试，将配置参数存入 Options 对象，并使用 Options 对象构造 Runner 启动测试。另外大家可以看下官方提供的 jmh 示例 demo：[官方Demo](http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/)

### 结果分析查看

> 将生成的result.json加载到上面的网站：http://deepoove.com/jmh-visual-chart/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212081645478.png" alt="image-20221208164550369" style="zoom:80%;" />

### 执行基准测试

准备工作做好了，接下来，运行代码，等待片刻，测试结果就出来了，下面对结果做下简单说明：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212081637022.png" alt="image-20221208163753915" style="zoom:80%;" />

该部分为**测试的基本信息**，比如使用的 Java 路径，预热代码的迭代次数，测量代码的迭代次数，使用的线程数量，测试的统计单位等。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212081639671.png" alt="image-20221208163913598" style="zoom:80%;" />

该部分为每一次热身中的性能指标，预热测试不会作为最终的统计结果。预热的目的是**让 JVM 对被测代码进行足够多的优化**，比如，在预热后，被测代码应该得到了充分的 JIT 编译和优化。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212081639834.png" alt="image-20221208163959742" style="zoom:80%;" />

该部分显示测量迭代的情况，每一次迭代都显示了当前的执行速率，即一个操作所花费的时间。在进行 5 次迭代后，进行统计，在本例中，length 为 100 的情况下 `testStringBuilderAdd` 方法的平均执行花费时间为 `819.329 ns`，误差为 `72.698 ns`。最后的测试结果如下所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202212081640194.png" alt="image-20221208164037103" style="zoom:80%;" />

结果表明，在拼接字符次数越多的情况下，`StringBuilder.append()` 的性能就更好。

### 生成 jar 包执行

对于一些小测试，直接用上面的方式写一个 main 函数手动执行就好了。

对于大型的测试，需要测试的时间比较久、线程数比较多，加上测试的服务器需要，一般要放在 Linux 服务器里去执行。

JMH 官方提供了生成 jar 包的方式来执行，我们需要在 maven 里增加一个 plugin，具体配置如下：

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>2.4.1</version>
        <executions>
            <execution>
                <phase>package</phase>
                <goals>
                    <goal>shade</goal>
                </goals>
                <configuration>
                    <finalName>jmh-demo</finalName>
                    <transformers>
                        <transformer
                                implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                            <mainClass>org.openjdk.jmh.Main</mainClass>
                        </transformer>
                    </transformers>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

接着执行 maven 的命令生成可执行 jar 包并执行：

```
mvn clean install
java -jar target/jmh-demo.jar StringConnectTest
```

## 注解介绍

下面我们来详细介绍一下相关的注解

`JMH`是一个jar包，它和单元测试框架`JUnit`非常的像，可以通过注解进行一些基础配置。这部分配置有很多是可以通过main方法的`OptionsBuilder`进行设置的。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221414094.png" alt="image-20220722141407007" style="zoom:67%;" />

### @Benchmark

`声明一个public方法为基准测试方法`。

```java
@Benchmark
@Test
public void testFor() {
    int sum = 0;
    for (int i = 0; i < 1000000; i++) {
        sum += i;
    }
}
```



### @BenchmarkMode(重点)

> 通过JMH我们可以轻松的测试出某个接口的吞吐量、平均执行时间等指标的数据。假设我想测试方法的**平均耗时**，那么可以使用@BenchmarkMode注解指定测试维度为Mode.AverageTime。此注解用来指定基准测试类型，对应Mode选项，用来修饰类和方法都可以。这里的value，是一个数组，可以配置多个统计维度。比如：
>

@BenchmarkMode({Throughput,Mode.AverageTime})。统计的就是吞吐量和平均执行时间两个指标。

微基准测试类型。**JMH** 提供了以下几种类型进行支持：

| 类型           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| Throughput     | 整体吞吐量，比如QPS，单位时间内的调用量等。                  |
| AverageTime    | 平均耗时，指的是每次执行的平均时间。如果这个值很小不好辨认，可以把统计的单位时间调小一点。 |
| SampleTime     | 随机`取样`。                                                 |
| SingleShotTime | 如果你想要测试仅仅一次的性能，比如第一次初始化花了多长时间，就可以使用这个参数，其实和传统的main方法没有什么区别。 |
| All            | 所有模式                                                     |

可以注释在方法级别，也可以注释在类级别，

```java
@BenchmarkMode(Mode.All)
public class LinkedListIterationBenchMark {
 ...
}

@Benchmark
@BenchmarkMode({Mode.Throughput, Mode.SingleShotTime})
public void m() {
 ...
}
```

我们拿平均时间，看一下一个大体的执行结果：

```apl
Result "com.github.xjjdog.tuning.BenchmarkTest.shift":
  2.068 ±(99.9%) 0.038 ns/op [Average]
  (min, avg, max) = (2.059, 2.068, 2.083), stdev = 0.010
  CI (99.9%): [2.030, 2.106] (assumes normal distribution)
```

由于我们声明的时间单位是纳秒，本次shift方法的平均响应时间就是2.068纳秒。

我们也可以看下最终的耗时时间。

```apl
Benchmark            Mode  Cnt  Score   Error  Units
BenchmarkTest.div    avgt    5  2.072 ± 0.053  ns/op
BenchmarkTest.shift  avgt    5  2.068 ± 0.038  ns/op
```

由于是平均数，这里的Error值的是误差的意思（或者波动）。

可以看到，在衡量这些指标的时候，都有一个时间维度，它就是通过**@OutputTimeUnit**注解进行配置的。

这个就比较简单了，它指明了基准测试结果的时间类型。可用于类或者方法上。一般选择秒、毫秒、微秒，纳秒那是针对的速度非常快的方法。

举个例子，`@BenchmarkMode(Mode.Throughput)`和`@OutputTimeUnit(TimeUnit.MILLISECONDS)`进行组合，代表的就是每毫秒的吞吐量。

如下面的关于吞吐量的结果，就是以毫秒计算的。

```apl
Benchmark             Mode  Cnt       Score       Error   Units
BenchmarkTest.div    thrpt    5  482999.685 ±  6415.832  ops/ms
BenchmarkTest.shift  thrpt    5  480599.263 ± 20752.609  ops/ms
```

`OutputTimeUnit`注解同样可以修饰类或者方法，通过更改时间级别，可以获取更加易读的结果。



### @Warmup(重点)

这个单词的意思就是预热，`iterations = 3`就是指预热轮数。

为了数据准确，我们可能需要让testGson方法做下热身运动。如在方法中创建GsonParser对象，预热可以避免首次创建GsonParser时因多了类加载的耗时而导致测试结果不准备的情况。jvm使用JIT即时编译器，一定的预热次数可让JIT对testGson方法的调用链路完成编译，去掉解释执行对测试结果的影响。

@Warmup注解用于配置预热参数。

```java
@Warmup(
iterations = 5,
time = 1,
timeUnit = TimeUnit.SECONDS)
```

我们不止一次提到预热，`warmup`这个注解，可以用在类或者方法上，进行预热配置。可以看到，它有几个配置参数。

- `timeUnit`：时间的单位，默认的单位是秒。
- `iterations`：预热阶段的迭代数。
- `time`：每次预热的时间。
- `batchSize`：批处理大小，指定了每次操作调用几次方法。

上面的注解，意思是对代码预热总计5秒（迭代5次，每次一秒） 。预热过程的测试数据，是不记录测量结果的。

我们可以看一下它执行的效果：

```java
# Warmup: 3 iterations, 1 s each
# Warmup Iteration   1: 0.281 ops/ns
# Warmup Iteration   2: 0.376 ops/ns
# Warmup Iteration   3: 0.483 ops/ns
```

一般来说，基准测试都是针对的比较小的、执行速度相对较快的代码块。这些代码有很大的可能被编译、内联，在编码的时候保持方法的精简，对JIT也是有好的。

说到预热，就不得不提一下在分布式环境下的服务预热。在对服务节点进行发布的时候，通常也会有预热过程，逐步放量到相应的服务节点，直到服务达到最优状态。如下图所示，负载均衡负责这个放量过程，一般是根据百分比进行放量。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221416939.png" alt="image-20220722141638859" style="zoom:67%;" />



### @Measurement(重点)

假设我想测量方法五次，那么可以使用`@Measurement`注解。

正式度量计算的轮数。

- `iterations` 进行测试的轮次
- `time` 每轮进行的时长
- `timeUnit`时长单位

```java
@Benchmark
@BenchmarkMode({Mode.Throughput, Mode.SingleShotTime})
@Measurement(iterations = 5)
@Test
public void m() {
 ...
}
```

`Measurement`和`Warmup`的参数是一样的。不同于预热，它指的是真正的迭代次数。

我们能够从日志中看到这个执行过程：

```apl
# Measurement: 5 iterations, 1 s each
Iteration   1: 1646.000 ns/op
Iteration   2: 1243.000 ns/op
Iteration   3: 1273.000 ns/op
Iteration   4: 1395.000 ns/op
Iteration   5: 1423.000 ns/op
```

虽然经过预热之后，代码都能表现出它的最优状态，但一般和实际应用场景还是有些出入的。如果你的测试机器性能很高，或者你的测试机资源利用已经达到了极限，都会影响测试结果的数值。通常情况下，我都会在测试的时候，给机器充足的资源，保持一个稳定的环境。在分析结果的时候，也更加关注不同实现方式的**性能差异**，而不是测试数据本身。



### @Threads

`fork`是面向进程的，而`Threads`是面向线程的。指定了这个注解以后，将会开启并行测试。

如果配置了 Threads.MAX ，则使用和处理机器核数相同的线程数。

`@Threads`注解用于指定使用多少个线程来执行基准测试方法，如果使用`@Threads`指定线程数为`2`，那么每次测量都会创建两个线程来执行基准测试方法。

每个进程中的测试线程。

```java
@Threads(Threads.MAX)
public class LinkedListIterationBenchMark {
 ...
}
```

如果@Measurement注解指定time为1s，基准测试方法的执行耗时为1s，那么如果只使用单个线程，一次测量只会执行一次基准测试方法，如果使用10个线程，一次测量就能执行10次基准测试方法。



### @Fork(重点)

面向进程

fork的值一般设置成1，表示只使用一个进程进行测试；如果这个数字大于1，表示会启用新的进程进行测试；但如果设置成0，程序依然会运行，不过这样是在用户的JVM进程上运行的，可以看下下面的提示，但不推荐这么做。

进行 fork 的次数。如果 fork 数是3的话，则 JMH 会 fork 出3个进程来进行测试。

`@Fork`用于指定`fork`出多少个子进程来执行同一基准测试方法。

假设我们不需要多个进程，那么 可以使用`@Fork`指定为进程数为1。

```java
@Benchmark
@BenchmarkMode({Mode.Throughput, Mode.SingleShotTime})
@Fork(value = 3)
public void m() {
 ...
}
```

在这里分享一个小技巧。其实fork注解有一个参数叫做`jvmArgsAppend`，我们可以通过它传递一些JVM的参数。

```apl
@Fork(value = 3, jvmArgsAppend = {"-Xmx2048m", "-server", "-XX:+AggressiveOpts"})
```

在平常的测试中，也可以适当增加fork数，来减少测试的误差。



### @OutputTimeUnit

OutputTimeUnit注解用于指定输出的方法执行耗时的单位。如果方法执行耗时为秒级别，为了便于 观察结果，我们可以使用@OutputTimeUnit指定输出的耗时时间单位为秒；如果方法执行耗时为毫秒级别，为了便于观察结果，`我们可以使用@OutputTimeUnit指定输出的耗时时间单位为毫秒，否则使用默认的秒做单位`，会输出10的负几次方这样的数字，不太直观。

基准测试结果的时间类型。一般选择秒、毫秒、微秒。

```java
@OutputTimeUnit(TimeUnit.SECONDS)
public class LinkedListIterationBenchMark {
 ...
}
```



### @Param(重点)

属性级注解，`@Param` 可以用来指定某项参数的多种情况。

特别适合用来`测试一个函数在不同的参数输入的情况下的性能`。

使用@Param注解可指定基准方法执行参数，@Param注解只能指定String类型的值，可以是一个数组，参数值将在运行期间按给定顺序遍历。假设@Param注解指定了多个参数值，那么JMH会为每个参数值进行一次测量。

```java
// 指定参数有三个值
@Param(value = {"1", "2", "3"})
private String jsonStr;
```

代码样例如下：

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(1)
@State(Scope.Benchmark)
public class JMHSample_27_Params {
    @Param({"1", "31", "65", "101", "103"})
    public int arg;
    @Param({"0", "1", "2", "4", "8", "16", "32"})
    public int certainty;
    @Benchmark
    public boolean bench() {
        return BigInteger.valueOf(arg).isProbablePrime(certainty);
    }
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JMHSample_27_Params.class.getSimpleName())
               // Use this to selectively constrain/override parameters
                //.param("arg", "41", "42") 
                .build();

        new Runner(opt).run();
    }
}
```

值得注意的是，如果你设置了非常多的参数，这些参数将执行多次，通常会运行很长时间。比如参数1 M个，参数2 N个，那么总共要执行M*N次。

下面是一个执行结果的截图。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221438963.png" alt="image-20220722143833806" style="zoom:80%;" />



### @Setup、@TearDown

方法级注解，这个注解的作用就是我们需要在测试之前进行一些**准备工作**，比如对一些数据的初始化之类的。

方法级注解，这个注解的作用就是我们需要在测试之后进行一些**结束工作**，比如关闭线程池，数据库连接等的，主要用于资源的回收等。

和单元测试框架JUnit类似，用于基准测试前的初始化动作， @TearDown 用于基准测试后的动作，来做一些全局的配置。

这两个注解，同样有一个Level值，标明了方法运行的时机，它有三个取值。

- **Trial**：默认的级别。也就是Benchmark级别。
- **Iteration**：每次迭代都会运行。
- **Invocation**：每次方法调用都会运行，这个是粒度最细的。



### @State(重点)

当使用`@Setup`参数的时候，`必须在类上加这个参数，不然会提示无法运行`。

就比如我上面的例子中，就必须设置`state`。

`State` 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。

1. Thread: 该状态为每个线程独享。
2. Group: 该状态为同一个组里面所有线程共享。
3. Benchmark: 该状态在所有线程间共享。

在`JMHSample04DefaultState`测试文件中，演示了变量`x`的默认作用范围是Thread，关键代码如下：

```java
@State(Scope.Thread)
public class JMHSample_04_DefaultState {
    double x = Math.PI;
    @Benchmark
    public void measure() {
        x++;
    }
}
```

### @CompilerControl 

这可以说是一个非常有用的功能了。

Java中方法调用的开销是比较大的，尤其是在调用量非常大的情况下。拿简单的getter/setter方法来说，这种方法在Java代码中大量存在。我们在访问的时候，就需要创建相应的栈帧，访问到需要的字段后，再弹出栈帧，恢复原程序的执行。

如果能够把这些对象的访问和操作，纳入到目标方法的调用范围之内，就少了一次方法调用，速度就能得到提升，这就是方法内联的概念。如图所示，代码经过JIT编译之后，效率会有大的提升。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221436455.png" alt="image-20220722143646369" style="zoom:67%;" />

这个注解可以用在类或者方法上，能够控制方法的编译行为，常用的有3种模式。

强制使用内联（INLINE），禁止使用内联（DONT_INLINE），甚至是禁止方法编译（EXCLUDE）等。



## 启动运行和结果展示

### 结果展示

使用JMH测试的结果，可以二次加工，进行图形化展示。结合图表数据，更加直观。通过运行时，指定输出的格式文件，即可获得相应格式的性能测试结果。

比如下面这行代码，就是指定输出JSON格式的数据。

```apl
Options opt = new OptionsBuilder()
    .resultFormat(ResultFormatType.JSON)
    .build();
```

自动生成该文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210302120672.png" alt="image-20221030212040518" style="zoom:80%;" />

JMH支持以下5种格式的结果：

- **TEXT** 导出文本文件。
- **CSV** 导出csv格式文件。
- **SCSV** 导出scsv等格式的文件。
- **JSON** 导出成json文件。
- **LATEX** 导出到latex，一种基于ΤΕΧ的排版系统。

一般来说，我们导出成CSV文件，直接在Excel中操作，生成相应的图形就可以了。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221430719.png" alt="image-20220722143044617" style="zoom: 50%;" />

另外介绍几个可以做图的工具：

**JMH Visualizer**这里有一个开源的项目（https://jmh.morethan.io/） ，通过导出json文件，上传之后，可得到简单的统计结果。个人认为它的展示方式并不是很好。

**jmh-visual-chart**

相比较而言，下面这个工具（http://deepoove.com/jmh-visual-chart） ，就相对直观一些。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221431598.png" alt="image-20220722143107510" style="zoom: 50%;" />

**meta-chart**

一个通用的在线图表生成器。（https://www.meta-chart.com/），导出CSV文件后，做适当处理，即可导出精美图像。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207221431588.png" alt="image-20220722143129518" style="zoom: 50%;" />

像Jenkins等一些持续集成工具，也提供了相应的插件，用来直接显示这些测试结果。



### 非注解启动运行

使用注解与不使用注解其实都是一样，只不过使用注解更加方便。在运行时，注解配置被用于解析生成BenchmarkListEntry配置类实例，而在`代码中使用Options配置也是被解析成一个个BenchmarkListEntry配置类实例`（每个方法对应一个）。非注解方式我们可以使用OptionsBuilder构造一个Options，例如，非注解方式实现上面的例子。

```java
public static void main(String[] args) throws RunnerException {
    Options options = new OptionsBuilder()
            .include(LinkedListIterationBenchMark.class.getSimpleName())
            // .exclude("testJackson")
            .forks(1)
            .threads(2)
            .timeUnit(TimeUnit.NANOSECONDS)
            .warmupIterations(5)
            .warmupTime(TimeValue.seconds(1))
            .measurementIterations(5)
            .measurementTime(TimeValue.seconds(1))
            .mode(Mode.AverageTime)
            .build();
    new Runner(options).run();
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205101404304.png" alt="image-20220510140428259" style="zoom:80%;" />

- include：`导入一个基准测试类。调用方法传递的是类的简单名称`，不含包名。
- exclude：`排除哪些方法`。默认JMH会为include导入的类的每个public方法都生成一个BenchmarkListEntry配置类实例，也就是把每个public方法都当成是基准测试方法，这时我们就可以使用exclude排除不需要参与基准测试的方法。例如本例中使用exclude排除了testJackson方法。

打jar包放服务器上执行
对于大型的测试，需要测试时间比较久、线程比较多的情况，我们可以将写好的基准测试项目打包成jar包丢到linux服务器上执行。对于吞吐量基准测试，建议放到服务器上执行，其结果会更准确一些，硬件、系统贴近线上环境、也不受本机开启的应用数、硬件配置等因素影响。

```apl
java -jar my-benchmarks.jar
```

在IDEA中执行
对于一般的方法执行耗时测试，我们不需要把测试放到服务器上执行，例如测试对比几个json解析框架的性能。在idea中，我们可以编写一个单元测试方法，在单元测试方法中创建一个org.openjdk.jmh.runner.Runner，调用Runner的run方法执行基准测试。但JMH不会去扫描包，不会执行每个基准测试方法，这需要我们通过配置项来告知JMH需要执行哪些基准测试方法。

```java
public class BenchmarkTest{
	@Test
	public void test() throws RunnerException {
    	Options options = null; // 创建Options
   		new Runner(options).run();
	}
}
```


复制代码
完整例子如下：

```java
public class BenchmarkTest{
     @Test
     public void test() throws RunnerException {
        Options options = new OptionsBuilder()
                 .include(JsonBenchmark.class.getSimpleName())
                 // .output("/tmp/json_benchmark.log")
                 .build();
        new Runner(options).run();
     }
}
```

Options在前面已经介绍过了，由于本例中JsonBenchmark这个类已经使用了注解，因此Options只需要配置需要执行基准

测试的类。如果需要执行多个基准测试类，include方法可以多次调用。

如果需要将测试结果输出到文件，可调用output方法配置文件路径，不配置则输出到控制台。


## 测试多个方法(重要)

假设我们需要在JsonBenchmark类中创建两个基准测试方法，一个是testGson，另一个是testJackson，用于对比Gson与Jackson这两个框架解析json的性能。那么`我们可以将除@Benchmark注解外的其它注解都声明到类上，让两个基准测试方法都使用同样的配置。`

```java
@BenchmarkMode(Mode.AverageTime) // 指定mode为Mode.AverageTime
@Fork(10) // 指定并行数量
@Threads(5) // 指定线程数量
@OutputTimeUnit(TimeUnit.NANOSECONDS) // 指定输出的耗时时长的单位
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@State(Scope.Thread) // 有公共变量必须写他，不然会报错
public class LinkedListIterationBenchMark {

    private static final int SIZE = 10000;

    private final List<String> list = new LinkedList<>();

    @Setup
    public void setUp() {
        for (int i = 0; i < SIZE; i++) {
            list.add(String.valueOf(i));
        }
    }

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    public void forIndexIterate() {
        for (int i = 0; i < list.size(); i++) {
            list.get(i);
            System.out.print("");
        }
    }

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    public void forEachIterate() {
        for (String s : list) {
            System.out.print("");
        }
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(LinkedListIterationBenchMark.class.getSimpleName())
                //可选，不写默认输出到控制台
                //.output("E:/Benchmark.log")
                .build();

        new Runner(opt).run();
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205101343214.png" alt="image-20220510134308157" style="zoom:80%;" />



## 测试单个方法

```java
@Benchmark
@BenchmarkMode(Mode.AverageTime) // 指定mode为Mode.AverageTime
@Fork(10) // 指定并行数量
@Threads(5) // 指定线程数量
@OutputTimeUnit(TimeUnit.NANOSECONDS) // 指定输出的耗时时长的单位
@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Test
public void testFor() {
    int sum = 0;
    for (int i = 0; i < 1000000; i++) {
        sum += i;
    }
}
```

```java
@AfterEach
public void after() throws RunnerException {
    Options opt = new OptionsBuilder()
            .include(JMHTest.class.getSimpleName())
            .warmupIterations(2)
            .measurementIterations(2)
            //可选，不写默认输出到控制台
            // .output("E:/Benchmark.log")
            .build();

    new Runner(opt).run();
}
```



启动方法

在启动方法中，可以直接指定上述说到的一些参数，并且能将测试结果输出到指定文件中，

```java
  /**
     * 仅限于IDE中运行
     * 命令行模式 则是 build 然后 java -jar 启动
     *
     * 1. 这是benchmark 启动的入口
     * 2. 这里同时还完成了JMH测试的一些配置工作
     * 3. 默认场景下，JMH会去找寻标注了@Benchmark的方法，
          可以通过include和exclude两个方法来完成包含以及排除的语义
     */
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                // 包含语义
                // 可以用方法名，也可以用XXX.class.getSimpleName()
                .include("Helloworld")
                // 排除语义
                .exclude("Pref")
                // 预热10轮
                .warmupIterations(10)
                // 代表正式计量测试做10轮，
                // 而每次都是先执行完预热再执行正式计量，
                // 内容都是调用标注了@Benchmark的代码。
                .measurementIterations(10)
                //  forks(3)指的是做3轮测试，
                // 因为一次测试无法有效的代表结果，
                // 所以通过3轮测试较为全面的测试，
                // 而每一轮都是先预热，再正式计量。
                .forks(3)
                // 不写默认输出到控制台
                .output("E:/Benchmark.log")
                .build();

        new Runner(opt).run();
    }
```

还需要使用@State注解指定字段的共享域。在本例中，我们使用@Threads注解声明创建两个线程来执行基准测试方法，假设我们配置@State(Scope.Thread)，那么在不同线程中，gsonParser、jacksonParser这两个字段都是不同的实例。

以testGson方法为例，我们可以认为JMH会为每个线程克隆出一个gsonParser对象。如果在testGson方法中打印gsonParser对象的hashCode，你会发现，相同线程打印的结果相同，不同线程打印的结果不同。例如：




## DEMO演示

这里先演示一个DEMO，让不了解JMH的同学能够快速掌握这个工具的大概用法。

### 1. 测试项目构建

JMH是内置Java9及之后的版本。这里是以Java8进行说明。

第二种方式就是直接在现有的maven项目中添加`jmh-core`和`jmh-generator-annprocess`的依赖来集成JMH。

```xml
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.35</version>
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.35</version>
</dependency>
```

### 2. 编写性能测试

这里我以测试LinkedList 通过index 方式迭代和foreach 方式迭代的性能差距为例子，编写测试类，涉及到的注解在之后会讲解，

```java
@State(Scope.Benchmark)
@OutputTimeUnit(TimeUnit.SECONDS)
@Threads(Threads.MAX)
public class LinkedListIterationBenchMark {
    private static final int SIZE = 10000;

    private List<String> list = new LinkedList<>();
    
    @Setup
    public void setUp() {
        for (int i = 0; i < SIZE; i++) {
            list.add(String.valueOf(i));
        }
    }

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    public void forIndexIterate() {
        for (int i = 0; i < list.size(); i++) {
            list.get(i);
            System.out.print("");
        }
    }

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    public void forEachIterate() {
        for (String s : list) {
            System.out.print("");
        }
    }
}
```



### 3. 执行测试

运行 **JMH** 基准测试有两种方式，一个是生产jar文件运行，另一个是直接写main函数或者放在单元测试中执行。

我们日常中遇到的一般是一些小测试，比如我上面写的例子，直接在IDE中跑就好了。启动方式如下：

```java
 public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(LinkedListIterationBenchMark.class.getSimpleName())
                .forks(1)
                .warmupIterations(2)
                .measurementIterations(2)
                //可选，不写默认输出到控制台
                .output("E:/Benchmark.log")
                .build();

        new Runner(opt).run();
    }
```



### 4. 报告结果

输出结果如下，

最后的结果：

```apl
Benchmark                                      Mode  Cnt     Score   Error  Units
LinkedListIterationBenchMark.forEachIterate   thrpt    2  1192.380          ops/s
LinkedListIterationBenchMark.forIndexIterate  thrpt    2   206.866          ops/s
```



## 测试结果报告的参数解释

最后是关于如何阅读JMH的测试报告，这里的这份报告是上边讲解的代码案例中的测试结果。由于报告的内容量比较大，所以这里只挑报告的结果来进行讲解：

```apl
Benchmark                   Mode  Cnt         Score        Error   Units
JMHHelloWord.baseMethod    thrpt   10  14343234.962 ± 585752.043  ops/ms
JMHHelloWord.measureRight  thrpt   10    260749.234 ±   5324.982  ops/ms
JMHHelloWord.measureWrong  thrpt   10    524449.863 ±   8330.106  ops/ms
```

从报告的左往右开始介绍起：

- Benchmark 就是对应的测试方法。
- Mode 测试的模式。
- Cnt 循环了多少次。
- Score 是指测试的得分，这里因为选择了以thrpt的模式进行测试，所以分值越高表示吞吐率越高。
- Error 代表并不是表示执行用例过程中出现了多少异常，而是指这个Score的精度可能存在误差，所以前边还有个± 的符号。

关于Error的解释，在stackoverflow中也有解释：

> https://codereview.stackexchange.com/questions/90886/jmh-benchmark-metrics-evaluation





# Postman 接口测试

Postman 是一款我们在工作中使用频率非常高的 API 调试工具，估计很多童鞋在使用它时也比较粗暴，填好接口地址、参数，直接 send 就完事了。估计大家要说了，这么简单的东西还能玩出什么花来。今天就和大家安利几个非常实用、但是可能一直被忽视的功能，用完之后，简直不要太香！

## 环境变量

我们通过一个例子来看一下环境变量的用法，在一个项目的生命周期中，可能会有开发环境、测试环境、预上线环境、线上环境等众多的不同环境，这时候就可以通过环境变量来管理接口的地址以及端口。

点击左侧的`Environments`，系统中默认已经存在了一个`Globals`的全局环境，在这里可以存放一些通用的公共变量的值。先在这里写入`host`和`port`信息：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDodsJRLuibttrK5fB6XMSKfUw479Xg87jJglIggpp20ZxL4xb1gOkyx9Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在需要使用变量时，可以在访问接口时使用双大括号包裹变量，以`{{variable}}`的方式进行引用：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDo318tNtAia9ZcnqQib54InyvJ2nNbmau6TpXfDrsge77ggUKK7YIia9iaMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

除了默认的全局环境外，也可以自己创建新的环境来存放变量。在下面的例子中，创建了`local`和`test`两个环境，这样我们可以直接在两个环境间进行切换激活，简化了开发中测试接口的过程，不再需要频繁地改动接口的地址。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoEx2iao3B5ElM2Z5c0vrJh0YiaVy4dJSHm3KuHicuJLdSdtkB0HIicKicrpA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果激活的环境和全局环境中有名称重复的变量，那么当前激活的环境中的变量具有更高的优先级，它会直接覆盖`globals`环境中变量的值：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDobKWDzqgMPDkmw2SlZJx2gzhzib0ibTQBJpT6aYyB85FibJNsIO2mJcgGw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在上面，我们将环境变量分为了两类，普通环境变量和全局变量。总的来说，全局变量具有更高的使用范围，即使切换到自己创建的环境，全局变量仍然可用。但是我们自己创建的环境之间是相互隔离的，如果切换到一个环境，那么其他环境中的变量将不再可用。

像上面这样手动写入变量的值，在某些时候可能不太方便满足一些需求，因此 postman 提供了一种方法，允许使用脚本来改变环境变量的值。我们来看一下发送请求中的`Pre-request Script`和`Tests`模块，它们是在请求发送前或完成后执行的脚本，具体的使用在后面具体介绍，现在我们只需要知道能在这里执行 js 代码就可以了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoSB7LpO5Bf4NiaLlWXibw1NN3d1C5xLoTmOavj4Omzzw6FSsHPmLzugiaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

下面，在`Pre-request Script`中加入两行 js 代码：

```
pm.globals.set("key1","value1");
pm.environment.set("key2","value2");
```

执行完成请求后再次查看环境变量，全局环境和当前环境中都写入了新的值：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoVj7vo3FYicdiag0LcFCf7RvDdqSJFick8M1SyECxI6ttoQTqia4icxODRAA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

同样，也可以使用脚本删除变量：

```
pm.globals.unset("key1");
pm.environment.unset("key2");
```

除了上面的两类变量外，postman 中的`Collection`也可以存储变量。`Collection`可以理解为一个集合，通常在使用中我们会将一个应用系统中的接口放在一个集合中，集合中的变量拥有更小的使用范围，仅在当前集合内可用：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoiaXrOPxm1xLScqvLzamUkicuKtakBXlibGa71acA3he1470IkmP27q5MQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

同样，也可以在脚本中对它进行操作：

```
pm.collectionVariables.set("key3","value3");
pm.collectionVariables.unset("key3");
```

在有了环境变量的基础后，再回头看一下上面提到的`Pre-request Script`和`Tests`，它们是两个比较类似的功能，用处也非常广泛。

## Pre-request Script

### 运行 JS 脚本

`Pre-request Script`可以翻译为预请求脚本，是在请求发送前被执行的代码逻辑，可以在这里执行一些`js`代码。通过下面的简单例子进行一下演示，先准备一个后台接口，将前端传递过来的时间戳转换为时间并打印：

```
 @GetMapping("test1")
 public void time(@RequestParam("time") String time){
     Date date = new Date(Long.parseLong(time));
     System.out.println(date);
 }
```

在`Pre-request Script`中利用 js 代码获取当前时间，并放到集合变量中，在请求中传给后端：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoCTmuX5U6kUeISPmGiazibLlqgM5GJCmVDFGThV1zXMYxiczOwVPuuNOqA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

发送请求，控制台打印了前端接口的调用时间：

```
Tue Aug 01 14:14:29 CST 2021
```

### 发送 GET 请求

`Pre-request Script`的另一大用途就是，在请求当前接口前，通过执行脚本来先请求一下其他接口。在 postman 中，已经内置了`sendRequest`方法来发送`get`方法请求。我们在这里调用一个本地接口，并将信息打印到`console`控制台（可以通过 `Show Postman Console`开启）。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoPPlnfEJVfIyncLq416jWNQxW31ZbwNelrHgzekXLzbOZFVvR8AibqVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

通过控制台的打印顺序，也可以看到，是先执行了`Pre-request`中的请求后，才去执行真正目标接口的请求。直接像上面这样调用`sendRequest`时，默认发送的`get`请求，如果需要使用`post`请求、配置请求`header`或使用`json`传参的话，可以使用下面单独封装请求的方式。

### 发送 POST 请求

在这里，我们通过一个例子来演示`Pre-request Script`在具体的工作中能够怎样应用。有一个很普遍的场景，通常在调试需要权限认证的接口时，需要提前通过一个接口获取 token，然后再访问目标接口时携带这个 token。

这时就可以在`Pre-request Script`中先调用获取 token 的接口，再将 token 设置到集合的环境变量中，在之后的接口调用中引用它。在这里先准备了一个应用了`Shiro+JWT`的项目，其中通过登录接口获取 token，之后的其他接口都需要带上这个 token 用于认证 。

我们在`sendRequest`发送`get`请求的基础上，进行一些修改。首先定义一个变量，在其中使用`url`指定请求地址，`method`指定请求方法，`body`携带参数，最后使用`sendRequest`进行请求的发送。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoTXTCct1PunhU6UnNhX7Tib9ibveTeo2n7PELXoaGmadl4mEUr2uGhvow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在获取完成 token 后，通过下面的代码将获取的 token 放入了`Collection`的变量中：

```
pm.collectionVariables.set("TOKEN",response.json().data.token);
```

查看`Collection`中的变量，已经保存了刚才获取的 token：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoexhRpgNGBpFZeQOow3bpYBDuGcG95QafSQ6QcDqBq0xtrH0ayxayug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在需要认证的接口`header`中，引用这个 token，就可以正常地调用接口了：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoXshQwMc6IXgGKOhMZKtDialHgQs2qXM0FWucohbhppsRjTb7rsnG7RQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在上面的例子中，我们使用的是`urlencoded`的表单传参方式，如果接口定义是使用 json 方式传参，可以写成下面的格式：

```
body: {
  mode: 'raw',
  raw: JSON.stringify({ key: 'value' })
}
```

如果需要传递`header`请求头信息，也可以在自定义的请求中添加：

```
const loginRequest = {
  url: '...',
  header: [
      'Key1 : Value1',
      'Key2 : Value2'
  ],
  ...
};
```

具体的使用中需要添加什么字段非常的灵活，可以由我们自行进行配置。

## Tests

和`Pre-request Script`相对，`Tests`是在请求完成后执行的操作。这里我们回顾一下上面`Pre-request Script`中发送`post`请求的例子，其实可以通过`Tests`来进行改进。

因为在上面的例子中，获取到的 token 是`JWT`生成的，具有一定有效时间，在一段时间内是都可以复用的。因此我们可以先手动调用一次`login`接口获取 token，完成后在`Tests`中使用脚本将获取的 token 放入`Collection`的变量中，就不需要在每次调用接口前都调用`login`接口重复获取 token 了。

调用`login`接口并存入缓存的过程：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDovdAGuyMXdaqxK4JgSEz86S5OSI5ic231mZeaNicjfH8daREoVvSicASaA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

之后在调用其他需要携带这个 token 的接口时，使用`{{TOKEN}}`的方式，就会自动填充刚才保存的`TOKEN`值。这样在获取到新的 token 后，每个接口中的 token 都会自动更新，就不需要再手动复制到每个接口了，极大地减少了工作量。

在 postman 中，在`Collection`中可以创建`Folder`文件夹，并且集合和文件夹上也可以添加`Pre-request Script`和`Tests`脚本。我们来看一下位于`Folder`中的请求，在执行`Pre-request Script`和`Tests`时顺序是怎样的，在每个环节中加入对应的打印语句，最后输出的结果是这样的：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoHqWmkM8wACqLhrypMkcicCu85o12JZ4Jzo6eZFfVaS6VOoibRW7qvCPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

也就是说，在发送请求前，postman 会先执行所有`Pre-request Script`，并且顺序是集合最先、文件夹次之、最后是请求中的，在执行完成真正的请求后执行所有的`Tests`，顺序同上。这也就要求我们在使用`Pre-request Script`及`Tests`功能前，首先要求我们对接口的调用顺序、数据的流向有一个明确的了解，这样才能保证不会出现取不到值或更新错误的情况。



# Faker(生产假数据)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204251819019.png" alt="image-20220425181917914" style="zoom:50%;" />

## Faker 是干什么的？

Faker 是专门用来产生各种假数据的辅助工具库。

比如，你想产生个和真实数据一样的有姓名、有地址的用户。

代码库地址：https://github.com/DiUS/java-faker



## 为什么在项目里用它？

我们经常需要造数据去测试，但是，如果没有工具辅助，我们自己造数据，存在一些问题。

### 数据是需要格式的

很多关于项目，都需要一些格式上尽量能模仿真实世界的数据。

比如，国内用户的姓名，大部分都是两字、三字的姓名，叫王大，就不能叫 王da 这种。

又比如，国内的地址是 xx市xx区xx街道xx号 这种的，就不能胡写一个几个没意义的汉字来当地址。

用贴近真实格式的数据，`一来可以测出我们对用户的数据解析是否存在问题，二来可以测出数据库内的字段长度是否没问题`。所以，格式对产生出可靠地测试结果，是很重要的。



### 数据的量大

有的测试数据量都是上十万、百万的，这些量级的数据并不是只会产生一次。

甚至几乎每个项目，每个项目的每次测试，可能都会需要新的数据，需要能源源不断地产生出来。

更甚至的是，有时候还想要根据我们的要求，在恰当的时候，产生某种关系的数据，或者以某些特定频率产生。比如，两秒后产生一次数据；比如，产生一批姓王的数据。

以上这三种要求综合起来，要是我们自己造数据，那真是要了命了。

与其自己开发，不如用现成的——Faker 库被我们找到了。

`Faker库可以创造三百多种数据，而且还很容易对它进行扩展改造，去产生更多的贴合我们需求的数据。`



## 使用示例

```xml
<dependency>
    <groupId>com.github.javafaker</groupId>
    <artifactId>javafaker</artifactId>
    <version>1.0.2</version>
</dependency>
```

```java
public static void t2() {
    Faker faker = new Faker(Locale.CHINA);
    String name = faker.name().fullName();
    String firstName = faker.name().firstName();
    String lastName = faker.name().lastName();
    String streetAddress = faker.address().streetAddress();
    System.out.println(name+" "+" "+firstName+" "+lastName+" "+streetAddress);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204251820149.png" alt="image-20220425182054048" style="zoom:67%;" />

几行代码，我们需要的一个用户就有了。

```java
public static void t3() {
    Faker faker = new Faker(Locale.CHINA);
    for (int i = 0; i < 5; i++) {
        System.out.print(faker.name().fullName() + " ");
        System.out.print(faker.country().capital() + " ");
        System.out.println(faker.address().streetAddress());
        System.out.println(faker.address().streetAddress());
        System.out.println(faker.weather().temperatureCelsius());
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205101944499.png" alt="image-20220510194445444" style="zoom:80%;" />



用上 Faker 后，小伙伴们纷纷表示“有更多的时间摸鱼了”。

## 具体用例

```java
public Faker(FakeValuesService fakeValuesService, RandomService random) {
    this.randomService = random;
    this.fakeValuesService = fakeValuesService;
    this.ancient = new Ancient(this);
    this.app = new App(this);
    this.artist = new Artist(this);
    this.avatar = new Avatar(this);
    this.aviation = new Aviation(this);
    this.lorem = new Lorem(this);
    this.music = new Music(this);
    this.name = new Name(this);
    this.number = new Number(this);
    this.internet = new Internet(this);
    this.phoneNumber = new PhoneNumber(this);
    this.pokemon = new Pokemon(this);
    this.address = new Address(this);
    this.book = new Book(this);
    this.business = new Business(this);
    this.chuckNorris = new ChuckNorris(this);
    this.color = new Color(this);
    this.idNumber = new IdNumber(this);
    this.hacker = new Hacker(this);
    this.company = new Company(this);
    this.crypto = new Crypto(this);
    this.elderScrolls = new ElderScrolls(this);
    this.commerce = new Commerce(this);
    this.currency = new Currency(this);
    this.options = new Options(this);
    this.code = new Code(this);
    this.file = new File(this);
    this.finance = new Finance(this);
    this.food = new Food(this);
    this.gameOfThrones = new GameOfThrones(this);
    this.dateAndTime = new DateAndTime(this);
    this.demographic = new Demographic(this);
    this.dog = new Dog(this);
    this.educator = new Educator(this);
    this.shakespeare = new Shakespeare(this);
    this.slackEmoji = new SlackEmoji(this);
    this.space = new Space(this);
    this.superhero = new Superhero(this);
    this.team = new Team(this);
    this.bool = new Bool(this);
    this.beer = new Beer(this);
    this.university = new University(this);
    this.cat = new Cat(this);
    this.stock = new Stock(this);
    this.lordOfTheRings = new LordOfTheRings(this);
    this.zelda = new Zelda(this);
    this.harryPotter = new HarryPotter(this);
    this.rockBand = new RockBand(this);
    this.esports = new Esports(this);
    this.friends = new Friends(this);
    this.hipster = new Hipster(this);
    this.job = new Job(this);
    this.twinPeaks = new TwinPeaks(this);
    this.rickAndMorty = new RickAndMorty(this);
    this.yoda = new Yoda(this);
    this.matz = new Matz(this);
    this.witcher = new Witcher(this);
    this.dragonBall = new DragonBall(this);
    this.funnyName = new FunnyName(this);
    this.hitchhikersGuideToTheGalaxy = new HitchhikersGuideToTheGalaxy(this);
    this.hobbit = new Hobbit(this);
    this.howIMetYourMother = new HowIMetYourMother(this);
    this.leagueOfLegends = new LeagueOfLegends(this);
    this.overwatch = new Overwatch(this);
    this.robin = new Robin(this);
    this.starTrek = new StarTrek(this);
    this.weather = new Weather(this);
    this.lebowski = new Lebowski(this);
    this.medical = new Medical(this);
    this.country = new Country(this);
    this.animal = new Animal(this);
    this.backToTheFuture = new BackToTheFuture(this);
    this.princessBride = new PrincessBride(this);
    this.buffy = new Buffy(this);
    this.relationships = new Relationships(this);
    this.nation = new Nation(this);
    this.dune = new Dune(this);
    this.aquaTeenHungerForce = new AquaTeenHungerForce(this);
    this.programmingLanguage = new ProgrammingLanguage(this);
}
```





#  Wiremock

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204251821196.png" alt="image-20220425182131067" style="zoom:67%;" />

## Wiremock 是干什么的？

Wiremock 是一个可以模拟服务的测试框架`

比如，你想测试访问阿里的支付相关接口的代码逻辑，就可以用它来做测试。

**代码库地址**：https://github.com/wiremock/wiremock



## 为什么在项目里用它？

比如，我们需要调用银行接口去做资金业务，调用微信接口去做微信登录……这些调用第三方服务的测试存在一个问题：即太过依赖对方的平台。假如对方平台限制了一些 IP，或者限制了访问频率，又或者就是服务出现了维护，都会影响我们自身的功能测试。

为了解决上述问题，在之前，我们需要自己写代码模仿第三方的接口，等我们自己全部测试没问题了，再去和第三方联调。对于这种模拟出来的接口，我们称作挡板。

可是，这种方式是个苦活，没人愿意干。因为每接入一个第三方，可能都需要做挡板。辛苦做个挡板，就是单纯为了测试。如果第三方的接口做了改造，你这边还得跟着改。

大家可以想想，换成你自己，你愿意做这么件事儿吗？

这时候，Wiremock 的价值就体现出来了。有了 Wiremock，挡板这种东西就再也不存在了，`直接在单元测试里模拟测试即可`，像这样：

```java
WireMock.stubFor(get(urlPathMatching("/aliyun/.*"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader("Content-Type", APPLICATION_JSON)
                        .withBody("\"testing-library\": \"WireMock\"")));

CloseableHttpClient httpClient = HttpClients.createDefault();
HttpGet request = new HttpGet(String.format(":%s/aliyun/wiremock", port));
HttpResponse httpResponse = httpClient.execute(request);
String stringResponse = convertHttpResponseToString(httpResponse);

verify(getRequestedFor(urlEqualTo(ALIYUN_WIREMOCK_PATH)));
assertEquals(200, httpResponse.getStatusLine().getStatusCode());
assertEquals(APPLICATION_JSON, httpResponse.getFirstHeader("Content-Type").getValue());
assertEquals("\"testing-library\": \"WireMock\"", stringResponse);
```



# Retrofit

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204251818583.png" alt="image-20220425181853489" style="zoom:67%;" />

**Retrofit 是干什么的？**

Retrofit 就是一套 Http 客户端，可以用来访问第三方的 Http 服务。

比如，咱们代码里想调用一个 Http 协议的 URL，就可以用它来访问这个 URL，获取响应结果。

**为什么在项目里用它？**

在公司里，我们有些项目有如下的特点：

1. 不是基于 Spring 的项目
2. 需要经常访问大量的第三方 Http 服务
3. 访问 Http 服务的模型通常是异步回调

以前的时候，我们访问 Http 服务，都是直接用的 HttpClient。

可是吧，HttpClient 用起来实在够麻烦的。主要也存在两个问题：

1.请求参数和 URL 拼接实在繁琐

请求参数和 URL 拼接实在是太烦人了。你想想，每调用一个接口，就需要自己去拼接参数，有的 URL，甚至十几二十个参数需要拼接。

拼接这事儿简单、枯燥、重复，还没有技术含量，但是工作量却不小，时间真的算浪费了。

```java
URIBuilder uriBuilder = new URIBuilder(uriBase);
uriBuilder.setParameter("a", "valuea");
uriBuilder.setParameter("b", "valueb");
uriBuilder.setParameter("c", "valuec");
uriBuilder.setParameter("d", "valued");
uriBuilder.setParameter("e", "valuee");
uriBuilder.setParameter("f", "valuef");
uriBuilder.setParameter("g", "valueg");
uriBuilder.setParameter("h", "valueh");
uriBuilder.setParameter("i", "valuei");
...
```

2.异步回调需要自己搞

异步回调这种模型不好处理，主要就是需要自己去搞线程池，还要对线程池管理，还要考虑出错的重试之类的容错问题，实在麻烦。

所以，我们就需要一套能用法简单，不用我们一直搞拼接参数，自己搞线程管理就能完成对第三方 Http 服务访问的库。

其实我们也想过用 Feign 这套框架的。但是，这套东西和 Spring 绑定的太紧了。如果离开 Spring，它的一些功能就没法简单的通过注解直接使用，必须自己写代码调用。

而且，Feign 要实现异步回调方式使用，尤其在协程方面，还是需要自己开发。

这时候，Retrofit 就跳进了我们的选型里。

Retrofit 的模型里，异步回调模型它支持的很好，我们只需要实现一个 Callable 就够了。

并且最清爽的是，它和 Spring 没什么关系。

```java
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl("http://xxx.example.com/")
        .build();

public interface BlogService {
    @GET("blog/{id}")
    Call<ResponseBody> getBlog(@Path("id") int id);
}

BlogService service = retrofit.create(BlogService.class);

Call<ResponseBody> call = service.getBlog(2);
// 用法和OkHttp的call如出一辙,
// 回调
call.enqueue(new Callback<ResponseBody>() {
    @Override
    public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call<ResponseBody> call, Throwable t) {
        t.printStackTrace();
    }
});
```

你看，只需要写上这些代码，我们就不需要操心恼人的 Url 拼接和异步回调的管理问题了。全交给了 Retrofit，着实推荐。

**代码库地址**：https://github.com/square/retrofit



# 前端性能测试工具 ⭐

## 1. Google PageSpeed Insights⭐

> Google PageSpeed Insights可以为网站生成性能报告，它在移动设备和桌面设备上都是免费的。并且还给出了影响页面加载速度的原因，并为这些问题提供了解决方案。网站速度按照 100 分进行划分，其中：

- 大于90：较好；
- 50-90：需要改进；
- 小于50：较差

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUhVwlGicELcp7OYm0eqTxZBF9jD1P7AlwOYCDaZn38rApqgvWibFic3nHQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://pagespeed.web.dev/

## 2. Pingdom Website Speed Test

Pingdom Website Speed Test 可以全面分析影响页面Web速度的因素。此外，还可以查看网站在亚洲、欧洲等多个不同的地理位置的性能信息。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUhcrtmQSrTwgNeIzd0UsUicJ4xyia8hyCYia6fureNoAia8a4qpVBHjxQ3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://tools.pingdom.com/

## 3. WebPagetest

> WebPagetest是 AOL 开发的一款在线的免费性能评测网站，从全球多个地点运行免费网站速度测试。可以运行简单的测试或执行高级测试，包括多步骤事务、视频捕获、内容阻塞等等。还将依据测试结果提供丰富的诊断信息，包括资源加载瀑布图，页面速度优化检查和改进建议，会给每一项内容一个最终的评级。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUyzInKsGnPfneaW566txx2uFKNXYGjia8kDmWq962Gu5dAm5mM5vBbgw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUhrSbuuLGyZ4lhFgnutCNIicibQGbj4lAg18R3FB0wticcIMor94JzKwEQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://www.webpagetest.org/

## 4. GTmetrix

> GTmetrix 是一个类似于 pingdom 的工具，可以快速轻松地测试网站速度。它主要有PageSpeed和YSlow两部分组成，并提供相应的得分数据，能够真实的反应出网站的性能，并且会提供可行性建议来帮助改善网站性能。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzU3UQCo5IzLwSGwruwIPvicedFaCkkelYWExp87cWSvLO7icvrlsdTDFeg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUAmBlibxQY3nFIf2ANxFFyK2oHIjfySibesxibroPy0fgmvPAiaGDmJZmng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://gtmetrix.com/

## 5. Keycdn Tool

> Keycdn Tool 是一个在全球 10 个不同地点的网站速度测试工具。它允许测试任何页面的性能。返回的结果将提供请求、内容大小和加载时间等详细信息。此外，还有一个完整的瀑布图，详细说明每个资源的加载时间和 HTTP 头

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUNuPxibPZicdxRuU54ibXsBWfEMrc2o1BjeFuMcbKMXhCd5mT2lE9LxbibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUEX7oBq2wQeQsmosiaZSn2zR7qFuS3AeaOOUgRPZicSwgicABveCeneK0w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://tools.keycdn.com/speed

## 6. GiftOfSpeed

> GiftofSpeed是一款免费网站载入速度测试工具，可以在上面获得网站综合性能信息，它能够展示网站加载时间以及评估网站有哪些需要改进的地方，并给予一个客观的综合评分。

> GiftofSpeed 的测试结果以瀑布流展示，可以很容易看到网站加载速度，每一项资源的的载入顺序、大小与响应时间的长短，方便了解网站的各项载入资源。此外，它还提供了载入时间最长的內部文件以及外部文件，从而分析出是由哪些因素影响了你网站的载入速度，就可以专门针对这些载入时间较长的元素进行优化，从而最大限度提升网站载入速度。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUibqrIMPWPVAYUr2npR5DEu1G0sIPV7tPw7FxwLIgCyphskpicZtnA4kw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUaria5ib5Ym69ibfyicRKFBBhfmTCKxszWSKRJreDK0Tib5mGaASjKLQ74ww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://www.giftofspeed.com/

## 7. Pagelocity

> Pagelocity 是一个网站分析性能测试工具。这个工具也提供了追踪竞争对手的能力。代码检视图在类似工具中是独一无二的。如果想知道 TTFB 和图形化 DOM 元素等，都能通过这项工具获取到。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUzMvdCxAcKibR3kRNNuh90z6zrJxicZQhbiagsDvOYfpkXBJuicnX1wNT9Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" /><img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUYCmhF2oubnTUibZr63vxhf5PUqTFARuicopsJ01z4x9vRnr51HeVnAXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://pagelocity.com/

## 8. Sucuri Loadtime Tester

> Sucuri Load Time Tester 是一个网站分析性能测试工具，它用不同的颜色表示网速快慢，可以很直观地看出测试网站在不同国家的运行速度。绿色表示畅通，没有颜色的普通数字表示一般，黄色表示中等偏慢，红色表示缓慢。

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUedzXMxOMTwggkyLRsziaeDfzxThcMEeDaRXaP9rEs91hWgO7MtasU5A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

在线地址：https://performance.sucuri.net/

## 9. GEEKFLARE

> GEEKFLARE 是一套免费的性能测试工具，用于测试网站的 DNS、安全性、性能、网络和 SEO 等问题。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzU3zmTZPcAxgy9fwuAwRkI47HEZhU5hq1M6tibdOJY5nwkuJyNHHP0ojg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUPBeBy24nqf529z1GibV2KcOZooO0JVAvR9BGWFicZZhWbCBFqlST1mVw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在线地址：https://gf.dev/

## 10. Dotcom-monitor

> Dotcom-monitor 是一款网站性能测试工具，它可以选择测试的地点、设备的类型、屏幕分辨率、网络情况等来测试不同情况下的网站速度。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUCziaiaY9wiaOJiaHn1qfnpPAcD4WmzfxLERicvo8iaPhdAle6iaalHeDF3MyA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在线地址：https://www.dotcom-tools.com/website-speed-test

## 11. Dareboost

> DareBoost 是一个免费网站速度测试和网站分析工具。它提供超过 100 种不同的检查项目用以分析你的网站速度。可以测试桌面端与行动页面、Firefox 与 Chrome 和五个节点的速度差异。

![图片](https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUICckBXQIpfoIBqwbUQ31ZHVNH23ZX5m1FaGTZ3DIYiapVxYuddnMxcw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

<img src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMov8eDZGgIOdg1iaEo35HzUTOxDFNBlDFokiaiaSQoTQe7nQKhJBErUibRfmdHy4bN3KqG9AvqcgGOKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />



在线地址：https://www.dareboost.com/en



> Jmeter
>

# 性能测试概述

## 性能测试概念

### 为什么要用性能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221011685.png" alt="image-20230122101156548" style="zoom:67%;" />

### 什么是性能 & 性能测试

> 时间：系统处理用户请求的响应时间
>
> 资源：系统运行过程中，系统资源的消耗情况

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221016337.png" alt="image-20230122101629262" style="zoom:67%;" />

### 性能测试目的

#### 1 评估当前系统能力

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221019770.png" alt="image-20230122101937721" style="zoom:67%;" />

#### 2 获取关键性指标进行比较

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221020792.png" alt="image-20230122102009595" style="zoom: 67%;" />

#### 3 寻找性能瓶颈，优化性能

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221021889.png" alt="image-20230122102145838" style="zoom:67%;" />

#### 4 评估软件是否满足未来需要

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221022254.png" alt="image-20230122102201198" style="zoom:67%;" />

## 功能测试 & 性能测试

> 先做功能测试，再做性能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221026277.png" alt="image-20230122102608193" style="zoom:67%;" />

## 性能测试策略

### 基准测试

> 用途：基准测试不会单独存在，为多用户并发测试和综合场景测试提供参考依据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221033996.png" alt="image-20230122103304918" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221034089.png" alt="image-20230122103453996" style="zoom:67%;" />

### 负载测试

#### 什么是负载测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221039983.png" alt="image-20230122103923925" style="zoom:67%;" />

#### 电梯案例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221042921.png" alt="image-20230122104230858" style="zoom:67%;" />

### 稳定性测试

#### 为什么要进行稳定测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221046269.png" alt="image-20230122104609163" style="zoom:67%;" />

#### 稳定测试概念

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221049868.png" alt="image-20230122104925809" style="zoom:67%;" />



### 并发测试

#### 为什么进行并发测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221106195.png" alt="image-20230122110603137" style="zoom:67%;" />

#### 并发测试概念

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221132516.png" alt="image-20230122113254463" style="zoom:67%;" />



### 压力测试

#### 为什么要压力测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221101020.png" alt="image-20230122110101890" style="zoom:67%;" />

#### 压力测试概念

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221103972.png" alt="image-20230122110304919" style="zoom:67%;" />



## 性能测试指标

### 响应时间

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221342977.png" alt="image-20230122134203922" style="zoom:67%;" />

> 通过HTTP接口请求消息来测试
>
> 不包括 **发消息时前端页面的处理时间** 和 **收到消息后前端页面的渲染显示时间**

![image-20230122134511026](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221345562.png)

### 并发数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221346997.png" alt="image-20230122134623887" style="zoom:60%;" />

### 吞吐量

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221349317.png" alt="image-20230122134939250" style="zoom: 67%;" />

### QPS

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221416257.png" alt="image-20230122141657211" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221417504.png" alt="image-20230122141736445" style="zoom:67%;" />

### TPS

> 事务：即业务，页面上的一次请求，可能对应一个或多个请求

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221451830.png" alt="image-20230122145122790" style="zoom:67%;" />

![image-20230122145339322](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221453409.png)

### 点击数

> **只有web项目才有此指标，点击数不是页面上的一次点击**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221455506.png" alt="image-20230122145521462" style="zoom:67%;" />

### 错误率

> **大多数系统都会要求错误率无限接近于0，错误率是一个性能指标，不是功能上的随机bug**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221457081.png" alt="image-20230122145727042" style="zoom: 67%;" />

### 资源利用率

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221501454.png" alt="image-20230122150159411" style="zoom:67%;" />

根据经验，资源指标通常要求

> - CPU不高于75%-85%
> - 内存不高于80%
> - 磁盘IO不高于90%
> - 网络不高于80%

## 性能测试流程

### 整体流程

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221512283.png" alt="image-20230122151230212" style="zoom:67%;" />

### 需求分析


### 计划和方案

> 测什么：项目背景，测试目的，测试范围
>
> 谁来测：进度与分工，交付清单
>
> 怎么测：测试策略

###  性能测试用例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221521462.png" alt="image-20230122152154388" style="zoom:67%;" />

### 性能测试执行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221606167.png" alt="image-20230122160615093" style="zoom:67%;" />

### 性能测试调优

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221607506.png" alt="image-20230122160747462" style="zoom:67%;" />

> 调优：开发人员为主导，数据库管理员，系统管理员，网络管理员，性能测试分析人员配合进行
>
> 验证：性能测试人员继续进行第二轮，第三轮的测试，与以前的测试结果进行对比，判断调整后系统是否提升

# Jmeter 压测工具

[48张图|手摸手教你性能监控、压测和调优 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU1NTkwODE4Mw==&mid=2247495751&idx=1&sn=dcaa50097b5cac9f85b292df20280e20&chksm=fbcf9d7fccb814699550645081b8776c12dc369d0b18bf3342ac8795d0b1bb6e94151e49ef76&mpshare=1&scene=23&srcid=0511fdLZpWUw8EeMF54TGdLm&sharer_sharetime=1652228096399&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

性能监控、压测和调优

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111933053.png" alt="image-20220511193342002" style="zoom:80%;" />

## 主流性能测试工具

> 日常项目测试JMeter足够用，出商业报告优先Loadrunner

### Loadrunner

![image-20230122162413457](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221624517.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221624883.png" alt="image-20230122162426837" style="zoom:67%;" />

### JMeter

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221626375.png" alt="image-20230122162655336" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221627942.png" alt="image-20230122162727905" style="zoom:67%;" />



## Jmeter 安装和配置

> 先提前装好JDK

### 下载Jmeter 工具

下载地址：https://jmeter.apache.org/download_jmeter.cgi，Linux是上面那个

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111936252.png" alt="image-20220511193632197" style="zoom:80%;" />

```sh
# 安装JDK
sudo apt-get install openjdk-8-jdk
java -version
```

```sh
tar -zxvf apache-jmeter-5.5.tgz
cd /root/apache-jmeter-5.5/bin
touch jmeter.log
chmod 777 jmeter.log
vim /etc/profile
```

```sh
# 配置环境变量
export JMETER_HOME=/root/apache-jmeter-5.5
export CLASSPATH=$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$CLASSPATH
export PATH=$JMETER_HOME/bin:$PATH
```

```sh
source /etc/profile
```

```sh
jmeter -v
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222029044.png" alt="image-20230122202908958" style="zoom:67%;" />

### 修改成中文

#### 临时修改

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221651571.png" alt="image-20230122165155516" style="zoom:67%;" />

#### 永久修改

> 文件在bin目录下

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111940535.png" alt="image-20220511194000485" style="zoom: 67%;" />

### 修改响应结果乱码

> 修改jmeter.properties文件即可

```sh
# The encoding to be used if none is provided (default ISO-8859-1)
sampleresult.default.encoding=UTF-8
```



### 运行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221637478.png" alt="image-20230122163707415" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221637117.png" alt="image-20230122163744041" style="zoom:67%;" />

## JMeter 常用目录

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221648179.png" alt="image-20230122164831096" style="zoom:67%;" />

![image-20230122165026227](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221650307.png)

## 元件和组件 ⭐

### 元件

> 元件：类似功能组件的容器，类似于Java中的类

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221655189.png" alt="image-20230122165550146" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221657875.png" alt="image-20230122165705792" style="zoom:67%;" />

### 组件

> 实现独立的某个功能(类似于类中的方法)

![image-20230122170104662](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221701758.png)

### 应用场景

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221702782.png" alt="image-20230122170245732" style="zoom:67%;" />

### 元件的作用域

> 元件的作用域是靠测试计划的树型结构中元件的父子关系来确定的
>
> 所有的组件都是**以取样器为核心**来运行的，组件添加的位置不同，生效的取样器也不同

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221704472.png" alt="image-20230122170423428" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221707474.png" alt="image-20230122170724420" style="zoom:67%;" />

### 元件的执行顺序

> 按照测试计划中顺序从上到下依次执行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221709223.png" alt="image-20230122170906186" style="zoom:67%;" />

## Hello World

> 使用JMeter访问百度首页，并查看请求和响应信息

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221712042.png" alt="image-20230122171213000" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221742660.png" alt="image-20230122174218609" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221742757.png" alt="image-20230122174240720" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221742532.png" alt="image-20230122174256466" style="zoom:67%;" />

## 线程组 ⭐

### 线程组概述

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301221827867.png" alt="image-20230122182756779" style="zoom:67%;" />

### 线程组分类

> 线程组：普通、常用的线程组，可以看做一个虚拟用户组，线程组中的每一个线程可以当作一个虚拟用户
>
> setUp线程组：一种特殊类型的线程组，可用于执行预测试操作
>
> tearDown线程组：一种特殊类型的线程组，可用于执行测试后工作，即最后执行

### 线程组属性参数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222051140.png" alt="image-20230122205129048" style="zoom:67%;" />

### 访问百度--线程组

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222053014.png" alt="image-20230122205250352" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222110569.png" alt="image-20230122211022523" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222058775.png" alt="image-20230122205835729" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222059031.png" alt="image-20230122205945995" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222101633.png" alt="image-20230122210105592" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222105872.png" alt="image-20230122210522824" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222108820.png" alt="image-20230122210837775" style="zoom:67%;" />

## HTTP 请求

### 参数分析

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222111597.png" alt="image-20230122211116470" style="zoom:67%;" />

### HTTP 请求案例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222114566.png" alt="image-20230122211401478" style="zoom: 50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222116530.png" alt="image-20230122211636488" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222117454.png" alt="image-20230122211759403" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222118452.png" alt="image-20230122211855401" style="zoom:67%;" />




## 参数化

### 为什么要参数化

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222124497.png" alt="image-20230122212456449" style="zoom:67%;" />

> 参数化测试：把测试数据组织起来，用不同的测试数据调用相同的测试方法

### 常见的参数化方式

> - 用户定义的变量
> - 用户参数
> - CSV Data Set Config
> - 函数

### 用户定义的变量

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222128098.png" alt="image-20230122212814024" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222130163.png" alt="image-20230122213055097" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222129056.png" alt="image-20230122212908981" style="zoom:67%;" />

### 用户参数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222133635.png" alt="image-20230122213301103" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222134381.png" alt="image-20230122213420316" style="zoom:67%;" />

### CSV数据文件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222136642.png" alt="image-20230122213631572" style="zoom:67%;" />

> 注意：CSV第一行如果带了用户名，密码等表头，忽略首行就要设置成true

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222141572.png" alt="image-20230122214125534" style="zoom: 80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222139050.png" alt="image-20230122213951990" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222138598.png" alt="image-20230122213859539" style="zoom:67%;" />

### 函数方式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222143043.png" alt="image-20230122214309988" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222144273.png" alt="image-20230122214410200" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301222145076.png" alt="image-20230122214504002" style="zoom:67%;" />

## 运行 JMeter 程序

打开批处理文件：\apache-jmeter-5.4.3\bin\jmeter.bat。如下图所示

JMeter安装完了，那我们来一个简单的实验。性能测试当然得有个测试目标，就是被测系统是什么，xmeter君这里就以测度娘为例来描述构造一个简单的性能测试过程：xmeter君保证你在5分钟之内完成一次测试体验。

### 添加虚拟用户组

如下图所示，右击“测试计划”>添加>Threads（Users）>线程组。这里xmeter君需要解释一下“线程组”的意思：JMeter是由Java实现的，并且使用一个Java线程来模拟一个用户，因此线程组（Thread Group）就是指一组用户的意思，换句话说一个线程组就是一组虚拟用户（virtual users），这些虚拟用户用来模拟访问被测系统。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207291533896.png" alt="image-20220729153353797" style="zoom: 50%;" />

### 线程组配置⭐

接下来xmeter君给大家介绍下“线程组”中常用到的一些设置。

> 1）线程数：这里就是指虚拟用户数，默认的输入是“1”，则表明模拟一个虚拟用户访问被测系统，如果想模拟100个用户，则此处输入100。

> 2）Ramp-Up Period (in seconds): 虚拟用户增长时长。不明白别着急，xmeter君给你举个栗子：比如你测试的是一个考勤系统，那么实际用户登录使用考勤系统的时候并不是大家喊1、2、3 - 走起，然后一起登录。实际使用场景可能是9点钟上班，那么从8:30开始，考勤系统会陆陆续续有人开始登录，直到9:10左右，那么如果完全按照用户的使用场景，设计该测试的时候此处应输入40（分钟）* 60（秒）= 2400。
>
> 但是实际测试一般不会设置如此长的Ramp-Up时间，原因嘛，难道你做一次测试要先等上40分钟做登录操作？一般情况下，可以估计出登录频率最高的时间长度，比如此处可能从8:55到9:00登录的人最多，那这里设置成300秒，如果“线程数”输入为100，则意味着在5分钟内100用户登录完毕。
>
> Ramp-Up Period=0：代表同时并发

> 3）循环次数：该处设置一个虚拟用户做多少次的测试。默认为1，意味着一个虚拟用户做完一遍事情之后，该虚拟用户停止运行。如果选中“永远”，则意味着测试运行起来之后就根本停不下来了，除非你把它强制咔嚓。

`1s 内启动 200 个线程，循环次数 100 次。2 w 个请求`。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111942777.png" alt="image-20220511194205725" style="zoom:67%;" />

### 添加被测页面

接下来的一步就是要加入实际被测页面，右击“线程组” > “添加” > “Sampler” > “HTTP请求”。

测试 HTTP 请求，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111944282.png" alt="image-20220511194451219" style="zoom:80%;" />

配置要测试的协议、服务器地址、端口号。配置信息如下：

协议：使用 http 协议。

服务器名称或 IP: www.baidu.com (只是为了演示)。

端口号：80 端口。

接下来需要设置一下“HTTP请求” Sampler的属性，如下所示：

1）名称：输入“百度”，就是被测试网页的描述性文字

2）服务器名称或IP：被测服务器的网站名字，也可以是IP地址。剩下的属性可以按照被测系统的属性按需配置，现在都可以为空。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207291539804.png" alt="image-20220729153938736" style="zoom:67%;" />

现在的测试脚本已经可以运行了，先点击下面如图所示的第一步：点击保存脚本按钮；然后点击如图所示的第二步：点击运行测试按钮。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207291540098.png" alt="image-20220729154044023" style="zoom:80%;" />

等等，xmeter君，为什么我的测试跑完了没啥反应？嗯，其实测试已经跑完了，你可以去“选项” > “Log Viewer”看看运行的日志。如果你还是看不到日志，你可以点击下面所示的三角箭头展开或者收起日志视图。日志视图中可以看到“线程组 1-1”的启动和结束时间，表明测试已经跑完。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207291540362.png" alt="image-20220729154058289" style="zoom:80%;" />

这JMeter运行看着也太不直观了吧？那如果我的测试有问题了，怎么发现啊？别着急，JMeter提供了“监听器”让用户来观察测试结果。

### 查看结果树

如下图所示，右击“线程组” > “监听器” > “察看结果树”来查看性能测试过程中请求和响应信息。添加完毕后，保存测试脚本，再次运行。

添加查看结果树、汇总报告和聚合报告。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111947296.png" alt="image-20220511194704231" style="zoom:80%;" />

#### 开始压力测试

点击播放按钮就开始启动了。注意启动之前需要先设置线程组的参数配置和 HTTP 请求的配置。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111947724.png" alt="image-20220511194739676" style="zoom:80%;" />

查看每个请求结果，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111949111.png" alt="image-20220511194900059" style="zoom:80%;" />

#### 查看汇总报告

主要关心平均值和吞吐量。

200 个线程，每个线程调用 100 次，总共 2 w 次，可以看到下图中表格中的样本列也是 2 w，请求所耗费的时间是 151 ms，吞吐量是 880 个请求每秒。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205111952838.png" alt="image-20220511195253788" style="zoom:80%;" />



#### 查看聚合报告

主要看中位数和90%百分位，

**中位数**是 59 ms，说明大部分请求的响应时间是 59 ms。

**90 % 的请求** 都是在 271 ms 以内响应完成的。

**异常 0.41%** 说明 2 w 个请求中有 82 个请求异常（20000 * 0.0041 = 82 ）。

**吞吐量 880.2/sec** 说明百度这个网站每秒能处理 880 个请求，性能一般（可能跟本地机器性能有关）。

如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112013113.png" alt="image-20220511201316061" style="zoom:80%;" />

#### 查看汇总图

查看汇总图时，需要先勾选想要查看的信息，如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112013657.png" alt="image-20220511201301593" style="zoom:80%;" />

然后查看图形汇总：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112012372.png" alt="image-20220511201243323" style="zoom:80%;" />

可以看到勾选的几列在图表中是用不同颜色表示的，比如绿色的柱状条就是 90 % 百分位。

我们来测试下 PassJava（佳必过）的管理后台的性能，吞吐量接近 2000/s。如下图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205112012376.png" alt="image-20220511201227325" style="zoom:80%;" />

# 断言

## 为什么要用断言

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231131107.png" alt="image-20230123113116054" style="zoom:67%;" />

## 响应断言

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231133832.png" alt="image-20230123113355737" style="zoom:67%;" />

### 测试字段-实际结果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231135649.png" alt="image-20230123113557602" style="zoom:67%;" />

### 模式匹配规则-比较方式

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231137558.png" alt="image-20230123113742498" style="zoom:60%;" />

### 预期结果

> 即填写你指定的结果(可填写多个)，按钮【添加】、【删除】是进行指定内容的管理

### 案例练习

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231141006.png" alt="image-20230123114103939" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231146421.png" alt="image-20230123114612350" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231146428.png" alt="image-20230123114649365" style="zoom:67%;" />

## JSON断言

### 语法详解

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231149336.png" alt="image-20230123114933242" style="zoom:67%;" />

### 案例练习

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231151168.png" alt="image-20230123115106531" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231204115.png" alt="image-20230123120411056" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231204838.png" alt="image-20230123120440783" style="zoom:67%;" />

![image-20230123120505478](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231205515.png)

## 断言持续时间

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231206403.png" alt="image-20230123120629336" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231207185.png" alt="image-20230123120724119" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231209751.png" alt="image-20230123120904695" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231209075.png" alt="image-20230123120938024" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231210472.png" alt="image-20230123121002416" style="zoom:67%;" />

# 关联

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231213472.png" alt="image-20230123121324405" style="zoom:60%;" />

## 什么是关联

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231214614.png" alt="image-20230123121456564" style="zoom:67%;" />

> 常用关联方法：正则表达式提取器、XPATH提取器、JSON提取器

## 正则表达式提取器

### 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231217918.png" alt="image-20230123121748820" style="zoom:67%;" />

### 案例练习

![image-20230123121936385](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231219469.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231224874.png" alt="image-20230123122420802" style="zoom:67%;" />

> **模板表示匹配第几个(.*?)，因为表达式可能有多个(.\*?)进行匹配**
>
> **匹配数字很重要，因为可能会匹配很多个数据，匹配数字表示选择第几个，-1表示获取所有结果**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231225466.png" alt="image-20230123122507402" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231225114.png" alt="image-20230123122533050" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231225509.png" alt="image-20230123122556435" style="zoom:67%;" />

其他案例

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231228966.png" alt="image-20230123122805921" style="zoom:80%;" />

## XPATH提取器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231240611.png" alt="image-20230123124003447" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231240328.png" alt="image-20230123124049228" style="zoom:67%;" />



![image-20230123124640477](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231246553.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231247362.png" alt="image-20230123124747294" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231248006.png" alt="image-20230123124805941" style="zoom:67%;" />

![image-20230123124827670](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231248108.png)

## JSON 提取器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231249581.png" alt="image-20230123124938496" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231251657.png" alt="image-20230123125103576" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231253311.png" alt="image-20230123125358248" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231254340.png" alt="image-20230123125414258" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231254459.png" alt="image-20230123125430379" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231254154.png" alt="image-20230123125450086" style="zoom:80%;" />

## JMeter 属性

### 为什么要用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231256675.png" alt="image-20230123125617615" style="zoom:67%;" />

### 配置函数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231345454.png" alt="image-20230123134504358" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231345064.png" alt="image-20230123134549997" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231359372.png" alt="image-20230123135909298" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231359701.png" alt="image-20230123135931640" style="zoom:67%;" />

工具---->函数对话框

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231351411.png" alt="image-20230123135135344" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231400010.png" alt="image-20230123140000944" style="zoom:67%;" />

> 另一个线程组

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231400257.png" alt="image-20230123140024191" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231400512.png" alt="image-20230123140046448" style="zoom:67%;" />

# 脚本录制

## JMeter 录制脚本

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231402856.png" alt="image-20230123140218766" style="zoom:67%;" />

## 录制脚本过程

![image-20230123140539470](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231405636.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231406910.png" alt="image-20230123140620720" style="zoom:67%;" />

## 实战演示

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231408634.png" alt="image-20230123140834585" style="zoom:67%;" />



# 直连数据库

## 使用场景

![image-20230123104213585](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231042675.png)

## 关键配置

### mysql-connector-java

指导网站：https://blog.csdn.net/T_Y_F_/article/details/125194749

下载地址：https://downloads.mysql.com/archives/c-j/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231055132.png" alt="image-20230123105457432" style="zoom: 50%;" />

添加MySQL Jar包

> 方式一：在测试计划面板点击浏览按钮，将你的JDBC驱动添加进来 当前线程组有效
>
> 方式二：将MySQL驱动jar包放在lib/ext目录下，重启JMeter 全部有效

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231053320.png" alt="image-20230123105351228" style="zoom:67%;" />

> 配置数据库连接：添加方式：测试计划--线程组--配置元件---JDBC Connection Configuration

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231101742.png" alt="image-20230123110146668" style="zoom:50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231113507.png" alt="image-20230123111310421" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231109553.png" alt="image-20230123110910488" style="zoom: 50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231114448.png" alt="image-20230123111407364" style="zoom:50%;" />

> 直接启动即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231115503.png" alt="image-20230123111512440" style="zoom:67%;" />

## 添加JDBC请求

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231104767.png" alt="image-20230123110440686" style="zoom:67%;" />

## 搜索结果断言

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231411198.png" alt="image-20230123141140091" style="zoom:67%;" />

![image-20230123141329863](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231413977.png)

![image-20230123141457599](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231415729.png)

![image-20230123141611422](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231417029.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231417311.png" alt="image-20230123141759234" style="zoom:67%;" />

# 控制器

## 循环控制器

> 连续访问百度10次

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231422810.png" alt="image-20230123142227752" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231423131.png" alt="image-20230123142300068" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231423343.png" alt="image-20230123142315268" style="zoom:67%;" />

## IF 控制器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231424674.png" alt="image-20230123142459572" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231426348.png" alt="image-20230123142647276" style="zoom:67%;" />

![image-20230123142900525](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231429590.png)

![image-20230123142936484](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231429597.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231430070.png" alt="image-20230123143011955" style="zoom:67%;" />

![image-20230123143053300](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231430396.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231431042.png" alt="image-20230123143112951" style="zoom:67%;" />

## Foreach 控制器

### 基本语法

![image-20230123143313421](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231433515.png)

### 案例演示

![image-20230123143357246](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231433340.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231438471.png" alt="image-20230123143847413" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231438647.png" alt="image-20230123143831579" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231439232.png" alt="image-20230123143903166" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231439308.png" alt="image-20230123143928246" style="zoom:67%;" />

### 案例演示2

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231441317.png" alt="image-20230123144104207" style="zoom: 50%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231448045.png" alt="image-20230123144828983" style="zoom:67%;" />

![image-20230123144846697](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231448762.png)

![image-20230123144858548](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231448605.png)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231449933.png" alt="image-20230123144908871" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231449772.png" alt="image-20230123144927703" style="zoom:67%;" />

# 定时器

## 同步定时器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231527780.png" alt="image-20230123152743715" style="zoom:50%;" />

### 什么是同步定时器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231528281.png" alt="image-20230123152851150" style="zoom: 50%;" />

### 如何使用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231529898.png" alt="image-20230123152948804" style="zoom:60%;" />

### 案例演示

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231530919.png" alt="image-20230123153053845" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231534014.png" alt="image-20230123153433950" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231534019.png" alt="image-20230123153445965" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231534985.png" alt="image-20230123153457919" style="zoom:67%;" />

![image-20230123153506539](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231535613.png)

## 常数吞吐量定时器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231538935.png" alt="image-20230123153817878" style="zoom:67%;" />

### 使用方法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231540224.png" alt="image-20230123154040130" style="zoom:60%;" />

### 案例演示

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231541839.png" alt="image-20230123154138769" style="zoom:60%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231544097.png" alt="image-20230123154458032" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231545204.png" alt="image-20230123154510136" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231545768.png" alt="image-20230123154523712" style="zoom:67%;" />

## 固定定时器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231550395.png" alt="image-20230123155003327" style="zoom: 80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231552095.png" alt="image-20230123155223040" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202301231553211.png" alt="image-20230123155313159" style="zoom:67%;" />

















































































