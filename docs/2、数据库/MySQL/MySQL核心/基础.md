

# 数据库概述

## 为什么学数据库

### 为什么学

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241033415.png" alt="image-20230224103318260" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241032843.png" alt="image-20230224103256726" style="zoom:80%;" />

### 学习规划⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241036213.png" alt="image-20230224103604116" style="zoom: 80%;" />

### 详细规划⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241037364.png" alt="image-20230224103748258" style="zoom:67%;" />



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206161925079.png" alt="image-20220616192521001" style="zoom:67%;" />

## 数据库基础概念

### 数据库

> Database，简称DB：按照一定的数据结构来组织、存储和管理数据的仓库

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191040174.png" alt="image-20220919104038052" style="zoom:80%;" />

### 数据库管理系统

#### DBMS

> DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据，操纵和管理数据库的大型软件

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191041903.png" alt="image-20220919104122798" style="zoom:80%;" />

#### 关系型数据库RDBMS

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241043242.png" alt="image-20230224104331154" style="zoom:80%;" />

#### 非关系型数据库NoSQL

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241044022.png" alt="image-20230224104406949" style="zoom:67%;" />

#### 主流数据库管理系统⭐

而目前主流的关系型数据库管理系统的市场占有率排名如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241045899.png" alt="image-20230224104524797" style="zoom:80%;" />

> Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。

> MySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。

> SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用
>
> PostgreSQL：开源免费的中小型数据库
>
> DB2：IBM公司的大型收费数据库产品
>
> SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。
>
> MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、衍生产品，与MySQL数据库有兼容性

### SQL

> SQL:结构化查询语言，用于和DBMS通信的语言，定义了一套操作关系型数据库统一**标准**

> 不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，因为我们前面讲到SQL语言，是操作关系型数据库的 **统一标准** 。所以即使我们现在学习的是MySQL，假如我们以后到了公司，使用的是别的关系型数据库，如：Oracle、DB2、SQLServer，也完全不用担心，因为操作的方式都是一致的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191044047.png" alt="image-20220919104445951" style="zoom:80%;" />

### 数据模型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191051228.png" alt="image-20220919105120111" style="zoom:80%;" />

## SQL的语言分类⭐

> SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL

> DQL（Data Query Language）：数据查询语言：select 
>
> DML(Data Manipulate Language):数据操作语言：insert 、update、delete
>
> DDL（Data Define Languge）：数据定义语言：create、drop、alter
>
> TCL（Transaction Control Language）：事务控制语言commit、rollback

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191054334.png" alt="image-20220919105404232" style="zoom:80%;" />



# 安装和启动

## Windows版

### 安装MySQL

> **1). 双击官方下来的安装包文件**

![image-20210916184347938](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184347938.png) 

> **2). 根据安装提示进行安装**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184532212.png" alt="image-20210916184532212" style="zoom:67%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184603712.png" alt="image-20210916184603712" style="zoom: 74%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184634094.png" alt="image-20210916184634094" style="zoom:70%;" /> 

> 安装MySQL的相关组件，这个过程可能需要耗时几分钟，耐心等待。
>

![image-20210916184700031](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184700031.png) 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184709776.png" alt="image-20210916184709776" style="zoom:96%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184743524.png" alt="image-20210916184743524" style="zoom:80%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184759021.png" alt="image-20210916184759021" style="zoom:80%;" /> 

> ==输入MySQL中root用户的密码,一定记得记住该密码==

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184814656.png" alt="image-20210916184814656" style="zoom:85%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184832159.png" alt="image-20210916184832159" style="zoom:85%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210916184851013.png" alt="image-20210916184851013" style="zoom:87%;" /> 

###  配置环境变量

> 安装好MySQL之后，还需要配置环境变量，这样才可以在任何目录下连接MySQL。
>

> 1). 在此电脑上，右键选择属性

![image-20210918161550977](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210918161550977.png) 

> 2). 点击左侧的 "高级系统设置"，选择环境变量

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210918161646433.png" alt="image-20210918161646433" style="zoom:80%;" /> 

> 3). 找到 Path 系统变量, 点击 "编辑"

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210918161803544.png" alt="image-20210918161803544" style="zoom:80%;" /> 

> 4). 选择 "新建" , 将MySQL Server的安装目录下的bin目录添加到环境变量

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210918161954696.png" alt="image-20210918161954696" style="zoom:80%;" /> 

### 修改配置文件

> 进入服务，查看配置文件位置
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230622102824861.png" alt="image-20230622102824861" style="zoom: 50%;" />

> 修改datadir，进入my.ini，datadir="D:\mysql8Data"
>

> 在D盘创建mysql8Data，然后将C:\ProgramData\MySQL\MySQL Server 8.0\Data下的内容复制到该目录

> 必须进行复制，不然无法启动
>



# 基础命令⭐

## 启动和停止

方式一：计算机——右击管理——服务，查看MySQL80服务，进行重启、暂停等操作

方式二：通过管理员身份运行

```apl
systemctl start mysqld
```

```apl
systemctl restart mysqld
```

```apl
systemctl stop mysqld
```

## 命令行登录

```apl
mysql 【-h主机名 -P端口号 】-u用户名 -p密码
```

```apl
mysql -uroot -p123456
mysql -uroot -p123456 -P 3307 
mysql -uroot -p123456 -h 192.168.0.155 -P 3307 
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209081227032.png" alt="image-20220908122707748" style="zoom:80%;" />

## 修改默认端口号

> 使用everything搜索my.ini

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241103288.png" alt="image-20230224110304213" style="zoom:67%;" />

> 打开之后搜索port，进行修改成3306，注意有两个port，都要修改成3306，之后重启MySQL80服务即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241104799.png" alt="image-20230224110435694" style="zoom:80%;" />

## 基本命令⭐

```SQL
#1.查看当前所有的数据库
show databases;
# 查询当前数据库
select database();

#2.打开指定的库
use 库名

#3.查看当前库的所有表
show tables;

#4.查看其它库的所有表
show tables from 库名;

#5.创建表
create table 表名(
	列名 列类型 主键,
	列名 列类型，
	...
);

#6.查看表结构
desc 表名;
describe 表名;

#7.查看服务器的版本
#方式一：新建查询
select version();

#方式二：在cmd里进行查看，要配置好环境变量，不然会出错 
mysql --version
#8.查询表中所有数据
select * from 表名;
```

### 查看连接的客户端详情

每个 MySQL 命令行窗口就是一个 MySQL 客户端，每个客户端都可以单独设置（不同的）事务隔离级别，这也是演示 MySQL 并发事务的基础。以下是查询客户端连接的 SQL 命令：

```sql
show processlist;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202206301704616.png" alt="image-20220630170442553" style="zoom:67%;" />

### 查询连接客户端的数量

可以使用以下 SQL 命令，查询连当前接 MySQL 服务器的客户端数量：

```sql
show status like 'Threads%';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202206301705716.png" alt="image-20220630170515658" style="zoom: 67%;" />

# 常见数据类型

> 所选择的类型越简单越好，能保存数值的类型越小越好

## 数值类型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241716633.png" alt="image-20230224171654542" style="zoom:80%;" />

## 字符串型

> char(10)   -------->存放1个字符也会占用10个字符空间，用空格补位，性能好，性别 ： gender  char(1)
>
> varchar(10) ----->存放1个字符就占用1个字符空间，性能较差，原因是要计算占用空间 ：username  varchar(50)

> MySQL 中的 `BLOB` 和 `TEXT` 字段类型可以存储数据量较大的文件，可以使用这些数据类型 存储图像、声音或者是大容量的文本内容，例如网页或者文档。虽然使用 BLOB 或者 TEXT 可 以存储大容量的数据，但是对这些字段的处理会降低数据库的性能。**📢 注意：** **如果并非必要，可以选择只储存文件的路径**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206161834924.png" alt="image-20220616183457829" style="zoom: 80%;" />

MySQL 是 **`不区分大小写`** 的，因此字符串比较函数也不区分大小写。

如果想执行区分大小写的比较，可以在字符串前面添加 BINARY 关键字。

```sql
-- 结果分别为1，0
select 'DOG' = 'dog';
select BINARY 'DOG' = 'dog';
```

## 日期型

> 日期赋值时，允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，'98-12-31 11:30:45'、'98.12.31 11+30+45'、'98/12/31 11*30*45'和'98@12@31 11^30^45'是等价的，对于不合法的将会转换为：0000-00-00 00:00:00

### 基本语法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206161834378.png" alt="image-20220616183434274" style="zoom:80%;" />

### 实战演练

> 创建时加入创建时间和更新时间，修改时修改更新时间，很重要的方法

```sql
create table home(
    id int auto_increment primary key ,
    name varchar(100) ,
    create_time datetime default now(),
    update_time datetime default now() on update now()
);
```

```sql
-- 下面进行插入数据测试
insert into home(id,name) values (null,'张三');
insert into home(id,name) values (null,'李四');
```

```sql
-- 更新数据，查看时间
update home set name = '二百五' where id = 1;
alter table home add column is_deleted int default 0;
update home set name = '小六子' where id = 2;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302241950377.png" alt="image-20230224195026296" style="zoom:80%;" />

### 如何选择

你会推荐使用 datetime 还是 timestamp 字段？为什么？

> 正如MySQL文档描述的那样——datetime的范围是“1000-01-01 00:00:00”到“9999-12-31 23:59:59”，而timestamp的范围是 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC。如果不想程序在2038年出问题，从这个方面作者建议还是使用datetime。

> 有一种观点是既不使用 DATETIME 也不使用 TIMESTAMP 字段。如果想将特定的一天作为一个整体来表示（例如生日），可以使用 DATE 类型，但是如果需要更具体的时间，不要使用 DATETIME 或 TIMESTAMP，**而是使用 BIGINT，并简单地存储自纪元以来的毫秒数（如果使用的是 Java，则为 System.currentTimeMillis()）**

这样有几个优点

> 可以在迁移数据库时避免因为数据类型差异，比如MySQL的DATETIME类型和Oracle的DATETIME类型之间可能存在差异，timestamp类型的精度可能也存在差异，MySQL的timestamp精度不是一开始就支持毫秒精度的。

> 没有时区问题，无论是哪个时区，因为开始计算的时间不同，无论当前时间如何，跨度是一致的。

> 没有timestamp和datatime的范围问题，哪怕是datatime，8000年以后也不能用了，没准我的数据库8000年能用8000年呢。

> 需要注意的是，bigint是占用8个字节，而timestamp只占用4个字节。从MySQL 5.6.4开始，Datetime的存储空间变成了5个字节了(准确的说应该是5字节+0~3个字节的FSP分秒精度）。

### timestamp问题分析

#### 时区问题

> TIMESTAMP支持的时间范围从1970-01-01 00:00:01.000000到2038-01-19 03:14:07.999999，使用了TIMESTAMP的应用很有可能在2038-01-19 03:14:07.999999之后宕机，同样面临这个问题的还有所有的类Unix系统，因为他们使用了time_t这一32位数字来表示时间，这就是著名的**2038年问题**。

但是`TIMESTAMP`的一些设计却非常鬼畜，比如：

- 如果表中包含`TIMESTAMP`的列，那么其建表语句有可能被系统篡改，取决于MySQL的版本和参数设置。
- 当`MySQL`参数`time_zone=system`时，高并发可能会引起CPU使用率暴涨，系统响应变慢甚至假死
- 如果存入超过范围的时间，在非严格状态下，MySql不会报错，反而会插入`'0000-00-00 00:00:00'`

虽然通过`TIMESTAMP`可以自动转换时区，代价是当`MySQL`参数`time_zone=system`时每次都会尝试获取一个全局锁，这在高并发的环境下无疑是致命的，可能会导致线程上下文频繁切换，CPU使用率暴涨，系统响应变慢甚至假死。

现在用`TIMESTAMP`比较少了，的确也应该尽量避免使用`TIMESTAMP`，MySQL在`TIMESTAMP`的设计上实在是蹩脚，如果你正在维护一个老的系统，涉及到`TIMESTAMP`的改动需要格外注意，尽量要在充分的测试后再上线。

#### 性能问题

前面已经提及，`TIMESTAMP` 的上限值 2038 年很快就会到来，那时业务又将面临一次类似千年虫的问题。另外，`TIMESTAMP` 还存在潜在的性能问题。

> 虽然通过`TIMESTAMP`可以自动转换时区，代价是当`MySQL`参数`time_zone=system`时每次都会尝试获取一个全局锁，这在高并发的环境下无疑是致命的，可能会导致线程上下文频繁切换，CPU 使用率暴涨，系统响应变慢甚至假死。

虽然从毫秒数转换到类型 `TIMESTAMP` 本身需要的 CPU 指令并不多，这并不会带来直接的性能问题。但是如果使用默认的操作系统时区，则每次通过时区计算时间时，要调用操作系统底层系统函数 `__tz_convert()`，而这个函数需要额外的加锁操作，以确保这时操作系统时区没有修改。所以，当大规模并发访问时，由于热点资源竞争，产生两个问题

- 性能不如 `DATETIME`：`DATETIME` 不存在时区转化问题。
- 性能抖动：海量并发时，存在性能抖动问题。

为了优化` TIMESTAMP` 的使用，强烈建议你使用显式的时区，而不是操作系统时区。比如在配置文件中显示地设置时区，而不要使用系统时区：

```apl
[mysqld]
time_zone = "+08:00"
```

最后，通过命令 `mysqlslap` 来测试 `TIMESTAMP`、`DATETIME` 的性能，命令如下：

```apl
# 比较time_zone为System和Asia/Shanghai的性能对比
mysqlslap -uroot -p123456  --number-of-queries=1000000 --concurrency=100 --query='SELECT NOW()'
```

最后的性能对比如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207281520471.png" alt="image-20220728152034397" style="zoom:67%;" />

> 从表中可以发现，显式指定时区的性能要远远好于直接使用操作系统时区。所以，日期字段推荐使用 `DATETIME`，没有时区转化。即便使用 `TIMESTAMP`，也需要在数据库中显式地配置时区，而不是用系统时区。



## 枚举类型

>  mysql枚举的字段类型不宜插入数字，但是需求就是要用数字，怎么办？解决：mysql数据类型定义为int,枚举限定在java代码中解决。限定值的取值范围，比如性别（男，女，未知）等。

```sql
CREATE TABLE test4 (  
  id BIGINT UNSIGNED  PRIMARY KEY AUTO_INCREMENT,  
  brand VARCHAR(255) NOT NULL,  
  color ENUM('RED','GREEN','BLUE')
) ENGINE = InnoDB; 
```

Java代码中，枚举类，实体类正常使用属性即可

```java
public enum Color {
    RED,  
    GREEN,  
    BLUE  
}
```

# DDL(库&表)

## 库的操作

> 字符集不要用utf-8，会插不进去表情。要用utf8mb4 才是真正的UTF-8

```sql
-- 使用数据库
use 库名
-- 创建库
create database 库名
-- 创建库存在就不创建
create database if not exists itcast;
-- 创建库指定字符集
create database itcast default charset utf8mb4;
-- 删除库
drop database 库名
-- 删除库不存在不报错
drop database if exists 库名
-- 查询所有数据库
show databases;
-- 查询当前数据库
select database()；
```

## 表的操作

### 创建表⭐

设计一张员工信息表，要求如下

> 1. 编号（纯数字）
> 2. 员工工号(字符串类型，长度不超过10位)
> 3. 员工姓名（字符串类型，长度不超过10位）
> 4. 性别（男/女，存储一个汉字）
> 5. 年龄（正常人年龄，不可能存储负数）
> 6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符）
> 7. 入职时间（取值年月日即可）

```sql
create table if not exists emp(
	id int comment '编号',
	workno varchar(10) comment '工号',
	name varchar(10) comment '姓名',
	gender char(1) comment '性别',
	age tinyint unsigned comment '年龄',
	idcard char(18) comment '身份证号',
	entrycard date comment '入职时间'	
) comment '员工表';
```

### 查看表结构

```sql
DESC emp;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191145018.png" alt="image-20220919114547912" style="zoom:80%;" />

### 查看建表语句

```sql
show create table emp;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191146639.png" alt="image-20220919114648528" style="zoom:80%;" />

### 修改表⭐

```sql
ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;
```

#### 修改数据类型

```sql
# 将列name的长度增加到50
ALTER TABLE emp MODIFY COLUMN name VARCHAR(50);
```

#### 修改字段名和数据类型

```sql
# 修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;
```

#### 修改表名

```sql
# 修改表名
ALTER TABLE stuinfo RENAME studentinfo;
```

#### 修改字段类型和列级约束

```sql
# 修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;
```

#### 添加字段

```sql
# 添加字段
ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20);
```

#### 删除字段

```sql
#⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;
```

### 表的删除 & 清空

```sql
DROP TABLE [IF EXISTS] emp;
DROP TABLE IF EXISTS  emo;
```

不删除表，但**清空表内所有数据**

```sql
truncate table 表名;
```

### 表的复制⭐

```sql
#1.仅仅复制表的结构 like
CREATE TABLE author_copy LIKE author;
```

```sql
#2.复制表的结构+数据
CREATE TABLE author_copy1 SELECT * FROM author;
```

```sql
# 复制表的结构+部分数据
CREATE TABLE author_copy2 
SELECT id,au_name FROM author WHERE id='101';
```

```sql
# 仅仅复制某些字段
CREATE TABLE author_copy3 SELECT id,name FROM author;
```



# DML(增删改)

## 插入

### 基本语法

1、给表中指定字段添加数据

```sql
insert into 表名(列名,...) values(值1,...);
```

```sql
-- 这种基本不用，限制太多
insert into 表名
set 列名=值,列名=值,...
```

2、给全部字段添加数据

```sql
insert into 表名 values(值1,值2,值3....);
```

3、批量添加数据

```sql
-- 方式一，带上列名，推荐
insert into 表名(列名,...) 
values(值1,...),(值1,值2,值3....);
-- 方式二，不带列名
insert into 表名 
values(值1,值2,值3....),(值1,值2,值3....);
```

### 注意事项

> - **插入数据时，指定的字段类型和顺序需要和值的顺序是一一对应的**
> - **字符串和日期型数据应该包含在引号中**
> - **插入数据大小，应该在字段规定的范围内**
> - **字段可以为null，添加时可以直接填null**

### 实战演练

#### 全部字段插入

```sql
-- 可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致
INSERT INTO beauty
VALUES(null,'张飞','男',NULL,'119',NULL,NULL);
```

#### 指定字段插入数据

全字段都插入值

```sql
INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)
VALUES(14,'唐艺1','女','1990-4-23','1898888888',NULL,2);
```

只插入指定字段(即可以为null的字段不写)

```sql
INSERT INTO beauty(id,NAME,sex,phone)
VALUES(15,'娜扎','女','1388888888');
```

#### 使用set插入

```sql
INSERT INTO beauty
SET id=23,NAME='刘涛',phone='999';
```

#### 批量添加数据

当id为自增时，插入时可以设置为null，但不可以不写

```sql
INSERT INTO beauty
VALUES
(null,'唐艺昕1','女','1990-4-23','1898888888',NULL,2),
(null,'唐艺昕2','女','1990-4-23','1898888888',NULL,2),
(null,'唐艺昕3','女','1990-4-23','1898888888',NULL,2);
```

### 拷贝插入⭐

```sql
-- 根据dept表创建dept1表
create table dept1 like dept;
-- 把dept表中数据查询并插入到dept1中
insert into dept1 select * from dept;
```

> 注意事项：使用insert into tablA select * from tableB语句时，一定要确保tableB后面的where，order或者其他条件，都需要有对应的索引，来避免出现tableB全部记录被锁定的情况。

## 批量插入

```sh
mysql --local-infile=1  -uroot -p123456
use itcast;
# 表结构要自己创建
# 数据是CSV格式，逗号分开
load data local infile '/root/tb_sku1.sql' into table `tb_sku` fields terminated by ',' lines terminated by '\n';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302282100802.png" alt="image-20230228210038714" style="zoom:80%;" />

## 更新

### 基本语法

#### 修改单表

> 如果不带where条件会修改整张表数据

```sql
update 表名 set 列=新值,列=新值,... where 筛选条件;
```

#### 修改多表

```sql
-- sql92语法
update 表1 别名,表2 别名
set 列=值,...
where 连接条件
and 筛选条件;

-- sql99语法
update 表1 别名
inner|left|right join 表2 别名
on 连接条件
set 列=值,...
where 筛选条件;
```



### 案例

#### 修改单表

```sql
-- 案例1：修改beauty表中姓唐的女神的电话为13899888899
UPDATE beauty SET phone = '13899888899'
WHERE NAME LIKE '唐%';
```

```sql
#案例2：修改boys表中id好为2的名称为张飞，魅力值 10
UPDATE boys SET boyname='张飞',usercp=10
WHERE id=2;
```

#### 修改多表

```sql
#案例 1：修改张无忌的女朋友的手机号为114
UPDATE boys bo
INNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`
SET b.`phone`='119',bo.`userCP`=1000
WHERE bo.`boyName`='张无忌';

#案例2：修改没有男朋友的女神的男朋友编号都为2号

UPDATE boys bo
RIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`
SET b.`boyfriend_id`=2
WHERE bo.`id` IS NULL;
SELECT * FROM boys;
```

### 注意事项

> 不要使用update语句的影响行数做重要的业务判断！

> 业务系统中，使用update语句更新数据是再正常不过的场景，我们也经常通过update更新的行数，来做一些业务判断，类似下面的伪代码：(mybatis + mysql 场景)
>

```java
if (xxxMapper.updateByPrimaryKeySelective(entity) > 0){
   //更新成功，做其它业务处理
}
```

> 但是这里有一个坑，mysql中update影响行数>0是有条件的，假如有一张表：里面只有一条记录（ID=1），用update更新一把ID=1的这条记录。这一行成功更新，影响行数为1，然后把这条update语句再执行一次
>

> 这时候，返回的影响行数为0，也就是说，当待更新的记录与原始记录旧值相同时，mysql其实并不会做任何更新。
>

> 换言之，如果上游传过来的数据，与数据库本身的旧值相等，没有变化时，update语句影响行数为0。这与另一种场景："**更新一条并不存在的记录，影响行数返回0**" 无法区分。
>

## 删除

### 基本语法

#### 单表删除

```sql
delete from 表名 where 筛选条件
```

#### 多表删除

```sql
-- sql92语法：
delete 表1的别名,表2的别名
from 表1 别名,表2 别名
where 连接条件
and 筛选条件;

-- sql99语法：
delete 表1的别名,表2的别名
from 表1 别名
inner|left|right join 表2 别名 on 连接条件
where 筛选条件;
```

#### 清空表

```sql
truncate table 表名;
```

### truncate、delete 与 drop

**相同点：**

> 1. `truncate`和不带`where`子句的`delete`、以及`drop`都会删除表内的数据。
> 2. `drop`、`truncate`都是`DDL`语句（数据定义语言），执行后会自动提交。

**不同点**

> 1. truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引；
> 2. 一般来说，执行速度: drop > truncate > delete。
> 3. truncate删除不能回滚，delete删除可以回滚.
> 4. truncate删除没有返回值，delete删除有返回值
> 5. 假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始
> 6. truncate删除，效率高一丢丢
> 7. delete 可以加where 条件，truncate不能加

### delete+limit⭐

在业务场景要求高的数据库中，`对于单条删除和更新操作，在delete和update后面加limit 1绝对是个好习惯`。

比如，在删除执行中，第一条就命中了删除行，如果SQL中有limit 1；这时就return了，否则还会执行完全表扫描才return。效率不言而喻。

在日常的SQL编写中，你写delete语句时是否用到过以下SQL？

```sql
delete from t where sex = 1 limit 100; 
```

- 降低写错SQL的代价，就算删错了，比如limit 500,那也就丢了500条数据，并不致命，通过binlog也可以很快恢复数据。
- 避免了长事务，delete执行时MySQL会将所有涉及的行加写锁和Gap锁（间隙锁），所有DML语句执行相关行会被锁住，如果删除数量大，会直接影响相关业务无法使用。
- delete数据量大时，不加limit容易把cpu打满，导致越删越慢。

针对上述第二点，前提是sex上加了索引，大家都知道，加锁都是基于索引的，如果sex字段没索引，就会扫描到主键索引上，那么就算sex = 1 的只有一条记录，也会锁表。



### 实战演练

#### 单表删除

```sql
#案例：删除手机号以9结尾的女神信息
DELETE FROM beauty WHERE phone LIKE '%9';
```

#### 多表删除

```sql
#案例：删除张无忌的女朋友的信息
DELETE b
FROM beauty b
INNER JOIN boys bo ON b.`boyfriend_id` = bo.`id`
WHERE bo.`boyName`='张无忌';
```

```sql
#案例：删除黄晓明的信息以及他女朋友的信息
DELETE b,bo
FROM beauty b
INNER JOIN boys bo ON b.`boyfriend_id`=bo.`id`
WHERE bo.`boyName`='黄晓明';
```



### 注意事项

> 注意：个人建议所有的 UPDATE 和 DELETE 语句全都在 WHERE 子句中指定条件。

```sql
update lucifer set age = 22 where name = 'xiaoliu';
```

如果省略 WHERE 子句，则 UPDATE 或 DELETE 将被应用到表中所有的行。

```sql
update lucifer set age = 22;
```

> 因此，除非确实打算更新或者删除所有记录，否则要注意使用不带 WHERE 子句的 UPDATE 或 DELETE  语句。

**📢 注意：** 建议在对表进行更新和删除操作之前，使用 SELECT 语句确认需要删除的记录，以免造成无法挽回的结果。



# DCL(数据控制语言)

> DCL英文全称是 (数据控制语言)，用来管理数据库用户 、控制数据库的访问权限

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192233938.png" alt="image-20220919223316837" style="zoom:80%;" />

## 设置简单密码

```mysql
-- MySQL8不能直接设置简单密码
set global validate_password.policy=0;
set global validate_password.length=4;
```

然后正常创建用户就行

```sql
create user 'maxwell'@'%' identified by '123456';
```

## 用户管理

### 1、查询用户

```sql
use mysql;
select * from user;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192234880.png" alt="image-20220919223407783" style="zoom:80%;" />

> 其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。
>

### 2、创建用户

```sql
create user '用户名'@'主机名' identified by '密码';
```

```sql
-- 创建用户 itcast , 只能够在当前主机localhost访问, 密码123456;
create user 'itcast'@'localhost' identified by '123456';

-- 创建用户 heima , 可以在任意主机访问该数据库, 密码123456 ;
create user 'heima'@'%' identified by '123456';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192235154.png" alt="image-20220919223559061" style="zoom:80%;" />

### 3、修改用户密码

```sql
alter user '用户名'@'主机名' identified with mysql_native_password by '密码';
alter user 'root'@'localhost' identified with mysql_native_password by '315217';
```

```sql
-- 修改用户 heima 的访问密码为 1234 ;
alter user 'heima'@'%' identified with mysql_native_password by '1234';
```

### 4、删除用户

```sql
drop user '用户名'@'主机名';
-- 删除itcast@localhost用户
drop user 'itcast'@'localhost';
```

## 权限控制

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120130129125.png" alt="image-20220120130129125" style="zoom:80%;" />

> - **多个权限之间，使用逗号分隔**
> - **授权时，数据库名和表名可以使用星号进行通配，代表所有**

### 1、查询权限

```sql
show grants for '用户名'@'主机名';
-- 查询权限
show grants for 'root'@'%';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192238827.png" alt="image-20220919223807734" style="zoom:80%;" />

### 2、授予权限

```sql
grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';
-- 授予权限
grant all on itcast.* to 'heima'@'%';
grant all on *.* to 'heima'@'%';
grant all on *.* to 'root'@'%';
```

### 3、撤销权限

```sql
revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';
-- 撤销权限
revoke all on itcast.* from 'heima'@'%';
```

```sql
GRANT SELECT ,REPLICATION SLAVE , REPLICATION CLIENT ON *.* TO maxwell@'%';
```

> - **privileges**：用户操作权限，如`SELECT`，`INSERT`，`UPDATE`、`DELETE`等，要授予所的权限则使用`ALL`
> - **databasename**：数据库名
> - **tablename**：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用`*`表示，如`*.*`
> - **username**：用户名
> - **host**：可以访问的域名
>
> 在给其他授权前，请先用管理员账户登录！

### 4、刷新

> 更新完权限后，必须进行刷新

```sql
flush privileges;
```

## 实战演练⭐

### 允许root远程登录

> 默认情况下，root用户是不运行远程登录的，只允许在MySQL所在的Linux服务器登陆MySQL系统
>
> 请注意，允许root远程登录会带来安全风险

```sql
use mysql
update user set host='%' where user='root';
grant all privileges on *.* to root@'%';
SELECT User, Host FROM user;
```

### 创建用户并授予权限

```sql
use mysql
create user 'heima'@'%' identified by '123456';
alter user 'heima'@'%' identified with mysql_native_password by '1234';
grant all on *.* to 'heima'@'%';
flush privileges;
SELECT User, Host FROM user;
```

# DQL(数据查询语言)⭐⭐

## 基本语法⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191223490.png" alt="image-20220919122314347" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192232824.png" alt="image-20220919223208727" style="zoom: 80%;" />

## 基础查询

```sql
select 要查询的字段 【from 表名】;
```

> - **通过select查询完的结果 ，是一个虚拟的表格，不是真实存在**
> - **要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数**

### 简单查询

```sql
#1.查询表中的单个字段
SELECT last_name FROM employees;

#2.查询表中的多个字段
SELECT last_name,salary,email FROM employees;

#3.查询表中的所有字段
SELECT * FROM employees;
 
#4.查询表达式
SELECT 100%23  as '结果'
 
#5.查询函数，能够查询该数据库的版本
SELECT version();
```

### 起别名

> 使用as | 空格 起别名，一般都用空格起别名

```sql
#方式一：使用as
SELECT 100%98 AS 结果;
SELECT last_name AS 姓,first_name AS 名 FROM employees;

#方式二：使用空格，一个空格即可，多个空格也行
SELECT last_name 姓,first_name 名 FROM employees;
```



### 去重

> distinct，显示出表employees中的全部job_id(不能重复)，只能显示该字段
>

```sql
SELECT DISTINCT department_id FROM employees;
```



### 判空

> - **避免因为查出null值导致计算出错或空指针异常之类的问题**
> - 第一个参数是**当前字段名**，第二个参数是值为null时**要进行填充的值**

```sql
select id,username,IFNULL(create_time,'2021-09-22 15:01:50') 'create_time' from admin 
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120133356785.png" alt="image-20220120133356785" style="zoom:80%;" />



### 字符拼接

> 注意：mysql中+号不能用于字符拼接，它只能作为运算符。只能用concat
>
> mysql中的+号：(重要)仅仅只有一个功能：运算符

```sql
select 100+90; # 两个操作数都为数值型，则做加法运算
select '123'+90; # 只要其中一方为字符型，试图将字符型数值转换成数值型，如果转换成功，则继续做加法运算
select 'john'+90;  # 如果转换失败，则将字符型数值转换成0
select null+10; # 只要其中一方为null，则结果肯定为null
```

```sql
# 案例：查询员工名和姓连接成一个字段，并显示为姓名
select concat('a','b','c') AS 结果;

select concat(last_name,first_name) as 姓名 from employees;
```



## 条件查询

### 基本语法

```sql
select 要查询的字段|表达式|常量值|函数  from 表 where  条件 ;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120135411824.png" alt="image-20220120135411824" style="zoom:80%;" />

```sql
select * from person where name='Java' and id=1;
select * from person where name='Java' or id=1;
select * from person where name is not null ;
select * from person where mobile between 13333333330 and 13333333334;
select * from person where name in ('Java','Redis');
```

### 实战演练

#### 数据准备

```sql
create table emp(
    id  int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '姓名',
    age  int comment '年龄',
    job varchar(20) comment '职位',
    salary int comment '薪资',
    entrydate date comment '入职时间',
    managerid int comment '直属领导ID',
    dept_id int comment '部门ID'
)comment '员工表';
```

```sql
INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES
            (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),

            (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
            (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
            (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
            (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),
            (6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),

            (7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),
            (8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),
            (9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),

            (10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),
            (11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),
            (12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),
            (13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),

            (14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),
            (15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),
            (16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),
            (17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);
```

#### 操作实战

```sql
-- 1. 查询年龄等于 88 的员工
select * from emp where age = 88;

-- 2. 查询年龄小于 20 的员工信息
select * from emp where age < 20;

-- 3. 查询年龄小于等于 20 的员工信息
select * from emp where age <= 20;

-- 4. 查询没有身份证号的员工信息
select * from emp where idcard is null;

-- 5. 查询有身份证号的员工信息
select * from emp where idcard is not null;

-- 6. 查询年龄不等于 88 的员工信息
select * from emp where age != 88;
select * from emp where age <> 88;

-- 7. 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息
select * from emp where age >= 15 && age <= 20;
select * from emp where age >= 15 and age <= 20;
select * from emp where age between 15 and 20;

-- 8. 查询性别为 女 且年龄小于 25 岁的员工信息
select * from emp where gender = '女' and age < 25;

-- 9. 查询年龄等于18 或 20 或 40的员工信息
select * from emp where age = 18 or age = 20 or age = 40;
select * from emp where age in(18,20,40);

-- 10. 查询姓名为两个字的员工信息 _ %
select * from emp where name like '__';

-- 11. 查询身份证号最后一位是X的员工信息
select * from emp where idcard like '%X';
select * from emp where idcard like '________________%';
```



### 算数运算符

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207120950812.png" alt="image-20220712095056728" style="zoom:80%;" />



### 逻辑表达式

逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207120951809.png" alt="image-20220712095146736" style="zoom:67%;" />

示例：salary>10000 && salary<20000

> - and（&&）:两个条件如果同时成立，结果为true，否则为false
> - or(||)：两个条件只要有一个成立，结果为true，否则为false
> - not(!)：如果条件成立，则not后为false，否则为true

```sql
#案例1：查询工资z在10000到20000之间的员工名、工资
SELECT last_name,salary
FROM employees
WHERE salary>=10000 AND salary<=20000;

#案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息
SELECT * FROM employees
WHERE NOT(department_id>=90 AND  department_id<=110) OR salary>15000;
```



## 聚合函数

> 注意：聚合函数不统计NULL值

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191246576.png" alt="image-20220919124613440" style="zoom:80%;" />

```sql
select count(*) from emp;
select avg(age) from emp;
select max(age) from emp;
select min(age) from emp;
select sum(age) from emp;
select count(*),avg(age),max(age),min(age),sum(age) from emp;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209191250427.png" alt="image-20220919125000299" style="zoom:80%;" />

## 分组查询⭐

### 基本语法

> 注意：**分组查询查询的字段一般是聚合函数和分组字段，查询其他字段是没有意义的**

```sql
select 查询的字段，分组函数
from 表
【where 筛选条件】
group by 分组的字段
【order by 排序的字段】
【having 分组后的过滤条件】;	
```

### 实战演练

```sqlite
-- 根据职位分组，统计不同职位员工的数量
select job,count(*) from emp group by job;

-- 根据职位分组，统计不同职位员工的平均薪资
select job,avg(salary) '平均薪资' from emp group by job;

-- 查询年龄小于45的员工，并根据职称分组，获取员工数量大于等于3的职位
select job,count(*) job_count from emp where age < 45 group by job having job_count >=2;
```

## 排序查询

### 基本语法

```sql
select 查询字段 from 表 where 条件
order by 排序的字段|表达式|函数|别名 【asc|desc】
```

> - **asc代表的是升序，可以省略 , desc代表的是降序**
> - **order by子句可以支持 单个字段、别名、表达式、函数、多个字段**
> - **order by子句在查询语句的最后面，除了limit子句**

### 实战演练

```sql
-- 1. 根据年龄对公司的员工进行升序排序
select * from emp order by age asc ;
select * from emp order by age desc ;
select * from emp order by age;

-- 2. 根据入职时间，对员工进行降序排序
select * from emp order by entrydate desc ;

-- 3. 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序
select * from emp order by age asc , entrydate desc ;
```

#### 添加筛选条件再排序

```sql
#案例：查询部门编号>=90的员工信息，并按员工编号降序
SELECT *
FROM employees
WHERE department_id>=90
ORDER BY employee_id DESC;
```

#### 按表达式排序

```sql
#案例：查询员工信息 按年薪降序
SELECT *,salary*12*(1+IFNULL(commission_pct,0))
FROM employees
ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;
```

#### 按别名排序

```sql
#案例：查询员工信息 按年薪升序
SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪
FROM employees
ORDER BY 年薪 ASC;
```

#### 按函数排序

```sql
#案例：查询员工名，并且按名字的长度降序
SELECT LENGTH(last_name),last_name
FROM employees
ORDER BY LENGTH(last_name) DESC;
```

#### 按多个字段排序

```sql
#案例：查询员工信息，要求先按工资降序，再按employee_id升序
SELECT * FROM employees
ORDER BY salary DESC,employee_id ASC;
```



### 排序特性

#### 问题场景

新上线一个交易记录导出功能，逻辑很简单：根据查询条件，导出对应的数据。由于数据量比较大，在查询数据库时采用了分页查询，每次查询1000条数据。

自测正常，测试环境正常，上线之后运营反馈导出的**数据有重复记录**。

原本是以为业务逻辑问题，重新Review了一遍代码，依旧未找到问题原因。最后只好把SQL语句拿出来单独执行，导出数据，对比发现竟然是SQL语句查询结果乱序导致的。

#### 原因分析

查询语句以create_time进行倒序排序，通过limit进行分页，在正常情况下不会出现问题。但当业务并发量比较大，导致create_time存在大量相同值时，再基于limit进行分页，就会出现乱序问题。

出现的场景是：**以create_time排序，当create_time存在相同值，通过limit分页，导致分页数据乱序**。

比如，查询1000条数据，其中有一批create_time记录值都为”2021-10-28 12:12:12“，当创建时间相同的这些数据，一部分出现在第一页，一部分出现在第二页，在查询第二页的数据时，可能会出现第一页已经查过的数据。

也就是说，数据会来回跳动，一会儿出现在第一页，一会儿出现在第二页，这就导致的数据一部分重复，一部分缺失。

> 简单来说就是：`ORDER BY查询的数据，如果ORDER BY列存在多行相同数据，MySQL会随机返回`。这就会导致虽然使用了排序，但也会发生乱序的状况。

#### 解决方案

针对上述问题，基本的解决思路是：**避免ORDER BY列的值出现重复**。因此，可以加入ID等其他排序列

```sql
select * from tb_order order by create_time ,id desc;
```

这样，在create_time相同时，会根据id进行排序，而id肯定是不同的，就再不会出现上述问题了。

## 案例巩固⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302261551634.png" alt="image-20230226155121532" style="zoom:80%;" />

```sql
-- 1、查询年龄为20，21，22，24岁的女性员工信息
select * from emp where gender = '女' and age in (20,21,22,24);

-- 2、查询性别为男，并且年龄在20-40岁(含)以内的姓名为三个字的员工
select * from emp where gender = '男' and (age between 20 and 40) and name like '___';

-- 3、统计员工表中，年龄小于60岁的，男性员工和女性员工的人数
select gender,count(*) from emp where age < 60 group by gender;

-- 4、查询所有年龄小于等于35岁员工的年龄和姓名，并对查询结果按年龄升序排序，
-- 如果年龄相同按入职时间降序排序
select name,age from emp where age <= 35 order by age asc ,entrydate desc ;

-- 5、查性别为男，年龄在20-40岁(含)以内的前5个员工的信息，对查询的结果按年龄升序，年龄相同按入职时间升序
select * from emp where gender = '男' and age between 20 and 40 
order by age asc ,entrydate asc limit 5;
```



## SQL执行顺序

### 完整执行顺序

在讲解DQL语句的具体语法之前，我们已经讲解了DQL语句的完整语法，及编写顺序，接下来，我们要来说明的是DQL语句在执行时的执行顺序，也就是先执行那一部分，后执行那一部分。

> 执行顺序： from ... where ... group by ...having ... select ... order by ... limit ...

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171718273.png" alt="image-20220617171852151" style="zoom:67%;" />

### 执行顺序验证

> 验证：查询年龄大于15的员工姓名、年龄，并根据年龄进行升序排序
>

```sql
select name,age from emp where age > 15 order by age asc;
```

在查询时，我们给emp表起一个别名 e，然后在select 及 where中使用该别名

```sql
select e.name , e.age from emp e where e.age > 15 order by age asc;
```

执行上述SQL语句后，我们看到依然可以正常的查询到结果

> 此时就说明： from 先执行, 然后where 和 select 执行。那 where 和 select 到底哪个先执行呢?此时，此时我们可以给select后面的字段起别名，然后在 where 中使用这个别名，然后看看是否可以执行成功。

```sql
select e.name ename , e.age eage from emp e where eage > 15 order by age asc; 
```

执行上述SQL报错了:

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192230274.png" alt="image-20220919223007167" style="zoom:80%;" />

> 由此我们可以得出结论: from 先执行，然后执行 where ， 再执行select 。

接下来，我们再执行如下SQL语句，查看执行效果：

```sql
select e.name ename , e.age eage from emp e where e.age > 15 order by eage asc; 
```

结果执行成功。 那么也就验证了: order by 是在select 语句之后执行的。

> 综上所述，我们可以看到DQL语句的执行顺序为： from ... where ... group by ...  select... having ... order by ... limit ...

## 分页查询

### 基本语法

```sql
select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【offset】, size;
```

- `offset要显示条目的起始索引`（起始索引从0开始）
- `size 要显示的条目个数`

### 注意事项

> - **起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数**
>- **分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT**
> - **如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10**

### 实战案例

A. 查询第1页员工数据, 每页展示10条记录

```sql
select * from emp limit 0,10; 
select * from emp limit 10;
```

B. 查询第2页员工数据, 每页展示10条记录 --------> offset = (页码-1)*页展示记录数

```sql
select * from emp limit 10,10;
```

## 分页问题

### 问题背景

> 最近部分销售人员反馈在 APP 上查询自己名下客户订单数据时，当往下拉取数据的时候，列表上经常出现重复的订单数据，经过排查，后端代码是通过如下方式来实现数据的分页查询的。

```sql
limit offset, size order by create_time desc
```

> **经过细致的分析，这种排序方式，在 app 端分页查询的时候，确实存在问题**。

详细的分析过程如下！

### 原因分析

首先我们初始化一张表，用于模拟订单表查询。

```sql
CREATE TABLE `tb_order` (
  `order_id` bigint(11) unsigned NOT NULL,
  `create_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

然后初始化 5 条数据进去，方便数据分析

```sql
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (1, '2023-03-03 12:00:01');
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (2, '2023-03-03 12:00:02');
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (3, '2023-03-03 12:00:03');
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (4, '2023-03-03 12:00:04');
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (5, '2023-03-03 12:00:05');
```

假设我们每次只查询 2 条数据，并且按照时间倒序来查询，结果如下：

```sql
-- 发起第一页查询
select * from tb_order order by create_time desc limit 0,2;
-- 第一页查询结果
|order_id |   create_time       |
|5        |  2023-03-03 12:00:05|
|4        |  2023-03-03 12:00:04|
```

```sql
-- 发起第二页查询
select * from tb_order order by create_time desc limit 2,2;
-- 第二页查询结果
|order_id |   create_time       |
|3        |  2023-03-03 12:00:03|
|2        |  2023-03-03 12:00:02|
```

当订单数据没有发生变动的时候，这种查询方式是不会造成出现重复的数据问题。**但是当订单数据发生了变动，比如在查询的时候，突然新增了订单数据，此时的查询结果就完全不一样了**。还是以上面为例，假设在第一次查询的时候，突然新增了一条数据，看看结果如何。

```sql
-- 发起第一页查询
select * from tb_order order by create_time desc limit 0,2;
-- 第一页查询结果
|order_id |   create_time       |
|5        |  2023-03-03 12:00:05|
|4        |  2023-03-03 12:00:04|

-- 新增一条订单数据
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (6, '2023-03-03 12:00:06');
```

```sql
-- 发起第二页查询
select * from tb_order order by create_time desc limit 2,2;
-- 第二页查询结果
|order_id |   create_time       |
|4        |  2023-03-03 12:00:04|
|3        |  2023-03-03 12:00:03|
```

**可以很明显的发现，订单ID=4的数据，出现在页面上两次，正常情况下只有一次**！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304220956582.png" alt="image-20230422095658512" style="zoom: 67%;" />

上面说到的是新增一条数据，假设删除某条数据，看看结果如何。

```sql
-- 发起第一页查询
select * from tb_order order by create_time desc limit 0,2;
-- 第一页查询结果
|order_id |   create_time       |
|5        |  2023-03-03 12:00:05|
|4        |  2023-03-03 12:00:04|

-- 删除一条订单数据
delete from tb_order where order_id = 4;

-- 发起第二页查询
select * from tb_order order by create_time desc limit 2,2;
-- 第二页查询结果
|order_id |   create_time       |
|2        |  2023-03-03 12:00:02|
|1        |  2023-03-03 12:00:01|
```

> **可以很明显的发现，删除订单ID=4的数据之后，页面查询结果直接到订单ID=2了，直接跳过订单ID=3了，也就是说订单ID=3的数据展示，丢失了**！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304220957120.png" alt="image-20230422095720045" style="zoom:67%;" />

总结下来，结论如下！

> - **当新增某条数据之后，通过常规的分页查询，列表会出现数据重复的现象**；
> - **当删除某条数据之后，通过常规的分页查询，列表会出现数据丢失的现象**；

那怎么解决以上的问题呢？办法如下！

### 解决方案

针对上面所说的分页查询方式，我们需要做一些调整，调整办法如下：

> - **第一步：当查询出当页的数据之后，记录下本次拉取的最后一条数据的排序字段值；当发起下一页数据查询的时候，带上这个参数，服务端通过这个参数做过滤条件**
> - **第二步：排序字段值不能出现重复**

以上面的新增为例，详细的实践过程如下：

```sql
-- 发起第一页查询
select * from tb_order order by create_time desc limit 0,2;
-- 第一页查询结果
|order_id |   create_time       |
|5        |  2023-03-03 12:00:05|
|4        |  2023-03-03 12:00:04|

-- 新增一条订单数据
INSERT INTO `tb_order` (`order_id`, `create_time`) VALUES (6, '2023-03-03 12:00:06');

-- 发起第二页查询，带上第一页查询的最后一条数据的排序字段值
select * from tb_order where create_time < '2023-03-03 12:00:04' order by create_time desc limit 0,2;
-- 第二页查询结果
|order_id |   create_time       |
|3        |  2023-03-03 12:00:03|
|2        |  2023-03-03 12:00:02|
```

**此时的查询结果正常，符合预期效果**！

同样的，以上面的删除为例，详细的实践过程如下：

```sql
-- 发起第一页查询
select * from tb_order order by create_time desc limit 0,2;
-- 第一页查询结果
|order_id |   create_time       |
|5        |  2023-03-03 12:00:05|
|4        |  2023-03-03 12:00:04|

-- 删除一条订单数据
delete from tb_order where order_id = 4;

-- 发起第二页查询
select * from tb_order where create_time < '2023-03-03 12:00:04' order by create_time desc limit 0,2;
-- 第二页查询结果
|order_id |   create_time       |
|3        |  2023-03-03 12:00:03|
|2        |  2023-03-03 12:00:02|
```

查询结果与预期一致，正常！

### 深入思考

- **选择的排序字段值出现了重复，怎么办**？

> 在上面我们提到了，**排序字段值不能出现重复**的要求，但是现实的情况是，如果以订单的创建时间来排序，当同一秒多次下单的时候大概率会出现重复，这个时候只能在订单表里面新增一个排序字段，设置全局唯一索引，内容是以时间为基础来生成，比如雪花算法，或者自己写一个基于时间全局自增的算法，确保全局唯一，**最重要的是值的长度必须固定**，订单主键 ID 的生成规则推荐采用此方式，利用主键 ID 来排序效率查询会非常高！

- **当出现多个排序字段时，如何处理**？

> 如果是 app 端的查询，不建议设计多字段排序，因为在多字段排序的环境下，服务端在进行多条件的过滤查询时，可能会把有效的数据给过滤掉，如果无法避开，尽量将多个排序字段合并到一个排序字段上，保证数据的查询符合预期。

## 实战技巧

### 查找是否存在

#### 目前多数人的写法

> 多次REVIEW代码时，发现如现现象：业务代码中，需要根据一个或多个条件，查询是否存在记录，不关心有多少条记录。普遍的SQL及代码写法如下

SQL写法

```sql
-- 返回查询到的条目
SELECT count(*) FROM table WHERE a = 1 AND b = 2
```

Java写法

```java
int nums = xxDao.countXxxxByXxx(params);
if ( nums > 0 ) {
  //当存在时，执行这里的代码
} else {
  //当不存在时，执行这里的代码
}
```

是不是感觉很OK，没有什么问题

#### 优化方案

> SQL不再使用count，而是改用LIMIT 1，让数据库查询时遇到一条就返回，不要再继续查找还有多少条了 业务代码中直接判断是否非空即可

SQL写法

```sql
-- 查到就返回1，没有就啥也不返回
SELECT 1 FROM table WHERE a = 1 AND b = 2 LIMIT 1;
```

Java写法

```java
Integer exist = xxDao.existXxxxByXxx(params);
if (exist != NULL) {
  //当存在时，执行这里的代码
} else {
  //当不存在时，执行这里的代码
}
```



# DQL多表查询

## 笛卡儿积

> - 只从多张表中查询数据
> - 笛卡尔积是指在数学中，两个集合A和B的所有组合情况(多表查询要消除笛卡尔积)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209200908167.png" alt="image-20220920090849022" style="zoom:80%;" />

## 多表关系⭐

> 多对多关系（Many-to-Many Relationship）：指两个表之间存在的一种关系，其中一个表中的一条记录可以对应另一个表中的多条记录，反之亦然。例如，一个学生可以选择多门课程，一门课程也可以被多个学生选择。在 MySQL 中，需要**使用中间表来实现多对多关系**。

> 自关联关系（Self-Referencing Relationship）：指一个表中的记录与该表中的其他记录存在关联关系。如在一个员工表中，可以存在一个“上级”字段，记录员工的上级是哪个员工。在 MySQL 中，可以使用外键来实现自关联关系

在实际使用中，需要根据具体的业务需求和数据结构来确定表与表之间的关系。



### 一对多

> 一对多关系（One-to-Many Relationship）：指两个表之间存在的一种关系，其中一个表的一条记录可以对应另一个表中的多条记录，但另一个表中的一条记录只能对应一个表中的一条记录。例如，一个班级有多个学生，但一个学生只属于一个班级。在 MySQL 中，**可以使用外键来实现一对多关系**。

> ➢案例: 部门与员工的关系
>
> ➢关系: 一个部门对应多个员工，一个员工对应一个部门
>
> ➢实现: 在多的一方建立外键，指向一的一方的主键

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081456950.png" alt="image-20220508145650881" style="zoom:80%;" />

#### 案例演示

```sql
-- 部门表
create table dept(
    id   int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '部门名称'
)comment '部门表';
-- 准备数据
INSERT INTO dept (id, name) VALUES
(1, '研发部'),
(2, '市场部'),
(3, '财务部'),
(4, '销售部'),
(5, '总经办'),
(6, '人事部');
```

```sql
-- 员工表
create table emp(
    id  int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '姓名',
    age  int comment '年龄',
    job varchar(20) comment '职位',
    salary int comment '薪资',
    entrydate date comment '入职时间',
    managerid int comment '直属领导ID',
    dept_id int comment '部门ID'
)comment '员工表';
-- 准备数据
INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES
(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),
(17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);
```

```sql
-- 添加外键(可选)
alter table emp add constraint fk_emp_dept_id
foreign key (dept_id)
references dept(id) on update cascade on delete cascade;
```

#### 查询测试

```sql
-- 内连接演示
-- 1. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)
-- 表结构: emp , dept
-- 连接条件: emp.dept_id = dept.id
select e.name 姓名,d.name 部门 from emp e , dept d
where e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302270944549.png" alt="image-20230227094447428" style="zoom:80%;" />

```sql
-- 2. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现)
-- INNER JOIN ... ON ...
-- 表结构: emp , dept
-- 连接条件: emp.dept_id = dept.id
select e.name, d.name from emp e
inner join dept d  on e.dept_id = d.id;

select e.name, d.name from emp e
join dept d  on e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081433282.png" alt="image-20220508143308216" style="zoom:80%;" />

### 多对多⭐

> ➢案例: 学生与课程的关系
>
> ➢关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择
>
> ➢实现: **建立第三张中间表**，中间表至少包含两个外键，分别关联两方主键

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120162752102.png" alt="image-20220120162752102" style="zoom:80%;" />

#### 案例演示

学生表

```sql
create table student(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    no varchar(10) comment '学号'
) comment '学生表';

insert into student values 
(null, '黛绮丝', '2000100101'),
(null, '谢逊', '2000100102'),
(null, '殷天正', '2000100103'),
(null, '韦一笑', '2000100104');
```

课程表

```sql
create table course(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '课程名称'
) comment '课程表';
insert into course values 
(null, 'Java'), 
(null, 'PHP'), 
(null , 'MySQL') , 
(null, 'Hadoop');
```

中间连接表

```sql
create table student_course(
    id int auto_increment comment '主键' primary key,
    studentid int not null comment '学生ID',
    courseid  int not null comment '课程ID',
    constraint fk_courseid foreign key (courseid) references course (id),
    constraint fk_studentid foreign key (studentid) references student (id)
)comment '学生课程中间表';

insert into student_course values 
(null,1,1),
(null,1,2),
(null,1,3),
(null,2,2),
(null,2,3),
(null,3,4);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081458876.png" alt="image-20220508145839805" style="zoom: 80%;" />

#### 查询测试

```sql
select s.name , s.no , c.name from
student s , student_course sc , course c
where s.id = sc.studentid and sc.courseid = c.id ;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081440055.png" alt="image-20220508144019988" style="zoom:80%;" />

```sql
select s.name 姓名,s.no 学号, c.name 学科 
from student s
join student_course sc
on s.id = sc.studentid
join course c
on sc.courseid = c.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171454358.png" alt="image-20220617145432286" style="zoom:80%;" />

### 一对一

> 一对一关系（One-to-One Relationship）：指两个表之间存在的一种关系，其中一个表的一条记录最多只能对应另一个表中的一条记录，反之亦然。例如，一个人只有一个身份证号码，一个身份证号码只能对应一个人。在 MySQL 中，**可以使用外键来实现一对一关系**。

> ➢案例: 用户与用户详情的关系
>
> ➢关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中
>
> ➢实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120162730764.png" alt="image-20220120162730764" style="zoom:80%;" />

#### 案例演示

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171456720.png" alt="image-20220617145653641" style="zoom:80%;" />

```sql
create table tb_user(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    age int comment '年龄',
    gender char(1) comment '1: 男 , 2: 女',
    phone char(11) comment '手机号'
) comment '用户基本信息表';

insert into tb_user(id, name, age, gender, phone) values 
(null,'黄渤',45,'1','18800001111'),
(null,'冰冰',35,'2','18800002222'),
(null,'码云',55,'1','18800008888'),
(null,'李彦宏',50,'1','18800009999');
```

```sql
create table tb_user_edu(
    id int auto_increment primary key comment '主键ID',
    degree varchar(20) comment '学历',
    major varchar(50) comment '专业',
    primaryschool varchar(50) comment '小学',
    middleschool varchar(50) comment '中学',
    university varchar(50) comment '大学',
    userid int unique comment '用户ID',
    -- 外键
    constraint fk_userid foreign key (userid) references tb_user(id)
) comment '用户教育信息表';

insert into 
tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid) values
(null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),
(null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),
(null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),
(null,'本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);
```

#### 查询测试

```sql
select u.id,u.name,e.degree,e.university
from tb_user u
inner join tb_user_edu e
where u.id = e.userid;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171502503.png" alt="image-20220617150217423" style="zoom:80%;" />



## 多表查询分类

### 内连接

> 内连接（INNER JOIN）：内连接会根据两个表之间的匹配关系来返回结果集，**只会返回符合匹配条件的记录**。内连接使用 `INNER JOIN` 关键字进行连接，也可以使用 `JOIN` 关键字进行连接。示例如下：

隐式内连接

```sql
select 字段列表 from 表1,表2 where 条件...；
```

显式内连接

```sql
select 字段列表 from 表1 inner join 表2 on 连接条件...；
```

内连接查询的是两张表交集的部分

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081515582.png" alt="image-20220508151511511" style="zoom:80%;" />

内连接演示

```sql
-- 内连接演示
-- 1. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)
-- 表结构: emp , dept ，连接条件: emp.dept_id = dept.id
-- 隐式内连接
select emp.name , dept.name from emp , dept
where emp.dept_id = dept.id ;
-- 隐式内连接，使用别名⭐
select e.name,d.name from emp e , dept d
where e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081519710.png" alt="image-20220508151921639" style="zoom:80%;" />

```sql
-- 2. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现)
-- INNER JOIN ... ON ...
-- 表结构: emp , dept，连接条件: emp.dept_id = dept.id
-- 显式
select e.name, d.name from emp e
inner join dept d  on e.dept_id = d.id;
-- 显式
select e.name, d.name from emp e
join dept d  on e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081522718.png" alt="image-20220508152227650" style="zoom: 80%;" />

### 外连接

外连接查询语法:

#### 左外连接

> 左连接**会返回左表中所有的记录以及符合匹配条件的右表中的记录。如果右表中没有匹配的记录，则会返回 NULL 值**。左连接使用 `LEFT JOIN` 关键字进行连接。

```sql
select 字段列表 from 表1 left [outer] join 表2  on  条件.....;
```

```sql
-- 外连接演示
-- 1. 查询emp表的所有数据, 和对应的部门信息(左外连接)
-- 表结构: emp, dept，连接条件: emp.dept_id = dept.id

select e.*, d.name from emp e
left outer join dept d
on e.dept_id = d.id;

select e.*, d.name from emp e
left join dept d
on e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081533532.png" alt="image-20220508153341452" style="zoom:80%;" />

#### 右外连接

> 右连接与左连接类似，不同之处在于右连接会返回右表中的所有记录以及符合匹配条件的左表中的记录。如果左表中没有匹配的记录，则会返回 NULL 值。右连接使用 `RIGHT JOIN` 关键字进行连接。

```sql
select 字段列表 from 表1 right [outer] join 表2  on  条件.....;
```

```sql
-- 2. 查询dept表的所有数据, 和对应的员工信息(右外连接)
select d.*, e.* from emp e
right outer join dept d
on e.dept_id = d.id;

select d.*, e.* from dept d
right outer join emp e
on e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081534130.png" alt="image-20220508153416051" style="zoom:80%;" />



### 自连接

#### 基本语法

> MySQL 自连接（Self Join）是指在一个表中进行连接操作，将该表视为两个独立的表进行连接操作。自连接通常用于需要在同一个表中进行相关数据查询的情况。

> 自连接操作需要在 `FROM` 子句中使用两个表别名（alias），一个别名用于表示连接的源表，另一个别名用于表示连接的目标表。接下来需要使用连接条件，将两个表连接起来。连接条件通常是基于两个表的字段进行连接，而这两个字段通常具有相关性。例如：在一张表上找两遍：例如找一张表上的一级标题对应的多个二级标题，或者查询员工名和上级的名称

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209200932467.png" alt="image-20220920093259273" style="zoom:80%;" />

```sql
select 字段列表 from 表A  别名A join 表A 别名B  on  条件.....;
```

例如，在一个员工表中，可以存在一个“上级”字段，记录员工的上级是哪个员工。如果需要查询每个员工的姓名和上级的姓名，可以使用自连接来实现。示例如下：

```sql
SELECT e.name, m.name AS manager_name
FROM employee e
LEFT JOIN employee m ON e.manager_id = m.id;
```

> 上面的 SQL 查询语句使用了自连接，将 `employee` 表连接两次，使用别名 `e` 和 `m` 分别表示源表和目标表。连接条件是 `e.manager_id = m.id`，表示 `e` 表中的 `manager_id` 字段与 `m` 表中的 `id` 字段相等。查询结果包括员工的姓名和上级的姓名，其中上级的姓名使用了别名 `manager_name` 进行重命名。注意，在使用自连接时，需要特别注意查询的字段、别名和连接条件等方面的设置，以确保查询结果正确无误。

#### 案例演示

```sql
-- 1. 查询员工 及其 所属领导的名字
select a.name , b.name from emp a , emp b
where a.managerid = b.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081537641.png" alt="image-20220508153750566" style="zoom:80%;" />

```sql
-- 2. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来
-- 表结构: emp a , emp b
select a.name '员工', b.name '领导'
from emp a left join emp b
on a.managerid = b.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081538705.png" alt="image-20220508153849629" style="zoom:80%;" />

## 联合查询

> union 联合、合并：将多条查询语句的结果合并成一个结果
>
> 应用场景：**要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时**

特点：★

> 1、**要求多条查询语句的查询列数是一致的！**
>
> 2、**要求多条查询语句的查询的每一列的类型和顺序最好一致**
>
> 3、**union关键字默认去重，如果使用union all 可以包含重复项**

```sql
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】
```

```sql
# 查询部门编号>90或邮箱包含a的员工信息
select * from employees where email like '%a%' or department_id>90
# 将or替换成union联合查询
select * from employees where email like '%a%'
union
select * from employees where department_id > 90;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20210817191633086.png" alt="image-20210817191633086" style="zoom:67%;" />

```sql
#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息
select id,cname from t_ca where csex='男'
union all
select t_id,tname from t_ua where tGender='male';
```



## 子查询⭐

### 基本语法

> SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。
>

#### 子查询分类

#### 结果不同

> 注意：**结果集是指括号内子查询的结果集，而不是最终的结果集，这非常重要**

> - 标量子查询（子查询结果为单个值）
> - 列子查询（子查询结果为一列）
> - 行子查询（子查询结果为一行）
> - 表子查询（子查询结果为多行多列）

#### 位置不同

> 子查询可以放在from后面、select后面、where后面、having后面

### 标量子查询

> 子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询成为标量子查询
>
> 常用的操作符：= <> > >= < <=

```sql
-- 标量子查询
-- 1. 查询 "销售部" 的所有员工信息
-- a. 查询 "销售部" 部门ID
select id from dept where name = '销售部';

-- b. 根据销售部部门ID, 查询员工信息
select * from emp where dept_id = (select id from dept where name = '销售部');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081546492.png" alt="image-20220508154609412" style="zoom:80%;" />

```sql
-- 2. 查询在 "方东白" 入职之后的员工信息
-- a. 查询 方东白 的入职日期
select entrydate from emp where name = '方东白';

-- b. 查询指定入职日期之后入职的员工信息
select * from emp where entrydate > (select entrydate from emp where name = '方东白');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081546984.png" alt="image-20220508154654910" style="zoom:80%;" />



### 列子查询

> 子查询返回的结果是一列（可以是多行），这种子查询称为列子查询
>
> 常用的操作符：IN 、NOT IN 、 ANY  、SOME 、 ALL

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209200942310.png" alt="image-20220920094230138" style="zoom:80%;" />

案例1：查询 "销售部" 和 "市场部" 的所有员工信息

```sql
-- 1. 查询 "销售部" 和 "市场部" 的所有员工信息
-- a. 查询 "销售部" 和 "市场部" 的部门ID
select id from dept where name = '销售部' or name = '市场部';

-- b. 根据部门ID, 查询员工信息
select * from emp where dept_id in 
(select id from dept where name = '销售部' or name = '市场部');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081548717.png" alt="image-20220508154820632" style="zoom:80%;" />

案例2：查询比财务部 所有人工资都高的员工信息

```sql
-- a. 查询所有财务部人员工资
select id from dept where name = '财务部';
select salary from emp where dept_id = (select id from dept where name = '财务部');

-- b. 比 财务部 所有人工资都高的员工信息
select * from emp where salary > all 
(select salary from emp where dept_id = (select id from dept where name = '财务部'));
```

案例3：查询比研发部其中任意一人工资高的员工信息

```sql
-- 3. 查询比研发部其中任意一人工资高的员工信息
-- a. 查询研发部所有人工资
select salary from emp where dept_id = (select id from dept where name = '研发部');

-- b. 比研发部其中任意一人工资高的员工信息
select * from emp where salary > some 
(select salary from emp where dept_id = (select id from dept where name = '研发部'));
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081550921.png" alt="image-20220508155018834" style="zoom:80%;" />

### 行子查询

> 子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。常用的操作符：= 、<> 、IN 、NOT  IN

案例：查询与 "张无忌" 的薪资及直属领导相同的员工信息;

```sql
-- 行子查询
-- 1. 查询与 "张无忌" 的薪资及直属领导相同的员工信息 ;
-- a. 查询 "张无忌" 的薪资及直属领导
select salary, managerid from emp where name = '张无忌';

-- b. 查询与 "张无忌" 的薪资及直属领导相同的员工信息 ;
select * from emp where (salary,managerid) = 
(select salary, managerid from emp where name = '张无忌');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081551285.png" alt="image-20220508155128206" style="zoom:80%;" />

### 表子查询

> 子查询返回的结果是多行多列(相当于一张表)，这种子查询称为表子查询。
>

```sql
-- 表子查询
-- 1. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息
-- a. 查询 "鹿杖客" , "宋远桥" 的职位和薪资
select job, salary from emp where name = '鹿杖客' or name = '宋远桥';

-- b. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息
select * from emp where (job,salary) in 
(select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081602674.png" alt="image-20220508160204592" style="zoom:80%;" />

```sql
-- 2. 查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息
-- a. 入职日期是 "2006-01-01" 之后的员工信息
select * from emp where entrydate > '2006-01-01';

-- b. 查询这部分员工, 对应的部门信息;
select e.*, d.* from (select * from emp where entrydate > '2006-01-01') e
left join dept d on e.dept_id = d.id ;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081602434.png" alt="image-20220508160239350" style="zoom:80%;" />



## 综合案例⭐

### 准备数据

> 在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 
>

```sql
create table salgrade(
    grade int,
    losal int,
    hisal int
) comment '薪资等级表';
```

```sql
insert into salgrade values 
(1,0,3000),
(2,3001,5000),
(3,5001,8000),
(4,8001,10000),
(5,10001,15000),
(6,15001,20000),
(7,20001,25000),
(8,25001,30000);
```

### 需求分析

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302271053599.png" alt="image-20230227105345439" style="zoom:80%;" />

### 查询实现

> 1.查询员工的姓名、年龄、职位、部门信息。

```sql
-- 1. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）
-- 表: emp , dept，连接条件: emp.dept_id = dept.id
select e.name , e.age , e.job , d.name
from emp e , dept d 
where e.dept_id = d.id;
```

```sql
select e.name , e.age , e.job , d.name
from emp e
join dept d
on e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209200953454.png" alt="image-20220920095328282" style="zoom:80%;" />

> 2.查询年龄小于30岁的员工姓名、年龄、职位、部门信息

```sql
-- 2. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）
-- 表: emp , dept，连接条件: emp.dept_id = dept.id
select e.name , e.age , e.job , d.name 
from emp e
inner join dept d 
on e.dept_id = d.id 
where e.age < 30;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081933148.png" alt="image-20220508193343055" style="zoom:80%;" />

> 3.查询拥有员工的部门ID、部门名称。

```sql
-- 3. 查询拥有员工的部门ID、部门名称
-- 表: emp , dept，连接条件: emp.dept_id = dept.id
select distinct d.id , d.name 
from emp e , dept d
where e.dept_id = d.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081934775.png" alt="image-20220508193419670" style="zoom:80%;" />

> 4.查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来。

```sql
-- 4. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来
-- 表: emp , dept
-- 连接条件: emp.dept_id = dept.id
-- 外连接
select e.*, d.name 
from emp e 
left join dept d
on e.dept_id = d.id 
where e.age > 40 ;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081934298.png" alt="image-20220508193451202" style="zoom:80%;" />

> 5.查询所有员工的工资等级。

```sql
-- 5. 查询所有员工的工资等级
-- 表: emp , salgrade
-- 连接条件 : emp.salary >= salgrade.losal and emp.salary <= salgrade.hisal
select e.* , s.grade , s.losal, s.hisal 
from emp e , salgrade s
where e.salary >= s.losal and e.salary <= s.hisal;
```

```sql
select e.* , s.grade , s.losal, s.hisal 
from emp e , salgrade s
where e.salary 
between s.losal and s.hisal;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081935420.png" alt="image-20220508193534321" style="zoom:80%;" />

> 6.查询 "研发部" 所有员工的信息及工资等级。

```sql
-- 6. 查询 "研发部" 所有员工的信息及 工资等级
-- 表: emp , salgrade , dept
-- 连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id
-- 查询条件 : dept.name = '研发部'
select e.*, s.grade
from emp e,
     dept d,
     salgrade s
where e.dept_id = d.id
  and (e.salary between s.losal and s.hisal)
  and d.name = '研发部';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081942454.png" alt="image-20220508194204331" style="zoom:80%;" />

> 7.查询 "研发部" 员工的平均工资。

```sql
-- 7. 查询 "研发部" 员工的平均工资
-- 表: emp , dept
-- 连接条件 :  emp.dept_id = dept.id
select avg(e.salary) 
from emp e, dept d
where e.dept_id = d.id and d.name = '研发部';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081941061.png" alt="image-20220508194132971" style="zoom:80%;" />

> 8.查询工资比 "灭绝" 高的员工信息（标量子查询）。

```sql
-- 8. 查询工资比 "灭绝" 高的员工信息。
-- a. 查询 "灭绝" 的薪资
select salary from emp where name = '灭绝';

-- b. 查询比她工资高的员工数据
select * from emp where salary > (select salary from emp where name = '灭绝');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081940275.png" alt="image-20220508194021181" style="zoom:80%;" />

> 9.查询比平均薪资高的员工信息。

```sql
-- 9. 查询比平均薪资高的员工信息
-- a. 查询员工的平均薪资
select avg(salary) from emp;

-- b. 查询比平均薪资高的员工信息
select * from emp where salary > (select avg(salary) from emp);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081939556.png" alt="image-20220508193950464" style="zoom:80%;" />

> 10.查询低于本部门平均工资的员工信息。

```sql
-- 10. 查询低于本部门平均工资的员工信息

-- a. 查询指定部门平均薪资  1
select avg(e1.salary) from emp e1 where e1.dept_id = 1;
select avg(e1.salary) from emp e1 where e1.dept_id = 2;

-- b. 查询低于本部门平均工资的员工信息
select * from emp e2
where e2.salary<( select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id);

-- 将平均薪资放在最后一列(可选，就是验证下结果)
select *, (select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id) '平均'
from emp e2
where e2.salary < (select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081938722.png" alt="image-20220508193848628" style="zoom:80%;" />

> 11.查询所有的部门信息, 并统计部门的员工人数⭐。

```sql
-- 11. 查询所有的部门信息, 并统计部门的员工人数
-- a.子查询语句
select id,name from dept;
select count(*) from emp where dept_id = 1;
-- b.实现子查询
select d.id, d.name , (select count(*) from emp e where e.dept_id = d.id ) '人数' 
from dept d;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081937817.png" alt="image-20220508193734726" style="zoom:80%;" />

> 12.查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称

```sql
-- 12. 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称
-- 表: student , course , student_course
-- 连接条件: student.id = student_course.studentid , course.id = student_course.courseid
select s.name, s.no, c.name
from student s,
     student_course sc,
     course c
where s.id = sc.studentid
  and sc.courseid = c.id;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.5/202205081936157.png" alt="image-20220508193606052" style="zoom:80%;" />

备注：以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条件的记录即可



# 自增长主键ID

## 自增长特点

> 1、标识列必须和主键搭配吗？不一定，**但要求是一个key**
>
> 2、一个表可以有几个标识列？**至多一个！**
>
> 3、标识列的**类型只能是数值型**
>
> 4、标识列可以通过 SET auto_increment_increment=3; 设置步长.可以通过 手动插入值，设置起始值

在实际使用过程中，推荐使用主键自增ID和雪花算法生成的随机ID。

但是使用自增ID也有缺点：

> 1、别人一旦爬取你的数据库，就可以根据数据库的自增id获取到你的业务增长信息，很容易进行数据窃取。2、其次，对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争。

总结起来，如果业务量小，推荐采用自增ID，如果业务量大，推荐采用雪花算法生成的随机ID。

## 自增长ID使用

创建表

```sql
CREATE TABLE wan(
   id INT auto_increment primary key ,
   NAME varchar(25) UNIQUE ,
   seat varchar(25)
);
```

插入数据

```sql
# 进行插入数据，自动递增的那一列变成null即可
INSERT INTO wan VALUES(null,'张三','1234');
INSERT INTO wan VALUES(null,'李四','4321');
```

设置和获取步长(可选)

```sql
-- 展示增长步长
SHOW VARIABLES LIKE '%auto_increment%';

-- 增长步长
SET auto_increment_increment=3;
```

再次插入数据

```sql
INSERT INTO wan VALUES(null,'李五','0987');
INSERT INTO wan VALUES(null,'李六','10987');
```

进行查看数据

```sql
select * from wan;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120213446430.png" alt="image-20220120213446430" style="zoom:80%;" />

## 自增ID用完了会怎么样

自增ID达到上限用完了之后，分为两种情况：

> 1. 如果设置了主键，那么将会报错主键冲突。
> 2. 如果没有设置主键，数据库则会帮我们自动生成一个全局的row_id，新数据会覆盖老数据

解决方案：

> 表尽可能都要设置主键，主键尽量使用bigint类型，21亿的上限还是有可能达到的，比如魔兽，虽然说row_id上限高达281万亿，但是覆盖数据显然是不可接受的。

## 主键一定要自增吗

> - 建表SQL里主键边上的`AUTO_INCREMENT`，可以让主键自增，去掉它是可以的，但这就需要你在insert的时候自己设置主键的值。
> - 建表sql里的 `PRIMARY KEY` 是用来声明主键的，如果去掉，那也能建表成功，但mysql内部会给你偷偷建一个 `ROW_ID`的隐藏列作为主键。
> - 由于mysql使用**B+树索引，叶子节点是从小到大排序的**，如果使用自增id做主键，这样每次数据都加在B+树的最后，比起每次加在B+树中间的方式，加在最后可以有效**减少页分裂的问题。**
> - 在分库分表的场景下，我们可以通过redis等第三方组件来获得严格自增的主键id。如果不想依赖redis，可以参考雪花算法进行**魔改**，**既能保证数据趋势递增，也能很好的满足分库分表的动态扩容。**
> - 并不是所有数据库都建议使用自增id作为主键，比如**tidb就推荐使用随机id**，这样可以有效避免**写热点**的问题。而对于一些敏感数据，比如用户id，订单id等，如果使用自增id作为主键的话，外部通过抓包，很容易可以知道新进用户量，成单量这些信息，所以需要**谨慎考虑**是否继续使用自增主键。

## 主键自增的问题

[MySQL 主键自增，那些奇奇怪怪的坑](https://mp.weixin.qq.com/s?__biz=MzAxNTM4NzAyNg==&mid=2247503717&idx=1&sn=99ce327b3f18bab89bbef84f53d65a32&chksm=9b865f98acf1d68effe3313633ddc9bbdae837eec7e0b128f7feb8842448aa8f99e1d5cd2d6c&mpshare=1&scene=23&srcid=0420Kl1eSJOhI3VL8GinRWAN&sharer_sharetime=1682002901202&sharer_shareid=29b8a04db1dbd975e3bf4e9f47e7ac67#rd)

一般来说，主键自增是没有什么问题的。但是，如果在高并发环境下，就会有问题了。首先最容易想到的就是在高并发插入的时候产生的尾部热点问题，并发插入时，大家都需要去查询这个值然后计算出自己的主键值，那么主键的上界就会成为热点数据，并发插入时这里会产生锁竞争。为了解决这个问题，我们就需要选择适合自己的 `innodb_autoinc_lock_mode`。



# 库和表占用空间大小⭐

> 在MySQL中有一个默认的数据表information_schema，information_schema这张数据表保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。
>

> 再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema表里面，所以请勿删改此表。
>

## 所有数据库容量大小

```sql
select
table_schema as '数据库',
sum(table_rows) as '记录数',
sum(truncate(data_length/1024/1024, 2)) as '数据容量(MB)',
sum(truncate(index_length/1024/1024, 2)) as '索引容量(MB)'
from information_schema.tables
group by table_schema
order by sum(data_length) desc, sum(index_length) desc;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209200904901.png" alt="image-20220920090424758" style="zoom:80%;" />

## 所有数据库各表容量大小

```sql
select
table_schema as '数据库',
table_name as '表名',
table_rows as '记录数',
truncate(data_length/1024/1024, 2) as '数据容量(MB)',
truncate(index_length/1024/1024, 2) as '索引容量(MB)'
from information_schema.tables
order by data_length desc, index_length desc;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209202013163.png" alt="image-20220920201356933" style="zoom:80%;" />

## 指定数据库容量大小

> 例：查看mysql库容量大小
>

```sql
select
table_schema as '数据库',
sum(table_rows) as '记录数',
sum(truncate(data_length/1024/1024, 2)) as '数据容量(MB)',
sum(truncate(index_length/1024/1024, 2)) as '索引容量(MB)'
from information_schema.tables
where table_schema='mysql';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209202013374.png" alt="image-20220920201330159" style="zoom:80%;" />

## 指定数据库各表容量大小

例：查看mysql库各表容量大小

```sql
select
table_schema as '数据库',
table_name as '表名',
table_rows as '记录数',
truncate(data_length/1024/1024, 2) as '数据容量(MB)',
truncate(index_length/1024/1024, 2) as '索引容量(MB)'
from information_schema.tables
where table_schema='mysql'
order by data_length desc, index_length desc;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209202012735.png" alt="image-20220920201252507" style="zoom:80%;" />



# 函数⭐⭐

函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中已经给我们提供

了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可。 那么，函数到底在哪儿使用呢？

我们先来看两个场景：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171725052.png" alt="image-20220617172504938" style="zoom:67%;" />

1). 在企业的OA或其他的人力系统中，经常会提供的有这样一个功能，每一个员工登录上来之后都能够看到当前员工入职的天数。 而在数据库中，存储的都是入职日期，如 2000-11-12，`那如果快速计算出天数呢？`

2). 在做报表这类的业务需求中,我们要展示出学员的分数等级分布。而在数据库中，存储的是学生的分数值，如98/75，`如何快速判定分数的等级呢？`

其实，上述的这一类的需求呢，我们通过MySQL中的函数都可以很方便的实现 。

MySQL中的函数主要分为以下四类： `字符串函数、数值函数、日期函数、流程函数。`



## 字符串函数

MySQL中内置了很多字符串函数，常用的几个如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192243070.png" alt="image-20220919224345956" style="zoom:80%;" />

### concat : 字符串拼接

```sql
select concat('Hello' , ' MySQL'); 
select concat(version(),'_',database(), '_',user());

#concat 拼接字符串
select concat(last_name,'_',first_name) 姓名 FROM employees;

#将姓变大写，名变小写，然后拼接
select concat(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;
```

### lower : 全部转小写

```sql
select lower('Hello'); 
```

### upper : 全部转大写

```sql
select upper('Hello'); 
```

### lpad : 左填充

```sql
-- ---01
select lpad('01', 5, '-'); 
```

> 由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0
>
> 比如： 1号员工的工号应该为00001，注意：字段类型必须为字符串类型，为int类型是无法补0的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171732340.png" alt="image-20220617173243217" style="zoom: 67%;" />

```sql
update emp set workno = lpad(workno, 5, '0');
```

处理完毕后, 具体的数据为: 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171733164.png" alt="image-20220617173331049" style="zoom: 67%;" />

### rpad : 右填充

```sql
-- 01---
select rpad('01', 5, '-'); 
```

### trim : 去除空格

```sql
select trim(' Hello MySQL '); 
```

### substring ,substr: 截取子字符串

```sql
# 注意，索引从1开始，Hello
select substring('Hello MySQL',1,5);
#4.substr、substring
# 注意：索引从1开始
#截取从指定索引处后面所有字符,陆展元
select substr('李莫愁爱上了陆展元',7)  out_put;
#截取从指定索引处指定字符长度的字符,李莫愁
select substr('李莫愁爱上了陆展元',1,3) out_put;
```

### length 获取字节个数

```sql
#一注意：一个汉字是3个字节，如第二个length长度为15
#1.length 获取参数值的字节个数
select length('john');
select length('张三丰hahaha');
```



### char_length获取字符个数

返回值为字符串str所包含的字符个数。一个多字节字符算作一个单字符

有时候我们需要获取字符的`长度`，然后根据字符的长度进行`排序`。MYSQL给我们提供了一些有用的函数，比如：`char_length`。通过该函数就能获取字符长度。

```sql
SELECT CHAR_LENGTH('任硕'); -- 2
```

获取字符长度并且排序的sql如下：

```
select * from brand where name like '%苏三%' 
order by char_length(name) asc limit 5;
```

执行效果如图所示：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212201738543.png" alt="image-20221220173846413" style="zoom: 50%;" />

name字段使用关键字`模糊查询`之后，再使用`char_length`函数获取name字段的字符长度，然后按长度`升序`。

### instr返回子串第一次出现的索引

```sql
#5.instr 返回子串第一次出现的索引，如果找不到返回0，下面的案例返回结果为3，索引从0开始
SELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷六') AS out_put;
```

### replace 替换

我们经常会有替换字符串中部分内容的需求，比如：将字符串中的字符A替换成B。这种情况就能使用`replace`函数

```sql
update brand set name=REPLACE(name,'A','B') where id=1;
```

这样就能轻松实现字符替换功能。也能用该函数去掉`前后空格`：

```sql
update brand set name=REPLACE(name,' ','') where name like ' %';

update brand set name=REPLACE(name,' ','') where name like '% ';
```

使用该函数还能替换`json格式`的数据内容，真的非常有用。

```sql
# 9.replace 替换
# 赵敏赵敏张无忌爱上赵敏
SELECT REPLACE('周芷若周芷若张无忌爱上周芷若','周芷若','赵敏') AS out_put;
```



### group_concat 字段拼接

在我们平常的工作中，使用`group by`进行分组的场景，是非常多的。

比如想统计出用户表中，名称不同的用户的具体名称有哪些？

```sql
select name from user group by name;
```

但如果想把name相同的code拼接在一起，放到另外一列中该怎么办呢？答：使用`group_concat`函数。例

```sql
select name,group_concat(code) from `user` group by name;
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jCDA5gqGg5txINBrQaWepDb0YYOF5FtibiaHBtYn7EbPjVWIcH9WpAiapRVmFjGptb9icic3sPm420x8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

使用`group_concat`函数，可以轻松的把分组后，name相同的数据拼接到一起，组成一个字符串，用`逗号`分隔。

## 数学函数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192249084.png" alt="image-20220919224914971" style="zoom:80%;" />

### ceil：向上取整

```sql
#ceil 向上取整,返回>=该参数的最小整数，结果-1
SELECT CEIL(-1.02);
```

### floor：向下取整

```sql
#floor 向下取整，返回<=该参数的最大整数，结果-10
SELECT FLOOR(-9.99);
```

### mod：取模

```sql
#mod取余，两个结果都为1
SELECT MOD(10,-3);
SELECT 10%3;
```

### rand：获取随机数

```sql
-- 随机数：0-1之间，0.6280307812877286
select rand();
```

```sql
-- 生成六位数验证码：177571，lpad作用是不足六位补0
select lpad(round(rand()*1000000,0),6,0);
```

### round：四舍五入

```sql
#round 四舍五入
SELECT ROUND(-1.55);  # 结果为-2
SELECT ROUND(1.567,2);  # 保留两位小数，结果为1.57
```

### truncate 截断

就是保留小数点后面几位，留几位就写几位

```sql
#truncate 截断，结果1.6
SELECT TRUNCATE(1.69999,1);
```

### format 格式化

`format(x,n)`将数字`x`进行格式化，并以四舍五入的方式保留小数点后`n`位，结果以字符串的形式返回。

如果`n`为0，则返回结果函数不含小数部分。

```sql
select format(999.12345678, 5), format(888.12345678, 0);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212191025660.png" alt="image-20221219102506575" style="zoom: 67%;" />

### conv：进制转换

`conv(n, from_base, to_base)`这个函数可以进行不同进制数之间的相互转换。比如将16进制的数字转换成2进制，亦或者将2进制的数字转换成10进制都可以。

返回值为数值`n`的字符串表示，由`from_base`进制转化为`to_base`进制。如果任意一个参数为`null`的话，那么返回值就是`null`。

```sql
select conv('a', 16, 10) as '16 to 10', 
       conv(123, 10, 2)  as '10 to 2', 
       conv(123, 10, 16) as '10 to 16', 
       conv(123, 10, 8) as '10 to 8';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302261724091.png" alt="image-20230226172418998" style="zoom:80%;" />

### inet_auto：IP地址和数字转换⭐

> `inet_auto(expr)`给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是4或者8`bit`地址。

```sql
select inet_aton('192.168.1.1');
select inet_aton('192.168.22.130');
```

反之，我们也可以使用`inet_ntoa`函数将数值网络地址转换为字符串网络点地址，往下看：

```sql
select inet_ntoa(3232235777);
```



## 日期函数⭐

常见的日期函数如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209192254080.png" alt="image-20220919225439961" style="zoom:80%;" />

1. `NOW()`：返回当前日期和时间。
2. `CURDATE()`：返回当前日期。
3. `CURTIME()`：返回当前时间。
4. `DATE()`：提取日期或日期时间表达式的日期部分。
5. `TIME()`：提取日期或日期时间表达式的时间部分。
6. `YEAR()`：提取日期或日期时间表达式的年份部分。
7. `MONTH()`：提取日期或日期时间表达式的月份部分。
8. `DAY()`：提取日期或日期时间表达式的日部分。
9. `HOUR()`：提取日期或日期时间表达式的小时部分。
10. `MINUTE()`：提取日期或日期时间表达式的分钟部分。
11. `SECOND()`：提取日期或日期时间表达式的秒部分。
12. `DATEDIFF(date1,date2)`：计算两个日期之间的天数差。
13. `DATE_ADD(date, INTERVAL value unit)`：将日期加上一定的时间间隔，返回一个新日期。
14. `DATE_SUB(date, INTERVAL value unit)`：将日期减去一定的时间间隔，返回一个新日期。
15. `DATE_FORMAT(date,format)`：将日期或日期时间格式化为指定的格式。

### now，curdate，curtime

```sql
select now(),curdate(), curtime(), now(3);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302261935856.png" alt="image-20230226193557754" style="zoom: 80%;" />

### year , month , day

```sql
select year('2022-3-4'),month('2025-3-12 12:22:33'),day(now());
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302262052026.png" alt="image-20230226205236925" style="zoom:80%;" />

```sql
-- 通过截取字符串的方式获取年月
select LEFT(now(), 4) 年, MID(now(),6,2) 月;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201838989.png" alt="image-20220920183802761" style="zoom:80%;" />

### date，day，time

- DATE() `提取日期或日期/时间表达式的日期部分`
- DAY() `返回当月的几号 (1-31)`
- TIME() `提取日期或日期/时间表达式的时间部分`

```sql
select date('2003-12-31 01:02:03'), day('2017-02-03'), time('2003-12-31 01:02:03');
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302262049938.png" alt="image-20230226204907836" style="zoom:80%;" />

### dayofweek  hour

> dayofweek：表示返回日期是星期几，记住：星期天=1，星期一=2， ... 星期六=7
>
> hour：返回该date或者time的hour值，值范围（0-23).

```sql
SELECT DAYOFWEEK('2007-02-03');    -> 7
#查询星期六下的订单
SELECT * FROM `order` WHERE DAYOFWEEK(OrderDate) =7;
```

```sql
SELECT HOUR('10:05:03');   -> 10
#查看2019年双11，0点下单量
SELECT count(*) FROM `order` WHERE  OrderDate
BETWEEN '2019-11-11' and '2019-11-12' and HOUR(OrderDate) = 0 ;
```

### extract 提取年月日

> 用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。
>

date 参数是合法的日期表达式。unit 参数可以是下列的值：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207181532956.png" alt="image-20220718153243873" style="zoom:50%;" />

```sql
SELECT EXTRACT(YEAR FROM '2019-07-02');                 -> 2019
SELECT EXTRACT(YEAR_MONTH FROM '2019-07-02 01:02:03');  -> 201907
SELECT EXTRACT(DAY_MINUTE FROM '2019-07-02 01:02:03');  -> 20102
```

查表示例

```sql
select extract(year FROM createtime) AS 年,
extract(month FROM createtime) AS 月,
extract(day FROM createtime) AS 日
from tb_user1;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207181547609.png" alt="image-20220718154731527" style="zoom:67%;" />

### date_add，date_sub

DATE_ADD: 向日期添加指定的时间间隔。

```sql
-- 2092-09-20 08:32:38
select date_add(now(), INTERVAL 70 YEAR ); 
```

DATE_SUB()：从日期减去指定的时间间隔。

```sql
-- '2017-05-01'
SELECT DATE_SUB('2018-05-01',INTERVAL 1 YEAR);
# 如果你查最近七天内的订单，可以这样：
select * from `order` where OrderDate>=DATE_SUB(NOW(),INTERVAL 7 DAY);
```

### datediff：获取两个日期相差的天数

```sql
-- 512
select datediff(NOW(),'2021-1-21') 相隔天数; 
```

查询所有员工的入职天数，并根据入职天数倒序排序。

思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。

```sql
select name, datediff(curdate(), entrydate) as 'entrydays' from emp 
order by entrydays desc;
```

```sql
# 如果你查最近30天内的订单，可以这样：
select * from order where datediff(NOW(),OrderDate) <= 30;
```

### str_to_date 字符转日期

```sql
#str_to_date 将字符通过指定的格式转换成日期，结果：1998-03-02
SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;
```

```sql
#查询入职日期为1992--4-3的员工信息
SELECT * FROM employees WHERE hiredate = '1992-4-3';
SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');
```

### date_format

**定义：** 用于以不同的格式显示日期/时间数据。

date为对应的日期，fromat为输出格式。format的格式如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207181549286.png" alt="image-20220718154923175" style="zoom:50%;" />

```sql
SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y');  ->'Sunday October 2009'
SELECT DATE_FORMAT('2007-10-04 22:23:00','%H:%i:%s');   ->'22:23:00'
```

```sql
#date_format 将日期转换成字符，结果为：21年08月16日
SELECT DATE_FORMAT(NOW(),'%y年%m月%d日') AS out_put;
```

```sql
#案例：查询有奖金的员工名和入职日期(xx月/xx日 xx年)
SELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期
FROM employees
WHERE commission_pct IS NOT NULL;
```

### 时间戳转换

利用 FROM_UNIXTIME() 和 UNIX_TIMESTAMP() 函数

```sql
# 1655879641
select unix_timestamp(now());
# 2022-06-22 14:34:01
select from_unixtime(1655879641);
select unix_timestamp(now()) '时间戳', from_unixtime(1655879641) '时间';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302262051843.png" alt="image-20230226205142744" style="zoom:80%;" />

## 其他函数

### version,database,user

```sql
select version();  # 查看当前数据库版本 
select database(); # 查看当前使用的数据库
select user(); # 查看当前用户：root@localhost
select version() '数据库版本' ,database() '当前数据库' , user() '当前用户';
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212191044413.png" alt="image-20221219104432321" style="zoom: 67%;" />

### 加锁函数和解锁函数

- GET_LOCK(str,timeout)设法使用字符串str给定的名字得到一个锁，超时为timeout秒。
- RELEASE_LOCK(str)解开被GET_LOCK()获取的，用字符串str所命名的锁。
- IS_FREE_LOCK(str)检查名为str的锁是否可以使用
- IS_USED_LOCK(str)检查名为str的锁是否正在被使用

```sql
select get_lock('yunweijia', 15) as getlock,
       is_used_lock('yunweijia') as isusedlock,
       is_free_lock('yunweijia') as isfreelock,
       release_lock('yunweijia') as releaselock;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212191032999.png" alt="image-20221219103219911" style="zoom:67%;" />

`get_lock('yunweijia', 15)`：返回结果为1，说明成功得到了一个名称为‘yunweijia’的锁，持续时间为15秒；

`is_used_lock('yunweijia')`：返回结果为当前连接`id`，表示名称为`yunweijia`的锁正在被使用；

`is_free_lock('yunweijia')`：返回结果是0，说明名称为`yunweijia`的锁正在被使用；

`release_lock('yunweijia')`：返回值为1，说明解锁成功了。

### 测试函数效率

> BENCHMARK(count,expr)函数重复count次执行表达式expr。他可以用于计算MYSQL处理表达式的速度。
>

> 结果值通常为0（0只是表示处理过程很快，并不是没有花费时间）另一个作用是他可以在MYSQL客户端内部报告语句执行的时间。
>

> benchmark函数只有两个参数，第一个是执行次数，第二个是要测试的函数或者[表达式](https://so.csdn.net/so/search?q=表达式&spm=1001.2101.3001.7020)。返回的结果始终是0，执行时间才是我们需要的结果

下面使用BENCHMARK函数重复执行PASSWORD操作500000次

```sql
select benchmark(50000000, sha('123321sasd'));
select benchmark(1e8,current_date());
select benchmark(1e8, 'select * from emp');
```

> 由此可以看出，使用BENCHMARK执行500000次的时间为0.49690秒，明显比执行一次的时间延长了。TIPS：BENCHMARK报告的时间是客户端经过的时间，而不是在服务器端的CPU时间，每次执行后报告的时间并不一定是相同的。请注意，这个查询语句可能会在数据库服务器上造成很大的负载，因为它会重复执行一条查询语句很多次。在生产环境中，应该非常谨慎地使用 `BENCHMARK()` 函数，以免对数据库服务器的性能产生负面影响。在测试和开发环境中使用时，应该仔细评估其影响，避免对其他用户和应用程序造成影响。
>

### 改变字符集的函数

CONVERT(...using...)带有USING的CONVERT()函数被用来在不同的字符集之间转化数据。

```sql
select charset('yunweijia') as coll,
       charset(convert('yunweijia' using latin1)) as coll_1;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212191039126.png" alt="image-20221219103918046" style="zoom:80%;" />

默认为utf8字符集，通过CONVERT()将字符串“string”的默认字符集改为latin1

### 改变数据类型的函数

#### 基本使用

CAST(x,AS type)和CONVERT(x,type)函数将一个类型的值转换为另一个类型的值，可转换的type有：

BINARY、CHAR(n)、DATE、TIME、DATETIME、DECIMAL、SIGNED、UNSIGNED

在SQLSERVER里也是使用这两个函数进行数据类型转换的~

```sql
select cast(1000 as char(3)), convert('2022-07-18 09:09:00', time);
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212191040470.png" alt="image-20221219104034387" style="zoom:67%;" />

可以看到，`select cast(1000 as char(3))`将整数数据1000，转换为带有两个显示宽度的字符串类型，结果为100；`convert('2022-07-18 09:09:00', time)`将`datetime`类型的值转换为`time`类型值，结果是`09:09:00`

#### TIPS

1、MySQL中，日期时间以字符串形式存储在数据表中，因此可以使用字符串函数分别截取日期时间值的不同部分

2、修改默认的字符集，更改MySQL默认的字符集，在Windows中，只需要修改my.ini，该文件在MySQL安装目录下。

修改配置文件中的default-character-set和character-set-server参数值，将其改为想要的字符集名称，如：

gbk、gb2312、latin1等，修改完之后，重启MySQL服务，即可生效。

如果不确定当前使用的字符集，可以使用下面的SQL语句来查看当前字符集进行对比

```sql
SHOW VARIABLES LIKE 'character_set_%'
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302261933129.png" alt="image-20230226193327002" style="zoom:80%;" />



## 流程函数if

流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209200835448.png" alt="image-20220920083529326" style="zoom:80%;" />

### if

```sql
#1.if函数： if else 的效果
# 第一个参数是判断表达式，第二个参数为执行结果为true的情况，第三个参数为结果为false的情况
select if(10<5,'大','小');
```

### ifnull

如果为null，值为第二个

```sql
select ifnull('Ok','Default'); 

select ifnull('','Default'); 

select ifnull(null,'Default'); 
```

### case when then else end

#### 基本语法

```sql
case
when 条件1 then 要显示的值1或语句1
when 条件2 then 要显示的值2或语句2
else 要显示的值n或语句n
end
```

#### 实战演练

案例: 统计班级各个学员的成绩

```sql
create table score(
    id int comment 'ID',
    name varchar(20) comment '姓名',
    math int comment '数学',
    english int comment '英语',
    chinese int comment '语文'
) comment '学员成绩表';

insert into score(id, name, math, english, chinese)VALUES
(1, 'Tom', 67, 88, 95 ),
(2, 'Rose' , 23, 66, 90),
(3, 'Jack', 56, 98, 76);
```

```sql
select
    id,
    name,
    (case when math >= 85 then '优秀' when math >=60 then '及格' else '不及格' end ) '数学',
    (case when english >= 85 then '优秀' when english >=60 then '及格' else '不及格' end ) '英语',
    (case when chinese >= 85 then '优秀' when chinese >=60 then '及格' else '不及格' end ) '语文'
from score;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302261929135.png" alt="image-20230226192928022" style="zoom:80%;" />

# 常见约束

## 常见约束分析⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120115012574.png" alt="image-20220120115012574" style="zoom:80%;" />

> 注意：**约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。**
>
> **可以创建多个字段联合主键，在创建表时最后写上PRIMARY KEY(name, deptid)**

```sql
CREATE TABLE 表名(
   字段名 字段类型 列级约束,
   字段名 字段类型,
   表级约束
)
```



## 添加和删除约束

### 创建表时添加约束

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120100344859.png" alt="image-20220120100344859" style="zoom:80%;" />

```sql
create table user1(
    id  int primary key auto_increment comment '主键' ,
    name varchar(50) not null unique comment '姓名',
    age int check(age>0 && age<120) comment  '年龄',
    status char(1) default '1' comment '状态',
    gender char(1) comment '性别'
)comment '用户表';
```

进行插入数据测试

```sql
insert into user1(name,age,status,gender) values('Tom',22,1,'男'),('Tom1',23,0,'男');
```

查看user1中的所有索引，包括主键、外键、唯一

```sql
show index from user1;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302270914432.png" alt="image-20230227091422328" style="zoom:80%;" />

查看表结构

```sql
desc user1
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202212191111216.png" alt="image-20221219111127123" style="zoom:67%;" />

### 修改表时添加约束

```sql
-- 1、添加列级约束
alter table 表名 modify column 字段名 字段类型 新约束;

-- 2、添加表级约束
alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;
```

案例

```sql
#1.添加非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;
#2.添加默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;
#3.添加主键
#①列级约束
ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;
#②表级约束
ALTER TABLE stuinfo ADD PRIMARY KEY(id);

#①列级约束
ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;
#②表级约束
ALTER TABLE stuinfo ADD UNIQUE(seat);
```

### 修改表时删除约束

```sql
#1.删除非空约束
ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;

#2.删除默认约束
ALTER TABLE stuinfo MODIFY COLUMN age INT ;

#3.删除主键
ALTER TABLE stuinfo DROP PRIMARY KEY;

#4.删除唯一
ALTER TABLE stuinfo DROP INDEX seat;

#5.删除外键
ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;

SHOW INDEX FROM stuinfo;
```



## 外键约束(主从表一致性)

> 外键用来在两个表的数据之间建立连接，可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，**一个表的外键可以是空值，若不为空值，则每一个外键值必须等于另一个表中主键的某个值**。

> 外键：首先他是表中的一个字段，虽可以不是本表的主键，但要对应另外一个表的主键。外键的主要作用是保证数据引用的完整性，定义外键后，不允许删除在另一个表中具有关联关系的行。外键的作用是保持数据的一致性、完整性。

> 主表（父表）：对于两个具有关联关系的表而言，相关联字段中**主键所在的那个表是主表**。
>
> 从表（子表）：对于两个具有关联关系的表而言，相关联字段中**外键所在的那个表是从表**。

### 外键作用

外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。我们来看一个例子：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206171844850.png" alt="image-20220617184416724" style="zoom:67%;" />

左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日

期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的

部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。

> 注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联，所以是无法保证数据的一致性和完整性的。

### 外键语法

#### 添加外键

```sql
alter table 表名 
add constraint 外键名称 foreign key (外键字段) 
references 主表名(主表字段名) 
on update 行为 on delete 行为;
```

注意：当执行更新和删除操作时，上面的主表的变化对关联的一个表没影响，而反之则会产生影响

方式一：默认添加(不推荐)

```sql
alter table emp 
add constraint fk_emp_dept_id 
foreign key (dept_id) references dept(id);
```

方式二：设置外键约束cascade(更新删除行为)

```sql
alter table emp 
add constraint fk_emp_dept_id foreign key (dept_id) 
references dept(id) 
on update cascade on delete cascade ;
```

方式三：设置外键约束null

```sql
alter table emp 
add constraint fk_emp_dept_id foreign key (dept_id) 
references dept(id) 
on update set null on delete set null ;
```

#### 删除外键

注意：如果本身有外键，再添加外键要先删除外键

```sql
alter table emp drop foreign key 外键名;
```



### 删除/更新行为⭐

添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行为有以下几种

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120105008855.png" alt="image-20220120105008855" style="zoom:80%;" />

> - 前面两个是默认行为，一旦执行更新和删除操作，就会报错
> - 后面三个是自己设置的行为，很好用

### 外键实战

#### 创建表

```sql
-- 创建部门表
create table dept(
    id   int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '部门名称'
)comment '部门表';

-- 插入数据
INSERT INTO dept (id, name) 
VALUES 
(1, '研发部'), 
(2, '市场部'),
(3, '财务部'), 
(4, '销售部'), 
(5, '总经办');

-- 创建员工表
create table emp(
    id  int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '姓名',
    age  int comment '年龄',
    job varchar(20) comment '职位',
    salary int comment '薪资',
    entrydate date comment '入职时间',
    managerid int comment '直属领导ID',
    dept_id int comment '部门ID'
)comment '员工表';

-- 插入数据
INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) 
VALUES
(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),
(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1);
```

dept

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120114610997.png" alt="image-20220120114610997" style="zoom:80%;" />

emp

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120114632516.png" alt="image-20220120114632516" style="zoom:80%;" />

#### 添加外键

方式一：默认添加(不推荐)

```sql
alter table emp 
add constraint fk_emp_dept_id 
foreign key (dept_id) references dept(id);
```

方式二：设置外键约束cascade

```sql
alter table emp 
add constraint fk_emp_dept_id foreign key (dept_id) 
references dept(id) 
on update cascade on delete cascade ;
```

修改dept表的id=1的字段

```sql
update dept set id=7 where id=1;
```

这时看emp表可以发现，id为1的全变成了7

emp表

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120111631329.png" alt="image-20220120111631329" style="zoom:80%;" />

> 当然，删除也是对应删除的。相当于父表删除子表对应内容全删除
>

方式三：设置外键约束null(推荐)

```sql
alter table emp 
add constraint fk_emp_dept_id foreign key (dept_id) 
references dept(id) 
on update set null on delete set null ;
```

删除dept表id=5的字段

```sql
delete from dept where id = 5
```

**进入emp表进行查看，发现关联的外键被设置成了null**

#### 删除外键

再次添加外键前要先删除外键

```sql
alter table emp drop foreign key fk_emp_dept_id;
```



# 事务

## 概述

> **事务是逻辑上的一组操作，要么都执行，要么都不执行,是一个不可分割的工作单位。**

这个场景中我们需要插入多条相关联的数据到数据库，这个过程可能会遇到下面这些问题：

> - 数据库中途突然因为某些原因挂掉了。
> - 客户端突然因为网络原因连接不上数据库了。
> - 并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。

> 假如A转账给B 100 元，先从A的账户里扣除 100 元，再在 B 的账户上加上 100 元。如果扣完A的100元后，还没来得及给B加上，银行系统异常了，最后导致A的余额减少了，B的余额却没有增加。所以就需要事务，将A的钱回滚回去，就是这么简单。

> 为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206162224070.png" alt="image-20220616222423985" style="zoom: 67%;" />

> 注意： **默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务**

## 基本语法

### 自动改手动

查看/设置事务提交方式

```sql
select @@autocommit; -- 查询事务提交方式：1表示自动，0表示手动
set @@autocommit = 0; -- 设置为手动提交
# 多条 SQL 语句
SQL1,SQL2,SQL3
commit；
```

### 推荐方式

开启事务

```sql
start transaction ;  或  begin ;
```

提交事务

```sql
commit;
```

回滚事务

```sql
-- 回滚事务
rollback ;
```

综合使用

```sql
# 开启一个事务
start transaction ;
# 多条 SQL 语句
SQL1,SQL2,SQL3
# 提交事务
commit;
```



## 四大特性和并发问题

### 四大特性ACID

> 只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302271112570.png" alt="image-20230227111249423" style="zoom:80%;" />

### 并发问题

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img/image-20220120193051267.png" alt="image-20220120193051267" style="zoom:80%;" />

> **不可重复读和幻读区别** ：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次查询同一条查询语句（DQL）时，记录发现记录增多或减少了



## 事务的隔离级别

### 四种隔离级别

> **READ-UNCOMMITTED(读取未提交)** ： **最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读**。

> **READ-COMMITTED(读取已提交)** ： **允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生**。

> **REPEATABLE-READ(可重复读)** ： **对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生**。

> **SERIALIZABLE(可串行化)** ： **最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201021387.png" alt="image-20220920102159181" style="zoom:80%;" />

- mysql中默认 第三个隔离级别 repeatable read

- oracle中默认第二个隔离级别 read committed

### 查看隔离级别

```sql
-- MySQL8.0前
select @@tx_isolation;
-- MySQL 8.0 该命令改为
SELECT @@transaction_isolation;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206161938075.png" alt="image-20220616193807000" style="zoom:80%;" />

### 设置隔离级别

通过以下 SQL 可以设置当前客户端的事务隔离级别：

```sql
set session transaction isolation level 事务隔离级别;
```

事务隔离级别的值有 4 个：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE。

```sql
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
```

> 注意：**事务隔离级别越高，数据越安全，但是性能越低**。

## 四大隔离级别实践

既然并发事务存在**脏读、不可重复、幻读**等问题，InnoDB实现了哪几种事务的隔离级别应对呢？

- 读未提交（Read Uncommitted）
- 读已提交（Read Committed）
- 可重复读（Repeatable Read）
- 串行化（Serializable）

```sql
CREATE TABLE `account`(
	`id` int(11) NOT NULL,
	`name` varchar(255) DEFAULT NULL,
    `balance` int(11) DEFAULT NULL,
     PRIMARY KEY (`id`),
     UNIQUE KEY `un_name_idx`(`name`)USING BTREE
)ENGINE=InnoDBDEFAULT CHARSET=utf8;
insert into account(id, name, money) VALUES (null,'张三',2000),(null,'李四',2000);
```

### 读未提交（Read Uncommitted）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202302271437588.png" alt="image-20230227143708414" style="zoom:80%;" />

先把事务隔离级别设置为read uncommitted，开启事务A，查询id=1的数据

```sql
set session transaction isolation level read uncommitted;
begin;
select * from account where id =1;
```

结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201408046.png" alt="image-20220720140823967" style="zoom:67%;" />

这时候，另开一个窗口打开mysql，也把当前事务隔离级别设置为read uncommitted，开启事务B，执行更新操作

```sql
set session transaction isolation level read uncommitted;
begin;
update account set balance=balance+20 where id =1;
```

> 可以发现，在**读未提交（Read Uncommitted）** 隔离级别下，一个事务会读到其他事务未提交的数据的，即存在**脏读**问题。事务B都还没commit到数据库呢，事务A就读到了，感觉都乱套了。。。实际上，读未提交是隔离级别最低的一种。
>



### 读已提交（Read committed）

为了避免脏读，数据库有了比**读未提交**更高的隔离级别，即**读已提交**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201411173.png" alt="image-20220720141131074" style="zoom:67%;" />

把当前事务隔离级别设置为读已提交（READ COMMITTED），开启事务A，查询account中id=1的数据

```sql
set session transaction isolation level read committed;
begin;
select * from account where id =1;
```

另开一个窗口打开mysql，也把事务隔离级别设置为read committed，开启事务B，执行以下操作

```sql
set session transaction isolation level read committed;
begin;
update account set balance=balance+20 where id =1;
```

接着回事务A的窗口，再查account数据，发现数据没变：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201414572.png" alt="image-20220720141452499" style="zoom:80%;" />

我们再去到事务B的窗口执行commit操作：

```sql
commit;
```

最后回到事务A窗口查询，发现数据变了：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201415789.png" alt="image-20220720141515717" style="zoom:67%;" />

> 由此可以得出结论，隔离级别设置为**已提交读（READ COMMITTED）** 时，已经不会出现脏读问题了，当前事务只能读取到其他事务提交的数据。但是，你站在事务A的角度想想，存在其他问题吗？
>

**读已提交的隔离级别会有什么问题呢？**

> **在同一个事务A里，相同的查询sql，读取同一条记录（id=1），读到的结果是不一样的**，即**不可重复读**。所以，隔离级别设置为read committed的时候，还会存在**不可重复读**的并发问题。

### 可重复读（Repeatable Read）

> 如果你的老板要求，在同个事务中，查询结果必须是一致的，即老板要求你解决不可重复的并发问题，怎么办呢？老板，臣妾办不到？来实践一下**可重复读（Repeatable Read）** 这个隔离级别吧~
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201413824.png" alt="image-20220720141351724" style="zoom:67%;" />

> 哈哈，步骤1、2、6的查询结果都是一样的，即**repeatable read解决了不可重复读问题**，是不是心里美滋滋的呢，终于解决老板的难题了~
>

**RR级别是否解决了幻读问题呢？**

> 再来看看网上的一个热点问题，有关于RR级别下，是否解决了幻读问题？我们来实践一下：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201414538.png" alt="image-20220720141406439" style="zoom:80%;" />

> 由图可得，步骤2和步骤6查询结果集没有变化，看起来RR级别是已经解决幻读问题了~ 但是呢，**RR级别还是存在这种现象**：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201414793.png" alt="image-20220720141420689" style="zoom:80%;" />

其实，上图如果事务A中，没有 `update account set balance=200 where id = 5;`这步操作， `select * from account where id > 2`查询到的结果集确实是不变，这种情况没有**幻读**问题。但是，有了update这个骚操作，同一个事务，相同的sql，查出的结果集不同，这个是符合了**幻读**的定义~

这个问题，亲爱的朋友，你觉得它算幻读问题吗？

### 串行化（Serializable）

> 前面三种数据库隔离级别，都有一定的并发问题，现在放大招吧，实践SERIALIZABLE隔离级别。
>

> 把事务隔离级别设置为Serializable，开启事务A，查询account表数据
>

```sql
set session transaction isolation level serializable;
select @@tx_isolation;
begin;
select * from account;
```

另开一个窗口打开mysql，也把事务隔离级别设置为Serializable，开启事务B，执行插入一条数据：

```sql
set session transaction isolation level serializable;
select @@tx_isolation;
begin;
insert into account(id,name,balance) value(6,'Li',100);
```

执行结果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207201412484.png" alt="image-20220720141246376" style="zoom:67%;" />

> 由图可得，当数据库隔离级别设置为serializable的时候，事务B对表的写操作，在等事务A的读操作。其实，这是隔离级别中最严格的，读写都不允许并发。它保证了最好的安全性，性能却是个问题~
>



## 实战演练⭐

> 注意：一次执行中rollback和commit只执行一个
>

### 数据准备

```sql
drop table if exists account;
-- 数据准备
create table account(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    money int comment '余额'
) comment '账户表';
insert into account(id, name, money) VALUES (null,'张三',2000),(null,'李四',2000);
```

### 未控制事务

#### 测试正常情况

```sql
-- 1. 查询张三余额 
select * from account where name = '张三'; 
-- 2. 张三的余额减少1000 
update account set money = money - 1000 where name = '张三'; 
-- 3. 李四的余额增加1000 
update account set money = money + 1000 where name = '李四';
-- 4. 查询账户情况
select * from account;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201003186.png" alt="image-20220920100307996" style="zoom:80%;" />

#### 测试异常情况

这样直接全部执行就行

```sql
-- 还原数据
update account set money = 2000 where name = '张三' or name = '李四';
-- 1. 查询张三余额 
select * from account where name = '张三'; 
-- 2. 张三的余额减少1000 
update account set money = money - 1000 where name = '张三'; 
出错了.... 
-- 3. 李四的余额增加1000 
update account set money = money + 1000 where name = '李四';
```

> 我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了.... 这句话不符合SQL语 法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201005010.png" alt="image-20220920100512819" style="zoom:80%;" />

### 使用事务控制⭐

即使中间发生错误，也能自动回滚，不会发生错误

```sql
-- 恢复数据
update account set money = 2000 where name = '张三' or name = '李四';
```

```sql
-- 转账操作 (张三给李四转账1000)
-- 开启事务
start transaction ;
-- 1. 查询张三账户余额
select * from account where name = '张三';

-- 2. 将张三账户余额-1000
update account set money = money - 1000 where name = '张三';

程序执行报错 ...

-- 3. 将李四账户余额+1000
update account set money = money + 1000 where name = '李四';
```

此时发现报错，再去查看，数据已经修改

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201010487.png" alt="image-20220920101050294" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201012345.png" alt="image-20220920101254156" style="zoom:80%;" />

```sql
-- 提交事务（此时不能进行提交，要执行回滚）
commit;

-- 回滚事务(commit之后就不能rollback了)
rollback ;
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202209201014018.png" style="zoom:80%;" />





































