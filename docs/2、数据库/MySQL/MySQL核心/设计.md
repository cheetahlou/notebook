

# 团队开发规范

## 数据库对象命名规范

### 数据库对象

> 数据库对象是数据库的组成部分，常见的有以下几种：**表（Table ）、索引（Index）、视图（View）、图表（Diagram）、缺省值（Default）、规则（Rule）、触发器（Trigger）、存储过程（Stored Procedure）、 用户（User）**等。

> 命名规范是指数据库对象如**数据库（SCHEMA）、表（TABLE）、索引（INDEX）、约束（CONSTRAINTS）等**

### 数据库对象全局命名规范

> 1、**命名使用具有意义的英文词汇，词汇中间以下划线分隔**
>
> 2、**命名只能使用英文字母、数字、下划线，以英文字母开头**
>
> 3、**避免用MySQL的保留字如：backup、call、group等**
>
> 4、**所有数据库对象使用小写字母**，实际上MySQL中是可以设置大小写是否敏感的

### 数据库命名规范

> 1、数据库命名尽量不超过30个字符。
>
> 2、**数据库命名一般为项目名称+代表库含义的简写**，比如IM项目的工作流数据库，可以是 im_flow。
>
> 3、**数据库创建时必须添加默认字符集和校对规则子句。默认字符集为UTF8（已迁移dumbo的使用utf8mb4）**
>
> 4、**命名应使用小写**

### 表命名规范

> 1、**常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo**

> 2、**临时表**（**RD、QA或DBA同学用于数据临时处理的表**），命名规则：**temp前缀+模块+表+日期后缀**：temp_user_eduinfo_20210719

> 3、**备份表**（**用于保存和归档历史数据或者作为灾备恢复的数据**）命名规则，**bak前缀+模块+表+日期后缀**：bak_user_eduinfo_20210719

> 4、**同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义**

> 5、**多个单词以下划线 _ 分隔**

> 6、**常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写**

### 字段命名规范

> 1、**字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接**，如 service_ip、service_port
>
> 2、**各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time**，不一致会很混乱
>
> 3、**多个单词以下划线 _ 分隔**
>
> 4、**字段名尽量不超过30个字符，命名应该使用小写**

### 索引命名规范

> 1、**唯一索引使用uni + 字段名** 来命名：create unique index uni_uid on t_user_basic(uid) 。
>
> 2、**非唯一索引使用idx + 字段名** 来命名：create index idx_uname_mobile on t_user_basic(uname,mobile) 。
>
> 3、**多个单词以下划线 _ 分隔**。
>
> 4、**索引名尽量不超过50个字符，命名应该使用小写，组合索引的字段不宜太多**，不然不利于查询效率的提升
>
> 5、**多单词组成的列名，取尽可能代表意义的缩写**，如 test_contact表member_id和friend_id上的组合索引：idx_mid_fid。
>
> 6、**理解组合索引最左前缀原则，避免重复建设索引**，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)。

### 视图命名规范

> 1、**视图名以v开头，表示view，完整结构是v+视图内容含义缩写**。
>
> 2、**如果视图只来源单个表，则为v+表名。如果视图由几个表关联产生就用v+下划线（_）连接几个表名，视图名尽量不超过30个字符。如超过30个字符则取简写**。
>
> 3、**如无特殊需要，严禁开发人员创建视图**。
>
> 4、**命名应使用小写**。

### 存储过程命名规范

> 1、**存储过程名以sp开头，表示存储过程（storage procedure）**。**之后多个单词以下划线（_）进行连接。存储过程命名中应体现其功能。存储过程名尽量不能超过30个字符**。
>
> 2、**存储过程中的输入参数以i_开头，输出参数以o开头**。
>
> 3、**命名应使用小写**。

```sql
create procedure sp_multi_param(in i_id bigint,
                                in i_name varchar(32),
                                out o_memo varchar(100)) 
```

### 函数命名规范

> 1、**函数名以func开始，表示function。之后多个单词以下划线（_）进行连接，函数命名中应体现其功能。函数名尽量不超过30个字符**。
>
> 2、**命名应使用小写**。

```sql
create function func_format_date(ctime datetime)
```

### 触发器命名规范

> 1、**触发器以trig开头，表示trigger 触发器**。
>
> 2、**基本部分，描述触发器所加的表，触发器名尽量不超过30个字符**。
>
> 3、**后缀（_i,_u,_d）,表示触发条件的触发方式（insert,update或delete）**。
>
> 4、**命名应使用小写**。

```sql
DROP TRIGGER IF EXISTS trig_attach_log_d;
CREATE TRIGGER trig_attach_log_d AFTER DELETE ON t_dept FOR EACH ROW; 
```

### 约束命名规范

> 1、**唯一约束**：**uk\_表名称_字段名**。**uk是UNIQUE KEY的缩写**。比如给一个部门的部门名称加上唯一约束，来保证不重名，如下：ALTER TABLE t_dept ADD CONSTRAINT un_name UNIQUE(name);

> 2、**外键约束**：**fk\_表名，后面紧跟该外键所在的表名和对应的主表名（不含t_）**。子表名和父表名用下划线(_)分隔。如下：ALTER TABLE t_user ADD CONSTRAINT fk_user_dept FOREIGN KEY(depno) REFERENCES t_dept (id);

> 3、**非空约束：如无特殊需要，建议所有字段默认非空(not null)，不同数据类型必须给出默认值(default)**。

```sql
`id` int(11) NOT NULL,
`name` varchar(30) DEFAULT '',
`deptId` int(11) DEFAULT 0,
`salary` float DEFAULT NULL, 
```

> 4、**出于性能考虑，如无特殊需要，建议不使用外键**。**参照完整性由代码控制。这个也是我们普遍的做法，从程序角度进行完整性控制，但是如果不注意，也会产生脏数据**。

> 5、**命名应使用小写**。

### 用户命名规范

> 1、 **生产使用的用户命名格式为 code_应用**
>
> 2、 **只读用户命名规则为 read_应用**

## 数据库对象设计规范

### 存储引擎的选择

> **如无特殊需求，必须使用innodb存储引擎**

> **可以通过 show variables like 'default_storage_engine' 来查看当前默认引擎**。主要有MyISAM 和 InnoDB，从5.5版本开始默认使用 InnoDB 引擎。

> 差别：**MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能**。
>

### 字符集的选择

> **如无特殊要求，必须使用utf8或utf8mb4**

> 在国内，选择对中文和各语言支持都非常完善的`utf8`格式是最好的方式，MySQL在5.5之后增加utf8mb4编码，**mb4就是most bytes 4的意思，专门用来兼容四字节的unicode，可以插入表情包**。
>

> **所以utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了**。

可以使用如下脚本来查看数据库的编码格式

```sql
1 SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%';
2 -- 或
3 SHOW VARIABLES Like '%char%';  
```

### 表设计规范

> 1、**不同应用间所对应的数据库表之间的关联应尽可能减少，不允许使用外键对表之间进行关联，确保组件对应的表之间的独立性，为系统或表结构的重构提供可能性**。目前业内的做法一般 由程序控制参照完整性。

> 2、**表设计的角度不应该针对整个系统进行数据库设计，而应该根据系统架构中组件划分，针对每个组件所处理的业务进行数据库设计**。

> 3、**表必须要有PK(primary key)，主键的优势是唯一标识、有效引用、高效检索，一般情况尽量有主键**。
>
> 4、**一个字段只表示一个含义**。
>
> 5、**表不应该有重复列**。
>
> 6、**禁止使用复杂数据类型(数组,自定义等)，Json类型的使用视情况而定**。
>
> 7、**需要join的字段(连接键)，数据类型必须保持绝对一致，避免隐式转换。比如关联的字段都是int类型**。

> 8、**设计应至少满足第三范式,尽量减少数据冗余**。**一些特殊场景允许反范式化设计，但在项目评审时需要对冗余字段的设计给出解释**。

> 9、**TEXT字段作为大体量文本存储，必须放在独立的表中 , 用PK与主表关联**。**如无特殊需要，禁止使用TEXT、BLOB字段**。

> 10、**需要定期删除(或者转移)过期数据的表，通过分表解决，我们的做法是按照2/8法则将操作频率较低的历史数据迁移到历史表中，按照时间或者则曾Id做切割点**。

> 11、**单表字段数不要太多，建议最多不要大于50个。过度的宽表对性能也是很大的影响**。

> 12、**MySQL在处理大表时，性能就开始明显降低，所以建议单表物理大小限制在16GB，表中数据行数控制在2000W内。业内的规则是超过2000W性能开始明显降低**。
>
> **但是这个值是灵活的，你可以根据实际情况进行测试来判断，比如阿里的标准就是500W，百度的确是2000W。实际上是否宽表，单行数据所占用的空间都有起到作用的**。

> 13、**如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略**，后续会有专门的文章来分析数据拆分的做法：**垂直拆分（垂直分库和垂直分表）、水平拆分（分库分表和库内分表）**；

> 14、**无特殊需求，严禁使用分区表**

### 字段设计规范

> 1、INT：**如无特殊需要，存放整型数字使用UNSIGNED INT型，整型字段后的数字代表显示长度**。比如

```sql
 `id` int(11) NOT NULL
```

> 2、DATETIME：**所有需要精确到时间(时分秒)的字段均使用DATETIME,不要使用TIMESTAMP类型**。

> **对于TIMESTAMP，它把写入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回**。而**对于DATETIME，不做任何改变，基本上是原样输入和输出**。

另外DATETIME存储的范围也比较大：

> timestamp所能存储的时间范围为：'1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999'。
>
> datetime所能存储的时间范围为：'1000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999'。

> 但是特殊情况，对于跨时区的业务，TIMESTAMP更为合适。
>

> 3、**VARCHAR：所有动态长度字符串 全部使用VARCHAR类型,类似于状态等有限类别的字段,也使用可以比较明显表示出实际意义的字符串,而不应该使用INT之类的数字来代替**；VARCHAR(N)，

> **N表示的是字符数而不是字节数**。比如VARCHAR(255)，可以最大可存储255个字符（字符包括英文字母，汉字，特殊字符等）。**但N应尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，且存储字符个数由所选字符集决定**。

> **如UTF8存储一个字符最大要3个字节，那么varchar在存放占用3个字节长度的字符时不应超过21845个字符。同时，在进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。(如无特殊需要，原则上单个varchar型字段不允许超过255个字符)**

> 4、**TEXT：仅仅当字符数量可能超过20000个的时候,才可以使用TEXT类型来存放字符类数据,因为所有MySQL数据库都会使用UTF8字符集**。

> **所有使用TEXT类型的字段必须和原表进行分拆，与原表主键单独组成另外一个表进行存放，与大文本字段的隔离，目的是。如无特殊需要，不使用MEDIUMTEXT、TEXT、LONGTEXT类型**

> 5、**对于精确浮点型数据存储，需要使用DECIMAL，严禁使用FLOAT和DOUBLE**。
>
> 6、**如无特殊需要，尽量不使用BLOB类型**
>
> 7、**如无特殊需要，字段建议使用NOT NULL属性，可用默认值代替NULL**
>
> 8、**自增字段类型必须是整型且必须为UNSIGNED，推荐类型为INT或BIGINT，自增字段必须是主键**。

> 7、**表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）**。 说明：任何字段如果为非负数，必须是 unsigned。 注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 
>
> 正例：**表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除**。 

> 8、**小数类型为 decimal，禁止使用 float 和 double**。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。（重要）

> 9、**如果存储的字符串长度几乎相等，使用 char 定长字符串类型**。 

> 10、**varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率**。



### 索引设计规范

> 1、**索引区分度**：**索引必须创建在索引选择性（区分度）较高的列上**，选择性的计算方式为:  selecttivity = count(distinct c_name)/count(*) ; 如果区分度结果小于0.2，则不在此列上创建索引，否则可能会拖慢SQL执行

> 2、**遵循最左前缀**：**对于确定需要组成组合索引的多个字段，设计时建议将选择性高的字段靠前放**。使用时，组合索引的首字段，必须在where条件中，且需要按照最左前缀规则去匹配。

> 3、**禁止使用外键，可以在程序级别来约束完整性**
>
> 4、**Text类型字段如果需要创建索引，必须使用前缀索引**
>
> 5、**单张表的索引数量理论上应控制在5个以内。经常有大批量插入、更新操作表，应尽量少建索引，索引建立的原则理论上是多读少写的场景**。
>
> 6、**ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面，形成覆盖索引**

> 7、**正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别**。

> 8、**正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引**。

> 9、**联合索引注意最左匹配原则：必须按照从左到右的顺序匹配**，MySQL会一直向右匹配索引直到遇到范围查询(>、<、between、like)然后停止匹配。如：depno=1 and empname>'' and job=1 如果建立(depno,empname,job)顺序的索引，job是用不到索引的。

> 10、**应需而取策略，查询记录的时候，不要一上来就使用*，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率**。

> 11、**正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率**。

> 12、**避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“**。

> 13、**避免非必要的类型转换，字符串字段使用数值进行比较的时候会导致索引无效**。

> 14、**模糊查询'%value%'会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是'value%'是可以有效利用索引**。

> 15、**索引覆盖排序字段，这样可以减少排序步骤，提升查询效率**

> 16、**尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可**。

举例子：比如一个品牌表，建立的的索引如下，一个主键索引，一个唯一索引

```sql
PRIMARY KEY (`id`),
UNIQUE KEY `uni_brand_define` (`app_id`,`define_id`)
```

当你同事业务代码中的检索语句如下的时候，应该立即警告了，即没有覆盖索引，也没按照最左前缀原则：

```sql
select brand_id,brand_name from  ds_brand_system where status=?  and define_id=?  and app_id=?
```

建议改成如下：

```sql
select brand_id,brand_name from  ds_brand_system where app_id=? and define_id=?  and  status=? 
```

### 约束设计规范

> 1、**PK应该是有序并且无意义的，由开发人员自定义，尽可能简短，并且是自增序列**。
>
> 2、**表中除PK以外,还存在唯一性约束的,可以在数据库中创建以“uk_”作为前缀的唯一约束索引**。
>
> 3、**PK字段不允许更新**。
>
> 4、**禁止创建外键约束，外键约束由程序控制**。
>
> 5、**如无特殊需要，所有字段必须添加非空约束，即not null**。
>
> 6、**如无特殊需要，所有字段必须有默认值**

> 5、**表必备三字段：id, gmt_create, gmt_modified**，其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。（如果使用分库分表集群部署，则id类型为verchar，非自增，业务中使用分布式id生成器）。**gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新**。

>  6、**单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表**。 **说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表**。 
>

> 11、**唯一索引名为 uk\_字段名；普通索引名则为 idx\_字段名。说明：uk_ 即 unique key；idx_ 即 index简称**

> 12、**不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度**。 

## SQL使用规范

### 检索的规范性

> 尽量避免使用`select *`，join语句使用`select *`可能导致只需要访问索引即可完成的查询需要回表取数。**一种是可能取出很多不需要的数据，对于宽表来说，这是灾难**；一种是**尽可能避免回表，因为取一些根本不需要的数据而回表导致性能低下**，是很不合算。

> 严禁使用 select * from t_name ，而不加任何where条件，道理一样，这样**会变成全表全字段扫描**。
>

> MySQL中的text类型字段存储：**不与其他普通字段存放在一起,因为读取效率低，也会影响其他轻量字段存取效率**。**如果不需要text类型字段，又使用了select *，会让该执行消耗大量io，效率也很低下**
>

> 4、在取出字段上可以使用相关函数，但**应尽可能避免出现 now() , rand() , sysdate() 等不确定结果的函数**，在Where条件中的过滤条件字段上严禁使用任何函数，包括数据类型转换函数。**大量的计算和转换会造成效率低下**，这个在索引那边也描述过了。

> 5、**分页查询语句全部都需要带有排序条件 , 否则很容易引起乱序**
>
> 6、**用in()/union替换or，效率会好一些，并注意in的个数小于300**
>
> 7、**严禁使用%前缀进行模糊前缀查询**:如：select a,b,c from t_name where a like ‘%name’; **可以使用%模糊后缀查询**如：select a,b from t_name where a like ‘name%’;

> **避免使用子查询，可以把子查询优化为join操作，通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化**。

### 子查询性能差

> **子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响**；

> **特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大**；

> **由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询**。



### 操作的规范性

> **禁止使用不含字段列表的INSERT语句**

```sql
insert into values ('a','b','c');  
应该使用  
insert into t_name(c1,c2,c3) values ('a','b','c'); 
```

> **大批量写操作（UPDATE、DELETE、INSERT），需要分批多次进行操作**

> **大批量操作可能会造成严重的主从延迟**，**特别是主从模式下，大批量操作可能会造成严重的主从延迟，因为需要slave从master的binlog中读取日志来进行数据同步**。

> **binlog日志为row格式时会产生大量的日志**

# 数据库建模工具

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304101420099.png" alt="image-20230410142019980" style="zoom:80%;" />

## MySQL Workbench

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304101423456.png" alt="image-20230410142357999" style="zoom:80%;" />

## SQL Power Architect

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304101424798.png" alt="image-20230410142427608" style="zoom:80%;" />

## PDManer⭐

> 国产，对中文支持好

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304101425110.png" alt="image-20230410142525971" style="zoom:80%;" />

## DB Designer

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304101426330.png" alt="image-20230410142614130" style="zoom:80%;" />

## dbdiagram.io

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202304101426292.png" alt="image-20230410142644163" style="zoom:80%;" />



# 表设计的经验准则

## 命名规范

> 数据库表名、字段名、索引名等都需要命名规范，可读性高（一般要求用英文），让别人一看命名，就知道这个字段表示什么意思。

比如一个表的账号字段，**反例如下**：

```sql
acc_no,1_acc_no,zhanghao
```

**正例：**

```sql
account_no,account_number
```

- 表名、字段名必须使用小写字母或者数字，禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写。
- 主键索引名为`pk_字段名`；唯一索引名为`uk_字段名`；普通索引名则为`idx_字段名`。

## 选择合适的字段类型

设计表时，我们需要选择合适的字段类型，比如：

- 选择存储空间小的字段类型，就好像数字类型的`tinyint、smallint、int、bigint`，从左往右开始选择
- 小数类型如金额，则选择 `decimal`，禁止使用 `float` 和 `double`。
- 如果存储的字符串长度几乎相等，使用 `char` 定长字符串类型。
- `varchar`是可变长字符串，不预先分配存储空间，长度不要超过`5000`。
- 如果存储的值太大，建议字段类型修改为`text`，同时抽出单独一张表，用主键与之对应。
- 同一表中，所有`varchar`字段的长度加起来，不能大于`65535`。如果有这样的需求，使用`TEXT/LONGTEXT `类型

## 主键设计要合理

> 主键设计的话，最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。**主键最好是毫无意义的一串独立不重复的数字**，比如`UUID`，又或者`Auto_increment`自增的主键，或者是雪花算法生成的主键等等。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpxLwpugXhicDPDvgRXjFPRn4jFgk9O0befPpt96IGVIeGG30rR51ibsLWp0RGv8WUNkmBCDteUTXYEA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

## 选择合适的字段长度

先问大家一个问题，大家知道数据库字段长度表示**字符长度**还是**字节长度**嘛？

> 其实在 mysql 中，`varchar`和`char`类型表示字符长度，而其他类型的则都表示字节长度。比如`char(10)`表示字符长度是 10，而`bigint（4）`表示显示长度是`4`个字节，但是因为 bigint 实际长度是`8`个字节，所以bigint（4）的实际长度就是 8 个字节。

我们在设计表的时候，需要充分考虑一个字段的长度，比如一个用户名字段（它的长度 5~20 个字符），你觉得应该设置多长呢？可以考虑设置为 `username varchar（32）`。字段长度一般设置为 2 的幂（也就是`2 的 n`次方）。

## 优先考虑逻辑删除，而不是物理删除

什么是物理删除？什么是逻辑删除？

- 物理删除：把数据从硬盘中删除，可释放存储空间。
- 逻辑删除：给数据添加一个字段，比如`is_deleted`，以标记该数据已经逻辑删除。

物理删除就是执行`delete`语句，如删除`account_no =‘666’`的账户信息 SQL 如下：

```sql
delete from account_info_tab whereaccount_no ='666';
```

逻辑删除呢，就是这样：

```sql
update account_info_tab set is_deleted = 1 where account_no ='666';
```

**为什么推荐用逻辑删除，不推荐物理删除呢？**

> - 为什么不推荐使用物理删除，因为恢复数据很困难。
> - 物理删除会使自增主键不再连续。
> - 核心业务表的数据不建议做物理删除，只适合做状态变更。

## 每个表都需要添加几个通用字段

一般来说，每个表都会具备以下这几个字段：

- id：主键，一个表必须得有主键，必须。
- create_time：创建时间，必须。
- modifed_time/update_time：修改时间，必须，更新记录时，需要更新它。
- version：数据记录的版本号，用于乐观锁，非必须。
- remark ：数据记录备注，非必须。
- modified_by：修改人，非必须。
- creator ：创建人，非必须。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpxLwpugXhicDPDvgRXjFPRn4ygqEGKDbHhdAIxmtedSCTZPdicJOLibpFgcicCqC72aTblxSWiaKL1gNow/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

## 一张表的字段不宜过多

我们建表的时候，要牢记，一张表的字段不宜过多，一般尽量不要超过 20 个字段。

如果一张表的字段过多，表中保存的数据可能就会很大，查询效率就会很低。

因此，一张表不要设计太多字段，如果业务需求，实在需要很多字段，可以把一张大的表，拆成多张小的表，它们的主键相同即可。

当表的字段数非常多时，可以将表分成两张表，一张作为条件查询表，一张作为详细内容表（主要是为了性能考虑）。

## 尽可能使用 not null 定义字段

如果没有特殊的理由， 一般都建议将字段定义为`NOT NULL` 。

**为什么呢？**

- 首先，`NOT NULL` 可以防止出现空指针问题。
- 其次，`NULL`值存储也需要额外的空间，它也会导致比较运算更为复杂，使优化器难以优化 SQL。
- `NULL`值有可能会导致索引失效。
- 如果将字段默认设置成一个空字符串或常量值并没有什么不同，且都不会影响到应用逻辑， 那就可以将这个字段设置为`NOT NULL`。

## 设计表时，评估哪些字段需要加索引

首先，评估你的表数据量。如果你的表数据量只有一百几十行，就没有必要加索引。否则设计表的时候，如果有查询条件的字段，一般就需要建立索引。但是索引也不能滥用：

- 索引也不要建得太多，一般单表索引个数不要超过`5`个。因为创建过多的索引，会降低写的速度。
- 区分度不高的字段，不能加索引，如性别等。
- 索引创建完后，还是要注意避免索引失效的情况，如使用 mysql 的内置函数，会导致索引失效。
- 索引过多的话，可以通过联合索引的方式来优化。然后，索引还有一些规则，如覆盖索引，最左匹配原则等等。

假设你新建一张用户表，如下：

```sql
CREATE TABLE user_info_tab (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL,
  `modifed_time` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

对于这张表，很可能会有根据`user_id`或者`name`查询用户信息，并且，`user_id`是唯一的。因此，你可以给`user_id`加上唯一索引，`name`加上普通索引：

```sql
CREATE TABLE user_info_tab (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL,
  `modifed_time` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE,
  UNIQUE KEY un_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

## 不需要严格遵守 3NF

通过业务字段冗余来减少表关联

什么是数据库三范式（`3NF`），大家是否还有印象吗？

- 第一范式：对属性的原子性，要求属性具有原子性，不可再分解。
- 第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖。
- 第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖。

我们设计表及其字段之间的关系，应尽量满足第三范式。但是有时候，可以适当冗余，来提高效率。比如以下这张表：

| 商品名称 | 商品型号 | 单价 | 数量 | 总金额 |
| :------- | :------- | :--- | :--- | :----- |
| 手机     | 华为     | 8000 | 5    | 40000  |

以上这张存放商品信息的基本表。`总金额`这个字段的存在，表明该表的设计不满足第三范式，因为`总金额`可以由`单价*数量`得到，说明`总金额`是冗余字段。但是，增加`总金额`这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。

当然，这只是个小例子，大家开发设计的时候，要结合具体业务进行分析。

## 避免使用 MySQL 保留字

如果库名、表名、字段名等属性含有保留字时，`SQL`语句必须用反引号来引用属性名称，这将使得 SQL 语句书写、SHELL 脚本中变量的转义等变得非常复杂。

因此，我们一般避免使用`MySQL`保留字，如`select、interval、desc`等等。

## 不搞外键关联，一般都在代码维护

什么是外键呢？

> 外键，也叫`FOREIGN KEY`，它是用于将两个表连接在一起的键。`FOREIGN KEY`是一个表中的一个字段（或字段集合），它引用另一个表中的`PRIMARY KEY`。它是用来保证数据的一致性和完整性的。

阿里的`Java`规范也有这么一条：

> 【强制】**不得使用外键与级联**，一切外键概念必须在应用层解决。

我们为什么不推荐使用**外键**呢？

> - 使用外键存在性能问题、并发死锁问题、使用起来不方便问题等等。每次做`DELETE`或者`UPDATE`都必须考虑外键约束，会导致开发的时候很难受，测试数据也不方便。
> - 还有一个场景不能使用外键，就是分库分表。

## 一般都选择 INNODB 存储引擎

建表是需要选择**存储引擎**的，我们一般都选择`INNODB`存储引擎，除非读写比率小于`1%`，才考虑使用`MyISAM`。

有些小伙伴可能会有疑惑，不是还有`MEMORY`等其他存储引擎吗？什么时候使用呢？其实其他存储引擎一般都建议在`DBA`的指导下使用。

我们来复习一下`MySQL`这三种存储引擎的对比区别吧：

| 特性         | INNODB | MyISAM | MEMORY |
| :----------- | :----- | :----- | :----- |
| 事务安全     | 支持   | 无     | 无     |
| 存储限制     | 64TB   | 有     | 有     |
| 空间使用     | 高     | 低     | 低     |
| 内存使用     | 高     | 低     | 高     |
| 插入数据速度 | 低     | 高     | 高     |
| 是否支持外键 | 支持   | 无     | 无     |

## 选择合适统一的字符集

数据库库、表、开发程序等都需要统一字符集，通常中英文环境用`utf8`。

MySQL 支持的字符集有`utf8、utf8mb4、GBK、latin1`等。

- utf8：支持中英文混合场景，国际通用，3 个字节长度。
- utf8mb4:  完全兼容 utf8，4 个字节长度，一般存储 **emoji 表情**需要用到它。
- GBK ：支持中文，但是不支持国际通用字符集，2 个字节长度。
- latin1：MySQL 默认字符集，1 个字节长度。

## 枚举类型注释清楚

如果你设计的数据库字段是枚举类型的话，就需要在`comment`后面注释清楚每个枚举的意思，以便于维护。

正例如下：

```sql
`session_status` varchar(2) COLLATE utf8_bin NOT NULL 
COMMENT 'session授权态 00：在线-授权态有效 01：下线-授权态失效 
                       02：下线-主动退出 03：下线-在别处被登录'
```

反例：

```sql
`session_status` varchar(2) COLLATE utf8_bin NOT NULL COMMENT 'session授权态'
```

并且，如果你的枚举类型在未来的版本有增加修改的话，也需要同时维护到`comment`后面。

## 时间的类型选择⭐

我们设计表的时候，一般都需要加通用时间的字段，如`create_time、modified_time`等等。那对于时间的类型，我们该如何选择呢？

对于 MySQL 来说，主要有`date、datetime、time、timestamp 和 year`。

- date ：表示日期值，格式`yyyy-mm-dd`，范围`1000-01-01 到 9999-12-31`，3 字节。
- time ：表示时间值，格式 `hh:mm:ss`，范围`-838:59:59 到 838:59:59`，3 字节。
- datetime：表示日期时间值，格式`yyyy-mm-dd hh:mm:ss`，范围`1000-01-01 00:00:00 到 9999-12-31 23:59:59`，8 字节，跟时区无关。
- timestamp：表示时间戳值，格式`yyyymmddhhmmss`，范围`1970-01-01 00:00:01 到 2038-01-19 03:14:07`，4 字节，跟时区有关。
- year：表示年份值，格式`yyyy`，范围`1901 到 2155`，1 字节。

推荐优先使用`datetime`类型来保存日期和时间，因为存储范围更大，且跟时区无关。

## 不建议使用存储过程、触发器

**什么是存储过程？**

已预编译为一个可执行过程的一个或多个 SQL 语句。

**什么是触发器？**

触发器，指一段代码，当触发某个事件时，自动执行这些代码。使用场景：

- 可以通过数据库中的相关表实现级联更改。
- 实时监控某张表中的某个字段的更改而需要做出相应的处理。
- 例如可以生成某些业务的编号。
- 注意不要滥用，否则会造成数据库及应用程序的维护困难。

对于 MYSQL 来说，存储过程、触发器等还不是很成熟， 并没有完善的出错记录处理，不建议使用。

## 1:N 关系的设计⭐

日常开发中，`1`对多的关系应该是非常常见的。比如一个班级有多个学生，一个部门有多个员工等等。这种情况的建表原则就是：在从表（`N`的这一方）创建一个字段，以字段作为外键指向主表（`1`的这一方）的主键。示意图如下:

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxLwpugXhicDPDvgRXjFPRn4qjeHplyXzrmYvltuEptX4YqQhNSwAhJHCbYicibIvK22Xzp6IdvAunOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

学生表是多（`N`）的一方，会有个字段`class_id`保存班级表的主键。当然，一般不加外键约束哈，只是单纯保存这个关系而已。

有时候两张表存在`N:N`关系时，我们应该消除这种关系。通过增加第三张表，把`N:N`修改为两个 `1:N`。比如图书和读者，是一个典型的多对多的关系。一本书可以被多个读者借，一个读者又可以借多本书。我们就可以设计一个借书表，包含图书表的主键，以及读者的主键，以及借还标记等字段。

## 大字段的存储

> 设计表的时候，我们尤其需要关注一些大字段，即占用较多存储空间的字段。比如用来记录用户评论的字段，又或者记录博客内容的字段，又或者保存合同数据的字段。如果直接把表字段设计成 text 类型的话，就会浪费存储空间，查询效率也不好。

> 在 MySQL 中，这种方式保存的设计方案，其实是不太合理的。这种非常大的数据，可以保存到`mongodb`中，然后，在业务表保存对应`mongodb`的`id`即可。

> 这种设计思想类似于，我们表字段保存图片时，为什么不是保存图片内容，而是直接保存图片 url 即可。

## 考虑是否需要分库分表

**什么是分库分表呢？**

- 分库：就是一个数据库分成多个数据库，部署到不同机器。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxLwpugXhicDPDvgRXjFPRn4xhvInqr13WcUAJrWsq4sqKHaBYalEPxFjfLnrh5b20bSVrWnDKNyLw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

- 分表：就是一个数据库表分成多个表。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxLwpugXhicDPDvgRXjFPRn4ovicPfzsuKic6KPA7VoB66JFpwu5liahvdFdrxoRq2T9CL362qGWLwLxA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

我们在设计表的时候，其实可以提前估算一下，是否需要做**分库分表**。比如一些用户信息，未来可能数据量到达百万甚至千万的话，就可以提前考虑分库分表。

> **为什么需要分库分表**：数据量太大的话，SQL 的查询就会变慢。如果一个查询 SQL 没命中索引，千百万数据量级别的表可能会拖垮整个数据库。即使 SQL 命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是 B+ 树结构，数据千万级别的话，B+ 树的高度会增高，查询就变慢啦。

分库分表主要有水平拆分、垂直拆分的说法，拆分策略有`range 范围、hash 取模`。

## SQL优化经验

最后，跟大家聊一些写 SQL 的经验：

- 查询 SQL 尽量不要使用`select *`，而是`select`具体字段。
- 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用`limit 1`。
- 应尽量避免在`where`子句中使用`or`来连接条件。
- 注意优化`limit`深分页问题。
- 使用`where`条件限定要查询的数据，避免返回多余的行。
- 尽量避免在索引列上使用`mysql`的内置函数。
- 应尽量避免在 `where`子句中对字段进行表达式操作。
- 应尽量避免在`where`子句中使用`!=`或`<>`操作符。
- 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。
- 对查询进行优化，应考虑在`where 及 order by`涉及的列上建立索引。
- 如果插入数据过多，考虑批量插入。
- 在适当的时候，使用覆盖索引。
- 使用 explain 分析 SQL 的计划。

# 建表15个技巧⭐

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208262153006.png" alt="image-20220826215327853" style="zoom:67%;" />

## 1.名字

建表的时候，给`表`、`字段`和`索引`起个好名字，真的太重要了。

### 见名知意

名字就像`表`、`字段`和`索引`的一张脸，可以给人留下第一印象。

好的名字，言简意赅，见名知意，让人心情愉悦，能够提高沟通和维护成本。

坏的名字，模拟两可，不知所云。而且显得杂乱无章，看得让人抓狂。

> **反例：**用户名称字段定义成：yong_hu_ming、用户_name、name、user_name_123456789

你看了可能会一脸懵逼，这是什么骚操作？

> **正例：**用户名称字段定义成：user_name
>
> 温馨提醒一下，名字也不宜过长，尽量控制在`30`个字符以内。

### **1.2 大小写**

名字尽量都用`小写字母`，因为从视觉上，小写字母更容易让人读懂。

**反例：**

```apl
字段名：PRODUCT_NAME、PRODUCT_name
```

全部大写，看起来有点不太直观。而一部分大写，一部分小写，让人看着更不爽。

**正例：**

```apl
字段名：product_name
```

名字还是使用全小写字母，看着更舒服。

### **1.3 分隔符**

很多时候，名字为了让人好理解，有可能会包含多个单词。

那么，多个单词间的`分隔符`该用什么呢？

**反例：**

```sql
字段名：productname、productName、product name、product@name
```

单词间没有分隔，或者单词间用驼峰标识，或者单词间用空格分隔，或者单词间用@分隔，这几种方式都不太建议。

**正例：**

```sql
字段名：product_name
```

强烈建议大家在单词间用`_`分隔。

### **1.4 表名**

对于表名，在言简意赅，见名知意的基础之上，建议带上`业务前缀`。

如果是订单相关的业务表，可以在表名前面加个前缀：`order_`。

例如：order_pay、order_pay_detail等。

如果是商品相关的业务表，可以在表名前面加个前缀：`product_`。

例如：product_spu，product_sku等。

这样做的好处是为了方便归类，把相同业务的表，可以非常快速的聚集到一起。

另外，还有有个好处是，如果哪天有非订单的业务，比如：金融业务，也需要建一个名字叫做pay的表，可以取名：finance_pay，就能非常轻松的区分。

这样就不会出现`同名表`的情况。

### **1.5 字段名称**

`字段名称`是开发人员发挥空间最大，但也最容易发生混乱的地方。

比如有些表，使用flag表示状态，另外的表用status表示状态。

可以统一一下，使用status表示状态。

如果一个表使用了另一个表的主键，可以在另一张表的名后面，加`_id`或`_sys_no`，例如：

在product_sku表中有个字段，是product_spu表的主键，这时候可以取名：product_spu_id或product_spu_sys_no。

还有创建时间，可以统一成：create_time，修改时间统一成：update_time。

删除状态固定为：delete_status。

其实还有很多公共字段，在不同的表之间，可以使用全局统一的命名规则，定义成相同的名称，以便于大家好理解。

### **1.6 索引名**

在数据库中，索引有很多种，包括：主键、普通索引、唯一索引、联合索引等。

每张表的主键只有一个，一般使用：`id`或者`sys_no`命名。

普通索引和联合索引，其实是一类。在建立该类索引时，可以加`ix_`前缀，比如：ix_product_status。

唯一索引，可以加`ux_`前缀，比如：ux_product_code。

## 2.字段类型

在设计表时，我们在选择`字段类型`时，可发挥空间很大。

时间格式的数据有：date、datetime和timestamp等等可以选择。

字符类型的数据有：varchar、char、text等可以选择。

数字类型的数据有：int、bigint、smallint、tinyint等可以选择。

说实话，选择很多，有时候是一件好事，也可能是一件坏事。

如何选择一个`合适`的字段类型，变成了我们不得不面对的问题。

如果字段类型选大了，比如：原本只有1-10之间的10个数字，结果选了`bigint`，它占`8`个字节。

其实，1-10之间的10个数字，每个数字`1`个字节就能保存，选择`tinyint`更为合适。

这样会白白浪费7个字节的空间。

如果字段类型择小了，比如：一个18位的id字段，选择了`int`类型，最终数据会保存失败。

所以选择一个合适的字段类型，还是非常重要的一件事情。

以下原则可以参考一下：

1. 尽可能选择占用存储空间小的字段类型，在满足正常业务需求的情况下，从小到大，往上选。
2. 如果字符串长度固定，或者差别不大，可以选择char类型。如果字符串长度差别较大，可以选择varchar类型。
3. 是否字段，可以选择bit类型。
4. 枚举字段，可以选择tinyint类型。
5. 主键字段，可以选择bigint类型。
6. 金额字段，可以选择decimal类型。
7. 时间字段，可以选择timestamp或datetime类型。

## 3.字段长度

前面我们已经定义好了`字段名称`，选择了合适的`字段类型`，接下来，需要重点关注的是`字段长度`了。

比如：varchar(20)，biginit(20)等。

那么问题来了，`varchar`代表的是`字节`长度，还是`字符`长度呢？

答：在mysql中除了`varchar`和`char`是代表`字符`长度之外，其余的类型都是代表`字节`长度。

biginit(n) 这个`n`表示什么意思呢？

假如我们定义的字段类型和长度是：bigint(4)，bigint实际长度是`8`个字节。

现在有个数据a=1，a显示4个字节，所以在不满4个字节时前面填充0（前提是该字段设置了zerofill属性），比如：0001。

当满了4个字节时，比如现在数据是a=123456，它会按照实际的长度显示，比如：123456。

但需要注意的是，有些mysql客户端即使满了4个字节，也可能只显示4个字节的内容，比如会显示成：1234。

所以bigint(4)，这里的4表示显示的长度为4个字节，实际长度还是占8个字节。

## 4.字段个数

我们在建表的时候，一定要对`字段个数`做一些限制。

我之前见过有人创建的表，有几十个，甚至上百个字段，表中保存的数据非常大，查询效率很低。

如果真有这种情况，可以将一张`大表`拆成多张`小表`，这几张表的主键相同。

建议每表的字段个数，不要超过`20`个。

## 5. 主键

在创建表时，一定要创建`主键`。

因为主键自带了主键索引，相比于其他索引，主键索引的查询效率最高，因为它不需要回表。

此外，主键还是天然的`唯一索引`，可以根据它来判重。

在`单个`数据库中，主键可以通过`AUTO_INCREMENT`，设置成`自动增长`的。

但在`分布式`数据库中，特别是做了分库分表的业务库中，主键最好由外部算法(比如：雪花算法）生成，它能够保证生成的id是全局唯一的。

除此之外，主键建议保存跟业务无关的值，减少业务耦合性，方便今后的扩展。

不过我也见过，有些一对一的表关系，比如：用户表和用户扩展表，在保存数据时是一对一的关系。

这样，用户扩展表的主键，可以直接保存用户表的主键。

## 6.存储引擎

在`mysql8`以前的版本，默认的存储引擎是`myslam`，而`mysql8`以后的版本，默认的存储引擎变成了`innodb`。

之前我们还在创建表时，还一直纠结要选哪种存储引擎？

`myslam`的索引和数据分开存储，而有利于查询，但它不支持事务和外键等功能。

而`innodb`虽说查询性能，稍微弱一点，但它支持事务和外键等，功能更强大一些。

以前的建议是：读多写少的表，用myslam存储引擎。而写多读多的表，用innodb。

但虽说mysql对innodb存储引擎性能的不断优化，现在myslam和innodb查询性能相差已经越来越小。

所以，建议我们在使用`mysql8`以后的版本时，直接使用默认的`innodb`存储引擎即可，无需额外修改存储引擎。

## 7. NOT NULL

在创建字段时，需要选择该字段是否允许为`NULL`。

我们在定义字段时，应该尽可能明确该字段`NOT NULL`。

为什么呢？

我们主要以innodb存储引擎为例，myslam存储引擎没啥好说的。

主要有以下原因：

1. 在innodb中，需要额外的空间存储null值，需要占用更多的空间。
2. null值可能会导致索引失效。
3. null值只能用`is null`或者`is not null`判断，用`=号`判断永远返回false。

因此，建议我们在定义字段时，能定义成NOT NULL，就定义成NOT NULL。

但如果某个字段直接定义成NOT NULL，万一有些地方忘了给该字段写值，就会`insert`不了数据。

这也算合理的情况。

但有一种情况是，系统有新功能上线，新增了字段。上线时一般会先执行sql脚本，再部署代码。

由于老代码中，不会给新字段赋值，则insert数据时，也会报错。

由此，非常有必要给NOT NULL的字段设置默认值，特别是后面新增的字段。

例如：

```sql
alter table product_sku add column  brand_id int(10) not null default 0;
```

## 8.外键

在mysql中，是存在`外键`的。

外键存在的主要作用是：保证数据的`一致性`和`完整性`。

例如：

```sql
create table class (
  id int(10) primary key auto_increment,
  cname varchar(15)
);
```

有个班级表class。

然后有个student表：

```sql
create table student(
  id int(10) primary key auto_increment,
  name varchar(15) not null,
  gender varchar(10) not null,
  cid int,
  foreign key(cid) references class(id)
);
```

其中student表中的cid字段，保存的class表的id，这时通过`foreign key`增加了一个外键。

这时，如果你直接通过student表的id删除数据，会报异常：

```sql
a foreign key constraint fails
```

必须要先删除class表对于的cid那条数据，再删除student表的数据才行，这样能够保证数据的一致性和完整性。

> 顺便说一句：只有存储引擎是innodb时，才能使用外键。

如果只有两张表的关联还好，但如果有十几张表都建了外键关联，每删除一次主表，都需要同步删除十几张子表，很显然性能会非常差。

因此，互联网系统中，一般建议不使用外键。因为这类系统更多的是为了性能考虑，宁可牺牲一点数据一致性和完整性。

除了`外键`之外，`存储过程`和`触发器`也不太建议使用，他们都会影响性能。

## 9. 索引

在建表时，除了指定`主键索引`之外，还需要创建一些`普通索引`。

例如：

```sql
create table product_sku(
  id int(10) primary key auto_increment,
  spu_id int(10) not null,
  brand_id int(10) not null,
  name varchar(15) not null
);
```

在创建商品表时，使用spu_id（商品组表）和brand_id（品牌表）的id。

像这类保存其他表id的情况，可以增加普通索引：

```sql
create table product_sku (
  id int(10) primary key auto_increment,
  spu_id int(10) not null,
  brand_id int(10) not null,
  name varchar(15) not null,
  KEY `ix_spu_id` (`spu_id`) USING BTREE,
  KEY `ix_brand_id` (`brand_id`) USING BTREE
);
```

后面查表的时候，效率更高。

但索引字段也不能建的太多，可能会影响保存数据的效率，因为索引需要额外的存储空间。

建议单表的索引个数不要超过：`5`个。

如果在建表时，发现索引个数超过5个了，可以删除部分`普通索引`，改成`联合索引`。

顺便说一句：在创建联合索引的时候，需要使用注意`最左匹配原则`，不然，建的联合索引效率可能不高。

对于数据重复率非常高的字段，比如：状态，不建议单独创建普通索引。因为即使加了索引，如果mysql发现`全表扫描`效率更高，可能会导致索引失效。

如果你对索引失效问题比较感兴趣，可以看看我的另一篇文章《[聊聊索引失效的10种场景，太坑了](https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247491626&idx=1&sn=18fc949c06f04fe8f4c29b6fc5c66f9c&chksm=c0e838c2f79fb1d45c6f9b2ab188bb4663414690bab0718a7d46beb875e6b83e5e67ec27d2ff&token=660773166&lang=zh_CN&scene=21#wechat_redirect)》，里面有非常详细的介绍。

## 10.时间字段

`时间字段`的类型，我们可以选择的范围还是比较多的，目前mysql支持：date、datetime、timestamp、varchar等。

`varchar`类型可能是为了跟接口保持一致，接口中的时间类型是String。

但如果哪天我们要通过时间范围查询数据，效率会非常低，因为这种情况没法走索引。

`date`类型主要是为了保存`日期`，比如：2020-08-20，不适合保存`日期和时间`，比如：2020-08-20 12:12:20。

而`datetime`和`timestamp`类型更适合我们保存`日期和时间`。

但它们有略微区别。

- `timestamp`：用4个字节来保存数据，它的取值范围为`1970-01-01 00:00:01` UTC ~ `2038-01-19 03:14:07`。此外，它还跟时区有关。
- `datetime`：用8个字节来保存数据，它的取值范围为`1000-01-01 00:00:00` ~ `9999-12-31 23:59:59`。它跟时区无关。

优先推荐使用`datetime`类型保存日期和时间，可以保存的时间范围更大一些。

> 温馨提醒一下，在给时间字段设置默认值是，建议不要设置成：`0000-00-00 00:00:00`，不然查询表时可能会因为转换不了，而直接报错。

## 11.金额字段

mysql中有多个字段可以表示浮点数：float、double、decimal等。

而`float`和`double`可能会丢失精度，因此推荐大家使用`decimal`类型保存金额。

一般我们是这样定义浮点数的：decimal(m,n)。

其中`n`是指`小数`的长度，而`m`是指`整数加小数`的总长度。

假如我们定义的金额类型是这样的：decimal(10,2)，则表示整数长度是8位，并且保留2位小数。

## 12.唯一索引

`唯一索引`在我们实际工作中，使用频率相当高。

你可以给单个字段，加唯一索引，比如：组织机构code。

也可以给多个字段，加一个联合的唯一索引，比如：分类编号、单位、规格等。

单个的唯一索引还好，但如果是联合的唯一索引，字段值出现null时，则唯一性约束可能会失效。

关于唯一索引失效的问题，感兴趣的小伙伴可以看看我的另一篇文章《[明明加了唯一索引，为什么还是产生重复数据？](https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247497090&idx=1&sn=53b81535a9815853382c3a4bff8c844b&chksm=c0e82d6af79fa47ccfece23a8b0ad46ef6c647f1d2f961823eed181732c47e250ed0cbcfe6fd&token=1169141359&lang=zh_CN&scene=21#wechat_redirect)》。

> 创建唯一索引时，相关字段一定不能包含null值，否则唯一性会失效。

## 13.字符集

mysql中支持的`字符集`有很多，常用的有：latin1、utf-8、utf8mb4、GBK等。

这4种字符集情况如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.8.30/202208262249977.png" alt="image-20220826224939852" style="zoom: 80%;" />

`latin1`容易出现乱码问题，在实际项目中使用比较少。

而`GBK`支持中文，但不支持国际通用字符，在实际项目中使用也不多。

从目前来看，mysql的字符集使用最多的还是：`utf-8`和`utf8mb4`。

其中`utf-8`占用3个字节，比`utf8mb4`的4个字节，占用更小的存储空间。

但utf-8有个问题：即无法存储emoji表情，因为emoji表情一般需要4个字节。

由此，使用utf-8字符集，保存emoji表情时，数据库会直接报错。

所以，建议在建表时字符集设置成：`utf8mb4`，会省去很多不必要的麻烦。

## 14. 排序规则

不知道，你关注过没，在mysql中创建表时，有个`COLLATE`参数可以设置。

例如：

```sql
CREATE TABLE `order` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `code` varchar(20) COLLATE utf8mb4_bin NOT NULL,
  `name` varchar(30) COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `un_code` (`code`),
  KEY `un_code_name` (`code`,`name`) USING BTREE,
  KEY `idx_name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
```

它是用来设置`排序规则`的。

字符排序规则跟字符集有关，比如：字符集如果是`utf8mb4`，则字符排序规则也是以：`utf8mb4_`开头的，常用的有：`utf8mb4_general_ci`、`utf8mb4_bin`等。

> 其中utf8mb4_general_ci排序规则，对字母的大小写不敏感。说得更直白一点，就是不区分大小写。
>
> 而utf8mb4_bin排序规则，对字符大小写敏感，也就是区分大小写。

说实话，这一点还是非常重要的。

假如order表中现在有一条记录，name的值是大写的YOYO，但我们用小写的yoyo去查，例如：

```sql
select * from order where name='yoyo';
```

如果字符排序规则是utf8mb4_general_ci，则可以查出大写的YOYO的那条数据。

如果字符排序规则是utf8mb4_bin，则查不出来。

由此，字符排序规则一定要根据实际的业务场景选择，否则容易出现问题。

## 15.大字段

我们在创建表时，对一些特殊字段，要额外关注，比如：`大字段`，即占用较多存储空间的字段。比如：用户的评论，这就属于一个大字段，但这个字段可长可短。但一般会对评论的总长度做限制，比如：最多允许输入500个字符。如果直接定义成`text`类型，可能会浪费存储空间，所以建议将这类字段定义成`varchar`类型的存储效率更高。当然，我还见过更大的字段，即该字段直接保存合同数据。一个合同可能会占`几Mb`。在mysql中保存这种数据，从系统设计的角度来说，本身就不太合理。

> 像合同这种非常大的数据，可以保存到`mongodb`中，然后在mysql的业务表中，保存mongodb表的id。



# 如何设计数据库

## 范式和反范式

优秀的库表设计是高性能数据库的基础。如何才能设计出高性能的库表结构呢？这里必须要提到数据库范式。范式是基础规范，反范式是针对性设计。

### 1 范式

范式是设计数据库结构过程中所要遵循的规则和指导方法

其实范式有很多，目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。但是一般我们就用到前三个范式

#### 第一范式(确保每列保持原子性)

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要 用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就

非要将“地址”这个属 性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一 部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所 示。

上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的 时候就非常方便，也提高了数据库的性能。

#### 第二范式(确保表中的每列都和主键相关)

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一 列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，

不可以把多种数据 保存在同一张数据库表中。

比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编 号和商品编号作为数据库表的联合主键。

#### 第三范式(确保每列都和主键列直接相关,而不是间接相关)

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立 相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司 等）的字段。

总结：1NF：无重复的列，属性不可以拆分（强调列的原子性，比如家庭电话和个人电话需要拆开）

　　　2NF：属性完全依赖于主键

　　　3NF：属性不传递依赖于其他非主属性

### 2 范式的优点缺点

优点：避免数据冗余，减少数据的空间，数据变更速度更快

缺点：范式等级越高，表的数量越多，获取数据时表关联过多，性能较差

### 3 反范式

范式设计的表无法满足性能需求时，需要根据业务场景，在范式的基础上灵活设计

1.业务场景

2.响应时间

3.字段冗余

### 4 反范式和范式的对比

![图片](https://mmbiz.qpic.cn/mmbiz_png/iaPfaDVSUoJFrAzQXa5U9NpBmCgIPBxWIvFPtNvYPicOPR7jKAIIia6javTvgGN5jbiaicRTp9XCq1QaerMJlBqcmBw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

## 基础规范和命名规范

### 1 基础规范

想要发挥 MySQL 的最佳性能，需要遵循 3 个基本使用原则。

1.回归存储的基本职能（MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离）

2.查询时尽量单表查询，减少跨库查询和多表关联

3.杜绝大事务、大SQL、大批量、大字段等性能杀手

大事务：运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。

大 SQL：复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下。

大批量：意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。

大字段：blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。

下面具体讲解数据库的基本设置规则：

1. 必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎，随着 MySQL 8.0 版本的发布，所有的数据字典表都已经转换成了 InnoDB，MyISAM 存储引擎已成为了历史。
2. 默认字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。
3. 关闭区分大小写功能。设置 lower_case_tables_name=1，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样。
4. 开启 per-table 表空间，开启后，每张业务表会单独创建一个独立于系统表空间的表空间，便于空间的回收，数据的迁移。

这里在实践中有个小问题，如何让系统中区分大小写的库表转换为不区分大小写的库表呢？因为要修改底层数据，还是比较麻烦的，操作步骤如下：

MySQL dump 导出数据库。

修改参数 lower_case_tables_name=1。

导入备份数据时，必须停止数据库，停止业务，影响非常大。

#### 禁用功能

MySQL 数据库提供的功能很全面，但并不是所有的功能性能都高效。

存储过程、触发器、视图、event。为了存储计算分离，这类功能尽量在程序中实现。这些功能非常不完整，调试、排错、监控都非常困难，相关数据字典也不完善，存在潜在的风险。一般在生产数据库中，禁止使用。

lob、text、enum、set。这些字段类型，在 MySQL 数据库的检索性能不高，很难使用索引进行优化。如果必须使用这些功能，一般采取特殊的结构设计，或者与程序结合使用其他的字段类型替代。比如：set 可以使用整型（0，1，2，3）、注释功能和程序的检查功能集合替代。

### 2 命名规范

- 名称的字符范围为：a-z,0-9和_（下划线）
- 所有表名小写
- 不允许使用-（横杠）、空格
- 不允许其他字符作为名称例如：@&*%￥#等等

库名：1位数据库类型代码+项目简称+识别代码+序号

![图片](https://mmbiz.qpic.cn/mmbiz_png/iaPfaDVSUoJFrAzQXa5U9NpBmCgIPBxWIZR0VOicgAsMnvpiaDzoYe0YITHr2dmenXqicMZqpicY6TfvEkrqj3yRBdQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

 

 表名：

![图片](https://mmbiz.qpic.cn/mmbiz_png/iaPfaDVSUoJFrAzQXa5U9NpBmCgIPBxWITMB97mKOYIwZsam0TYzKRicqorHTx5LsjhiaGaNuvia1G0h49UMWWT8Vw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

字段名：

![图片](https://mmbiz.qpic.cn/mmbiz_png/iaPfaDVSUoJFrAzQXa5U9NpBmCgIPBxWI0MjnXBuhX8Qb6SoBx4egvJSxhibrL6ZahoCia2nuov5cvWBFBVhSKw1g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

##  Innodb表要求

> - 主键列，UNSIGNED证书，使用auto_increment(这个如果在实际项目中不一定的，大多数不会用自增，因为在分库分表会有问题，会用雪花算法计算id)
> - 必须添加comment注解（主要是为了方便他人理解）
> - 必须显式指定engine（引擎）
> - 表必备三字段：id,xxx_create,xxx_modified(主键id，创建时间，更新时间)

## 字段设计要求

数据值进行参考

> - 合理的类型，最短的长度，NotNULL
> - 表字段少而精
> - 单表个数必须控制在2000个以内
> - 单表分表个数必须控制在1024个以内
> - 单表字段数上限控制在20-50

总结

1. 以高性能为目标，库表设计以范式为主，根据特殊业务场景使用反范式，允许必要的空间换时间。
2. 规范数据库的使用原则，统一规范命名，减少性能隐患，减少隐式转换。
3. 高性能表设计的原则：合适的字段、合适的长度、NOT NULL。
4. 从不同角度思考 IP、timestamp 的转换，拓宽设计思路。
5. 规范的命名可提高可读性，反范式设计可提高查询性能。

# 高性能优化规范

## 数据库命令规范

1、所有数据库对象名称必须使用小写字母并用下划线分割；

2、所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）；

3、数据库对象的命名要能做到见名识意，并且最后不要超过32个字符；

4、临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀；

5、所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。

## 数据库基本设计规范

### 所有表必须使用Innodb存储引擎

没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）。

Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

### 数据库和表的字符集统一使用UTF8

兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集。

所有表和字段都需要添加注释

使用comment从句添加表和列的备注，从一开始就进行数据字典的维护。

### 尽量控制单表数据量的大小，建议控制在500万以内

500万并不是Mysql数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。

### 谨慎使用MySQL分区表

分区表在物理上表现为多个文件，在逻辑上表现为一个表；

谨慎选择分区键，跨分区查询效率可能更低；

建议采用物理分表的方式管理大数据。

### 尽量做到冷热数据分离，减小表的宽度

MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节；

减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO）；更有效利用缓存，避免读入无用的冷数据；经常一起使用的列放到一个表中（避免更多的关联操作）。

### 禁止在表中建立预留字段

预留字段的命名很难做到见名识义；

预留字段无法确认存储的数据类型，所以无法选择合适的类型；

对预留字段类型的修改，会对表进行锁定。

### 禁止在数据库中存储图片，文件等大的二进制数据

通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时；

通常存储于文件服务器，数据库只存储文件地址信息。

**禁止在线上做数据库压力测试**

**禁止从开发环境，测试环境直接连接生成环境数据库**

## 数据库字段设计规范

### 优先选择符合存储需要的最小的数据类型

原因是：列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多，索引的性能也就越差。

方法：**将字符串转换成数字类型存储**

如：将IP地址转换成整型数据。mysql提供了两个方法来处理ip地址：

- inet_aton 把ip转为无符号整型(4-8位)
- inet_ntoa 把整型的ip转为地址

插入数据前，先用inet_aton把ip地址转为整型，可以节省空间，显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。

- **对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储**

因为：无符号相对于有符号可以多出一倍的存储空间：

- SIGNED INT -2147483648~2147483647
- UNSIGNED INT 0~4294967295

VARCHAR(N)中的N代表的是字符数，而不是字节数，使用UTF8存储255个汉字 Varchar(255)=765个字节，过大的长度会消耗更多的内存。

### 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据

- **建议把BLOB或是TEXT列分离到单独的扩展表中**

Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。

而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。

- **TEXT或BLOB类型只能使用前缀索引**

因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。

### 避免使用ENUM类型

- 修改ENUM值需要使用ALTER语句；
- ENUM类型的ORDER BY操作效率低，需要额外操作；
- 禁止使用数值作为ENUM的枚举值。

### 尽可能把所有列定义为NOT NULL

索引NULL列需要额外的空间来保存，所以要占用更多的空间，进行比较和计算时要对NULL值做特别的处理。

**使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间**

TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。

TIMESTAMP 占用4字节和INT相同，但比INT可读性高，超出TIMESTAMP取值范围的使用DATETIME类型存储。

经常会有人用字符串存储日期型的数据（不正确的做法）：

缺点1：无法用日期函数进行计算和比较；

缺点2：用字符串存储日期要占用更多的空间。

### 同财务相关的金额类数据必须使用decimal类型

- 非精准浮点：float,double
- 精准浮点：decimal



Decimal类型为精准浮点数，在计算时不会丢失精度，占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节，可用于存储比bigint更大的整型数据。





# 数据库设计的 10 个最佳实践

数据库是应用及计算机的核心元素，负责存储运行软件应用所需的一切重要数据。为了保障应用正常运行，总有一个甚至多个数据库在默默运作。我们可以把数据库视为信息仓库，以结构化的方式存储了大量的相关信息，并合理分类，方便搜索及使用。

因此，数据库设计成为软件开发中的重要一环，对于开发者来说，设计一个高效的数据库至关重要。那么，为什么数据库设计很重要，“好”的标准又是什么？本文将做以介绍。

## 为什么数据库设计很重要？

用我们订购衬衫的在线商城网站举例。如今，从网站上订购衬衫的过程似乎很简单，但涉及了很多信息交换。例如：第一次浏览网页时，系统会展示给你一系列信息，包含产品分类，所有可用商品、相应价格、可用尺码、颜色以及其他相关信息。

网站会从存储数据的数据库中检索，当用户选中所需商品并继续操作购买时，网站会询问个人详细信息、送货地址、付款详细信息，并确认订单。目前在此过程中产生的新数据，如用户详细信息、订单详细信息、购买及付款都会在同一个数据库中添加及更新。

数据库设计很重要，因为对构建可伸缩且能够在高工作负载下运行的软件应用来说，它是至关重要的。设计数据库首先来说，选择数据库软件很关键。目前可用于构建应用的数据库软件有数百种可供选择，我们可以从一些最好的免费数据库软件中选择，之后便是设计符合要求的数据库了。下面列出了10个最优的数据库设计实践。

## 数据库设计的10个最佳实践

### 1、**将所有人的观点列入考量**

> 要设计好的数据库，必须考虑所有相关利益者的观点。在构建数据库之前，先去收集信息，了解他们对数据库的期望以及对数据库的操作熟练度。这样就能得出数据库应当采用的技术水平，以及是否要就数据库的功能来训练用户。

### 2、选择符合需求的数据库类型

> 数据库有多种类型，选择正确类型则是数据库设计的关键。我们可以将数据库以两种方式分类。一是基于数据库用以定义和操作数据的查询语言。使用SQL的数据库是结构化数据最常用的类型。然而，由于NoSQL数据库的可伸缩性、灵活性和速度更优，它们更适合机器学习、网络分析以及物联网（IoT）使用。

> 第二种分类方式则是基于数据模型。这样分类会有四种类型：**关系数据库、分层数据库、网络数据库以及面向对象的数据库。研究数据库的不同类型，并针对应用需求作出选择，这是必要的初始步骤。

### 3、以一致的方式来定义与标记表和列

> 在定义数据项以及标记表与列时，遵从一致性原则非常重要，可以帮助我们更好地理解数据。命名表与列的最佳实践之一便是使用简单的名字来定义其包含的数据。比如：只需将包含用户名称的列标记为“CustomerName”（“用户名”）即可。应当避免使用复数名（如CustomerNames）、缩写（如CN），并且名称中不得使用空格（如Customer Name）。如果坚持遵守这些规则，则将来的用户在使用数据库时会更容易。

### 4、规范化是关键

数据库的规范化指的是将数据库中的所有信息组织起来，避免数据重复和冗余。简单来说，规范化是将数据打散分配到多个较小的相关表中，而不是统统存在一个大表里。《[*MySQL数据库开发的 36 条军规！*》](http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247486173&idx=2&sn=0603756b36279b5f5f036151af85f9fd&chksm=eb538febdc2406fd70748604c500eeaea584306c137cb2020ab5a72187c9359926015e00a46d&scene=21#wechat_redirect)建议你看下。

将数据规范化是很好的数据库设计实践，有助于提高效率。但是请确保不要过度规范化，否则将会把数据分散到太多的小表中，反而造成混乱。

### 5、数据库设计的文档化很重要

> 事实上，文档化并非人见人爱，因为实在太烦了。但要记得，文档化对于良好的数据库设计至关重要，可以追踪所有的小细节。数据库设计应当附有指示说明、ER图、存储过程及所有其他相关的信息。文档还应当为编程者和终端用户提供足够信息量，确保他们能够理解并使用。

### 6、隐私是首要考量

> 很多时候，存储在数据库中的信息是加密信息，隐私就成了一个值得关注的问题。为了获得最大程度的安全性，我们应当对密码加密，使用身份验证来限制数据库的访问，并使用另一个服务器来存放数据库，而不是应用所在的服务器。这将确保你的数据不受攻击和隐私侵犯的威胁。

### 7、考虑长期需求

> 优秀的数据库设计应当具备可伸缩性，即：在使用量增加的情况下，仍然能承受较高的工作负载，并保障应用的运行。对工作量可能会有所改变的企业来说，在设计数据库时牢记此项至关重要。

> 例如：如果一个电子商务网站预计当销售量增长时，访客会在一个月内急速增加，那么在设计数据库时应当将这一点列入考量，以便数据库可以响应迅速增长的访客，并保持在高工作负载的情况下运作。

### 8、代码以及使用预存程序

> 数据库设计中的常见错误之一，就是不使用预存程序。预存程序指的是，在操作数据时手边随时可用的提前预存代码串。例如，如果有个SQL查询是常用的操作指令，则将它提前写入预存程序，而不是在用的时候重新来写，就会让工作简单起来。一旦有了预存程序，就可以在需要时一步执行并载入这个SQL查询了。

> 编写大量预存程序是个吃力的工作，但如果花时间完成并用文档记录下来的话，对终端用户来说，使用数据库就更加轻松了。

### 9、在数据库建模和设计上投入时间

> 优秀数据库设计的专业技巧之一是在数据库建模和设计上投入时间和精力。开发者常见的错误就是忽略这一步以节省时间，将重点放在软件开发更重要的其他方面上。

> 但是，数据库设计对于保障应用的功能来说非常关键。如果一味想节省时间，不仔细思考设计的话，未来就会需要花费更多时间来维护数据库，甚至重新设计。

### 10、测试设计

> 测试也是数据库设计很关键的步骤，而且经常会被疏忽对待，甚至完全跳过，只为了赶DDL。我们应当在发布项目前，花些时间来彻底测试数据库设计，以确保其满足了所有计划中的需求，且正常运行。

































