

# 支付安全

## 机密性

> - 密钥的度量单位是位 bit，如，秘钥长度128，就是16字节的二进制串
> - 按照密钥的使用方式，加密可以分为两大类：对称加密和非对称加密

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291617846.png" alt="image-20230529161726767" style="zoom:80%;" />

## 对称加密

> - AES加密算法，密钥长度128、192或256，安全强度很高，性能很好
> - 加密分组模式：将明文分组加密，微信支付中使用 AEAD_AES_256_GCM

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291618506.png" alt="image-20230529161819425" style="zoom:80%;" />

## 非对称加密

> 使用公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密
>
> RSA加密算法：最著名的非对称加密算法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291619281.png" alt="image-20230529161910209" style="zoom:80%;" />

## 对称 VS 非对称

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291619227.png" alt="image-20230529161951149" style="zoom:80%;" />

## 身份认证

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291620101.png" alt="image-20230529162020007" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291620567.png" alt="image-20230529162040377" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291621065.png" alt="image-20230529162104938" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291621270.png" alt="image-20230529162117167" style="zoom:80%;" />

## 摘要算法和数据的完整性

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291621599.png" alt="image-20230529162152503" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291622618.png" alt="image-20230529162209535" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291622565.png" alt="image-20230529162227447" style="zoom:80%;" />

## 数字签名

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291622314.png" alt="image-20230529162254161" style="zoom:80%;" />

## 数字签名+对称加密原文

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291623751.png" alt="image-20230529162323606" style="zoom:80%;" />

## 数字证书

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291623139.png" alt="image-20230529162348016" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291624766.png" alt="image-20230529162400687" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291624541.png" alt="image-20230529162416447" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291624978.png" alt="image-20230529162427884" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291624092.png" alt="image-20230529162447969" style="zoom:80%;" />

## https协议

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291625585.png" alt="image-20230529162513496" style="zoom:80%;" />

## 支付宝：防止订单重复支付

> 如图是一个简化的下单流程，首先是提交订单，然后是支付。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.11.17/image-20230724193304094.png" alt="image-20230724193304094" style="zoom:80%;" />

> 支付的话，一般是走支付网关（支付中心），然后支付中心与第三方支付渠道（微信、支付宝、银联）交互。支付成功以后，异步通知支付中心，支付中心更新自身支付订单状态，再通知业务应用，各业务再更新各自订单状态。

> 这个过程中经常可能遇到的问题是掉单，无论是超时未收到回调通知也好，还是程序自身报错也好。

> 总之由于各种各样的原因，没有如期收到通知并正确的处理后续逻辑等等，都会造成用户支付成功了，但是服务端这边订单状态没更新。

> 这个时候有可能产生投诉，或者用户重复支付。

> 由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单

> 基于 Spring Boot + MyBatis Plus + Vue 3.2 + Vite + Element Plus 实现的前后端分离博客，包含后台管理系统，支持文章、分类、标签管理、仪表盘等功能。
>
> - GitHub 地址：https://github.com/weiwosuoai/WeBlog
> - Gitee 地址：https://gitee.com/AllenJiang/WeBlog

为了防止掉单，这里可以这样处理：

> 1. 支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。
> 2. 支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理
> 3. 支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）
> 4. 无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略
> 5. 业务应用也应做超时主动查询支付结果

> 对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫

为了防止订单重复提交，可以这样处理：

> 创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。就是在一段时间内不可重复相同的操作

> 附上微信支付最佳实践：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.11.17/image-20230724193423150.png" alt="image-20230724193423150" style="zoom:80%;" />



# 后端搭建

> 后端：https://gitee.com/sure-s-renshuo/payment-demo
>
> 前端：https://gitee.com/sure-s-renshuo/payment-demo-front

## 项目创建

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291442018.png" alt="image-20230529144251925" style="zoom:80%;" />

### pom.xml

> 包括mybatis-plus-boot-starter、mysql、lomlok。就这三个依赖，在项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写。要在idea插件中安装lombok依赖才能使用

> spring-boot-starter、spring-boot-starter-test  这两个是SpringBoot依赖

```xml
<dependencies>
        <!--mysql依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <!--mybatis-plus依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.2</version>
        </dependency>
        <!--lombok依赖-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!-- 数据连接池 druid-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.8</version>
        </dependency>
        <!--如果不加入这依赖配置监控统计拦截的filters时这个会报错filters: stat,wall,log4j-->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
        <!-- API文档knife4j-->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-openapi2-spring-boot-starter</artifactId>
        <version>4.1.0</version>
        <!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.10.1</version>
        </dependency>
</dependencies>
```

### application.yml

```yml
spring:
  application:
    name: payment-demo
  profiles:
    active: a
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 由于默认的是UTC时间，所以在中国有8个小时的时差，需要将serverTimezone的值改为GMT%2B8
    # 还可以拼接如下条件：&characterEncoding=utf-8&useSSL=false
    url: jdbc:mysql://localhost:3306/payment_demo?serverTimezone=GMT%2B8
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource

# 下面是可选配置
mybatis-plus:
  configuration:
    # mybatisPlus日志，可以在控制台查看具体的sql执行语句
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    # 数据库字段的下划线转驼峰,比如数据库字段cron_id，实体类就是cronId
    map-underscore-to-camel-case: true
    mapper-locations: classpath:com/it/mapper/xml/*.xml
```

## 数据库表

```sql
create database if not exists `payment_demo`  default character set utf8mb4;

use `payment_demo`;
```

### t_product

```sql
create table `t_product` (
  `id` bigint(20) not null auto_increment comment '商品id',
  `title` varchar(20) default null comment '商品名称',
  `price` int(11) default null comment '价格（分）',
  `create_time` datetime default current_timestamp comment '创建时间',
  `update_time` datetime default current_timestamp on update current_timestamp comment '更新时间',
  primary key (`id`)
) engine=innodb auto_increment=5 default charset=utf8mb4;
```

```sql
insert  into `t_product`(`id`,`title`,`price`,`create_time`,`update_time`) values (1,'java课程',1,'2021-12-08 00:51:26','2021-12-10 00:21:37'),
(2,'大数据课程',1,'2021-12-08 00:51:26','2021-12-10 00:21:38'),
(3,'前端课程',1,'2021-12-08 00:51:26','2022-04-11 07:55:00'),
(4,'ui课程',1,'2021-12-08 00:51:26','2021-12-10 00:21:39');
```

### t_order_info

```sql
create table `t_order_info` (
  `id` bigint(11) unsigned not null auto_increment comment '订单id',
  `title` varchar(256) default null comment '订单标题',
  `order_no` varchar(50) default null comment '商户订单编号',
  `payment_type` varchar(20) default null,
  `user_id` bigint(20) default null comment '用户id',
  `product_id` bigint(20) default null comment '支付产品id',
  `total_fee` int(11) default null comment '订单金额(分)',
  `code_url` varchar(50) default null comment '订单二维码连接',
  `order_status` varchar(10) default null comment '订单状态',
  `create_time` datetime default current_timestamp comment '创建时间',
  `update_time` datetime default current_timestamp on 
   update current_timestamp comment '更新时间',
  primary key (`id`)
) engine=innodb auto_increment=126 default charset=utf8mb4;
```

### t_payment_info

```sql
create table `t_payment_info` (
  `id` bigint(20) unsigned not null auto_increment comment '支付记录id',
  `order_no` varchar(50) default null comment '商户订单编号',
  `transaction_id` varchar(50) default null comment '支付系统交易编号',
  `payment_type` varchar(20) default null comment '支付类型',
  `trade_type` varchar(20) default null comment '交易类型',
  `trade_state` varchar(50) default null comment '交易状态',
  `payer_total` int(11) default null comment '支付金额(分)',
  `content` text comment '通知参数',
  `create_time` datetime default current_timestamp comment '创建时间',
  `update_time` datetime default current_timestamp on 
    update current_timestamp comment '更新时间',
  primary key (`id`)
) engine=innodb auto_increment=47 default charset=utf8mb4;
```

### t_refund_info

```sql
create table `t_refund_info` (
  `id` bigint(20) unsigned not null auto_increment comment '退款单id',
  `order_no` varchar(50) default null comment '商户订单编号',
  `refund_no` varchar(50) default null comment '商户退款单编号',
  `refund_id` varchar(50) default null comment '支付系统退款单号',
  `total_fee` int(11) default null comment '原订单金额(分)',
  `refund` int(11) default null comment '退款金额(分)',
  `reason` varchar(50) default null comment '退款原因',
  `refund_status` varchar(50) default null comment '退款状态',
  `content_return` text comment '申请退款返回参数',
  `content_notify` text comment '退款结果通知参数',
  `create_time` datetime default current_timestamp comment '创建时间',
  `update_time` datetime default current_timestamp on update current_timestamp comment '更新时间',
  primary key (`id`)
) engine=innodb auto_increment=23 default charset=utf8mb4;
```

## knife4j

> 文档：https://doc.xiaominfo.com/，knife4j是为Java MVC框架集成Swagger生成Api文档的增强方案

### API文档

前后端分离开发模式中，api文档是最好的沟通方式。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。

> 1、及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)
>
> 2、规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)
>
> 3、一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)
>
> 4、可测性 (直接在接口文档上进行测试，以方便理解业务)

### 集成knife4j

> knife4j属于service模块公共资源，因此我们集成到service-uitl模块

#### 添加依赖

操作模块：service-uitl

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi2-spring-boot-starter</artifactId>
    <version>4.1.0</version>
</dependency>
```

#### 配置文件

```yml
knife4j:
  enable: true
  openapi:
    title: Knife4j官方文档
    description: 我是测试
    email: 17315118673@qq.com
    concat: 任硕
    url: https://docs.xiaominfo.com
    version: v4.0
    license: Apache 2.0
    license-url: https://stackoverflow.com/
    terms-of-service-url: https://stackoverflow.com/
    group:
      test1:
        group-name: 接口
        api-rule: package
        api-rule-resources:
          - com.it.controller
```

```
spring.profiles.active=a
```

#### 访问路径

http://127.0.0.1:8090/doc.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305271058093.png" alt="image-20230527105816957" style="zoom:80%;" />

## 统一结果 & 异常

### 统一结果返回

```java
@Getter
public enum ResultCodeEnum {
    // 定义枚举
    SUCCESS(200,"成功"),
    FAIL(201, "失败"),
    SERVICE_ERROR(2012, "服务异常"),
    DATA_ERROR(204, "数据异常"),
    LOGIN_AUTH(208, "未登陆"),
    PERMISSION(209, "没有权限");
    // 设置code和message
    private Integer code;
    private String message;
    // 设置有参构造，目的是传递参数
    private ResultCodeEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

```java
@Data
public class R<T> {
    // 状态码和信息
    private Integer code;
    private String message;
    // 封装的结果
    private T data;
    // 构造器私有
    private R(){}
    // 进行返回数据封装
    public static <T> R<T> build(T body, ResultCodeEnum resultCodeEnum) {
        R<T> result =  new R<>();
        // 封装数据
        if (body != null) {
            result.setData(body);
        }
        // 状态码
        result.setCode(resultCodeEnum.getCode());
        // 返回信息
        result.setMessage(resultCodeEnum.getMessage());
        return result;
    }
    // 操作成功，根据是否传入参数进行方法重载
    public static<T> R<T> ok(){
        return build(null,ResultCodeEnum.SUCCESS);
    }
    public static<T> R<T> ok(T data){
        return build(data, ResultCodeEnum.SUCCESS);
    }
    // 操作失败，根据是否传入参数进行方法重载
    public static<T> R<T> fail(){
        return build(null,ResultCodeEnum.FAIL);
    }
    public static<T> R<T> fail(T data){
        return build(data, ResultCodeEnum.FAIL);
    }
    // 可以自定义消息和返回值，即通过R.ok().code(304).message("事务回滚出错")
    public R<T> message(String msg){
        this.setMessage(msg);
        return this;
    }
    public R<T> code(Integer code){
        this.setCode(code);
        return this;
    }
}
```

### 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    /**-------- 通用异常处理方法 --------**/
    @ExceptionHandler(Exception.class)
    public R errorFull(Exception e) {
        e.printStackTrace();
        return R.fail(); // 通用异常结果
    }

    @ExceptionHandler(NullPointerException.class)
    public R errorNull(Exception e) {
        e.printStackTrace();
        return R.fail().code(403).message("空指针异常"); // 通用异常结果
    }
}
```

## Mybatis-X

> 此插件能直接生成mapper、service、和entity代码

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305231551812.png" alt="image-20230523155144716" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305231552631.png" alt="image-20230523155240534" style="zoom:80%;" />

> 因为生成的代码xml文件不在resource目录下，需要进行配置

```xml
<build>
    <finalName>${project.artifactId}</finalName>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
    <resources>
        <!-- 项目打包时会将java目录中的*.xml文件也进行打包 -->
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.yml</include>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.yml</include>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
                <include>**/*.png</include>
            </includes>
            <filtering>false</filtering>
        </resource>
    </resources>
</build>
```

```properties
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 查看日志
  mapper-locations: classpath:com/it/mapper/xml/*.xml
```

## 详细代码

### entity

```java
@Data
public class BaseEntity {

    //定义主键策略：跟随数据库的主键自增
    @TableId(value = "id", type = IdType.AUTO)
    private String id; //主键

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime; //创建时间

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime updateTime;//更新时间
}
```

```java
@Data
@TableName("t_order_info")
public class OrderInfo  extends BaseEntity{
    private String title;//订单标题
    private String orderNo;//商户订单编号
    private Long userId;//用户id
    private Long productId;//支付产品id
    private Integer totalFee;//订单金额(分)
    private String codeUrl;//订单二维码连接
    private String orderStatus;//订单状态
}
```

```java
@Data
@TableName("t_payment_info")
public class PaymentInfo extends BaseEntity{
    private String orderNo;//商品订单编号
    private String transactionId;//支付系统交易编号
    private String paymentType;//支付类型
    private String tradeType;//交易类型
    private String tradeState;//交易状态
    private Integer payerTotal;//支付金额(分)
    private String content;//通知参数
}
```

```java
@Data
@TableName("t_product")
public class Product extends BaseEntity{
    private String title; //商品名称
    private Integer price; //价格（分）
}
```

```java
@Data
@TableName("t_refund_info")
public class RefundInfo extends BaseEntity{
    private String orderNo;//商品订单编号
    private String refundNo;//退款单编号
    private String refundId;//支付系统退款单号
    private Integer totalFee;//原订单金额(分)
    private Integer refund;//退款金额(分)
    private String reason;//退款原因
    private String refundStatus;//退款单状态
    private String contentReturn;//申请退款返回参数
    private String contentNotify;//退款结果通知参数
}
```

### Mapper

```java
public interface OrderInfoMapper extends BaseMapper<OrderInfo> {
}
```

```java
public interface PaymentInfoMapper extends BaseMapper<PaymentInfo> {
}
```

```java
public interface ProductMapper extends BaseMapper<Product> {
}
```

```java
public interface RefundInfoMapper extends BaseMapper<RefundInfo> {
}
```

### Service

```java
public interface OrderInfoService extends IService<OrderInfo> {
}
```

```java
public interface PaymentInfoService {
}
```

```java
public interface ProductService extends IService<Product> {
}
```

```java
public interface RefundInfoService extends IService<RefundInfo> {
}
```

### ServiceImpl

```java
@Service
public class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> 
    implements OrderInfoService {

}
```

```java
@Service
public class PaymentInfoServiceImpl extends ServiceImpl<PaymentInfoMapper, PaymentInfo> 
    implements PaymentInfoService {

}
```

```java
@Service
public class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> 
    implements ProductService {

}
```

```java
@Service
public class RefundInfoServiceImpl extends ServiceImpl<RefundInfoMapper, RefundInfo> 
    implements RefundInfoService {

}
```

### config

> Mapper扫描

```java
@Configuration
@MapperScan("com.it.mapper") //持久层扫描
@EnableTransactionManagement //启用事务管理
public class MybatisPlusConfig {
    
}
```

> 跨域

```java
@Configuration // 一定不要忽略此注解
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // 所有接口
                .allowCredentials(true) // 是否发送 Cookie
                .allowedOriginPatterns("*") // 支持域
                .allowedMethods(new String[]{"GET", "POST", "PUT", "DELETE"}) // 支持方法
                .allowedHeaders("*")
                .exposedHeaders("*");
    }
}
```



## 接口请求

http://127.0.0.1:8090/doc.html

```java
@RestController
@RequestMapping("/api/product")
public class productController {

    @Resource
    private ProductService productService;

    @GetMappin
    g("list")
    public R list() {
        return R.ok(productService.list());
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291614930.png" alt="image-20230529161402856" style="zoom:80%;" />

# 前端搭建

## 基本配置

### 启动和安装

```
npm install
npm run serve
```

### 配置全屏显示

> App.vue

```css
html,
body,
#app {
  height: 100% ;
  margin: 0 ;
  padding: 0 ;
}
```

> css/global.css

```css
#footer {
    background-color: #323232;
    border-top-width: 5px;
    border-top-style: solid;
    color: #999;
    width: 100%;
    overflow: hidden;
    padding-top: 30px;
    /* 设置绝对定位到底部 */
    position: absolute;
    bottom: 0;
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291612964.png" alt="image-20230529161213845" style="zoom:80%;" />

## API

### aliPay.js

```js
// axios 发送ajax请求
import request from '@/utils/request'

export default{

  //发起支付请求
  tradePagePay(productId) {
    return request({
      url: '/api/ali-pay/trade/page/pay/' + productId,
      method: 'post'
    })
  },
  cancel(orderNo) {
    return request({
      url: '/api/ali-pay/trade/close/' + orderNo,
      method: 'post'
    })
  },
  refunds(orderNo, reason) {
    return request({
      url: '/api/ali-pay/trade/refund/' + orderNo + '/' + reason,
      method: 'post'
    })
  }
}
```

### bill.js

```js
import request from '@/utils/request'

export default{
  downloadBillWxPay(billDate, type) {
    return request({
      url: '/api/wx-pay/downloadbill/' + billDate + '/' + type,
      method: 'get'
    })
  },
  downloadBillAliPay(billDate, type) {
    return request({
      url: '/api/ali-pay/bill/downloadurl/query/' + billDate + '/' + type,
      method: 'get'
    })
  }
}
```

### orderInfo

```java
import request from '@/utils/request'

export default{
  //查询订单列表
  list() {
    return request({
      url: '/api/order-info/list',
      method: 'get'
    })
  },
  queryOrderStatus(orderNo) {
    return request({
      url: '/api/order-info/query-order-status/' + orderNo,
      method: 'get'
    })
  }
}
```

### product.js

```js
// axios 发送ajax请求
import request from '@/utils/request'

export default{
  //查询商品列表
  list() {
    return request({
      url: '/api/product/list',
      method: 'get'
    })
  }
}
```

## router/index.js

```js
// 创建应用程序的路由器
import Vue from 'vue'
import VueRouter from 'vue-router'
// 此时就可以在Vue实例中配置路由器了
Vue.use(VueRouter)

// 引入组件
import Index from '../views/index'
import Orders from '../views/Orders'
import Download from '../views/Download'
import Success from '../views/Success'

// 创建并暴露一个路由器
export default new VueRouter({
    routes:[
        {
            path: '/',
            component: Index
        },
        {
            path: '/orders',
            component: Orders
        },
        {
            path: '/download',
            component: Download
        },
        {
            path: '/success',
            component: Success
        }
    ]
})
```

## utils/request.js

```js
import axios from 'axios'
import { Message } from 'element-ui'

// 创建axios实例
const service = axios.create({
  baseURL: ':8090', // api 的 base_url
  timeout: 20000 // 请求超时时间
})

// request拦截器
service.interceptors.request.use(
  config => {
    return config
  },
  error => {
    // Do something with request error
    Promise.reject(error)
  }
)

// response 拦截器
service.interceptors.response.use(
  response => {
    const res = response.data
    if (res.code < 0) {
      Message({
        message: res.message,
        type: 'error',
        duration: 5 * 1000
      })
      return Promise.reject('error')
    } else {
      return response.data
    }
  },
  error => {
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000
    })
    return Promise.reject(error)
  }
)

export default service
```

## main.js

```js
// 引入Vue
import Vue from 'vue'
// 引入ElementUI
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
// 引入App
import App from './App'
// 引入路由器
import router from './router'
// 二维码生成器
import VueQriously from 'vue-qriously'
Vue.use(VueQriously)

// 关闭Vue生产提示
Vue.config.productionTip = false

Vue.use(ElementUI)

new Vue({
  render: h => h(App), //将App组件放入容器中
  router: router
}).$mount('#app')
```

## components

### AppFooter.vue

```vue
<template>
  <!-- 公共底 -->
  <footer id="footer">
    <section class="container">
      <div class>
        <h4 class="hLh30">
          <span class="fsize18 f-fM c-999">友情链接</span>
        </h4>
        <ul class="of flink-list">
          <li>
            <a href="http://www.atguigu.com" title="尚硅谷" target="_blank">尚硅谷</a>
          </li>
        </ul>
        <div class="clear"/>
      </div>
      <div class="b-foot">
        <section class="fl col-7">
          <section class="mr20">
            <section class="b-f-link">
              <a href="#" title="关于我们" target="_blank">关于我们</a>|
              <a href="#" title="联系我们" target="_blank">联系我们</a>|
              <a href="#" title="帮助中心" target="_blank">帮助中心</a>|
              <a href="#" title="资源下载" target="_blank">资源下载</a>|
              <span>服务热线：010-56253825(北京) 0755-85293825(深圳)</span>
              <span>Email：info@atguigu.com</span>
            </section>
            <section class="b-f-link mt10">
              <span>©2018课程版权均归谷粒学院所有 京ICP备17055252号</span>
            </section>
          </section>
        </section>
        <div class="clear"/>
      </div>
    </section>
  </footer>
</template>
```

### AppHeader.vue

```vue
<template>
  <!-- 公共头 -->
  <header id="header">
    <section class="container">
      <h1 id="logo">
        <a href="#/" title="谷粒学院">
          <img src="../assets/img/logo.png" width="100%" alt="谷粒学院">
        </a>
      </h1>
      <div>
        <ul class="nav">
          <router-link to="/" tag="li" active-class="current" exact>
            <a>购买课程</a>
          </router-link>
          <router-link to="/orders" tag="li" active-class="current">
            <a>我的订单</a>
          </router-link>
          <router-link to="/download" tag="li" active-class="current">
            <a>下载账单</a>
          </router-link>
        </ul>
      </div>
      <div class="clear"></div>
    </section>
  </header>
</template>
```

## views

### index.vue

```vue
<template>
  <div class="bg-fa of">
    <section id="index" class="container">
      <header class="comm-title">
        <h2 class="fl tac">
          <span class="c-333">课程列表</span>
        </h2>
      </header>
      <ul>
        <li v-for="product in productList" :key="product.id">
          <a
            :class="[
              'orderBtn',
              { current: payOrder.productId === product.id },
            ]"
            @click="selectItem(product.id)"
            href="javascript:void(0);"
          >
            {{ product.title }}
            ¥{{ product.price / 100 }}
          </a>
        </li>
      </ul>

      <div class="PaymentChannel_payment-channel-panel">
        <h3 class="PaymentChannel_title">选择支付方式</h3>
        <div class="PaymentChannel_channel-options">
          <!-- 选择微信 -->
          <div
            :class="[
              'ChannelOption_payment-channel-option',
              { current: payOrder.payType === 'wxpay' },
            ]"
            @click="selectPayType('wxpay')"
          >
            <div class="ChannelOption_channel-icon">
              <img src="../assets/img/wxpay.png" class="ChannelOption_icon" />
            </div>
            <div class="ChannelOption_channel-info">
              <div class="ChannelOption_channel-label">
                <div class="ChannelOption_label">微信支付</div>
                <div class="ChannelOption_sub-label"></div>
                <div class="ChannelOption_check-option"></div>
              </div>
            </div>
          </div>

          <!-- 选择支付宝 -->
          <div
            :class="[
              'ChannelOption_payment-channel-option',
              { current: payOrder.payType === 'alipay' },
            ]"
            @click="selectPayType('alipay')"
          >
            <div class="ChannelOption_channel-icon">
              <img src="../assets/img/alipay.png" class="ChannelOption_icon" />
            </div>
            <div class="ChannelOption_channel-info">
              <div class="ChannelOption_channel-label">
                <div class="ChannelOption_label">支付宝</div>
                <div class="ChannelOption_sub-label"></div>
                <div class="ChannelOption_check-option"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="payButtom">
        <el-button
          :disabled="payBtnDisabled"
          type="warning"
          round
          style="width: 280px; height: 44px; font-size: 18px"
          @click="toPay()"
        >
          确认支付（支付宝和微信V3）
        </el-button>
        <el-button
          :disabled="payBtnDisabled"
          type="warning"
          round
          style="width: 280px; height: 44px; font-size: 18px"
          @click="toPayV2()"
        >
          确认支付（微信V2）
        </el-button>
      </div>
    </section>

    <!-- 微信支付二维码 -->
    <el-dialog
      :visible.sync="codeDialogVisible"
      :show-close="false"
      @close="closeDialog"
      width="350px"
      center
    >
      <qriously :value="codeUrl" :size="300" />
      <!-- <img src="../assets/img/code.png" alt="" style="width:100%"><br> -->
      使用微信扫码支付
    </el-dialog>
  </div>
</template>

<script>
import productApi from '../api/product'
import wxPayApi from '../api/wxPay'
import aliPayApi from '../api/aliPay'
import orderInfoApi from '../api/orderInfo'

export default {
  data() {
    return {
      payBtnDisabled: false, //确认支付按钮是否禁用
      codeDialogVisible: false, //微信支付二维码弹窗
      productList: [], //商品列表
      payOrder: {
        //订单信息
        productId: '', //商品id
        payType: 'wxpay', //支付方式
      },
      codeUrl: '', // 二维码
      orderNo: '', //订单号
      timer: null, // 定时器
    }
  },

  //页面加载时执行
  created() {
    //获取商品列表
    productApi.list().then((response) => {
      this.productList = response.data
      this.payOrder.productId = this.productList[0].id
    })
  },

  methods: {
    //选择商品
    selectItem(productId) {
      console.log('商品id：' + productId)
      this.payOrder.productId = productId
      console.log(this.payOrder)
      //this.$router.push({ path: '/order' })
    },

    //选择支付方式
    selectPayType(type) {
      console.log('支付方式：' + type)
      this.payOrder.payType = type
      //this.$router.push({ path: '/order' })
    },

    //确认支付
    toPay() {
      //禁用按钮，防止重复提交
      this.payBtnDisabled = true

      //微信支付
      if (this.payOrder.payType === 'wxpay') {
        //调用统一下单接口
        wxPayApi.nativePay(this.payOrder.productId).then((response) => {
          this.codeUrl = response.data.codeUrl
          this.orderNo = response.data.orderNo

          //打开二维码弹窗
          this.codeDialogVisible = true

          //启动定时器
          this.timer = setInterval(() => {
            //查询订单是否支付成功
            this.queryOrderStatus()
          }, 3000)
        })

        //支付宝支付
      } else if (this.payOrder.payType === 'alipay') {

        //调用支付宝统一收单下单并支付页面接口
        aliPayApi.tradePagePay(this.payOrder.productId).then((response) => {
          //将支付宝返回的表单字符串写在浏览器中，表单会自动触发submit提交
          document.write(response.data)
        })
      }
    },

    //确认支付
    toPayV2() {
      //禁用按钮，防止重复提交
      this.payBtnDisabled = true

      //微信支付
      if (this.payOrder.payType === 'wxpay') {
        //调用统一下单接口
        wxPayApi.nativePayV2(this.payOrder.productId).then((response) => {
          this.codeUrl = response.data.codeUrl
          this.orderNo = response.data.orderNo

          //打开二维码弹窗
          this.codeDialogVisible = true

          //启动定时器
          this.timer = setInterval(() => {
            //查询订单是否支付成功
            this.queryOrderStatus()
          }, 3000)
        })
      }
    },

    //关闭微信支付二维码对话框时让“确认支付”按钮可用
    closeDialog() {
      console.log('close.................')
      this.payBtnDisabled = false
      console.log('清除定时器')
      clearInterval(this.timer)
    },

    // 查询订单状态
    queryOrderStatus() {
      orderInfoApi.queryOrderStatus(this.orderNo).then((response) => {
        console.log('查询订单状态：' + response.code)

        // 支付成功后的页面跳转
        if (response.code === 0) {
          console.log('清除定时器')
          clearInterval(this.timer)
          // 三秒后跳转到支付成功页面
          setTimeout(() => {
            this.$router.push({ path: '/success' })
          }, 3000)
        }
      })
    },
  },
}
</script>
```

### Orders.vue

```vue
<template>
  <div class="bg-fa of">
    <section id="index" class="container">
      <header class="comm-title">
        <h2 class="fl tac">
          <span class="c-333">订单列表</span>
        </h2>
      </header>
      <el-table :data="list" border style="width: 100%">
        <el-table-column type="index" width="50"></el-table-column>
        <el-table-column prop="orderNo" label="订单编号" width="230" ></el-table-column>
        <el-table-column prop="title" label="订单标题"></el-table-column>
        <el-table-column prop="totalFee" label="订单金额">
          <template slot-scope="scope">
              {{scope.row.totalFee / 100}} 元
          </template>
        </el-table-column>
        <el-table-column prop="paymentType" label="支付方式"></el-table-column>
        <el-table-column label="订单状态">
          <template slot-scope="scope">
            <el-tag v-if="scope.row.orderStatus === '未支付'">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '支付成功'" type="success">
              {{ scope.row.orderStatus }}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '超时已关闭'" type="warning">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '用户已取消'" type="info">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '退款中'" type="danger">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '已退款'" type="info">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '退款异常'" type="danger">
              {{scope.row.orderStatus}}
            </el-tag>
          </template>
        </el-table-column>
        <!-- <el-table-column prop="createTime" label="创建时间"></el-table-column> -->
        <el-table-column label="操作" width="100" align="center">
          <template slot-scope="scope">
            <el-button v-if="scope.row.orderStatus === '未支付'" type="text" @click="cancel(scope.row.orderNo, scope.row.paymentType)">取消</el-button>
            <el-button v-if="scope.row.orderStatus === '支付成功'" type="text" @click="refund(scope.row.orderNo, scope.row.paymentType)">退款</el-button>
          </template>
        </el-table-column>
      </el-table>
    </section>

    <!-- 退款对话框 -->
   <el-dialog
      :visible.sync="refundDialogVisible"
      @close="closeDialog"
      width="350px"
      center>
      <el-form>
        <el-form-item label="退款原因">
          <el-select v-model="reason" placeholder="请选择退款原因">
            <el-option label="不喜欢" value="不喜欢"></el-option>
            <el-option label="买错了" value="买错了"></el-option>
          </el-select>
        </el-form-item>
      </el-form>
      <div slot="footer" class="dialog-footer">
        <el-button type="primary" @click="toRefunds()" :disabled="refundSubmitBtnDisabled">确 定</el-button>
      </div>
    </el-dialog>
  </div>
</template>

<script>
import aliPay from '../api/aliPay';
import orderInfoApi from "../api/orderInfo"
import wxPayApi from "../api/wxPay"

export default {
  data() {
    return {
      list: [], //订单列表
      refundDialogVisible: false, //退款弹窗
      orderNo: '', //退款订单号
      reason: '', //退款原因,
      refundSubmitBtnDisabled: false, //防止重复提交
      paymentType: ''
    };
  },

  created() {
    this.showOrderList()
  },

  methods: {

    //显示订单列表
    showOrderList(){
      orderInfoApi.list().then((response) => {
        this.list = response.data;
      });
    },

    //用户取消订单
    cancel(orderNo, paymentType){

      if(paymentType === '微信'){
        wxPayApi.cancel(orderNo).then(response => {
          this.$message.success(response.message)
          //刷新订单列表
          this.showOrderList()
        })
      }else{
        aliPay.cancel(orderNo).then(response => {
          this.$message.success(response.message)
          //刷新订单列表
          this.showOrderList()
        })
      }

    },

    //退款对话框
    refund(orderNo, paymentType){
      this.refundDialogVisible = true
      this.orderNo = orderNo
      this.paymentType = paymentType
    },

    //关闭退款对话框
    closeDialog(){
      console.log('close.................')
      this.refundDialogVisible = false
      //还原组件状态
      this.orderNo = ''
      this.reason = ''
      this.refundSubmitBtnDisabled = false
    },

    //确认退款
    toRefunds(){
      this.refundSubmitBtnDisabled = true //禁用按钮，防止重复提交

      if(this.paymentType === '微信'){
        wxPayApi.refunds(this.orderNo, this.reason).then(response => {
          console.log('response', response)
          this.closeDialog()
          this.showOrderList()
        })
      }else{
        aliPay.refunds(this.orderNo, this.reason).then(response => {
          console.log('response', response)
          this.closeDialog()
          this.showOrderList()
        })
      }
    }
  }
};
</script>
```

### Download.vue

```vue
<template>
  <div class="bg-fa of">
    <section id="index" class="container">
      <header class="comm-title">
        <h2 class="fl tac">
          <span class="c-333">微信账单申请</span>
        </h2>
      </header>

      <el-form :inline="true" >
        <el-form-item>
            <el-date-picker v-model="billDate" value-format="yyyy-MM-dd" placeholder="选择账单日期" />
        </el-form-item>
        <el-form-item>
            <el-button type="primary" @click="downloadBill('tradebill')">下载交易账单</el-button>
        </el-form-item>
         <el-form-item>
            <el-button type="primary" @click="downloadBill('fundflowbill')">下载资金账单</el-button>
        </el-form-item>
      </el-form>
    </section>

    <section id="index" class="container">
      <header class="comm-title">
        <h2 class="fl tac">
          <span class="c-333">支付宝账单申请</span>
        </h2>
      </header>

      <el-form :inline="true" >
        <el-form-item>
            <el-date-picker v-model="billDate_alipay" value-format="yyyy-MM-dd" placeholder="选择账单日期" />
        </el-form-item>
        <el-form-item>
            <el-button type="primary" @click="downloadBillAliPay('trade')">下载交易账单</el-button>
        </el-form-item>
         <el-form-item>
            <el-button type="primary" @click="downloadBillAliPay('signcustomer')">下载资金账单</el-button>
        </el-form-item>
      </el-form>
    </section>

  </div>
</template>

<script>
import billApi from '../api/bill'

export default {
  data () {
    return {
       billDate: '', //微信支付账单日期
       billDate_alipay: '' //支付宝账单日期
    }
  },

  methods: {

    //下载账单：微信支付
    downloadBill(type){
      //获取账单内容
      billApi.downloadBillWxPay(this.billDate, type).then(response => {
        console.log(response)
        const element = document.createElement('a')
        element.setAttribute('href', 'data:application/vnd.ms-excel;charset=utf-8,' + encodeURIComponent(response.data.result))
        element.setAttribute('download', this.billDate + '-' + type)
        element.style.display = 'none'
        element.click()
      })
    },

    //下载账单：支付宝
    downloadBillAliPay(type){
        billApi.downloadBillAliPay(this.billDate_alipay, type).then(response => {
          console.log(response.data)
          const element = document.createElement('a')
          element.setAttribute('href', response.data)
          element.setAttribute('download', this.billDate_alipay + '-' + type)
          element.style.display = 'none'
          element.click()
        })
    }
  }
}
</script>
```

### Success.vue

```vue
<template>
  <div class="bg-fa of" style="padding: 40px;">
    <el-alert
        title="支付成功！"
        type="success">
    </el-alert>
  </div>
</template>
```

## App.vue

```vue
<template>
  <div id="app">
    <!-- 公共头 -->
    <AppHeader />
    <!-- /公共头 -->

    <router-view />

    <!-- 公共底 -->
    <AppFooter />
    <!-- /公共底 -->

  </div>
</template>

<script>
import AppHeader from './components/AppHeader'
import AppFooter from './components/AppFooter'
import './assets/css/reset.css'
import './assets/css/theme.css'
import './assets/css/global.css'

export default {
  name: 'App',
  components: {
    AppHeader, AppFooter
  }
}
</script>

<style>
/* 定义全局样式属性 */
html,
body,
#app {
  height: 100% ;
  margin: 0 ;
  padding: 0 ;
}
</style>
```

## package.json

```js
"dependencies": {
  "axios": "^0.24.0",
  "core-js": "^3.6.5",
  "element-ui": "^2.15.6",
  "vue": "^2.6.11",
  "vue-qriously": "^1.1.1",
  "vue-router": "^3.5.3"
},
```



# 微信







# 支付宝

## 支付能力

### 能⼒地图

> ⽀付能⼒、⽀付扩展、资⾦能⼒、⼝碑能⼒、营销能⼒、会员能⼒、⾏业能⼒、安全能⼒、基础能⼒

### 开放平台账号注册

> 官网：https://open.alipay.com/
>
> 网页支付：https://opendocs.alipay.com/open/270/105898

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291647745.png" alt="image-20230529164739648" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291651068.png" alt="image-20230529165143958" style="zoom:80%;" />

> 点击进入到：https://opendocs.alipay.com/open/270/105898

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291654437.png" alt="image-20230529165429334" style="zoom:80%;" />



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291425849.png" alt="image-20230529142511770" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291425352.png" alt="image-20230529142524285" style="zoom:80%;" />

### 常规接入流程

https://opendocs.alipay.com/open/270/105898#%E6%8E%A5%E5%85%A5%E6%96%B9%E5%BC%8F

> 在文档中有如何进行接入的方式

> 创建应⽤：选择应⽤类型、填写应⽤基本信息、添加应⽤功能、配置应⽤环境（获取⽀付宝公钥、应⽤公钥、应⽤私钥、⽀付宝⽹关地址，配置接⼝内容加密⽅式）、查看 APPID

> 绑定应⽤：将开发者账号中的APPID和商家账号PID进⾏绑定
>
> 配置秘钥：即创建应⽤中的“配置应⽤环境”步骤
>
> 上线应⽤：将应⽤提交审核
>
> 签约功能：在商家中⼼上传营业执照、已备案⽹站信息等，提交审核进⾏签约

### 创建应用

[创建应用](https://open.alipay.com/develop/pm/create?templateId=6-bcb9-7250e6fd2c431487669730456&from=payappsite)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291659816.png" alt="image-20230529165948705" style="zoom:80%;" />

> 点击立即创建后，会跳转到如下页面

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291702565.png" alt="image-20230529170223476" style="zoom:80%;" />

> 按照上面蓝色的应用状态，配置接口加签方式，有具体方法

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291709591.png" alt="image-20230529170901504" style="zoom:80%;" />

> 产品绑定

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291710893.png" alt="image-20230529171015798" style="zoom:80%;" />



## 沙箱环境⭐

> 我们是个人开发者，就不用管上面的创建应用等步骤了，直接从沙箱环境开始

### 进入沙箱

> 沙箱环境配置：**https://opendocs.alipay.com/common/02kkv7**
>
> 沙箱版⽀付宝的下载和登录：**https://open.alipay.com/platform/appDaily.htm?tab=tool**
>
> 文档：https://opendocs.alipay.com/common/02kkv7

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291714367.png" alt="image-20230529171448267" style="zoom:80%;" />

### 沙箱应用

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291715253.png" alt="image-20230529171536145" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291922036.png" alt="image-20230529192225917" style="zoom:80%;" />

### 配置文件

> **在resource目录下创建alipay.properties，加入如下内容，对应网页上的内容**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291721982.png" alt="image-20230529172149896" style="zoom:80%;" />

```properties
# 支付宝支付相关参数

# 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号
alipay.app-id=9021000122675799

# 商户PID,卖家支付宝账号ID
alipay.seller-id=2088721003609101

# 支付宝网关
alipay.gateway-url=https://openapi-sandbox.dl.alipaydev.com/gateway.do

# 商户私钥，您的PKCS8格式RSA2私钥
alipay.merchant-private-key=MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCfUOZ7h3yf+L3PhDMCEF2P+BVHbIRQ2/StC/y7Zr81MxidOjHWXYz9LjEMcPCNhhCamtO9n744htGPyh+atGHSkgkLYovtntKge54ZQ2TsrnjtlPYuPwgnhrkY2tdQYHvqS2pOSQFaxtZwYx4FrHWduyOXZOravZ0WYj7DLVy6i3E1hUlqvIWT+IeBvEaRcSXF6ivJ+yCiW+OJTltSQLUCWX9A6kZLfa3/fCQQcUc+OFxcWG+hJiTs8u/oDMDScLkv/2Yu85sTlC+oGKrzXP+ooGGDfwLeKJlzCnyisa5hU/gHLJ06B76u/KAEg+KihY+9JLz4P394GKbiQy30CnXhAgMBAAECggEALvuNrPpMv2R8nXkQDdjDrtRreg+/iZUEOBAj7SQk2UyDQsLJtb0K+hMoNdIMrr/Nn7pvHSnB0Cu6G1xxK49slcupTSk3uNCwrtEl069zUPU3BmF6pDLEddueNH09KB/8CyFIbWPMOXgP/z7LuMKeQPDSUzBYrj9i1xoMBkUXZo+FsZOgXWKUqE2dbPodMlyQFWbazhxwzY8BSTzVKKzRiI5aXLsdSCtK3voNzKrrc9mBtNWrkItnIEg8QkPAEs3q/McgNNEFHazrJ1jzjFPNooJ8o/s2Yym3qa+KZHs0vrQjcbx8AFOb1com19Bgw7QSgv/rBsQ8atTTumou+9dP0QKBgQDyOTPxwgOZULs29SN95S9v7kSo7vSNVuPy7GtX6qHuIY8t7yj5kQYjuu3CwJ6rdlRCwPGRLb8ZVB37nGXUF368oiEVq738+5gVMSH3pK/tOftt5iYl4jSiBKlFsBzKG1l/sxg2FbUVbAtz9ht6Mv/Jezg5ncbs8J+nDb2G9Zh8nQKBgQCoYI6eLdsVQnscCQvjCe7/h11zov437QQOHv91uMpQEoDD6C4t6kNdXHqbc3GzhSxBXbzvMMbor3osmLBkFH/qy7KribJko0a7ZYtONlouSKdtNEHuFFZD63ucwP61cAxgVC/Fo6wiROOt+IJ+jg5ch3wVRbzq+E9H+fSlatghFQKBgQDXbISEKNbmjeRTFmYAW8p6s+AglpSs93A35of5YtWtYe9jHObGPnLFaER5BrKXL9/0loDBa3wf3K3lzszJejPfNBpUma+YxXIWtuHMy40jYIP608ttueaxiY+6SMzx+qz4Y6HOyDOK39K3yVPatGzFFm+E3ovCwqZa/l9nHhoGCQKBgDzG3bPrCXGbFaUA/vFs3IAP9IORCgJV42jVd5CeqyhMBX6xiDm6naZNg1QpT5llMJxHobMVADdtX8RJOSJm4+V0sYGJqoL5DMcH2EjbBaI/R2/7tPCjFqBdl7j1UPtc/pqmyLemZLPZ+fUKBtB3pmdv4DItgguupa9tYglzj6AhAoGBAJ+G4GneymhV8wG2axFVGTgekoZZSiA1It83iDui9ZEHAig1f7Y8Q7TpoefwIBkV4fpPiAMutqpQTWiElfLlz5zYCJXe0m4+Ni8BLcLjkFLORVKXKOyf3Rs0il0pd4U/mfA4xkQNFy7Kh0Yfhv9qKyc3CJZmv1Cw1Vu2LqqASzR0

# 查看地址：https://openhome.alipay.com/platform/keyManage.htm对应APPID下的支付宝公钥
alipay.alipay-public-key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkQhfxcDqt0Rkz8KDuDlGGnl2IvPKHXJOHPgRNmOc3U/kQfrdBbbzadpSlbt9RJTC9wL+XjYVwX3FBJ1rz0Mv3RgQzJNbf0ik6XQgznsLuNsB7oq2dFXTO2bBvgj22DYPskRMPLbsmCFq6TQX2VZbcTG9fJAXcISe9acPS6DBbH60OfuCv93ApPt/O1QYmFsk2O6OVzniNpYzvMYeAdNSImIuFIZWlzdSUFfEmF8T3DjoXy2/7YJ3y9RcXLn9Nk5pSyUqnMZFaXaTc/zoFzHIkDb9NvPisDNDWovNwCM6FXqcHvV1Y9wE7boaSdU4ZhJFGuacSzEbnWlSan5oFPPY2QIDAQAB

# 接口内容加密秘钥，对称秘钥
alipay.content-key=2dg+ct4EWrNVouU+aP1acg==

# 页面跳转同步通知页面路径
alipay.return-url=:8080/#/success

# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url=https://a863-180-174-204-169.ngrok.io/api/ali-pay/trade/notify
```

### 沙箱账户 & 工具

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291924048.png" alt="image-20230529192415981" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291926654.png" alt="image-20230529192628580" style="zoom:80%;" />

## 支付参数

### 引⼊沙箱配置⽂件

> 将之前的 alipay-sandbox.properties 复制到项⽬的 resources ⽬录中并将其设置为 spring 配置⽂件

```properties
# 支付宝支付相关参数

# 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号
alipay.app-id=9021000122675799

# 商户PID,卖家支付宝账号ID
alipay.seller-id=2088721003609101

# 支付宝网关
alipay.gateway-url=https://openapi-sandbox.dl.alipaydev.com/gateway.do

# 商户私钥，您的PKCS8格式RSA2私钥
alipay.merchant-private-key=MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCfUOZ7h3yf+L3PhDMCEF2P+BVHbIRQ2/StC/y7Zr81MxidOjHWXYz9LjEMcPCNhhCamtO9n744htGPyh+atGHSkgkLYovtntKge54ZQ2TsrnjtlPYuPwgnhrkY2tdQYHvqS2pOSQFaxtZwYx4FrHWduyOXZOravZ0WYj7DLVy6i3E1hUlqvIWT+IeBvEaRcSXF6ivJ+yCiW+OJTltSQLUCWX9A6kZLfa3/fCQQcUc+OFxcWG+hJiTs8u/oDMDScLkv/2Yu85sTlC+oGKrzXP+ooGGDfwLeKJlzCnyisa5hU/gHLJ06B76u/KAEg+KihY+9JLz4P394GKbiQy30CnXhAgMBAAECggEALvuNrPpMv2R8nXkQDdjDrtRreg+/iZUEOBAj7SQk2UyDQsLJtb0K+hMoNdIMrr/Nn7pvHSnB0Cu6G1xxK49slcupTSk3uNCwrtEl069zUPU3BmF6pDLEddueNH09KB/8CyFIbWPMOXgP/z7LuMKeQPDSUzBYrj9i1xoMBkUXZo+FsZOgXWKUqE2dbPodMlyQFWbazhxwzY8BSTzVKKzRiI5aXLsdSCtK3voNzKrrc9mBtNWrkItnIEg8QkPAEs3q/McgNNEFHazrJ1jzjFPNooJ8o/s2Yym3qa+KZHs0vrQjcbx8AFOb1com19Bgw7QSgv/rBsQ8atTTumou+9dP0QKBgQDyOTPxwgOZULs29SN95S9v7kSo7vSNVuPy7GtX6qHuIY8t7yj5kQYjuu3CwJ6rdlRCwPGRLb8ZVB37nGXUF368oiEVq738+5gVMSH3pK/tOftt5iYl4jSiBKlFsBzKG1l/sxg2FbUVbAtz9ht6Mv/Jezg5ncbs8J+nDb2G9Zh8nQKBgQCoYI6eLdsVQnscCQvjCe7/h11zov437QQOHv91uMpQEoDD6C4t6kNdXHqbc3GzhSxBXbzvMMbor3osmLBkFH/qy7KribJko0a7ZYtONlouSKdtNEHuFFZD63ucwP61cAxgVC/Fo6wiROOt+IJ+jg5ch3wVRbzq+E9H+fSlatghFQKBgQDXbISEKNbmjeRTFmYAW8p6s+AglpSs93A35of5YtWtYe9jHObGPnLFaER5BrKXL9/0loDBa3wf3K3lzszJejPfNBpUma+YxXIWtuHMy40jYIP608ttueaxiY+6SMzx+qz4Y6HOyDOK39K3yVPatGzFFm+E3ovCwqZa/l9nHhoGCQKBgDzG3bPrCXGbFaUA/vFs3IAP9IORCgJV42jVd5CeqyhMBX6xiDm6naZNg1QpT5llMJxHobMVADdtX8RJOSJm4+V0sYGJqoL5DMcH2EjbBaI/R2/7tPCjFqBdl7j1UPtc/pqmyLemZLPZ+fUKBtB3pmdv4DItgguupa9tYglzj6AhAoGBAJ+G4GneymhV8wG2axFVGTgekoZZSiA1It83iDui9ZEHAig1f7Y8Q7TpoefwIBkV4fpPiAMutqpQTWiElfLlz5zYCJXe0m4+Ni8BLcLjkFLORVKXKOyf3Rs0il0pd4U/mfA4xkQNFy7Kh0Yfhv9qKyc3CJZmv1Cw1Vu2LqqASzR0

# 查看地址：https://openhome.alipay.com/platform/keyManage.htm对应APPID下的支付宝公钥
alipay.alipay-public-key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkQhfxcDqt0Rkz8KDuDlGGnl2IvPKHXJOHPgRNmOc3U/kQfrdBbbzadpSlbt9RJTC9wL+XjYVwX3FBJ1rz0Mv3RgQzJNbf0ik6XQgznsLuNsB7oq2dFXTO2bBvgj22DYPskRMPLbsmCFq6TQX2VZbcTG9fJAXcISe9acPS6DBbH60OfuCv93ApPt/O1QYmFsk2O6OVzniNpYzvMYeAdNSImIuFIZWlzdSUFfEmF8T3DjoXy2/7YJ3y9RcXLn9Nk5pSyUqnMZFaXaTc/zoFzHIkDb9NvPisDNDWovNwCM6FXqcHvV1Y9wE7boaSdU4ZhJFGuacSzEbnWlSan5oFPPY2QIDAQAB

# 接口内容加密秘钥，对称秘钥
alipay.content-key=2dg+ct4EWrNVouU+aP1acg==

# 页面跳转同步通知页面路径
alipay.return-url=:8080/#/success

# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url=https://a863-180-174-204-169.ngrok.io/api/ali-pay/trade/notify
```

### 创建配置⽂件

> 在config包中创建AlipayClientConfig

```java
@Configuration
//加载配置文件
@PropertySource("classpath:alipay-sandbox.properties")
public class AlipayClientConfig {
}
```

### 测试配置⽂件

```java
package com.atguigu.paymentdemo;

@SpringBootTest
@Slf4j
public class AlipayTests {
    
    @Resource
    private Environment config;
    
    @Test
    void testGetAlipayConfig(){
        log.info("appid = " + config.getProperty("alipay.app-id"));
    }
}
```

### 服务端SDK

> 参考⽂档：开放平台 => ⽂档 => 开发⼯具 => 服务端SDK => Java => 通⽤版 => Maven项⽬依赖

**https://search.maven.org/artifact/com.alipay.sdk/alipay-sdk-java**

```xml
<!--SDK-->
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>4.22.57.ALL</version>
</dependency>
```

> 创建带数据签名的客⼾端对象，参考⽂档：开放平台 => ⽂档 => 开发⼯具 => 技术接⼊指南 => 数据签名

**https://opendocs.alipay.com/common/02kf5q**

> 参考⽂档中 公钥方式 完善 AlipayClientConfig 类，添加 alipayClient() ⽅法 初始化 AlipayClient 对象

```java
@Configuration
//加载配置文件
@PropertySource("classpath:alipay-sandbox.properties")
public class AlipayClientConfig {

    @Resource
    private Environment config;

    @Bean
    public AlipayClient alipayClient() throws AlipayApiException {

        AlipayConfig alipayConfig = new AlipayConfig();
        //设置网关地址
        alipayConfig.setServerUrl(config.getProperty("alipay.gateway-url"));
        //设置应用Id
        alipayConfig.setAppId(config.getProperty("alipay.app-id"));
        //设置应用私钥
        alipayConfig.setPrivateKey(config.getProperty("alipay.merchant-private-key"));
        //设置请求格式，固定值json
        alipayConfig.setFormat(AlipayConstants.FORMAT_JSON);
        //设置字符集
        alipayConfig.setCharset(AlipayConstants.CHARSET_UTF8);
        //设置支付宝公钥
        alipayConfig.setAlipayPublicKey(config.getProperty("alipay.alipay-public-key"));
        //设置签名类型
        alipayConfig.setSignType(AlipayConstants.SIGN_TYPE_RSA2);
        //构造client
        AlipayClient alipayClient = new DefaultAlipayClient(alipayConfig);
        return alipayClient;
    }
}
```



## 支付功能

### 统⼀收单下单并⽀付⻚⾯

#### ⽀付调⽤流程

**https://opendocs.alipay.com/open/270/105899**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305291431451.png" alt="image-20230529143151387" style="zoom:80%;" />

### 接⼝说明

**https://opendocs.alipay.com/apis/028r8t?scene=22**

> 公共请求参数：**所有接⼝都需要的参数**
>
> 请求参数：当前接⼝需要的参数
>
> 公共响应参数：**所有接⼝的响应中都包含的数据**
>
> 响应参数：当前接⼝的响应中包含的数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292142406.png" alt="image-20230529214259300" style="zoom:80%;" />

### 发起支付请求

#### OrderStatus

```java
@AllArgsConstructor
@Getter
public enum OrderStatus {
    /**
     * 未支付
     */
    NOTPAY("未支付"),


    /**
     * 支付成功
     */
    SUCCESS("支付成功"),

    /**
     * 已关闭
     */
    CLOSED("超时已关闭"),

    /**
     * 已取消
     */
    CANCEL("用户已取消"),

    /**
     * 退款中
     */
    REFUND_PROCESSING("退款中"),

    /**
     * 已退款
     */
    REFUND_SUCCESS("已退款"),

    /**
     * 退款异常
     */
    REFUND_ABNORMAL("退款异常");

    /**
     * 类型
     */
    private final String type;
}
```

#### OrderNoUtils

> 订单号工具类

```java
public class OrderNoUtils {

    // 获取订单编号
    public static String getOrderNo() {
        return "ORDER_" + getNo();
    }

    // 获取退款单编号
    public static String getRefundNo() {
        return "REFUND_" + getNo();
    }

    // 获取编号
    public static String getNo() {
        // 获取当前时间
        LocalDateTime now = LocalDateTime.now();
        // 定义日期时间格式
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
        // 格式化日期时间为字符串
        String newDate = now.format(formatter);
        String result = "";
        Random random = new Random();
        for (int i = 0; i < 3; i++) {
            result += random.nextInt(10);
        }
        return newDate + result;
    }

    public static void main(String[] args) {
        System.out.println(getOrderNo()); // ORDER_20230529210352120
    }
}
```



#### controller

```java
@RestController
@RequestMapping("/api/ali-pay")
@Api(tags = "网站支付宝支付")
public class AliPayController {

    @Resource
    private AliPayService aliPayService;
    
    @ApiOperation("统一收单下单并支付页面接口的调用")
    @PostMapping("/trade/page/pay/{productId}")
    public R tradePagePay(@PathVariable Long productId){
        // 支付宝开放平台接受 request 请求对象后
        // 会为开发者生成一个html 形式的 form表单，包含自动提交的脚本
        String formStr = aliPayService.tradeCreate(productId);
        //我们将form表单字符串返回给前端程序，之后前端将会调用自动提交脚本，进行表单的提交
        //此时，表单会自动提交到action属性所指向的支付宝开放平台中，从而为用户展示一个支付页面
        return R.ok(formStr);
    }
}
```

#### OrderInfoService

```java
public interface OrderInfoService extends IService<OrderInfo> {
    OrderInfo createOrderByProductId(Long productId);
}
```

```java
@Service
public class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> 
    implements OrderInfoService {

    @Resource
    private ProductMapper productMapper;

    @Override
    public OrderInfo createOrderByProductId(Long productId) {
        //查找已存在但未支付的订单
        OrderInfo orderInfo = this.getNoPayOrderByProductId(productId);
        if( orderInfo != null){
            return orderInfo;
        }
        //获取商品信息
        Product product = productMapper.selectById(productId);
        //生成订单
        orderInfo = new OrderInfo();
        orderInfo.setTitle(product.getTitle());
        orderInfo.setOrderNo(OrderNoUtils.getOrderNo()); //订单号
        orderInfo.setProductId(productId);
        orderInfo.setTotalFee(product.getPrice()); //分
        orderInfo.setOrderStatus(OrderStatus.NOTPAY.getType()); //未支付
        baseMapper.insert(orderInfo);
        return orderInfo;
    }

    // 根据商品id查询未支付订单,防止重复创建订单对象
    private OrderInfo getNoPayOrderByProductId(Long productId) {
        QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("product_id", productId);
        queryWrapper.eq("order_status", OrderStatus.NOTPAY.getType());
        return baseMapper.selectOne(queryWrapper);
    }
}
```

#### AliPayService

```java
public interface AliPayService {
    String tradeCreate(Long productId);
}
```

```java
@Service
@Slf4j
public class AliPayServiceImpl implements AliPayService {

    @Resource
    private OrderInfoService orderInfoService;

    @Resource
    private AlipayClient alipayClient;

    @Resource
    private Environment config;
    
    @Transactional(rollbackFor = Exception.class)
    @Override
    public String tradeCreate(Long productId) {
        try {
            //生成订单
            log.info("生成订单");
            OrderInfo orderInfo = orderInfoService.createOrderByProductId(productId);
            //调用支付宝接口
            AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
            //配置需要的公共请求参数
            //支付完成后，支付宝向谷粒学院发起异步通知的地址
            request.setNotifyUrl(config.getProperty("alipay.notify-url"));
            //支付完成后，我们想让页面跳转回谷粒学院的页面，配置returnUrl
            request.setReturnUrl(config.getProperty("alipay.return-url"));
            //组装当前业务方法的请求参数
            JSONObject bizContent = new JSONObject();
            bizContent.put("out_trade_no", orderInfo.getOrderNo());
            BigDecimal total = new BigDecimal(orderInfo.getTotalFee().toString())
                                             .divide(new BigDecimal("100"));
            bizContent.put("total_amount", total);
            bizContent.put("subject", orderInfo.getTitle());
            bizContent.put("product_code", "FAST_INSTANT_TRADE_PAY");
            request.setBizContent(bizContent.toString());
            //执行请求，调用支付宝接口
            AlipayTradePagePayResponse response = alipayClient.pageExecute(request);
            if(response.isSuccess()){
                log.info("调用成功，返回结果 ===> " + response.getBody());
                return response.getBody();
            } else {
                log.info("调用失败，返回码 ===> " + response.getCode() + 
                         ", 返回描述 ===> " + response.getMsg());
                throw new RuntimeException("创建支付交易失败");
            }
        } catch (AlipayApiException e) {
            e.printStackTrace();
            throw new RuntimeException("创建支付交易失败");
        }
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292109036.png" alt="image-20230529210932867" style="zoom:67%;" />



### 前端⽀付按钮

#### aliPay.js

```js
// axios 发送ajax请求
import request from '@/utils/request'

export default{
  //发起支付请求
  tradePagePay(productId) {
    return request({
      url: '/api/ali-pay/trade/page/pay/' + productId,
      method: 'post'
    })
  }
}
```

#### index.vue

```vue
<template>
  <div class="bg-fa of">
    <section id="index" class="container">
      <header class="comm-title">
        <h2 class="fl tac">
          <span class="c-333">课程列表</span>
        </h2>
      </header>
      <ul>
        <li v-for="product in productList" :key="product.id">
          <a
            :class="[
              'orderBtn',
              { current: payOrder.productId === product.id },
            ]"
            @click="selectItem(product.id)"
            href="javascript:void(0);"
          >
            {{ product.title }}
            ¥{{ product.price / 100 }}
          </a>
        </li>
      </ul>

      <div class="PaymentChannel_payment-channel-panel">
        <h3 class="PaymentChannel_title">选择支付方式</h3>
        <div class="PaymentChannel_channel-options">
          <!-- 选择微信 -->
          <div
            :class="[
              'ChannelOption_payment-channel-option',
              { current: payOrder.payType === 'wxpay' },
            ]"
            @click="selectPayType('wxpay')">
            <div class="ChannelOption_channel-icon">
              <img src="../assets/img/wxpay.png" class="ChannelOption_icon" />
            </div>
            <div class="ChannelOption_channel-info">
              <div class="ChannelOption_channel-label">
                <div class="ChannelOption_label">微信支付</div>
                <div class="ChannelOption_sub-label"></div>
                <div class="ChannelOption_check-option"></div>
              </div>
            </div>
          </div>

          <!-- 选择支付宝 -->
          <div
            :class="[
              'ChannelOption_payment-channel-option',
              { current: payOrder.payType === 'alipay' },
            ]"
            @click="selectPayType('alipay')"
          >
            <div class="ChannelOption_channel-icon">
              <img src="../assets/img/alipay.png" class="ChannelOption_icon" />
            </div>
            <div class="ChannelOption_channel-info">
              <div class="ChannelOption_channel-label">
                <div class="ChannelOption_label">支付宝</div>
                <div class="ChannelOption_sub-label"></div>
                <div class="ChannelOption_check-option"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="payButtom">
        <el-button
          :disabled="payBtnDisabled"
          type="warning"
          round
          style="width: 280px; height: 44px; font-size: 18px"
          @click="toPay()">
          确认支付（支付宝和微信V3）
        </el-button>
        <el-button
          :disabled="payBtnDisabled"
          type="warning"
          round
          style="width: 280px; height: 44px; font-size: 18px"
          @click="toPayV2()"
        >
          确认支付（微信V2）
        </el-button>
      </div>
    </section>

    <!-- 微信支付二维码 -->
    <el-dialog
      :visible.sync="codeDialogVisible"
      :show-close="false"
      @close="closeDialog"
      width="350px"
      center>
      <qriously :value="codeUrl" :size="300" />
      <!-- <img src="../assets/img/code.png" alt="" style="width:100%"><br> -->
      使用微信扫码支付
    </el-dialog>
  </div>
</template>

<script>
import productApi from '../api/product'
import wxPayApi from '../api/wxPay'
import aliPayApi from '../api/aliPay'
import orderInfoApi from '../api/orderInfo'

export default {
  data() {
    return {
      payBtnDisabled: false, //确认支付按钮是否禁用
      codeDialogVisible: false, //微信支付二维码弹窗
      productList: [], //商品列表
      payOrder: {
        //订单信息
        productId: '', //商品id
        payType: 'wxpay', //支付方式
      },
      codeUrl: '', // 二维码
      orderNo: '', //订单号
      timer: null, // 定时器
    }
  },

  //页面加载时执行
  created() {
    //获取商品列表
    productApi.list().then((response) => {
      this.productList = response.data
      this.payOrder.productId = this.productList[0].id
    })
  },

  methods: {
    //选择商品
    selectItem(productId) {
      console.log('商品id：' + productId)
      this.payOrder.productId = productId
      console.log(this.payOrder)
      //this.$router.push({ path: '/order' })
    },

    //选择支付方式
    selectPayType(type) {
      console.log('支付方式：' + type)
      this.payOrder.payType = type
      //this.$router.push({ path: '/order' })
    },

    //确认支付
    toPay() {
      //禁用按钮，防止重复提交
      this.payBtnDisabled = true

      //微信支付
      if (this.payOrder.payType === 'wxpay') {
        //调用统一下单接口
        wxPayApi.nativePay(this.payOrder.productId).then((response) => {
          this.codeUrl = response.data.codeUrl
          this.orderNo = response.data.orderNo

          //打开二维码弹窗
          this.codeDialogVisible = true

          //启动定时器
          this.timer = setInterval(() => {
            //查询订单是否支付成功
            this.queryOrderStatus()
          }, 3000)
        })

        //支付宝支付
      } else if (this.payOrder.payType === 'alipay') {

        //调用支付宝统一收单下单并支付页面接口
        aliPayApi.tradePagePay(this.payOrder.productId).then((response) => {
          //将支付宝返回的表单字符串写在浏览器中，表单会自动触发submit提交
          document.write(response.data)
        })
      }
    },

    //确认支付
    toPayV2() {
      //禁用按钮，防止重复提交
      this.payBtnDisabled = true

      //微信支付
      if (this.payOrder.payType === 'wxpay') {
        //调用统一下单接口
        wxPayApi.nativePayV2(this.payOrder.productId).then((response) => {
          this.codeUrl = response.data.codeUrl
          this.orderNo = response.data.orderNo

          //打开二维码弹窗
          this.codeDialogVisible = true

          //启动定时器
          this.timer = setInterval(() => {
            //查询订单是否支付成功
            this.queryOrderStatus()
          }, 3000)
        })
      }
    },

    //关闭微信支付二维码对话框时让“确认支付”按钮可用
    closeDialog() {
      console.log('close.................')
      this.payBtnDisabled = false
      console.log('清除定时器')
      clearInterval(this.timer)
    },

    // 查询订单状态
    queryOrderStatus() {
      orderInfoApi.queryOrderStatus(this.orderNo).then((response) => {
        console.log('查询订单状态：' + response.code)
        // 支付成功后的页面跳转
        if (response.code === 0) {
          console.log('清除定时器')
          clearInterval(this.timer)
          // 三秒后跳转到支付成功页面
          setTimeout(() => {
            this.$router.push({ path: '/success' })
          }, 3000)
        }
      })
    },
  },
}
</script>
```



### 支付测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292114629.png" alt="image-20230529211452520" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292113382.png" alt="image-20230529211330221" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292113193.png" alt="image-20230529211359068" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292114197.png" alt="image-20230529211412104" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292114579.png" alt="image-20230529211431494" style="zoom:80%;" />

> 再次发起支付，发现提示已经支付

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305292121888.png" alt="image-20230529212143818" style="zoom:80%;" />

## 订单列表

### 后端实现

```java
@Api(tags = "商品订单管理")
@RestController
@RequestMapping("/api/order-info")
public class OrderInfoController {
    @Resource
    private OrderInfoService orderInfoService;

    @ApiOperation("订单列表")
    @GetMapping("/list")
    public R list(){
        List<OrderInfo> list = orderInfoService.listOrderByCreateTimeDesc();
        return R.ok(list);
    }
}
```

```java
public interface OrderInfoService extends IService<OrderInfo> {
    OrderInfo createOrderByProductId(Long productId);
    List<OrderInfo> listOrderByCreateTimeDesc();
}
```

```java
@Service
public class OrderInfoServiceImpl extends ServiceImpl<OrderInfoMapper, OrderInfo> implements OrderInfoService {

    @Resource
    private ProductMapper productMapper;

    @Override
    public OrderInfo createOrderByProductId(Long productId) {
        //查找已存在但未支付的订单
        OrderInfo orderInfo = this.getNoPayOrderByProductId(productId);
        if( orderInfo != null){
            return orderInfo;
        }
        //获取商品信息
        Product product = productMapper.selectById(productId);
        //生成订单
        orderInfo = new OrderInfo();
        orderInfo.setTitle(product.getTitle());
        orderInfo.setOrderNo(OrderNoUtils.getOrderNo()); //订单号
        orderInfo.setProductId(productId);
        orderInfo.setTotalFee(product.getPrice()); //分
        orderInfo.setOrderStatus(OrderStatus.NOTPAY.getType()); //未支付
        baseMapper.insert(orderInfo);
        return orderInfo;
    }

    // 根据商品id查询未支付订单,防止重复创建订单对象
    private OrderInfo getNoPayOrderByProductId(Long productId) {
        QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("product_id", productId);
        queryWrapper.eq("order_status", OrderStatus.NOTPAY.getType());
        return baseMapper.selectOne(queryWrapper);
    }

    // 查询订单列表，并倒序查询
    @Override
    public List<OrderInfo> listOrderByCreateTimeDesc() {
        QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<OrderInfo>
            ().orderByDesc("create_time");
        return baseMapper.selectList(queryWrapper);
    }
}
```

### 前端实现

```vue
<template>
  <div class="bg-fa of">
    <section id="index" class="container">
      <header class="comm-title">
        <h2 class="fl tac">
          <span class="c-333">订单列表</span>
        </h2>
      </header>
      <el-table :data="list" border style="width: 100%">
        <el-table-column type="index" width="50"></el-table-column>
        <el-table-column prop="orderNo" label="订单编号" width="230" ></el-table-column>
        <el-table-column prop="title" label="订单标题"></el-table-column>
        <el-table-column prop="totalFee" label="订单金额">
          <template slot-scope="scope">
              {{scope.row.totalFee / 100}} 元
          </template>
        </el-table-column>
        <el-table-column prop="paymentType" label="支付方式"></el-table-column>
        <el-table-column label="订单状态">
          <template slot-scope="scope">
            <el-tag v-if="scope.row.orderStatus === '未支付'">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '支付成功'" type="success">
              {{ scope.row.orderStatus }}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '超时已关闭'" type="warning">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '用户已取消'" type="info">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '退款中'" type="danger">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '已退款'" type="info">
              {{scope.row.orderStatus}}
            </el-tag>
            <el-tag v-if="scope.row.orderStatus === '退款异常'" type="danger">
              {{scope.row.orderStatus}}
            </el-tag>
          </template>
        </el-table-column>
        <!-- <el-table-column prop="createTime" label="创建时间"></el-table-column> -->
        <el-table-column label="操作" width="100" align="center">
          <template slot-scope="scope">
            <el-button v-if="scope.row.orderStatus === '未支付'" type="text" @click="cancel(scope.row.orderNo, scope.row.paymentType)">取消</el-button>
            <el-button v-if="scope.row.orderStatus === '支付成功'" type="text" @click="refund(scope.row.orderNo, scope.row.paymentType)">退款</el-button>
          </template>
        </el-table-column>
      </el-table>
    </section>

    <!-- 退款对话框 -->
   <el-dialog
      :visible.sync="refundDialogVisible"
      @close="closeDialog"
      width="350px"
      center>
      <el-form>
        <el-form-item label="退款原因">
          <el-select v-model="reason" placeholder="请选择退款原因">
            <el-option label="不喜欢" value="不喜欢"></el-option>
            <el-option label="买错了" value="买错了"></el-option>
          </el-select>
        </el-form-item>
      </el-form>
      <div slot="footer" class="dialog-footer">
        <el-button type="primary" @click="toRefunds()" :disabled="refundSubmitBtnDisabled">确 定</el-button>
      </div>
    </el-dialog>
  </div>
</template>

<script>
import aliPay from '../api/aliPay';
import orderInfoApi from "../api/orderInfo"
import wxPayApi from "../api/wxPay"

export default {
  data() {
    return {
      list: [], //订单列表
      refundDialogVisible: false, //退款弹窗
      orderNo: '', //退款订单号
      reason: '', //退款原因,
      refundSubmitBtnDisabled: false, //防止重复提交
      paymentType: ''
    };
  },

  created() {
    this.showOrderList()
  },

  methods: {

    //显示订单列表
    showOrderList(){
      orderInfoApi.list().then((response) => {
        this.list = response.data;
      });
    },

    //用户取消订单
    cancel(orderNo, paymentType){

      if(paymentType === '微信'){
        wxPayApi.cancel(orderNo).then(response => {
          this.$message.success(response.message)
          //刷新订单列表
          this.showOrderList()
        })
      }else{
        aliPay.cancel(orderNo).then(response => {
          this.$message.success(response.message)
          //刷新订单列表
          this.showOrderList()
        })
      }

    },

    //退款对话框
    refund(orderNo, paymentType){
      this.refundDialogVisible = true
      this.orderNo = orderNo
      this.paymentType = paymentType
    },

    //关闭退款对话框
    closeDialog(){
      console.log('close.................')
      this.refundDialogVisible = false
      //还原组件状态
      this.orderNo = ''
      this.reason = ''
      this.refundSubmitBtnDisabled = false
    },

    //确认退款
    toRefunds(){
      this.refundSubmitBtnDisabled = true //禁用按钮，防止重复提交

      if(this.paymentType === '微信'){
        wxPayApi.refunds(this.orderNo, this.reason).then(response => {
          console.log('response', response)
          this.closeDialog()
          this.showOrderList()
        })
      }else{
        aliPay.refunds(this.orderNo, this.reason).then(response => {
          console.log('response', response)
          this.closeDialog()
          this.showOrderList()
        })
      }
    }
  }
};
</script>
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305300900939.png" alt="image-20230530090040841" style="zoom:80%;" />

## 支付结果通知

### 内网穿透

> 官网：https://ngrok.com/，账号是使用Github注册登录的，下载解压成ngrok.exe，进入CMD

```sh
# 这条设置一次就行，本次设置后下次就不用设置了
ngrok config add-authtoken 2QUWbsrQqwhoRR2N3hyV1AZPwwV_7uXPYZKPdarZy7Sp4C9Lt
# 启动8090端口
ngrok http 8090
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305300909193.png" alt="image-20230530090930123" style="zoom:80%;" />

> 上面生成了两个地址，这里我们使用https那个，注意：每次重新启动ngrok地址都会发生变化

### 异步通知

> 首先要在上面的支付功能开发中配置回调地址，前面已经配置了

> AliPayServiceImpl

```java
@Transactional(rollbackFor = Exception.class)
@Override
public String tradeCreate(Long productId) {
    try {
        //生成订单
        log.info("生成订单");
        OrderInfo orderInfo = orderInfoService.createOrderByProductId(productId);
        //调用支付宝接口
        AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();
        //配置需要的公共请求参数
        //支付完成后，支付宝向谷粒学院发起异步通知的地址
        request.setNotifyUrl(config.getProperty("alipay.notify-url"));
        //支付完成后，我们想让页面跳转回谷粒学院的页面，配置returnUrl，就是这里
        request.setReturnUrl(config.getProperty("alipay.return-url"));
        //组装当前业务方法的请求参数
        JSONObject bizContent = new JSONObject();
        ....
    }
}
```

> alipay-sandbox.properties

```properties
# 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问
# 注意：每次重新启动ngrok，都需要根据实际情况修改这个配置
alipay.notify-url= https://4b52-216-244-74-251.ngrok-free.app/api/ali-pay/trade/notify
```

> 支付通知接口开发

```java
@ApiOperation("支付通知")
@PostMapping("/trade/notify")
public String tradeNotify(@RequestParam Map<String, String> params){
    log.info("支付通知正在执行");
    log.info("通知参数 ===> {}", params);
}
```

> 进入支付页面，测试看是否传入了通知参数

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305300924281.png" alt="image-20230530092401218" style="zoom:80%;" />

### 签名验证

> 这里进行签名验证，主要看能否验证

```java
@ApiOperation("支付通知")
@PostMapping("/trade/notify")
// 此处支付宝只支持返回failure或success
public String tradeNotify(@RequestParam Map<String, String> params){
    log.info("支付通知正在执行");
    log.info("通知参数 ===> {}", params);
    String result = "failure";
    try {
        //异步通知验签
        boolean signVerified = AlipaySignature.rsaCheckV1(
                params,
                config.getProperty("alipay.alipay-public-key"),
                AlipayConstants.CHARSET_UTF8,
                AlipayConstants.SIGN_TYPE_RSA2); //调用SDK验证签名
        // 判断验签是否成功
        if(!signVerified){
            //验签失败则记录异常日志，并在response中返回failure.
            log.error("支付成功异步通知验签失败！");
            return result;
        }
        // 验签成功后
        log.info("支付成功异步通知验签成功！");
        //校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
        result = "success";
    } catch (AlipayApiException e) {
        e.printStackTrace();
    }
    return result;
}
```

> 扫码登录，查看控制台

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305300934792.png" alt="image-20230530093458708" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305300935210.png" alt="image-20230530093546152" style="zoom:80%;" />

### 二次校验

> 先编写根据订单号获取订单功能，在OrderInfo和OrderInfoService中

```java
OrderInfo getOrderByOrderNo(String outTradeNo);
```

```java
// 根据订单号获取订单
@Override
public OrderInfo getOrderByOrderNo(String orderNo) {
    QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("order_no", orderNo);
    return baseMapper.selectOne(queryWrapper);
}
```

> 在编写二次校验的方法，如果没有任何失败通知，则校验成功

```java
@ApiOperation("支付通知")
@PostMapping("/trade/notify")
// 此处支付宝只支持返回failure或success
public String tradeNotify(@RequestParam Map<String, String> params){
    log.info("支付通知正在执行");
    log.info("通知参数 ===> {}", params);
    String result = "failure";
    try {
        //异步通知验签
        boolean signVerified = AlipaySignature.rsaCheckV1(
                params,
                config.getProperty("alipay.alipay-public-key"),
                AlipayConstants.CHARSET_UTF8,
                AlipayConstants.SIGN_TYPE_RSA2); //调用SDK验证签名
        // 判断验签是否成功
        if(!signVerified){
            //验签失败则记录异常日志，并在response中返回failure.
            log.error("支付成功异步通知验签失败！");
            return result;
        }
        // 验签成功后
        log.info("支付成功异步通知验签成功！");
        //按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验，
        //1、 商户需要验证该通知数据中的 out_trade_no 是否为商户系统中创建的订单号
        String outTradeNo = params.get("out_trade_no");
        OrderInfo order = orderInfoService.getOrderByOrderNo(outTradeNo);
        if(order == null){
            log.error("订单不存在");
            return result; // result默认为failure
        }
        //2、 判断 total_amount 是否确实为该订单的实际金额（即商户订单创建时的金额）
        String totalAmount = params.get("total_amount");
        // total_amount是以元为单位，而数据库是以分为单位的，所以要除以100
        int totalAmountInt = new BigDecimal(totalAmount)
                                 .multiply(new BigDecimal("100")).intValue();
        int totalFeeInt = order.getTotalFee().intValue();
        if(totalAmountInt != totalFeeInt){
            log.error("金额校验失败");
            return result;
        }
        //3、 校验通知中的商家id seller_id（或者 seller_email)
        //    是否为 out_trade_no 这笔单据的对应的操作方
        String sellerId = params.get("seller_id");
        String sellerIdProperty = config.getProperty("alipay.seller-id");
        if(!sellerId.equals(sellerIdProperty)){
            log.error("商家pid校验失败");
            return result;
        }
        //4 验证 app_id 是否为该商户本身
        String appId = params.get("app_id");
        String appIdProperty = config.getProperty("alipay.app-id");
        if(!appId.equals(appIdProperty)){
            log.error("appid校验失败");
            return result;
        }
        //在支付宝的业务通知中，只有交易通知状态为 TRADE_SUCCESS时，
        // 支付宝才会认定为买家付款成功。
        String tradeStatus = params.get("trade_status");
        if(!"TRADE_SUCCESS".equals(tradeStatus)){
            log.error("支付未成功");
            return result;
        }
        // TODO 处理业务 修改订单状态 记录支付日志
    //    aliPayService.processOrder(params);
        //校验成功后在response中返回success并继续商户自身业务处理，校验失败返回failure
        result = "success";
    } catch (AlipayApiException e) {
        e.printStackTrace();
    }
    return result;
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305300949697.png" alt="image-20230530094903638" style="zoom:80%;" />

### 记录支付日志

#### AliPayService

```java
@ApiOperation("支付通知")
@PostMapping("/trade/notify")
// 此处支付宝只支持返回failure或success
public String tradeNotify(@RequestParam Map<String, String> params){
    log.info("支付通知正在执行");
    log.info("通知参数 ===> {}", params);
        ....
        // TODO 处理业务 修改订单状态 记录支付日志
        aliPayService.processOrder(params);
        ....
    return result;
}
```

```java
public interface AliPayService {
    String tradeCreate(Long productId);
    void processOrder(Map<String, String> params);
}
```

```java
// 处理订单
@Transactional(rollbackFor = Exception.class)
@Override
public void processOrder(Map<String, String> params) {
    log.info("处理订单");
    //获取订单号
    String orderNo = params.get("out_trade_no");
    //更新订单状态,OrderStatus枚举类，上面已经定义
    orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);
    //记录支付日志
    paymentInfoService.createPaymentInfoForAliPay(params);
}
```

#### OrderInfoService

```java
public interface OrderInfoService extends IService<OrderInfo> {
    OrderInfo createOrderByProductId(Long productId);
    List<OrderInfo> listOrderByCreateTimeDesc();
    String getOrderStatus(String orderNo);
    OrderInfo getOrderByOrderNo(String outTradeNo);
    //更新订单状态
    void updateStatusByOrderNo(String orderNo, OrderStatus success);
}
```

```java
// 根据订单号更新订单状态
@Override
public void updateStatusByOrderNo(String orderNo, OrderStatus orderStatus) {
    log.info("更新订单状态 ===> {}", orderStatus.getType());
    QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("order_no", orderNo);
    OrderInfo orderInfo = new OrderInfo();
    orderInfo.setOrderStatus(orderStatus.getType());
    baseMapper.update(orderInfo, queryWrapper);
}
```

#### PaymentInfoService

```java
public interface PaymentInfoService {
    void createPaymentInfoForAliPay(Map<String, String> params);
}
```

```java
@Slf4j
@Service
public class PaymentInfoServiceImpl extends ServiceImpl<PaymentInfoMapper, PaymentInfo>
        implements PaymentInfoService {

    ObjectMapper mapper = new ObjectMapper();

    // 记录支付日志：支付宝
    @Override
    public void createPaymentInfoForAliPay(Map<String, String> params) {
        try {
            log.info("记录支付日志");
            //获取订单号
            String orderNo = params.get("out_trade_no");
            //业务编号
            String transactionId = params.get("trade_no");
            //交易状态
            String tradeStatus = params.get("trade_status");
            //交易金额
            String totalAmount = params.get("total_amount");
            int totalAmountInt = new BigDecimal(totalAmount)
                .multiply(new BigDecimal("100")).intValue();
            PaymentInfo paymentInfo = new PaymentInfo();
            paymentInfo.setOrderNo(orderNo);
            paymentInfo.setPaymentType(PayType.ALIPAY.getType());
            paymentInfo.setTransactionId(transactionId);
            paymentInfo.setTradeType("电脑网站支付");
            paymentInfo.setTradeState(tradeStatus);
            paymentInfo.setPayerTotal(totalAmountInt);
            String json = mapper.writeValueAsString(params);
            paymentInfo.setContent(json);
            baseMapper.insert(paymentInfo);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

> 再次进行支付，查看t_payment_info和t_order_info，发现已经成功记录日志和支付状态修改成功

### 处理重复通知+上锁

#### OrderInfoService

```java
OrderInfo getOrderByOrderNo(String outTradeNo);
```

```java
// 根据订单号获取订单
@Override
public OrderInfo getOrderByOrderNo(String orderNo) {
    QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("order_no", orderNo);
    return baseMapper.selectOne(queryWrapper);
}
```

#### AliPayServiceImpl

```java
@Resource
private PaymentInfoService paymentInfoService;
private final ReentrantLock lock = new ReentrantLock();

// 处理订单
@Transactional(rollbackFor = Exception.class)
@Override
public void processOrder(Map<String, String> params) {
    log.info("处理订单");
    //获取订单号
    String orderNo = params.get("out_trade_no");
    // 在对业务数据进行状态检查和处理之前，要采用数据锁进行并发控制，以避免函数重入造成的数据混乱
    // 尝试获取锁：成功获取则立即返回true，进入方法，获取失败则立即返回false。不必一直等待锁的释放
    if(lock.tryLock()) {
        try {
            // 处理重复通知
            // 接口调用的幂等性：无论接口被调用多少次，以下业务执行一次
            // NOTPAY("未支付")，获取订单状态，只有未支付才能进行记录日志等操作
            String orderStatus = orderInfoService.getOrderStatus(orderNo);
            if (!OrderStatus.NOTPAY.getType().equals(orderStatus)) {
                return;
            }
            //更新订单状态
            orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);
            //记录支付日志
            paymentInfoService.createPaymentInfoForAliPay(params);
        } finally {
            //要主动释放锁
            lock.unlock();
        }
    }
}
```

### 订单表优化

#### 字段添加

> t_order_info 表中添加 payment_type 字段，微信支付就写微信，支付宝支付就写支付宝

> orderInfo实体类添加该字段

```java
private String paymentType; // 支付方式
```

#### PayType

```java
@AllArgsConstructor
@Getter
public enum PayType {
    // 微信
    WXPAY("微信"),
    // 支付宝
    ALIPAY("支付宝");
    // 类型
    private final String type;
}
```

#### AliPayServiceImpl

```java
public String tradeCreate(Long productId) {
    try {
        //生成订单
        log.info("生成订单");
        // 添加PayType
        OrderInfo orderInfo = orderInfoService
                  .createOrderByProductId(productId, 
                                          PayType.ALIPAY.getType());
        //调用支付宝接口
        ...
    }
}
```

#### OrderInfoService

```java
public interface OrderInfoService extends IService<OrderInfo> {
    // 添加paymentType字段
    OrderInfo createOrderByProductId(Long productId,String paymentType);
    ...
}
```

```java
@Override
public OrderInfo createOrderByProductId(Long productId,String paymentType) {
    //查找已存在但未支付的订单
    OrderInfo orderInfo = this.getNoPayOrderByProductId(productId,paymentType);
    if( orderInfo != null){
        return orderInfo;
    }
    ...
}
```

```java
// 根据商品id查询未支付订单,防止重复创建订单对象
private OrderInfo getNoPayOrderByProductId(Long productId,String paymentType) {
    QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("product_id", productId);
    queryWrapper.eq("order_status", OrderStatus.NOTPAY.getType());
    queryWrapper.eq("payment_type", paymentType);
    return baseMapper.selectOne(queryWrapper);
}
```

> 进行支付测试，发现t_order_info表已经成功添加上支付宝

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301036751.png" alt="image-20230530103612688" style="zoom:80%;" />

## 用户取消订单

> 是用户已经创建订单，扫码或输入密码前的一步

```java
// 用户取消订单
@ApiOperation("用户取消订单")
@PostMapping("/trade/close/{orderNo}")
public R cancel(@PathVariable String orderNo){
    log.info("取消订单");
    aliPayService.cancelOrder(orderNo);
    return R.ok("订单已取消");
}
```

```java
public interface AliPayService {
    String tradeCreate(Long productId);
    void processOrder(Map<String, String> params);
	// 取消订单
    void cancelOrder(String orderNo);
}
```

```java
// 用户取消订单
@Override
public void cancelOrder(String orderNo) {
    //调用支付宝提供的统一收单交易关闭接口
    this.closeOrder(orderNo);
    //更新用户订单状态
    orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.CANCEL);
}
```

```java
// 统一收单交易关闭接口
private void closeOrder(String orderNo) {
    try {
        log.info("关单接口的调用，订单号 ===> {}", orderNo);
        AlipayTradeCloseRequest request = new AlipayTradeCloseRequest();
        JSONObject bizContent = new JSONObject();
        bizContent.put("out_trade_no", orderNo);
        request.setBizContent(bizContent.toString());
        AlipayTradeCloseResponse response = alipayClient.execute(request);
        if(response.isSuccess()){
            log.info("调用成功，返回结果 ===> " + response.getBody());
        } else {
            log.info("调用失败，返回码 ===> " + response.getCode() + 
                     ", 返回描述 ===> " + response.getMsg());
            //throw new RuntimeException("关单接口的调用失败");
        }
    } catch (AlipayApiException e) {
        e.printStackTrace();
        throw new RuntimeException("关单接口的调用失败");
    }
}
```

> 在这边无需输入密码，回到订单列表，去取消订单

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301421711.png" alt="image-20230530142123624" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301421744.png" alt="image-20230530142151664" style="zoom:80%;" />

![image-20230530142206257](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301422332.png)

## 交易查询

```java
@ApiOperation("查询订单：测试订单状态用")
@GetMapping("/trade/query/{orderNo}")
public R queryOrder(@PathVariable String orderNo)  {
    log.info("查询订单");
    String result = aliPayService.queryOrder(orderNo);
    return R.ok(result);
}
```

```java
public interface AliPayService {
    String tradeCreate(Long productId);
    void processOrder(Map<String, String> params);
    void cancelOrder(String orderNo);
	// 查询订单
    String queryOrder(String orderNo);
}
```

```java
// 查询订单,返回订单查询结果，如果返回null则表示支付宝端尚未创建订单
@Override
public String queryOrder(String orderNo) {
    try {
        log.info("查单接口调用 ===> {}", orderNo);
        AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
        JSONObject bizContent = new JSONObject();
        bizContent.put("out_trade_no", orderNo);
        request.setBizContent(bizContent.toString());
        AlipayTradeQueryResponse response = alipayClient.execute(request);
        if(response.isSuccess()){
            log.info("调用成功，返回结果 ===> " + response.getBody());
            return response.getBody();
        } else {
            log.info("调用失败，返回码 ===> " + response.getCode() + 
                     ", 返回描述 ===> " + response.getMsg());
            //throw new RuntimeException("查单接口的调用失败");
            return null;//订单不存在
        }
    } catch (AlipayApiException e) {
        e.printStackTrace();
        throw new RuntimeException("查单接口的调用失败");
    }
}
```

## 定时查单

> 查询未支付订单

### AliPayTask

```java
@Slf4j
@EnableScheduling
@Component
public class AliPayTask {

    @Resource
    private OrderInfoService orderInfoService;

    @Resource
    private AliPayService aliPayService;

    // 从第0秒开始每隔30秒执行1次，查询创建超过5分钟，并且未支付的订单
    @Scheduled(cron = "0/30 * * * * ?")
    public void orderConfirm(){
        log.info("orderConfirm 被执行......");
        List<OrderInfo> orderInfoList = orderInfoService
                        .getNoPayOrderByDuration(1, PayType.ALIPAY.getType());
        for (OrderInfo orderInfo : orderInfoList) {
            String orderNo = orderInfo.getOrderNo();
            log.warn("超时订单 ===> {}", orderNo);
            //核实订单状态：调用支付宝查单接口
            aliPayService.checkOrderStatus(orderNo);
        }
    }
}
```

### OrderInfoService

```java
public interface OrderInfoService extends IService<OrderInfo> {
    OrderInfo createOrderByProductId(Long productId,String paymentType);
    List<OrderInfo> listOrderByCreateTimeDesc();
    String getOrderStatus(String orderNo);
    OrderInfo getOrderByOrderNo(String outTradeNo);
    void updateStatusByOrderNo(String orderNo, OrderStatus success);
	// 定时查询
    List<OrderInfo> getNoPayOrderByDuration(int minutes, String type);
}
```

```java
// 查询创建超过minutes分钟并且未支付的订单
@Override
public List<OrderInfo> getNoPayOrderByDuration(int minutes, String paymentType) {
    Instant instant = Instant.now().minus(Duration.ofMinutes(minutes));
    QueryWrapper<OrderInfo> queryWrapper = new QueryWrapper<>();
    queryWrapper.eq("order_status", OrderStatus.NOTPAY.getType());
    queryWrapper.le("create_time", instant);
    queryWrapper.eq("payment_type", paymentType);
    return baseMapper.selectList(queryWrapper);
}
```

### AliPayService

```java
public interface AliPayService {
    String tradeCreate(Long productId);
    void processOrder(Map<String, String> params);
    void cancelOrder(String orderNo);
    String queryOrder(String orderNo);
	// 查询订单状态
    void checkOrderStatus(String orderNo);
}
```

```java
/**
 * 根据订单号调用支付宝查单接口，核实订单状态
 * 如果订单未创建，则更新商户端订单状态
 * 如果订单未支付，则调用关单接口关闭订单，并更新商户端订单状态
 * 如果订单已支付，则更新商户端订单状态，并记录支付日志
 * @param orderNo
 */
@Override
public void checkOrderStatus(String orderNo) {
    log.warn("根据订单号核实订单状态 ===> {}", orderNo);
    String result = this.queryOrder(orderNo);
    //订单未创建
    if(result == null){
        log.warn("核实订单未创建 ===> {}", orderNo);
        //更新本地订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.CLOSED);
    }
    //解析查单响应结果
    Gson gson = new Gson();
    HashMap<String, LinkedTreeMap> resultMap = gson.fromJson(result, HashMap.class);
    LinkedTreeMap alipayTradeQueryResponse = resultMap
                  .get("alipay_trade_query_response");
    String tradeStatus = (String)alipayTradeQueryResponse.get("trade_status");
    if(AliPayTradeState.NOTPAY.getType().equals(tradeStatus)){
        log.warn("核实订单未支付 ===> {}", orderNo);
        //如果订单未支付，则调用关单接口关闭订单
        this.closeOrder(orderNo);
        // 并更新商户端订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.CLOSED);
    }
    if(AliPayTradeState.SUCCESS.getType().equals(tradeStatus)){
        log.warn("核实订单已支付 ===> {}", orderNo);
        //如果订单已支付，则更新商户端订单状态
        orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.SUCCESS);
        //并记录支付日志
        paymentInfoService.createPaymentInfoForAliPay(alipayTradeQueryResponse);
    }
}
```

### 测试查询

> 创建订单，不支付，去查看

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301451312.png" alt="image-20230530145119216" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301450075.png" alt="image-20230530145052981" style="zoom:80%;" />

## 申请退款

### AliPayService

```java
// 申请退款
@ApiOperation("申请退款")
@PostMapping("/trade/refund/{orderNo}/{reason}")
public R refunds(@PathVariable String orderNo, @PathVariable String reason){
    log.info("申请退款");
    aliPayService.refund(orderNo, reason);
    return R.ok();
}
```

```java
public interface AliPayService {
	// 申请退款
    void refund(String orderNo, String reason);
}
```

```java
@Resource
private RefundInfoService refundsInfoService;

// 退款
@Transactional(rollbackFor = Exception.class)
@Override
public void refund(String orderNo, String reason) {
    try {
        log.info("调用退款API");
        //创建退款单
        RefundInfo refundInfo = refundsInfoService
                                .createRefundByOrderNoForAliPay(orderNo, reason);
        //调用统一收单交易退款接口
        AlipayTradeRefundRequest request = new AlipayTradeRefundRequest ();
        //组装当前业务方法的请求参数
        JSONObject bizContent = new JSONObject();
        bizContent.put("out_trade_no", orderNo);//订单编号
        BigDecimal refund = new BigDecimal(refundInfo.getRefund().toString())
            .divide(new BigDecimal("100"));
        //BigDecimal refund = new BigDecimal("2").divide(new BigDecimal("100"));
        bizContent.put("refund_amount", refund);//退款金额：不能大于支付金额
        bizContent.put("refund_reason", reason);//退款原因(可选)
        request.setBizContent(bizContent.toString());
        //执行请求，调用支付宝接口
        AlipayTradeRefundResponse response = alipayClient.execute(request);
        if(response.isSuccess()){
            log.info("调用成功，返回结果 ===> " + response.getBody());
            //更新订单状态
            orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.REFUND_SUCCESS);
            //更新退款单
            refundsInfoService.updateRefundForAliPay(
                    refundInfo.getRefundNo(),
                    response.getBody(),
                    AliPayTradeState.REFUND_SUCCESS.getType()); //退款成功

        } else {
            log.info("调用失败，返回码 ===> " + response.getCode() + 
                     ", 返回描述 ===> " + response.getMsg());
            //更新订单状态
            orderInfoService.updateStatusByOrderNo(orderNo, OrderStatus.REFUND_ABNORMAL);
            //更新退款单
            refundsInfoService.updateRefundForAliPay(
                    refundInfo.getRefundNo(),
                    response.getBody(),
                    AliPayTradeState.REFUND_ERROR.getType()); //退款失败
        }
    } catch (AlipayApiException e) {
        e.printStackTrace();
        throw new RuntimeException("创建退款申请失败");
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301513587.png" alt="image-20230530151317500" style="zoom:80%;" />

### RefundInfoService

```java
public interface RefundInfoService extends IService<RefundInfo> {
    RefundInfo createRefundByOrderNo(String orderNo, String reason);
    void updateRefund(String content);
    List<RefundInfo> getNoRefundOrderByDuration(int minutes);
    RefundInfo createRefundByOrderNoForAliPay(String orderNo, String reason);
    void updateRefundForAliPay(String refundNo, String content, String refundStatus);
}
```

```java
@Service
public class RefundInfoServiceImpl extends ServiceImpl<RefundInfoMapper, RefundInfo> implements RefundInfoService {

    @Resource
    private OrderInfoService orderInfoService;

    // 根据订单号创建退款订单
    @Override
    public RefundInfo createRefundByOrderNo(String orderNo, String reason) {
        //根据订单号获取订单信息
        OrderInfo orderInfo = orderInfoService.getOrderByOrderNo(orderNo);
        //根据订单号生成退款订单
        RefundInfo refundInfo = new RefundInfo();
        refundInfo.setOrderNo(orderNo);//订单编号
        refundInfo.setRefundNo(OrderNoUtils.getRefundNo());//退款单编号
        refundInfo.setTotalFee(orderInfo.getTotalFee());//原订单金额(分)
        refundInfo.setRefund(orderInfo.getTotalFee());//退款金额(分)
        refundInfo.setReason(reason);//退款原因
        //保存退款订单
        baseMapper.insert(refundInfo);
        return refundInfo;
    }

    // 记录退款记录
    @Override
    public void updateRefund(String content) {

        //将json字符串转换成Map
        Gson gson = new Gson();
        Map<String, String> resultMap = gson.fromJson(content, HashMap.class);

        //根据退款单编号修改退款单
        QueryWrapper<RefundInfo> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("refund_no", resultMap.get("out_refund_no"));

        //设置要修改的字段
        RefundInfo refundInfo = new RefundInfo();

        refundInfo.setRefundId(resultMap.get("refund_id"));//微信支付退款单号

        //查询退款和申请退款中的返回参数
        if(resultMap.get("status") != null){
            refundInfo.setRefundStatus(resultMap.get("status"));//退款状态
            refundInfo.setContentReturn(content);//将全部响应结果存入数据库的content字段
        }
        //退款回调中的回调参数
        if(resultMap.get("refund_status") != null){
            refundInfo.setRefundStatus(resultMap.get("refund_status"));//退款状态
            refundInfo.setContentNotify(content);//将全部响应结果存入数据库的content字段
        }

        //更新退款单
        baseMapper.update(refundInfo, queryWrapper);
    }

    // 找出申请退款超过minutes分钟并且未成功的退款单
    @Override
    public List<RefundInfo> getNoRefundOrderByDuration(int minutes) {
        //minutes分钟之前的时间
        Instant instant = Instant.now().minus(Duration.ofMinutes(minutes));
        QueryWrapper<RefundInfo> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("refund_status", WxRefundStatus.PROCESSING.getType());
        queryWrapper.le("create_time", instant);
        List<RefundInfo> refundInfoList = baseMapper.selectList(queryWrapper);
        return refundInfoList;
    }

    // 根据订单号创建退款订单
    @Override
    public RefundInfo createRefundByOrderNoForAliPay(String orderNo, String reason) {
        //根据订单号获取订单信息
        OrderInfo orderInfo = orderInfoService.getOrderByOrderNo(orderNo);
        //根据订单号生成退款订单
        RefundInfo refundInfo = new RefundInfo();
        refundInfo.setOrderNo(orderNo);//订单编号
        refundInfo.setRefundNo(OrderNoUtils.getRefundNo());//退款单编号

        refundInfo.setTotalFee(orderInfo.getTotalFee());//原订单金额(分)
        refundInfo.setRefund(orderInfo.getTotalFee());//退款金额(分)
        refundInfo.setReason(reason);//退款原因
        //保存退款订单
        baseMapper.insert(refundInfo);
        return refundInfo;
    }

    // 更新退款记录
    @Override
    public void updateRefundForAliPay(String refundNo, String content, 
                                      String refundStatus) {
        //根据退款单编号修改退款单
        QueryWrapper<RefundInfo> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("refund_no", refundNo);
        //设置要修改的字段
        RefundInfo refundInfo = new RefundInfo();
        refundInfo.setRefundStatus(refundStatus);//退款状态
        refundInfo.setContentReturn(content);//将全部响应结果存入数据库的content字段
        //更新退款单
        baseMapper.update(refundInfo, queryWrapper);
    }
}
```

## 退款查询

```java
@ApiOperation("查询退款：测试用")
@GetMapping("/trade/fastpay/refund/{orderNo}")
public R queryRefund(@PathVariable String orderNo) throws Exception {
    log.info("查询退款");
    String result = aliPayService.queryRefund(orderNo);
    return R.ok(result);
}
```

```java
public interface AliPayService {
    String tradeCreate(Long productId);
    void processOrder(Map<String, String> params);
    void cancelOrder(String orderNo);
    String queryOrder(String orderNo);
    void checkOrderStatus(String orderNo);
    void refund(String orderNo, String reason);
	// 退款查询
    String queryRefund(String orderNo);
}
```

```java
// 查询退款
@Override
public String queryRefund(String orderNo) {
    try {
        log.info("查询退款接口调用 ===> {}", orderNo);
        AlipayTradeFastpayRefundQueryRequest request = new 
            AlipayTradeFastpayRefundQueryRequest();
        JSONObject bizContent = new JSONObject();
        bizContent.put("out_trade_no", orderNo);
        bizContent.put("out_request_no", orderNo);
        request.setBizContent(bizContent.toString());

        AlipayTradeFastpayRefundQueryResponse response = alipayClient.execute(request);
        if(response.isSuccess()){
            log.info("调用成功，返回结果 ===> " + response.getBody());
            return response.getBody();
        } else {
            log.info("调用失败，返回码 ===> " + response.getCode() +
                    ", 返回描述 ===> " + response.getMsg());
            //throw new RuntimeException("查单接口的调用失败");
            return null;//订单不存在
        }
    } catch (AlipayApiException e) {
        e.printStackTrace();
        throw new RuntimeException("查单接口的调用失败");
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301519296.png" alt="image-20230530151918183" style="zoom:80%;" />

## 下载对账

```java
// 根据账单类型和日期获取账单url地址
@ApiOperation("获取账单url")
@GetMapping("/bill/downloadurl/query/{billDate}/{type}")
public R queryTradeBill(
        @PathVariable String billDate,
        @PathVariable String type)  {
    log.info("获取账单url");
    String downloadUrl = aliPayService.queryBill(billDate, type);
    return R.ok(downloadUrl);
}
```

```java
public interface AliPayService {
    String tradeCreate(Long productId);
    void processOrder(Map<String, String> params);
    void cancelOrder(String orderNo);
    String queryOrder(String orderNo);
    void checkOrderStatus(String orderNo);
    void refund(String orderNo, String reason);
    String queryRefund(String orderNo);
    // 获取账单URL
    String queryBill(String billDate, String type);
}
```

```java
// 申请账单
@Override
public String queryBill(String billDate, String type) {
    try {
        AlipayDataDataserviceBillDownloadurlQueryRequest request = new 
        AlipayDataDataserviceBillDownloadurlQueryRequest();
        JSONObject bizContent = new JSONObject();
        bizContent.put("bill_type", type);
        bizContent.put("bill_date", billDate);
        request.setBizContent(bizContent.toString());
        AlipayDataDataserviceBillDownloadurlQueryResponse response = 
            alipayClient.execute(request);
        if(response.isSuccess()){
            log.info("调用成功，返回结果 ===> " + response.getBody());
            //获取账单下载地址
            Gson gson = new Gson();
            HashMap<String, LinkedTreeMap> resultMap = gson.fromJson(response.getBody(), 
                                                                     HashMap.class);
            LinkedTreeMap billDownloadurlResponse = resultMap
                .get("alipay_data_dataservice_bill_downloadurl_query_response");
            String billDownloadUrl = (String)billDownloadurlResponse
                                     .get("bill_download_url");
            return billDownloadUrl;
        } else {
            log.info("调用失败，返回码 ===> " + response.getCode() +
                     ", 返回描述 ===> " + response.getMsg());
            throw new RuntimeException("申请账单失败");
        }
    } catch (AlipayApiException e) {
        e.printStackTrace();
        throw new RuntimeException("申请账单失败");
    }
}
```

> 注意：不能选择当天日期，只能选择至少前一天日期，不然会报错

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301530407.png" alt="image-20230530153031321" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202305301530858.png" alt="image-20230530153056777" style="zoom:80%;" />