# 购物车

## 课程内容

> - 缓存菜品
> - 缓存套餐
> - 添加购物车
> - 查看购物车
> - 清空购物车

> 功能实现：**缓存商品**、**购物车**
>

**效果图：**




## 缓存菜品

### 问题说明

> 小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力增大
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221208180228667.png" alt="image-20221208180228667" style="zoom:80%;" /> 

> **结果：**系统响应慢、用户体验差

### 实现思路

> 通过Redis来缓存菜品数据，减少数据库查询操作。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221208180818572.png" alt="image-20221208180818572" style="zoom:80%;" /> 

**缓存逻辑分析：**

> - 每个分类下的菜品保存一份缓存数据
> - 数据库中菜品数据有变更时清理缓存数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221208181007639.png" alt="image-20221208181007639" style="zoom:67%;" /> 

### 查询缓存⭐

> **修改用户端接口 DishController 的 list 方法，加入缓存处理逻辑：**

```java
@RestController("userDishController")
@RequestMapping("/user/dish")
@Slf4j
@Api(tags = "C端-菜品浏览接口")
public class DishController {

    @Resource
    private DishService dishService;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    // 根据分类id查询菜品
    // 根据分类id查询菜品
    @GetMapping("/list")
    @ApiOperation("根据分类id查询菜品")
    public Result list(Long categoryId) {

        //构造redis中的key，规则：dish_分类id
        String key = "sky:dish:" + categoryId;

        //查询redis中是否存在菜品数据
        String dishR = stringRedisTemplate.opsForList().leftPop(key);
        if(dishR != null){
            //如果存在，直接返回，无须查询数据库
            return Result.success(dishR);
        }
        // Redis不存在，查询数据库
        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品，值为1
        // 如果不存在，查询数据库，将查询到的数据放入redis中
        List<DishVO> list = dishService.listWithFlavor(dish);
        // 因为使用的是列表，所以用列表返回
        stringRedisTemplate.opsForList().leftPushAll(key, String.valueOf(list));
        return Result.success(list);
    }
}
```

### 清理缓存⭐

> 为了保证**数据库**和**Redis**中的数据保持一致，修改**管理端接口 DishController** 的相关方法清理缓存
>

需要改造的方法：

> - **新增**菜品
> - **修改**菜品
> - **批量删除**菜品
> - 起售、停售菜品

```java
// 菜品管理
@RestController
@RequestMapping("/admin/dish")
@Api(tags = "菜品相关接口")
@Slf4j
public class DishController {

    @Resource
    private DishService dishService;

    @Resource
    private RedisTemplate<String,String> redisTemplate;

    // 新增菜品
    @PostMapping
    @ApiOperation("新增菜品")
    public Result save(@RequestBody DishDTO dishDTO) {
        log.info("新增菜品：{}", dishDTO);
        dishService.saveWithFlavor(dishDTO);//后绪步骤开发
        redisTemplate.delete("sky:dish:"+dishDTO.getId());
        return Result.success();
    }

    @GetMapping("/page")
    @ApiOperation("菜品分页查询")
    public Result page(DishPageQueryDTO dishPageQueryDTO) {
        log.info("菜品分页查询:{}", dishPageQueryDTO);
        Page pageResult = dishService.pageQuery(dishPageQueryDTO);//后绪步骤定义
        return Result.success(pageResult);
    }

    @DeleteMapping
    @ApiOperation("菜品批量删除")
    public Result delete(@RequestParam List<Long> ids) {
        log.info("菜品批量删除：{}", ids);
        dishService.deleteBatch(ids);//后绪步骤实现
        for (int i = 0; i < ids.size(); i++) {
            redisTemplate.delete("sky:dish:"+ ids.get(i));
        }
        return Result.success();
    }

    // 根据id查询菜品
    @GetMapping("/{id}")
    @ApiOperation("根据id查询菜品")
    public Result<DishVO> getById(@PathVariable Long id) {
        log.info("根据id查询菜品：{}", id);
        DishVO dishVO = dishService.getByIdWithFlavor(id);//后绪步骤实现
        return Result.success(dishVO);
    }

    // 修改菜品
    @PutMapping
    @ApiOperation("修改菜品")
    public Result update(@RequestBody DishDTO dishDTO) {
        log.info("修改菜品：{}", dishDTO);
        dishService.updateWithFlavor(dishDTO);
        redisTemplate.delete("sky:dish:"+dishDTO.getId());
        return Result.success();
    }
}
```

### 功能测试

可以通过如下方式进行测试：

> - 查看控制台sql
> - 前后端联调
> - 查看Redis中的缓存数据

> 以**加入缓存**、**菜品修改**两个功能测试为例，通过前后端联调方式，查看控制台sql的打印和Redis中的缓存数据变化。
>

#### 加入缓存

> 当第一次查询某个分类的菜品时，会从数据为中进行查询，同时将查询的结果存储到Redis中，在后绪的访问，若查询相同分类的菜品时，直接从Redis缓存中查询，不再查询数据库。
>

> **登录小程序：**选择蜀味牛蛙(id=17)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210174656770.png" alt="image-20221210174656770" style="zoom:50%;" /> 

> **查看控制台sql：**有查询语句，说明是从数据库中进行查询

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210174839028.png" alt="image-20221210174839028" style="zoom:50%;" /> 

> **查看Redis中的缓存数据：**说明缓存成功

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210175055282.png" alt="image-20221210175055282" style="zoom:50%;" /> 

> **再次访问：**选择蜀味牛蛙(id=17)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210175438411.png" alt="image-20221210175438411" style="zoom:50%;" /> 

> 说明是从Redis中查询的数据。
>

#### 菜品修改

> 当在后台修改菜品数据时，为了保证Redis缓存中的数据和数据库中的数据时刻保持一致，当修改后，需要清空对应的缓存数据。用户再次访问时，还是先从数据库中查询，同时再把查询的结果存储到Redis中，这样，就能保证缓存和数据库的数据保持一致。
>

> **进入后台：**修改蜀味牛蛙分类下的任意一个菜品，当前分类的菜品数据已在Redis中缓存

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210180624453.png" alt="image-20221210180624453" style="zoom:50%;" /> 

> **修改：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210180900924.png" alt="image-20221210180900924" style="zoom:50%;" /> 

> **查看Redis中的缓存数据：**说明修改时，已清空缓存

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210181142408.png" alt="image-20221210181142408" style="zoom:50%;" /> 

> 用户再次访问同一个菜品分类时，需要先查询数据库，再把结果同步到Redis中，保证了两者数据一致性。其它功能测试步骤基本一致，自已测试即可。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230711095110283.png" alt="image-20230711095110283" style="zoom:80%;" />

##  SpringCache

### 基础介绍

> **Spring Cache**是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能，大大简化我们在业务中操作缓存的代码。

> Spring Cache只是提供了一层抽象，底层可以切换不同的cache实现。具体就是通过**CacheManager**接口来统一不同的缓存技术。CacheManager是Spring提供的各种缓存技术抽象接口。

> 针对不同的缓存技术需要实现不同的CacheManager：

| **CacheManager**    | **描述**                           |
| ------------------- | ---------------------------------- |
| EhCacheCacheManager | 使用EhCache作为缓存技术            |
| GuavaCacheManager   | 使用Google的GuavaCache作为缓存技术 |
| RedisCacheManager   | 使用Redis作为缓存技术              |

### 注解分析

> 在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：

| **注解**       | **说明**                                                     |
| -------------- | ------------------------------------------------------------ |
| @EnableCaching | 开启缓存注解功能                                             |
| @Cacheable     | 在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 |
| @CachePut      | 将方法的返回值放到缓存中                                     |
| @CacheEvict    | 将一条或多条数据从缓存中删除                                 |

> 在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。

### 基础入门

> 项目地址：https://gitee.com/sure-s-renshuo/cache_demo.git

> 接下来，我们将通过一个入门案例来演示一下SpringCache的常见用法。 上面我们提到，SpringCache可以集成不同的缓存技术，如Redis、Ehcache甚至我们可以使用Map来缓存数据， 接下来我们在演示的时候，就先通过一个Map来缓存数据，最后我们再换成Redis来缓存。

#### 环境准备

**数据库准备**

将今天资料中的SQL脚本直接导入数据库中。

```sql
CREATE TABLE `user` (
  `id` bigint NOT NULL COMMENT '主键',
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL COMMENT '姓名',
  `phone` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '手机号',
  `sex` varchar(2) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL COMMENT '性别',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COLLATE=utf8_bin COMMENT='用户信息'
```

**导入基础工程**

> 基础环境的代码，工程结构如下： 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109303.png" alt="image-20210822225934512" style="zoom:80%;" /> 

> 由于SpringCache的基本功能是Spring核心(spring-context)中提供的，所以目前我们进行简单的SpringCache测试，是可以不用额外引入其他依赖的。

**注入CacheManager**

> 在UserController注入一个CacheManager，在Debug时，我们可以通过CacheManager跟踪缓存中的数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109317.png" alt="image-20210822231333527" style="zoom:80%;" /> 

> 我们可以看到CacheManager是一个接口，默认的实现有以下几种 ；

![image-20210822231217450](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109328.png) 

> 而在上述的这几个实现中，默认使用的是 ConcurrentMapCacheManager。稍后我们可以通过断点的形式跟踪缓存数据的变化。

> **引导类上加@EnableCaching**

> 在引导类上加该注解，就代表当前项目开启缓存注解功能。

![image-20210822231616569](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109400.png) 

#### @CachePut注解

> 当前UserController的save方法是用来保存用户信息的，我们希望在该用户信息保存到数据库的同时，也往缓存中缓存一份数据，我们可以在save方法上加上注解 @CachePut，用法如下： 

```java
// CachePut：将方法返回值放入缓存
// value：缓存的名称，每个缓存名称下面可以有多个key，相当于个目录
// key：缓存的key，支持Spring的表达式语言SPEL语法
@CachePut(value = "userCache", key = "#user.id")
@PostMapping
public User save(User user){
    userService.save(user);
    return user;
}
```

key的写法如下： 

> user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ;
>
> user.name: #user指的是方法形参的名称, name指的是user的name属性 ,即使用user的name属性作为key ;
>
> result.id : #result代表方法返回值，该表达式 代表以返回对象的id属性作为key ；
>
> result.name : #result代表方法返回值，该表达式 代表以返回对象的name属性作为key ；

> 启动服务,通过postman请求访问UserController的方法, 然后通过断点的形式跟踪缓存数据。

![image-20210822233438182](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109733.png)

> 第一次访问时，缓存中的数据是空的，因为save方法执行完毕后才会缓存数据。 

![image-20210822233724439](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109745.png) 

> 第二次访问时，我们通过debug可以看到已经有一条数据了，就是上次保存的数据，已经缓存了，缓存的key就是用户的id。

![image-20210822234105085](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109758.png) 

> 注意: 上述的演示，最终的数据，实际上是缓存在ConcurrentHashMap中，那么当我们的服务器重启之后，缓存中的数据就会丢失。 我们后面使用了Redis来缓存就不存在这样的问题了。

#### @CacheEvict注解

> **在 delete 方法上加注解@CacheEvict**,当我们在删除数据库user表的数据的时候,我们需要删除缓存中对应的数据,此时就可以使用@CacheEvict注解, 具体的使用方式如下: 

```java
/**
* CacheEvict：清理指定缓存
* value：缓存的名称，每个缓存名称下面可以有多个key
* key：缓存的key,支持Spring的表达式语言SPEL语法
*/
@CacheEvict(value = "userCache",key = "#p0")  //#p0 代表第一个参数
//@CacheEvict(value = "userCache",key = "#root.args[0]") //#root.args[0] 代表第一个参数
//@CacheEvict(value = "userCache",key = "#id") //#id 代表变量名为id的参数
//@CacheEvict(value = "userCache",allEntries = true) //删除所有数据
@DeleteMapping("/{id}")
public void delete(@PathVariable Long id){
    userService.removeById(id);
}
```

> 要测试缓存的删除，我们先访问save方法4次，保存4条数据到数据库的同时，也保存到缓存中，最终我们可以通过debug看到缓存中的数据信息。 然后我们在通过postman访问delete方法， 如下： 

![image-20210823000431356](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109773.png) 

> 删除数据时，通过debug我们可以看到已经缓存的4条数据：

![image-20210823000458089](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109785.png) 

> 当执行完delete操作之后，我们再次保存一条数据，保存时debug查看一下删除的ID值是否已经被删除

![image-20210823000733218](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109100.png) 

> **在 update 方法上加注解@CacheEvict**在更新数据之后，数据库的数据已经发生了变更，我们需要将缓存中对应的数据删除掉，避免出现数据库数据与缓存数据不一致的情况。

``` java
//@CacheEvict(value = "userCache",key = "#p0.id")   //第一个参数的id属性
//@CacheEvict(value = "userCache",key = "#user.id") //参数名为user参数的id属性
//@CacheEvict(value = "userCache",key = "#root.args[0].id") //第一个参数的id属性
@CacheEvict(value = "userCache",key = "#result.id")         //返回值的id属性
@PutMapping
public User update(User user){
    userService.updateById(user);
    return user;
}
```

> 加上注解之后，我们可以重启服务，然后测试方式，基本和上述相同，先缓存数据，然后再更新某一条数据，通过debug的形式查询缓存数据的情况。

#### @Cacheable注解

> **在getById上加注解@Cacheable**

```java
/**
* Cacheable：在方法执行前spring先查看缓存中是否有数据，
            如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中
* value：缓存的名称，每个缓存名称下面可以有多个key
* key：缓存的key
*/
@Cacheable(value = "userCache",key = "#id")
@GetMapping("/{id}")
public User getById(@PathVariable Long id){
    User user = userService.getById(id);
    return user;
}
```

> 我们可以重启服务，然后通过debug断点跟踪程序执行。我们发现，第一次访问，会请求我们controller的方法，查询数据库。后面再查询相同的id，就直接获取到数据库，不用再查询数据库了

![image-20210823002517941](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109111.png) 

> 当我们在测试时，查询一个数据库不存在的id值，第一次查询缓存中没有，也会查询数据库。而第二次再查询时，会发现，不再查询数据库了，而是直接返回，那也就是说如果根据ID没有查询到数据,那么会自动缓存一个null值。 我们可以通过debug，验证一下： 

![image-20210823002907048](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109129.png) 

我们能不能做到，当查询到的值不为null时，再进行缓存，如果为null，则不缓存呢? 答案是可以的。

> **缓存非null值**

> 在@Cacheable注解中，提供了两个属性分别为： condition， unless 。

> condition : 表示满足什么条件, 再进行缓存 ;
>
> unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ;

具体实现方式如下: 

```java
/**
 * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；
   若没有数据，调用方法并将方法返回值放到缓存中
 * value：缓存的名称，每个缓存名称下面可以有多个key
 * key：缓存的key
 * condition：条件，满足条件时才缓存数据
 * unless：满足条件则不缓存
 */
@Cacheable(value = "userCache",key = "#id", unless = "#result == null")
@GetMapping("/{id}")
public User getById(@PathVariable Long id){
    User user = userService.getById(id);
    return user;
}
```

> 注意： 此处，我们使用的时候只能够使用 unless， 因为在condition中，我们是无法获取到结果 #result

> **在list方法上加注解@Cacheable**

> 在list方法中进行查询时，有两个查询条件，如果传递了id，根据id查询； 如果传递了name， 根据name查询，那么我们缓存的key在设计的时候，就需要既包含id，又包含name。 

```java
@Cacheable(value = "userCache",key = "#user.id + '_' + #user.name")
@GetMapping("/list")
public List<User> list(User user){
    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(user.getId() != null,User::getId,user.getId());
    queryWrapper.eq(user.getName() != null,User::getName,user.getName());
    List<User> list = userService.list(queryWrapper);
    return list;
}
```

> 然后再次重启服务，进行测试。

![image-20210823005220230](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210292109140.png) 

> 第一次查询时，需要查询数据库，在后续的查询中，就直接查询了缓存，不再查询数据库了。

### 集成Redis

> 在使用上述默认的ConcurrentHashMap做缓存时，服务重启之后，之前缓存的数据就全部丢失了，操作起来并不友好。在项目中使用，我们会选择使用redis来做缓存，主要需要操作以下几步： 

#### 依赖和配置

> 1). pom.xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

> 2). application.yml

```yml
spring:
  redis:
    host: 192.168.200.200
    port: 6379
    password: 315210
    database: 0
  cache:
    redis:
      time-to-live: 1800000   #设置缓存过期时间，可选
```

#### 序列化

```java
@Bean
public GenericJackson2JsonRedisSerializer springSessionDefaultRedisSerializer() {
    return new GenericJackson2JsonRedisSerializer();
}
```

```java
@Bean
public CacheManager cacheManager(RedisConnectionFactory factory) {
    // 解决查询缓存转换异常的问题
    ObjectMapper om = new ObjectMapper();
    //POJO无public的属性或方法时，不报错
    om.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
    // null值字段不显示
    om.setSerializationInclusion(JsonInclude.Include.NON_NULL);
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    // 序列化JSON串时，在值上打印出对象类型
    // om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    // 替换上方 过期的enableDefaultTyping
    om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,
            ObjectMapper.DefaultTyping
                    .NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);
    new Jackson2JsonRedisSerializer<>(Object.class).setObjectMapper(om);
    // 解决jackson2无法反序列化LocalDateTime的问题
    om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    om.registerModule(new GeoModule());

    // 配置序列化（解决乱码的问题）
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            // 默认 30天过期
            .entryTtl(Duration.ofDays(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new
                            GenericJackson2JsonRedisSerializer()))
            .disableCachingNullValues();

    return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
}
```

#### 测试

> 重新启动项目，通过postman发送根据id查询数据的请求，然后通过redis的图形化界面工具，查看redis中是否可以正常的缓存数据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210301824365.png" alt="image-20221030182435264" style="zoom:80%;" />



## 缓存套餐

### 实现思路

> 1). 导入Spring Cache和Redis相关maven坐标
>
> 2). 在启动类上加入@EnableCaching注解，开启缓存注解功能
>
> 3). 在用户端接口SetmealController的 list 方法上加入@Cacheable注解
>
> 4). 在管理端接口SetmealController的 save、delete、update、startOrStop等方法上加入CacheEvict注解

### Maven坐标

> **Spring Cache和Redis相关maven坐标(已实现)**

```xml
<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 开启缓存

> **在启动类上加入@EnableCaching注解，开启缓存注解功能**

```java
@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@Slf4j
@EnableCaching // 开启缓存
public class SkyApplication {
    public static void main(String[] args) {
        SpringApplication.run(SkyApplication.class, args);
        log.info("server started");
    }
}
```

> **在用户端接口SetmealController的 list 方法上加入@Cacheable注解**

```java
// 条件查询
@GetMapping("/list")
@ApiOperation("根据分类id查询套餐")
@Cacheable(cacheNames = "sky:setmeal",key = "#categoryId")
public Result<List<Setmeal>> list(Long categoryId) {
    Setmeal setmeal = new Setmeal();
    setmeal.setCategoryId(categoryId);
    setmeal.setStatus(StatusConstant.ENABLE);
    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.like(StringUtils.hasText(setmeal.getName()),
                      Setmeal::getName,setmeal.getName());
    if (setmeal.getCategoryId() != null) {
        queryWrapper.eq(Setmeal::getCategoryId,setmeal.getCategoryId());
    }
    if (setmeal.getStatus() != null) {
        queryWrapper.eq(Setmeal::getStatus,setmeal.getStatus());
    }
    List<Setmeal> list = setmealService.list(queryWrapper);
    return Result.success(list);
}
```

> **在管理端接口SetmealController的 save、delete、update、startOrStop等方法上加入CacheEvict注解**

```java
@RestController
@RequestMapping("/admin/category")
@Api(tags = "分类相关接口")
@Slf4j
public class CategoryController {

    @Resource
    private CategoryService categoryService;

    // 新增分类
    @PostMapping
    @ApiOperation("新增分类")
    @CacheEvict(cacheNames = "sky:setmeal",key = "#setmealDTO.categoryId")
    public Result<String> save(@RequestBody CategoryDTO categoryDTO){
        log.info("新增分类：{}", categoryDTO);
        Category category = new Category();
        // 属性值拷贝,其他属性是自动填充的
        BeanUtils.copyProperties(categoryDTO,category);
        categoryService.save(category);
        return Result.success();
    }
	// 分页查询等查询操作无需操作缓存，因此可以省略
    // 删除分类
    @CacheEvict(cacheNames = "sky:setmeal",allEntries = true)
    @DeleteMapping
    @ApiOperation("删除分类")
    public Result<String> deleteById(Long id){
        log.info("删除分类：{}", id);
        categoryService.deleteById(id);
        return Result.success();
    }

    // 修改分类
    // 根据id修改分类信息
    @PutMapping
    @CacheEvict(cacheNames = "sky:setmeal",allEntries = true)
    public Result update(@RequestBody Category category){
        log.info("修改分类信息：{}",category);
        categoryService.updateById(category);
        return Result.success("修改分类信息成功");
    }

    // 启用、禁用分类
    @PostMapping("/status/{status}")
    @ApiOperation("启用禁用分类")
    @CacheEvict(cacheNames = "sky:setmeal",allEntries = true)
    public Result<String> startOrStop(@PathVariable("status") Integer status, Long id){
        Category category = Category.builder()
                .status(status)
                .id(id)
                .build();
        categoryService.updateById(category);
        return Result.success();
    }
}
```

### 功能测试

> 通过前后端联调方式来进行测试，同时观察redis中缓存的套餐数据。和**缓存菜品**功能测试基本一致
>

## 需求设计

### 产品原型

> 用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20210813181916235.png" alt="image-20210813181916235" style="zoom: 67%;" />将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量，也可以清空购物车。
>

> **效果图：**

 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210203822817.png" alt="image-20221210203822817" style="zoom:50%;" /> 

### 接口设计

> 通过上述原型图，设计出对应的添加购物车接口。
>


> **说明：**添加购物车时，有可能添加菜品，也有可能添加套餐。故传入参数要么是菜品id，要么是套餐id

### 表设计

> 用户的购物车数据，也是需要保存在数据库中的，购物车对应的数据表为shopping_cart表，表结构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230711104623840.png" alt="image-20230711104623840" style="zoom:80%;" />

> - 购物车数据是关联用户的，在表结构中，我们需要记录，每一个用户的购物车数据是哪些
> - 菜品列表展示出来的既有套餐，又有菜品，如果用户选择的是套餐，就保存套餐ID(setmeal_id)，如果用户选择的是菜品，就保存菜品ID(dish_id)
> - 对同一个菜品/套餐，如果选择多份不需要添加多条记录，增加数量number即可

## 准备工作

> 分析完毕购物车的业务需求和实现思路之后，在开发业务功能前，先将需要用到的类和接口结构

### ShoppingCart

```java
// 购物车
@Data
public class ShoppingCart implements Serializable {
    private static final long serialVersionUID = 1L;
	
    private Long id;

    //名称
    private String name;

    //用户id
    private Long userId;

    //菜品id
    private Long dishId;

    //套餐id
    private Long setmealId;

    //口味
    private String dishFlavor;

    //数量
    private Integer number;

    //金额
    private BigDecimal amount;

    //图片
    private String image;
    // 这里不用自动填充，因为只有一个字段
    private LocalDateTime createTime;
}
```

### ShoppingCartDTO

> 在sky-pojo模块，ShoppingCartDTO.java已定义

```java
@Data
public class ShoppingCartDTO implements Serializable {
    private Long dishId;
    private Long setmealId;
    private String dishFlavor;
}
```

### ShoppingCartMapper

```java
@Mapper
public interface ShoppingCartMapper extends BaseMapper<ShoppingCart> {
}
```

### ShoppingCartService

```java
public interface ShoppingCartService extends IService<ShoppingCart> {
}
```

### ShoppingCartServiceImpl

```java
@Service
public class ShoppingCartServiceImpl extends ServiceImpl<ShoppingCartMapper, 
ShoppingCart> implements ShoppingCartService {
}
```

### ShoppingCartController

```java
// 购物车
@Slf4j
@RestController
@RequestMapping("/shoppingCart")
public class ShoppingCartController {
    @Resource
    private ShoppingCartService shoppingCartService;
 
 }   
```

## 代码开发

### 添加购物车⭐

在ShoppingCartController中创建add方法，来完成添加购物车的逻辑实现，具体的逻辑如下： 

> A. 获取当前登录用户，为购物车对象赋值
>
> B. 根据当前登录用户ID 及 本次添加的菜品ID/套餐ID，查询购物车数据是否存在
>
> C. 如果已经存在，就在原来数量基础上加1
>
> D. 如果不存在，则添加到购物车，数量默认就是1

```java
// 添加购物车
@PostMapping("/add1")
public Result add1(@RequestBody ShoppingCartDTO shoppingCartDTO){
    log.info("购物车数据:{}",shoppingCartDTO);
    ShoppingCart shoppingCart = new ShoppingCart();
    BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
    //只能查询自己的购物车数据，正常是通过ThreadLocal取的，这里简化
    shoppingCart.setUserId(4L);
    //判断当前商品是否在购物车中（构造查询条件）
    LambdaQueryWrapper<ShoppingCart> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(shoppingCart.getUserId() != null,ShoppingCart::getUserId,
               shoppingCart.getUserId());
    wrapper.eq(shoppingCart.getDishId() != null,ShoppingCart::getDishId,
               shoppingCart.getDishId());
    wrapper.eq(shoppingCart.getSetmealId() != null,
               ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
    wrapper.eq(shoppingCart.getDishFlavor() != null,
               ShoppingCart::getDishFlavor,shoppingCart.getDishFlavor());
    wrapper.orderByDesc(ShoppingCart::getCreateTime);
    //只可能查出来一条数据，但不影响用List接收
    List<ShoppingCart> shoppingCartList = shoppingCartService.list(wrapper);
    // 判断商品是否存在
    if (shoppingCartList != null && shoppingCartList.size() == 1) {
        //如果已经存在，就更新数量，数量加1，因为只有一条数据，所以get(0),获取这条数据
        shoppingCart = shoppingCartList.get(0);
        shoppingCart.setNumber(shoppingCart.getNumber() + 1);
        shoppingCartService.updateById(shoppingCart);
        return Result.success("新增商品数量成功");
    } else {
        //如果不存在，插入数据，数量就是1
        //判断当前添加到购物车的是菜品还是套餐
        Long dishId = shoppingCartDTO.getDishId();
        if (dishId != null) {
            //添加到购物车的是菜品
            Dish dish = dishService.getById(dishId);
            //分别设置菜品的名称，图片和价格
            shoppingCart.setName(dish.getName());
            shoppingCart.setImage(dish.getImage());
            shoppingCart.setAmount(dish.getPrice());
        } else {
            //添加到购物车的是套餐
            Setmeal setmeal = setmealService.getById(shoppingCartDTO.getSetmealId());
            shoppingCart.setName(setmeal.getName());
            shoppingCart.setImage(setmeal.getImage());
            shoppingCart.setAmount(setmeal.getPrice());
        }
        // 刚添加到购物车，商品数量为1
        shoppingCart.setNumber(1);
        shoppingCart.setCreateTime(LocalDateTime.now());
        shoppingCartService.save(shoppingCart);
        return Result.success("加入购物车成功");
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230711112226962.png" alt="image-20230711112226962" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230711112320376.png" alt="image-20230711112320376" style="zoom:80%;" />

### 查询购物车

> 在ShoppingCartController中创建list方法，根据当前登录用户ID查询购物车列表，并对查询的结果进行创建时间的倒序排序。

```java
// 查看购物车
@GetMapping("/list")
public Result<List<ShoppingCart>> list(){
    log.info("查看购物车...");
    LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,4);
    queryWrapper.orderByAsc(ShoppingCart::getCreateTime);
    List<ShoppingCart> list = shoppingCartService.list(queryWrapper);
    return Result.success(list);
}
```

### 清空购物车

> 在ShoppingCartController中创建clean方法，在方法中获取当前登录用户，根据登录用户ID，删除购物车数据。代码实现如下： 

```java
// 清空购物车
@DeleteMapping("/clean")
public Result<String> clean(){
    //SQL:delete from shopping_cart where user_id = ?
    LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,4);
    shoppingCartService.remove(queryWrapper);
    return Result.success("清空购物车成功");
}
```



## 功能测试

进入小程序，添加菜品

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210210338094.png" alt="image-20221210210338094" style="zoom:50%;" /> 
加入购物车，查询数据库

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210210643308.png" alt="image-20221210210643308" style="zoom:80%;" /> 

因为现在没有实现查看购物车功能，所以只能在表中进行查看。

在前后联调时，后台可通断点方式启动，查看运行的每一步。

## 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221210215130746.png" alt="image-20221210215130746" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。

#  地址 & 支付 & 下单

## 课程内容

> - 导入地址簿功能代码
> - 用户下单
> - 订单支付

> 功能实现：**用户下单**、**订单支付**
>

### 用户下单效果图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214181127718.png" alt="image-20221214181127718" style="zoom:50%;" />        

### 订单支付效果图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214181221426.png" alt="image-20221214181221426" style="zoom:50%;" />   

## 地址管理

### 需求分析

> 地址簿，指的是移动端消费者用户的地址信息，用户登录成功后可以维护自己的地址信息。**同一个用户可以有多个地址信息**，但是只能有一个**默认地址**。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026093.png" alt="image-20210812191332892" style="zoom: 67%;" />  

> **功能： 新增地址、地址列表查询、设置默认地址、编辑地址、删除地址**

### 数据模型

> 用户的地址信息会存储在address_book表，即地址簿表中。具体表结构如下：

![image-20210812192228678](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026097.png) 

> 这里面有一个字段is_default，实际上我们在设置默认地址时，只需要更新这个字段就可以了。

### 代码实现

> 对于这一类的单表的增删改查，我们已经写过很多了，基本的开发思路都是一样的，那么本小节的用户地址簿管理的增删改查功能，

> **实体类 AddressBook**

```java
// 地址簿
@Data
public class AddressBook implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
	
    //用户id
    private Long userId;
	
    //收货人
    private String consignee;
	
    //手机号
    private String phone;
	
    //性别 0 女 1 男
    private String sex;
	
    //省级区划编号
    private String provinceCode;
	
    //省级名称
    private String provinceName;
	
    //市级区划编号
    private String cityCode;
	
    //市级名称
    private String cityName;
	
    //区级区划编号
    private String districtCode;
	
    //区级名称
    private String districtName;
	
    //详细地址
    private String detail;
	
    //标签
    private String label;
    
    //是否默认 0 否 1是
    private Integer isDefault;
    
    //创建时间
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    //更新时间
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    //创建人
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;

    //修改人
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;

    //是否删除
    private Integer isDeleted;
}
```

> **Mapper接口 AddressBookMapper**

```java
@Mapper
public interface AddressBookMapper extends BaseMapper<AddressBook> {
}
```

> **业务层接口 AddressBookService**

```java
public interface AddressBookService extends IService<AddressBook> {
}
```

> **业务层实现类 AddressBookServiceImpl**

```java
@Service
public class AddressBookServiceImpl extends ServiceImpl<AddressBookMapper, AddressBook> 
                                    implements AddressBookService {
}
```

> **控制层 AddressBookController**

```java
// 地址簿管理
@Slf4j
@RestController
@RequestMapping("/addressBook")
public class AddressBookController {

    @Resource
    private AddressBookService addressBookService;

    // 新增地址逻辑说明：需要记录当前是哪个用户的地址(关联当前登录用户)
    @PostMapping
    public Result<AddressBook> save(@RequestBody AddressBook addressBook) {
        // LoginUserThreadLocal.getUser().getId()
        addressBook.setUserId(4L);
        log.info("addressBook:{}", addressBook);
        addressBookService.save(addressBook);
        return Result.success(addressBook);
    }

    // 设置默认地址
    // 每个用户可以有很多地址，但是默认地址只能有一个
    // 先将该用户所有地址的is_default更新为0 , 然后将当前的设置的默认地址的is_default设置为1
    @PutMapping("default")
    public Result<AddressBook> setDefault(@RequestBody AddressBook addressBook) {
        log.info("addressBook:{}", addressBook);
        LambdaUpdateWrapper<AddressBook> wrapper = new LambdaUpdateWrapper<>();
        wrapper.eq(AddressBook::getUserId, 4L);
        wrapper.set(AddressBook::getIsDefault, 0);
        //SQL:update address_book set is_default = 0 where user_id = ?
        addressBookService.update(wrapper);
        // 再设置该地址为1
        addressBook.setIsDefault(1);
        //SQL:update address_book set is_default = 1 where id = ?
        addressBookService.updateById(addressBook);
        return Result.success(addressBook);
    }

    // 根据id查询地址
    @GetMapping("/{id}")
    public Result get(@PathVariable Long id) {
        AddressBook addressBook = addressBookService.getById(id);
        if (addressBook != null) {
            return Result.success(addressBook);
        } else {
            return Result.error("没有找到该对象");
        }
    }

    // 查询默认地址
    // 根据当前登录用户ID 以及 is_default进行查询，查询当前登录用户is_default为1的地址信息
    @GetMapping("default")
    public Result<AddressBook> getDefault() {
        LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(AddressBook::getUserId, 4L);
        queryWrapper.eq(AddressBook::getIsDefault, 1);
        //SQL:select * from address_book where user_id = ? and is_default = 1
        AddressBook addressBook = addressBookService.getOne(queryWrapper);
        if (null == addressBook) {
            return Result.error("没有找到地址");
        } else {
            return Result.success(addressBook);
        }
    }

    // 查询指定用户的全部地址
    // 根据当前登录用户ID，查询所有的地址列表
    @GetMapping("/list")
    public Result<List<AddressBook>> list(AddressBook addressBook) {
        addressBook.setUserId(4L);
        log.info("addressBook:{}", addressBook);

        //条件构造器
        LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId,
                addressBook.getUserId());

        //SQL:select * from address_book where user_id = ? order by update_time desc
        return Result.success(addressBookService.list(queryWrapper));
    }
}
```

### 功能测试

> 代码导入进来，并且去阅读了一下地址管理各个功能的逻辑实现，接下来，我们就可以启动项目，进行一个测试。测试过程中，通过debug断点调试观察服务端程序的执行过程，在浏览器中使用调试工具查看页面和服务端的交互过程和请求响应数据。

#### 新增地址

> 填写表单数据，点击保存地址，查看网络请求。

![image-20210812201636567](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026098.png) 

> 测试完毕之后，检查数据库中的数据，是否正常插入。

![image-20210812201845336](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026097.png) 

#### 列表查询

> 当新增地址完成后，页面会再次发送一个请求，来查询该用户的所有地址列表，在界面进行展示。

![image-20210812202430677](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026103.png) 

![image-20210812202534169](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026699.png) 

#### 设置默认

> 在地址列表页面中，勾选 "设为默认地址" ，此时会发送PUT请求，来设置默认地址。

![image-20210812202841250](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026755.png) 

> 测试完毕后，我们再次查看数据库表中的数据：

![image-20210812203123499](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.12.30/202210272026839.png)

 

代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214204411614.png" alt="image-20221214204411614" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。



## 用户下单⭐

### 需求设计

#### 产品原型

> **用户下单业务说明：**在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货。用户下单后会产生订单相关数据，订单数据需要能够体现如下信息：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214195633802.png" alt="image-20221214195633802" style="zoom:50%;" /> 

> 用户将菜品或者套餐加入购物车后，可以点击购物车中的 "去结算" 按钮，页面跳转到订单确认页面，点击 "去支付" 按钮则完成下单操作。
>

**用户点餐业务流程(效果图)：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214195913467.png" alt="image-20221214195913467" style="zoom:80%;" /> 

#### 接口设计

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214200913654.png" alt="image-20221214200913654" style="zoom:50%;" /> 

**接口设计：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214201211364.png" alt="image-20221214201211364" style="zoom:50%;" /> 

#### 表设计

> 用户下单业务对应的数据表为orders表和order_detail表(一对多关系,一个订单关联多个订单明细)：
>

| 表名         | 含义       | 说明                                                         |
| ------------ | ---------- | ------------------------------------------------------------ |
| orders       | 订单表     | 主要存储订单的基本信息(如: 订单号、状态、金额、支付方式、下单用户、收件地址等) |
| order_detail | 订单明细表 | 主要存储订单详情信息(如: 该订单关联的套餐及菜品的信息)       |

> **orders订单表**

| **字段名**              | **数据类型**  | **说明**     | **备注**                                        |
| ----------------------- | ------------- | ------------ | ----------------------------------------------- |
| id                      | bigint        | 主键         | 自增                                            |
| number                  | varchar(50)   | 订单号       |                                                 |
| status                  | int           | 订单状态     | 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消 |
| user_id                 | bigint        | 用户id       | 逻辑外键                                        |
| address_book_id         | bigint        | 地址id       | 逻辑外键                                        |
| order_time              | datetime      | 下单时间     |                                                 |
| checkout_time           | datetime      | 付款时间     |                                                 |
| pay_method              | int           | 支付方式     | 1微信支付 2支付宝支付                           |
| pay_status              | tinyint       | 支付状态     | 0未支付 1已支付 2退款                           |
| amount                  | decimal(10,2) | 订单金额     |                                                 |
| remark                  | varchar(100)  | 备注信息     |                                                 |
| phone                   | varchar(11)   | 手机号       | 冗余字段                                        |
| address                 | varchar(255)  | 详细地址信息 | 冗余字段                                        |
| consignee               | varchar(32)   | 收货人       | 冗余字段                                        |
| cancel_reason           | varchar(255)  | 订单取消原因 |                                                 |
| rejection_reason        | varchar(255)  | 拒单原因     |                                                 |
| cancel_time             | datetime      | 订单取消时间 |                                                 |
| estimated_delivery_time | datetime      | 预计送达时间 |                                                 |
| delivery_status         | tinyint       | 配送状态     | 1立即送出 0选择具体时间                         |
| delivery_time           | datetime      | 送达时间     |                                                 |
| pack_amount             | int           | 打包费       |                                                 |
| tableware_number        | int           | 餐具数量     |                                                 |
| tableware_status        | tinyint       | 餐具数量状态 | 1按餐量提供 0选择具体数量                       |

> **order_detail订单明细表**

| **字段名**  | **数据类型**  | **说明**     | **备注** |
| ----------- | ------------- | ------------ | -------- |
| id          | bigint        | 主键         | 自增     |
| name        | varchar(32)   | 商品名称     | 冗余字段 |
| image       | varchar(255)  | 商品图片路径 | 冗余字段 |
| order_id    | bigint        | 订单id       | 逻辑外键 |
| dish_id     | bigint        | 菜品id       | 逻辑外键 |
| setmeal_id  | bigint        | 套餐id       | 逻辑外键 |
| dish_flavor | varchar(50)   | 菜品口味     |          |
| number      | int           | 商品数量     |          |
| amount      | decimal(10,2) | 商品单价     |          |

> **说明：**用户提交订单，需要往订单表orders中插入一条记录，并且往order_detail中插入一条或多条记录

### 准备工作

> 在开发业务功能前，先将需要用到的类和接口基本结构创建好：

> **实体类 Orders、OrderDetail**

```java
// 订单
@Data
public class Orders implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
    //订单号
    private String number;
    //订单状态 1待付款，2待派送，3已派送，4已完成，5已取消
    private Integer status;

    //下单用户id
    private Long userId;

    //地址id
    private Long addressBookId;

    //下单时间
    private LocalDateTime orderTime;

    //结账时间
    private LocalDateTime checkoutTime;

    //支付方式 1微信，2支付宝
    private Integer payMethod;

    //实收金额
    private BigDecimal amount;

    //备注
    private String remark;

    //用户名
    private String userName;

    //手机号
    private String phone;

    //地址
    private String address;

    //收货人
    private String consignee;
}
```

```java
// 订单明细
@Data
public class OrderDetail implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;

    //名称
    private String name;

    //订单id
    private Long orderId;

    //菜品id
    private Long dishId;

    //套餐id
    private Long setmealId;

    //口味
    private String dishFlavor;

    //数量
    private Integer number;

    //金额
    private BigDecimal amount;

    //图片
    private String image;
}
```

> **Mapper接口 OrderMapper、OrderDetailMapper**

```java
@Mapper
public interface OrderMapper extends BaseMapper<Orders> {
}
```

```java
@Mapper
public interface OrderDetailMapper extends BaseMapper<OrderDetail> {
}
```

> **业务层接口 OrderService、OrderDetailService**

```java
public interface OrderService extends IService<Orders> {
}
```

```java
public interface OrderDetailService extends IService<OrderDetail> {
}
```

> **业务层实现类 OrderServiceImpl、OrderDetailServiceImpl**

```java
@Service
@Slf4j
public class OrderServiceImpl extends ServiceImpl<OrderMapper, Orders> 
                              implements OrderService {
}
```

```java
@Service
public class OrderDetailServiceImpl extends ServiceImpl<OrderDetailMapper, OrderDetail> 
                                    implements OrderDetailService {
}
```

> **控制层 OrderController、OrderDetailController**

```java
// 订单
@Slf4j
@RestController
@RequestMapping("/user/order")
public class OrderController {
    
    @Resource
    private OrderService orderService;
}
```

```java
// 订单明细
@Slf4j
@RestController
@RequestMapping("/user/orderDetail")
public class OrderDetailController {

    @Resource
    private OrderDetailService orderDetailService;
}
```

### 代码开发

> 在OrderController中创建submit方法，处理用户下单的逻辑 ：

```java
// 订单
@RestController("userOrderController")
@RequestMapping("/user/order")
@Slf4j
@Api(tags = "C端-订单接口")
public class OrderController {

    @Resource
    private OrderService orderService;

    // 用户下单
    @PostMapping("/submit")
    @ApiOperation("用户下单")
    public Result submit(@RequestBody Orders orders) {
        log.info("用户下单：{}", orders);
        Result result = orderService.submitOrder(orders);
        return Result.success(result);
    }
}
```

> 由于下单的逻辑相对复杂，我们可以在OrderService中定义submit方法，来处理下单的具体逻辑：

```java
public interface OrderService extends IService<Orders> {

    Result submitOrder(Orders orders);
}
```

> 然后在OrderServiceImpl中完成下单功能的具体实现，下单功能的具体逻辑如下： 

> A. 获得当前用户id, 查询当前用户的购物车数据
>
> B. 根据当前登录用户id, 查询用户数据
>
> C. 根据地址ID, 查询地址数据
>
> D. 组装订单明细数据, 批量保存订单明细 
>
> E. 组装订单数据, 批量保存订单数据
>
> F. 删除当前用户的购物车列表数据

> 具体代码实现如下: 

```java
@Service
@Slf4j
public class OrderServiceImpl extends ServiceImpl<OrderMapper, Orders>
                              implements OrderService {
    @Resource
    private ShoppingCartService shoppingCartService;

    @Resource
    private UserService userService;

    @Resource
    private AddressBookService addressBookService;

    @Resource
    private OrderDetailService orderDetailService;

    // 用户下单
    @Transactional
    public Result submitOrder(Orders orders) {
        //获得当前用户id
        Long userId = 4L;

        //查询当前用户的购物车数据
        LambdaQueryWrapper<ShoppingCart> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(ShoppingCart::getUserId,userId);
        List<ShoppingCart> shoppingCarts = shoppingCartService.list(wrapper);
        //异常情况的处理（收货地址为空、超出配送范围、购物车为空）
        if(shoppingCarts == null || shoppingCarts.size() == 0){
            return Result.error("购物车为空，不能下单");
        }

        //查询用户数据
        User user = userService.getById(userId);

        //查询地址数据
        Long addressBookId = orders.getAddressBookId();
        AddressBook addressBook = addressBookService.getById(addressBookId);
        if(addressBook == null){
            return Result.error("用户地址信息有误，不能下单");
        }

        long orderId = IdWorker.getId();//订单号
        AtomicInteger amount = new AtomicInteger(0);
        //组装订单明细信息
        List<OrderDetail> orderDetails = shoppingCarts.stream().map((item) -> {
            OrderDetail orderDetail = OrderDetail.builder()
                    .orderId(orderId)
                    .number(item.getNumber())
                    .dishFlavor(item.getDishFlavor())
                    .dishId(item.getDishId())
                    .setmealId(item.getSetmealId())
                    .name(item.getName())
                    .image(item.getImage())
                    .amount(item.getAmount()).build();
            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber()))
                    .intValue());
            return orderDetail;
        }).collect(Collectors.toList());

        //组装订单数据
        orders.setId(orderId);
        orders.setOrderTime(LocalDateTime.now());
        orders.setCheckoutTime(LocalDateTime.now());
        orders.setStatus(2);
        orders.setAmount(new BigDecimal(amount.get()));//总金额
        orders.setUserId(userId);
        orders.setNumber(String.valueOf(orderId));
        orders.setUserName(user.getName());
        orders.setConsignee(addressBook.getConsignee());
        orders.setPhone(addressBook.getPhone());
        orders.setAddress((addressBook.getProvinceName() == null ? "" : addressBook
                .getProvinceName())
                + (addressBook.getCityName() == null ? "" : addressBook.getCityName())
                + (addressBook.getDistrictName() == null ? "" : 
                   addressBook.getDistrictName())
                + (addressBook.getDetail() == null ? "" : addressBook.getDetail()));
        //向订单表插入数据，一条数据
        this.save(orders);
        //向订单明细表插入数据，多条数据
        orderDetailService.saveBatch(orderDetails);
        //清空购物车数据
        shoppingCartService.remove(wrapper);
        return Result.success("下单成功");
    }
}
```

> 备注: 上述逻辑处理中，计算购物车商品的总金额时，为保证我们每一次执行的累加计算是一个原子操作，我们这里用到了JDK中提供的一个原子类 AtomicInteger

### 功能测试

> 登录小程序，完成下单操作，下单操作时，同时会删除购物车中的数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214214128415.png" alt="image-20221214214128415" style="zoom:50%;" /> 

> **查看shopping_cart表**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214214642428.png" alt="image-20221214214642428" style="zoom: 80%;" /> 

> **去结算-->去支付**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214214808218.png" alt="image-20221214214808218" style="zoom:50%;" />

> **查看orders表**

![image-20221214215116451](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214215116451.png)

> **查看order_detail表**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214215250553.png" alt="image-20221214215250553" style="zoom:80%;" /> 

> **同时，购物车表中数据删除**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214215428516.png" alt="image-20221214215428516" style="zoom:80%;" /> 

### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214215650664.png" alt="image-20221214215650664" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。



## 订单支付

### 微信支付介绍

> 前面的课程已经实现了用户下单，那接下来就是订单支付，就是完成付款功能。支付大家应该都不陌生了，在现实生活中经常购买商品并且使用支付功能来付款，在付款的时候可能使用比较多的就是微信支付和支付宝支付了。在苍穹外卖项目中，选择的就是**微信支付**这种支付方式。
>

> 要实现微信支付就需要注册微信支付的一个商户号，这个商户号是必须要有一家企业并且有正规的营业执照。只有具备了这些资质之后，才可以去注册商户号，才能开通支付权限。
>

> 个人不具备这种资质，所以我们在学习微信支付时，最重要的是了解微信支付的流程，并且能够阅读微信官方提供的接口文档，能够和第三方支付平台对接起来就可以了。
>

**微信支付产品：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214223302651.png" alt="image-20221214223302651" style="zoom:50%;" /> 

本项目选择**小程序支付**

参考：https://pay.weixin.qq.com/static/product/product_index.shtml



**微信支付接入流程：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214223509246.png" alt="image-20221214223509246" style="zoom:50%;" /> 



**微信小程序支付时序图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214223910840.png" alt="image-20221214223910840" style="zoom:50%;" /> 



**微信支付相关接口：**

**JSAPI下单：**商户系统调用该接口在微信支付服务后台生成预支付交易单(对应时序图的第5步)

![image-20221214224409174](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214224409174.png)



**微信小程序调起支付：**通过JSAPI下单接口获取到发起支付的必要参数prepay_id，然后使用微信支付提供的小程序方法调起小程序支付(对应时序图的第10步)

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214224551220.png" alt="image-20221214224551220" style="zoom:50%;" /> 



### 微信支付准备工作

#### 如何保证数据安全？

完成微信支付有两个关键的步骤：

> **第一个**就是需要在商户系统当中调用微信后台的一个下单接口，就是生成预支付交易单。

> **第二个**就是支付成功之后微信后台会给推送消息。

> 这两个接口数据的安全性，要求其实是非常高的。
>

> **解决：**微信提供的方式就是对数据进行加密、解密、签名多种方式。要完成数据加密解密，需要提前准备相应的一些文件，其实就是一些证书。

> **获取微信支付平台证书、商户私钥文件：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221214234038395.png" alt="image-20221214234038395" style="zoom:50%;" /> 

> 在后绪程序开发过程中，就会使用到这两个文件，需要提前把这两个文件准备好。
>

#### 如何调用到商户系统？

> 微信后台会调用到商户系统给推送支付的结果，在这里我们就会遇到一个问题，就是微信后台怎么就能调用到我们这个商户系统呢？因为这个调用过程，其实本质上也是一个HTTP请求。
>

> 目前，商户系统它的ip地址就是当前自己电脑的ip地址，只是一个局域网内的ip地址，微信后台无法调用到。**解决：**内网穿透。通过**cpolar软件**可以获得一个临时域名，而这个临时域名是一个公网ip，这样，微信后台就可以请求到商户系统了。
>

**cpolar软件的使用：**

**1). 下载与安装**

下载地址：https://dashboard.cpolar.com/get-started

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215184407217.png" alt="image-20221215184407217" style="zoom:50%;" /> 

> 在资料中已提供，可无需下载。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215184446260.png" alt="image-20221215184446260" style="zoom:80%;" /> 

> 安装过程中，一直下一步即可，不再演示。
>

**2). cpolar指定authtoken**

复制authtoken：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215184746092.png" alt="image-20221215184746092" style="zoom:50%;" /> 

执行命令：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215185152869.png" alt="image-20221215185152869" style="zoom:50%;" /> 



**3). 获取临时域名**

执行命令：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215185749163.png" alt="image-20221215185749163" style="zoom:50%;" /> 

获取域名：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215185833157.png" alt="image-20221215185833157" style="zoom:50%;" /> 



**4). 验证临时域名有效性**

**访问接口文档**

使用localhost:8080访问

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215190440717.png" alt="image-20221215190440717" style="zoom:50%;" /> 

使用临时域名访问

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215190525166.png" alt="image-20221215190525166" style="zoom:50%;" /> 

证明临时域名生效。

### 代码导入

导入资料中的微信支付功能代码即可

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215192120424.png" alt="image-20221215192120424" style="zoom:50%;" /> 

#### 微信支付相关配置

application-dev.yml

```yaml
sky:
  wechat:
    appid: wxcd2e39f677fd30ba
    secret: 84fbfdf5ea288f0c432d829599083637
    mchid : 1561414331
    mchSerialNo: 4B3B3DC35414AD50B1B755BAF8DE9CC7CF407606
    privateKeyFilePath: D:\apiclient_key.pem
    apiV3Key: CZBK51236435wxpay435434323FFDuv3
    weChatPayCertFilePath: D:\wechatpay_166D96F876F45C7D07CE98952A96EC980368ACFC.pem
    notifyUrl: https://www.weixin.qq.com/wxpay/pay.php
    refundNotifyUrl: https://www.weixin.qq.com/wxpay/pay.php
```

application.yml

```yaml
sky:
  wechat:
    appid: ${sky.wechat.appid}
    secret: ${sky.wechat.secret}
    mchid : ${sky.wechat.mchid}
    mchSerialNo: ${sky.wechat.mchSerialNo}
    privateKeyFilePath: ${sky.wechat.privateKeyFilePath}
    apiV3Key: ${sky.wechat.apiV3Key}
    weChatPayCertFilePath: ${sky.wechat.weChatPayCertFilePath}
    notifyUrl: ${sky.wechat.notifyUrl}
    refundNotifyUrl: ${sky.wechat.refundNotifyUrl}
```

WeChatProperties.java：读取配置(已定义)

```java
@Component
@ConfigurationProperties(prefix = "sky.wechat")
@Data
public class WeChatProperties {

    private String appid; //小程序的appid
    private String secret; //小程序的秘钥
    private String mchid; //商户号
    private String mchSerialNo; //商户API证书的证书序列号
    private String privateKeyFilePath; //商户私钥文件
    private String apiV3Key; //证书解密的密钥
    private String weChatPayCertFilePath; //平台证书
    private String notifyUrl; //支付成功的回调地址
    private String refundNotifyUrl; //退款成功的回调地址
}
```

#### Mapper层

> **在OrderMapper.java中添加getByNumberAndUserId和update两个方法**

```java
// 根据订单号和用户id查询订单
@Select("select * from orders where number = #{orderNumber} and user_id= #{userId}")
Orders getByNumberAndUserId(String orderNumber, Long userId);

// 修改订单信息
void update(Orders orders);
```

> **在OrderMapper.xml中添加**

```xml
<update id="update" parameterType="com.sky.entity.Orders">
        update orders
        <set>
            <if test="cancelReason != null and cancelReason!='' ">
                cancel_reason=#{cancelReason},
            </if>
            <if test="rejectionReason != null and rejectionReason!='' ">
                rejection_reason=#{rejectionReason},
            </if>
            <if test="cancelTime != null">
                cancel_time=#{cancelTime},
            </if>
            <if test="payStatus != null">
                pay_status=#{payStatus},
            </if>
            <if test="payMethod != null">
                pay_method=#{payMethod},
            </if>
            <if test="checkoutTime != null">
                checkout_time=#{checkoutTime},
            </if>
            <if test="status != null">
                status = #{status},
            </if>
            <if test="deliveryTime != null">
                delivery_time = #{deliveryTime}
            </if>
        </set>
        where id = #{id}
</update>
```

#### Service层

**在OrderService.java中添加payment和paySuccess两个方法定义**

```java
	/**
     * 订单支付
     * @param ordersPaymentDTO
     * @return
     */
    OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception;

    /**
     * 支付成功，修改订单状态
     * @param outTradeNo
     */
    void paySuccess(String outTradeNo);
```

**在OrderServiceImpl.java中实现payment和paySuccess两个方法**

```java
 	@Autowired
    private UserMapper userMapper;
	@Autowired
    private WeChatPayUtil weChatPayUtil;
    /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception {
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();
        User user = userMapper.getById(userId);

        //调用微信支付接口，生成预支付交易单
        JSONObject jsonObject = weChatPayUtil.pay(
                ordersPaymentDTO.getOrderNumber(), //商户订单号
                new BigDecimal(0.01), //支付金额，单位 元
                "苍穹外卖订单", //商品描述
                user.getOpenid() //微信用户的openid
        );

        if (jsonObject.getString("code") != null && jsonObject.getString("code").equals("ORDERPAID")) {
            throw new OrderBusinessException("该订单已支付");
        }

        OrderPaymentVO vo = jsonObject.toJavaObject(OrderPaymentVO.class);
        vo.setPackageStr(jsonObject.getString("package"));

        return vo;
    }

    /**
     * 支付成功，修改订单状态
     *
     * @param outTradeNo
     */
    public void paySuccess(String outTradeNo) {
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();

        // 根据订单号查询当前用户的订单
        Orders ordersDB = orderMapper.getByNumberAndUserId(outTradeNo, userId);

        // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
        Orders orders = Orders.builder()
                .id(ordersDB.getId())
                .status(Orders.TO_BE_CONFIRMED)
                .payStatus(Orders.PAID)
                .checkoutTime(LocalDateTime.now())
                .build();

        orderMapper.update(orders);
    }
```

#### Controller层

**在OrderController.java中添加payment方法**

```java
 	/**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    @PutMapping("/payment")
    @ApiOperation("订单支付")
    public Result<OrderPaymentVO> payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception {
        log.info("订单支付：{}", ordersPaymentDTO);
        OrderPaymentVO orderPaymentVO = orderService.payment(ordersPaymentDTO);
        log.info("生成预支付交易单：{}", orderPaymentVO);
        return Result.success(orderPaymentVO);
    }
```

PayNotifyController.java

```java
package com.sky.controller.notify;

import com.alibaba.druid.support.json.JSONUtils;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.sky.annotation.IgnoreToken;
import com.sky.properties.WeChatProperties;
import com.sky.service.OrderService;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.entity.ContentType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;

/**
 * 支付回调相关接口
 */
@RestController
@RequestMapping("/notify")
@Slf4j
public class PayNotifyController {
    @Autowired
    private OrderService orderService;
    @Autowired
    private WeChatProperties weChatProperties;

    /**
     * 支付成功回调
     *
     * @param request
     */
    @RequestMapping("/paySuccess")
    public void paySuccessNotify(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //读取数据
        String body = readData(request);
        log.info("支付成功回调：{}", body);

        //数据解密
        String plainText = decryptData(body);
        log.info("解密后的文本：{}", plainText);

        JSONObject jsonObject = JSON.parseObject(plainText);
        String outTradeNo = jsonObject.getString("out_trade_no");//商户平台订单号
        String transactionId = jsonObject.getString("transaction_id");//微信支付交易号

        log.info("商户平台订单号：{}", outTradeNo);
        log.info("微信支付交易号：{}", transactionId);

        //业务处理，修改订单状态、来单提醒
        orderService.paySuccess(outTradeNo);

        //给微信响应
        responseToWeixin(response);
    }

    /**
     * 读取数据
     *
     * @param request
     * @return
     * @throws Exception
     */
    private String readData(HttpServletRequest request) throws Exception {
        BufferedReader reader = request.getReader();
        StringBuilder result = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) {
            if (result.length() > 0) {
                result.append("\n");
            }
            result.append(line);
        }
        return result.toString();
    }

    /**
     * 数据解密
     *
     * @param body
     * @return
     * @throws Exception
     */
    private String decryptData(String body) throws Exception {
        JSONObject resultObject = JSON.parseObject(body);
        JSONObject resource = resultObject.getJSONObject("resource");
        String ciphertext = resource.getString("ciphertext");
        String nonce = resource.getString("nonce");
        String associatedData = resource.getString("associated_data");

        AesUtil aesUtil = new AesUtil(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));
        //密文解密
        String plainText = aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),
                nonce.getBytes(StandardCharsets.UTF_8),
                ciphertext);

        return plainText;
    }

    /**
     * 给微信响应
     * @param response
     */
    private void responseToWeixin(HttpServletResponse response) throws Exception{
        response.setStatus(200);
        HashMap<Object, Object> map = new HashMap<>();
        map.put("code", "SUCCESS");
        map.put("message", "SUCCESS");
        response.setHeader("Content-type", ContentType.APPLICATION_JSON.toString());
        response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));
        response.flushBuffer();
    }
}
```



### 功能测试

测试过程中，可通过断点方式查看后台每一步执行情况。

**下单：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215205122716.png" alt="image-20221215205122716" style="zoom: 80%;" /> 

**去支付：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215205308701.png" alt="image-20221215205308701" style="zoom:80%;" /> 

**确认支付：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215205434552.png" alt="image-20221215205434552" style="zoom:80%;" /> 

进行扫码支付即可。

### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221215205746248.png" alt="image-20221215205746248" style="zoom:50%;" /> 

 后续步骤和其它功能代码提交一致，不再赘述。



#  订单状态⭐

## 课程内容

> - Spring Task
> - 订单状态定时处理
> - WebSocket
> - 来单提醒
> - 客户催单

> 功能实现：**订单状态定时处理**、**来单提醒**和**客户催单**
>

### 订单状态定时处理

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218204021760.png" alt="image-20221218204021760" style="zoom:50%;" /> 

### 来单提醒

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218204119663.png" alt="image-20221218204119663" style="zoom:50%;" /> 

### 客户催单

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218204202847.png" alt="image-20221218204202847" style="zoom:50%;" /> 

## Spring Task

### 基本概述

> **Spring Task** 是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑。

> **定位：**定时任务框架

> **作用：**定时自动执行某段Java代码

 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218183054818.png" alt="image-20221218183054818" style="zoom:50%;" /> 为什么要在Java程序中使用Spring Task？

**应用场景：**

> 1). 信用卡每月还款提醒

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218183213088.png" alt="image-20221218183213088" style="zoom:50%;" /> 

> 2). 银行贷款每月还款提醒

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218183410430.png" alt="image-20221218183410430" style="zoom:50%;" /> 

> 3). 火车票售票系统处理未支付订单

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218183614351.png" alt="image-20221218183614351" style="zoom:50%;" /> 

> 4). 入职纪念日为用户发送通知

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218183655186.png" alt="image-20221218183655186" style="zoom:50%;" /> 

> **强调：**只要是需要定时处理的场景都可以使用Spring Task

### cron表达式⭐

> **cron表达式**其实就是一个字符串，通过cron表达式可以**定义任务触发的时间**

> **构成规则：**分为6或7个域，由空格分隔开，每个域代表一个含义

> 每个域的含义分别为：**秒、分钟、小时、日、月、周、年(可选)**
>

> 2022年10月12日上午9点整 对应的cron表达式为：**0 0 9 12 10 ? 2022**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218184412491.png" alt="image-20221218184412491" style="zoom:50%;" /> 

> **说明：**一般**日**和**周**的值不同时设置，其中一个设置，另一个用？表示。

> **比如：**描述2月份的最后一天，最后一天具体是几号呢？可能是28号，也有可能是29号，所以就不能写具体数字。为了描述这些信息，提供一些特殊的字符。这些具体的细节，我们就不用自己去手写，因为这个cron表达式，它其实有在线生成器。cron表达式在线生成器：https://cron.qqe2.com/

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218184959888.png" alt="image-20221218184959888" style="zoom:50%;" /> 



> 可以直接在这个网站上面，只要根据自己的要求去生成corn表达式即可。所以一般就不用自己去编写这个表达式。
>

**通配符：**

> * 表示所有值； 
>
> ? 表示未说明的值，即不关心它为何值； 
>
> \- 表示一个指定的范围； 
>
> , 表示附加一个可能值； 
>
> / 符号前表示开始时间，符号后表示每次递增的值；

**cron表达式案例：**

> */5 * * * * ? 每隔5秒执行一次
>
> 0 */1 * * * ? 每隔1分钟执行一次
>
> 0 0 5-15 * * ? 每天5-15点整点触发
>
> 0 0/3 * * * ? 每三分钟触发一次
>
> 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 
>
> 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发
>
> 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
>
> 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时
>
> 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 

### 实战演练

#### 使用步骤

> 导入maven坐标 spring-context（已存在）
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218193251182.png" alt="image-20221218193251182" style="zoom:50%;" /> 

> 启动类添加注解 @EnableScheduling 开启任务调度,自定义定时任务类

#### 自定义定时

```java
// 自定义定时任务类
@Component
@Slf4j
public class MyTask {
    // 定时任务 每隔5秒触发一次
    @Scheduled(cron = "0/5 * * * * ?")
    public void executeTask(){
        log.info("定时任务开始执行：{}",new Date());
    }
}
```

#### 开启任务调度

> 启动类添加注解 @EnableScheduling
>

```java
@SpringBootApplication
@EnableTransactionManagement 
@Slf4j
@EnableCaching
@EnableScheduling
public class SkyApplication {
    public static void main(String[] args) {
        SpringApplication.run(SkyApplication.class, args);
        log.info("server started");
    }
}
```

#### 功能测试

启动服务，查看日志

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218194511420.png" alt="image-20221218194511420" style="zoom:80%;" /> 

每隔5秒执行一次。

## 订单状态定时处理

### 需求分析

用户下单后可能存在的情况：

> - 下单后未支付，订单一直处于**“待支付”**状态
> - 用户收货后管理端未点击完成按钮，订单一直处于**“派送中”**状态

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218194939516.png" alt="image-20221218194939516" style="zoom:50%;" />                 

> 支付超时的订单如何处理派送中的订单一直不点击完成如何处理？

> 对于上面两种情况需要通过**定时任务**来修改订单状态，具体逻辑为：

> - 通过定时任务每分钟检查一次是否存在支付超时订单（下单后超过15分钟仍未支付则判定为支付超时订单），如果存在则修改订单状态为“已取消”
> - 通过定时任务每天凌晨1点检查一次是否存在“派送中”的订单，如果存在修改订单状态为“已完成”

### 代码开发⭐

> **自定义定时任务类OrderTask（待完善）：**

```java
package com.sky.task;

// 自定义定时任务，实现订单状态定时处理
@Component
@Slf4j
public class OrderTask {

    @Resource
    private OrderMapper orderMapper;

    // 处理支付超时订单，每分钟触发一次
    @Scheduled(cron = "0 * * * * ?")
    public void processTimeoutOrder(){
        log.info("处理支付超时订单：{}", new Date());
    }

    // 处理“派送中”状态的订单，每天凌晨一点检查一次
    @Scheduled(cron = "0 0 1 * * ?")
    public void processDeliveryOrder(){
        log.info("处理派送中订单：{}", new Date());
    }
}
```

> **在OrderMapper接口中扩展方法**

```java
@Mapper
public interface OrderMapper extends BaseMapper<Orders> {

    // 根据状态和下单时间查询订单
    @Select("select * from orders where status = #{status} and order_time < "
            + "#{orderTime}")
    List<Orders> getByStatusAndOrdertimeLT(Integer status, LocalDateTime orderTime);
}
```

> **完善定时任务类的processTimeoutOrder方法**

```java
// 处理支付超时订单
@Scheduled(cron = "0 * * * * ?")
public void processTimeoutOrder(){
    log.info("处理支付超时订单：{}", new Date());
    LocalDateTime time = LocalDateTime.now().plusMinutes(-15);
    // select * from orders where status = 1 and order_time < 当前时间-15分钟
    List<Orders> ordersList = orderMapper
                             .getByStatusAndOrdertimeLT(Orders.PENDING_PAYMENT, time);
    if(ordersList != null && ordersList.size() > 0){
        ordersList.forEach(order -> {
            order.setStatus(Orders.CANCELLED);
            order.setCancelReason("支付超时，自动取消");
            order.setCancelTime(LocalDateTime.now());
            orderMapper.updateById(order);
        });
    }
}
```

> **完善定时任务类的processDeliveryOrder方法：**

```java
// 处理“派送中”状态的订单
@Scheduled(cron = "0 0 1 * * ?")
public void processDeliveryOrder(){
    log.info("处理派送中订单：{}", new Date());
    // select * from orders where status = 4 and order_time < 当前时间-1小时
    LocalDateTime time = LocalDateTime.now().plusMinutes(-60);
    List<Orders> ordersList = orderMapper.getByStatusAndOrdertimeLT(Orders
                                         .DELIVERY_IN_PROGRESS, time);
    if(ordersList != null && ordersList.size() > 0){
        ordersList.forEach(order -> {
            order.setStatus(Orders.COMPLETED);
            orderMapper.updateById(order);
        });
    }
}
```

### 功能测试

可以通过如下方式进行测试：

> - 查看控制台sql
> - 查看数据库中数据变化

**支付超时的订单测试：**

> **1). 查看订单表**
>
> 有一条订单，状态为1。订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218202334773.png" alt="image-20221218202334773" style="zoom:50%;" /> 

> **2). 开启定时任务**

> 启动服务，观察控制台日志。处理支付超时订单任务每隔1分钟执行一次。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218203045089.png" alt="image-20221218203045089" style="zoom:50%;" /> 

> **3). 再次查看订单表**

> 状态已更改为6，已取消。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221218203146535.png" alt="image-20221218203146535" style="zoom:80%;" /> 

> 证明定时任务已生效。**处理“派送中”状态的订单任务**测试自已完成，测试步骤和上述一致。可适当修改cron表达式，改变任务执行频率，方便测试。
>



## WebSocket⭐

### 基本概述

> WebSocket 是基于 TCP 的一种新的**网络协议**。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建**持久性**的连接， 并进行**双向**数据传输。
>

> **HTTP协议和WebSocket协议对比：**

> - HTTP是**短连接**
> - WebSocket是**长连接**
> - HTTP通信是**单向**的，基于请求响应模式
> - WebSocket支持**双向**通信
> - HTTP和WebSocket底层都是TCP连接

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222184340172.png" alt="image-20221222184340172" style="zoom:50%;" />          

> **思考：**既然WebSocket支持双向通信，功能看似比HTTP强大，那么我们是不是可以基于WebSocket开发所有的业务功能？

**WebSocket缺点：**

> 1. 服务器长期维护长连接需要一定的成本
> 2. 各个浏览器支持程度不一
> 3. WebSocket 是长连接，受网络限制比较大，需要处理好重连
> 4. **结论：**WebSocket并不能完全取代HTTP，它只适合在特定的场景下使用

**WebSocket应用场景：**

1). 视频弹幕

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222184616570.png" alt="image-20221222184616570" style="zoom:50%;" />v

2). 网页聊天

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222184641675.png" alt="image-20221222184641675" style="zoom:50%;" /> 

3). 体育实况更新

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222184714092.png" alt="image-20221222184714092" style="zoom:50%;" /> 

4). 股票基金报价实时更新

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222184742094.png" alt="image-20221222184742094" style="zoom:50%;" /> 

### 实战演练

#### 案例分析

> **需求：**实现浏览器与服务器全双工通信。
>
> 浏览器既可以向服务器发送消息，服务器也可主动向浏览器推送消息。

> **效果展示：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222190401414.png" alt="image-20221222190401414" style="zoom:50%;" /> 

**实现步骤：**

> 1). 直接使用websocket.html页面作为WebSocket客户端
>
> 2). 导入WebSocket的maven坐标
>
> 3). 导入WebSocket服务端组件WebSocketServer，用于和客户端通信
>
> 4). 导入配置类WebSocketConfiguration，注册WebSocket的服务端组件
>
> 5). 导入定时任务类WebSocketTask，定时向客户端推送数据

#### 代码开发⭐

> 定义websocket.html页面,定义在resource目录下即可
>

```html
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebSocket Demo</title>
</head>
<body>
    <input id="text" type="text" />
    <button onclick="send()">发送消息</button>
    <button onclick="closeWebSocket()">关闭连接</button>
    <div id="message">
    </div>
</body>
<script type="text/javascript">
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    //判断当前浏览器是否支持WebSocket
    if('WebSocket' in window){
        //连接WebSocket节点
        websocket = new WebSocket("ws://localhost:8080/ws/"+clientId);
    }
    else{
        alert('Not support websocket')
    }

    //连接发生错误的回调方法
    websocket.onerror = function(){
        setMessageInnerHTML("error");
    };

    //连接成功建立的回调方法
    websocket.onopen = function(){
        setMessageInnerHTML("连接成功");
    }

    //接收到消息的回调方法
    websocket.onmessage = function(event){
        setMessageInnerHTML(event.data);
    }

    //连接关闭的回调方法
    websocket.onclose = function(){
        setMessageInnerHTML("close");
    }

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，
    //server端会抛异常。
    window.onbeforeunload = function(){
        websocket.close();
    }

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML){
        document.getElementById('message').innerHTML += innerHTML + '<br/>';
    }

    //发送消息
    function send(){
        var message = document.getElementById('text').value;
        websocket.send(message);
    }
	
	//关闭连接
    function closeWebSocket() {
        websocket.close();
    }
</script>
</html>
```

> **maven坐标，在sky-server模块pom.xml中已定义**

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

> 定义WebSocket服务端组件(资料中已提供)，直接导入到sky-server模块即可
>

```java
package com.sky.websocket;

// WebSocket服务
@Component
@ServerEndpoint("/ws/{sid}")
public class WebSocketServer {

    //存放会话对象
    private static Map<String, Session> sessionMap = new HashMap();

    // 连接建立成功调用的方法
    @OnOpen
    public void onOpen(Session session, @PathParam("sid") String sid) {
        System.out.println("客户端：" + sid + "建立连接");
        sessionMap.put(sid, session);
    }

    // 收到客户端消息后调用的方法;客户端发送过来的消息
    @OnMessage
    public void onMessage(String message, @PathParam("sid") String sid) {
        System.out.println("收到来自客户端：" + sid + "的信息:" + message);
    }

    // 连接关闭调用的方法
    @OnClose
    public void onClose(@PathParam("sid") String sid) {
        System.out.println("连接断开:" + sid);
        sessionMap.remove(sid);
    }

    // 群发
    public void sendToAllClient(String message) {
        Collection<Session> sessions = sessionMap.values();
        for (Session session : sessions) {
            try {
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

> 4). 定义配置类，注册WebSocket的服务端组件(从资料中直接导入即可)

```java
// WebSocket配置类，用于注册WebSocket的Bean
@Configuration
public class WebSocketConfiguration {

    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }

}
```

> **定义定时任务类，定时向客户端推送数据(从资料中直接导入即可)**

```java
@Component
public class WebSocketTask {
    @Resource
    private WebSocketServer webSocketServer;

    // 通过WebSocket每隔5秒向客户端发送消息
    @Scheduled(cron = "0/5 * * * * ?")
    public void sendMessageToClient() {
        webSocketServer.sendToAllClient("这是来自服务端的消息：" + 
                                        DateTimeFormatter.ofPattern("HH:mm:ss")
                                        .format(LocalDateTime.now()));
    }
}
```

#### 功能测试

> 启动服务，打开websocket.html页面
>

> **浏览器向服务器发送数据：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222192759049.png" alt="image-20221222192759049" style="zoom:50%;" /> 

> **服务器向浏览器间隔5秒推送数据：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222192926954.png" alt="image-20221222192926954" style="zoom:50%;" /> 

## 来单提醒

### 需求设计

用户下单并且支付成功后，需要第一时间通知外卖商家。通知的形式有如下两种：

- 语音播报  <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222194413901.png" alt="image-20221222194413901" style="zoom:50%;" />
- 弹出提示框

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222194450142.png" alt="image-20221222194450142" style="zoom:50%;" /> 

**设计思路：**

> - 通过WebSocket实现管理端页面和服务端保持长连接状态
> - 当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息
> - 客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报
> - 约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content
>   - type 为消息类型，1为来单提醒 2为客户催单
>   - orderId 为订单id
>   - content 为消息内容

### 代码开发

> **在OrderServiceImpl中注入WebSocketServer对象，修改paySuccess方法，加入如下代码：**

```java
@Resource
private WebSocketServer webSocketServer;

// 支付成功方法会去调用这个方法，修改订单状态
public void paySuccess(String outTradeNo) {
    // 当前登录用户id
    Long userId = 1L;

    // 根据订单号查询当前用户的订单
    LambdaQueryWrapper<Orders> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(Orders::getNumber,outTradeNo);
    wrapper.eq(Orders::getUserId,userId);
    Orders ordersDB = getOne(wrapper);

    // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
    Orders orders = Orders.builder()
            .id(ordersDB.getId())
            .status(Orders.TO_BE_CONFIRMED)
            .payStatus(Orders.PAID)
            .checkoutTime(LocalDateTime.now())
            .build();

    updateById(orders);
    //////////////////////////////////////////////
    Map map = new HashMap();
    map.put("type", 1);//消息类型，1表示来单提醒
    map.put("orderId", orders.getId());
    map.put("content", "订单号：" + outTradeNo);
    //通过WebSocket实现来单提醒，向客户端浏览器推送消息
    webSocketServer.sendToAllClient(JSON.toJSONString(map));
    ///////////////////////////////////////////////////
}
```

### 功能测试

可以通过如下方式进行测试：

> - 查看浏览器调试工具数据交互过程
> - 前后端联调

**1). 登录管理端后台**

登录成功后，浏览器与服务器建立长连接

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222200842731.png" alt="image-20221222200842731" style="zoom:50%;" /> 

查看控制台日志

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222200941497.png" alt="image-20221222200941497" style="zoom:50%;" /> 

> **小程序端下单支付**:修改回调地址，利用内网穿透获取域名

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222201350616.png" alt="image-20221222201350616" style="zoom:50%;" /> 

> 下单支付
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222201718622.png" alt="image-20221222201718622" style="zoom:50%;" /> 

> **查看来单提醒**:支付成功后，后台收到来单提醒，并有语音播报

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222202310953.png" alt="image-20221222202310953" style="zoom:50%;" /> 



## 客户催单

### 需求设计

用户在小程序中点击催单按钮后，需要第一时间通知外卖商家。通知的形式有如下两种：

- 语音播报 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222203301218.png" alt="image-20221222203301218" style="zoom:50%;" />
- 弹出提示框

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222203345829.png" alt="image-20221222203345829" style="zoom:50%;" /> 

**设计思路：**

> - 通过WebSocket实现管理端页面和服务端保持长连接状态
> - 当用户点击催单按钮后，调用WebSocket的相关API实现服务端向客户端推送消息
> - 客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报
>   约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content
>   - type 为消息类型，1为来单提醒 2为客户催单
>   - orderId 为订单id
>   - content 为消息内容

> 当用户点击催单按钮时，向服务端发送请求。
>

**接口设计(催单)：**


### 代码开发

#### Controller层

> **根据用户催单的接口定义，在user/OrderController中创建催单方法：**

```java
// 用户催单
@GetMapping("/reminder/{id}")
@ApiOperation("用户催单")
public Result reminder(@PathVariable("id") Long id) {
    orderService.reminder(id);
    return Result.success();
}
```

#### Service层接口

> **在OrderService接口中声明reminder方法**

```java
// 用户催单
void reminder(Long id);
```

```java
// 用户催单
public void reminder(Long id) {
    // 查询订单是否存在
    Orders orders = orderMapper.getById(id);
    if (orders == null) {
        throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
    }
    //基于WebSocket实现催单
    Map map = new HashMap();
    map.put("type", 2);//2代表用户催单
    map.put("orderId", id);
    map.put("content", "订单号：" + orders.getNumber());
    webSocketServer.sendToAllClient(JSON.toJSONString(map));
}
```

### 功能测试

> - 查看浏览器调试工具数据交互过程
> - 前后端联调

> **登录管理端后台**：登录成功后，浏览器与服务器建立长连接

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222200842731.png" alt="image-20221222200842731" style="zoom:50%;" /> 

> 查看控制台日志
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222200941497.png" alt="image-20221222200941497" style="zoom:50%;" /> 

> **用户进行催单**：用户可在订单列表或者订单详情，进行催单

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222210932942.png" alt="image-20221222210932942" style="zoom:50%;" /> 

> **查看催单提醒**：既有催单弹窗，同时语音播报

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222211238000.png" alt="image-20221222211238000" style="zoom:50%;" /> 

## 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20221222211740927.png" alt="image-20221222211740927" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。



# 统计图

## 课程内容

> - Apache ECharts
> - 营业额统计
> - 用户统计
> - 订单统计
> - 销量排名Top10

> 功能实现：**数据统计**
>

> **数据统计效果图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101152725417.png" alt="image-20230101152725417" style="zoom:80%;" /> 

## Apache ECharts

### 基本概述

> Apache ECharts 是一款基于 Javascript 的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。官网地址：https://echarts.apache.org/zh/index.html
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101153041348.png" alt="image-20230101153041348" style="zoom:50%;" /> 

> **常见效果展示：**

> 柱形图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101153748714.png" alt="image-20230101153748714" style="zoom:50%;" /> 

> 饼形图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101153230868.png" alt="image-20230101153230868" style="zoom:50%;" /> 

> 折线图

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101153824086.png" alt="image-20230101153824086" style="zoom:50%;" /> 

> **总结：**不管是哪种形式的图形，最本质的东西实际上是数据，它其实是对数据的一种可视化展示。

### 基本案例

> Apache Echarts官方提供的快速入门：https://echarts.apache.org/handbook/zh/get-started/
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101155524477.png" alt="image-20230101155524477" style="zoom:50%;" /> 

**实现步骤：**

> 1). 引入echarts.js 文件(当天资料已提供)
>
> 2). 为 ECharts 准备一个设置宽高的 DOM
>
> 3). 初始化echarts实例
>
> 4). 指定图表的配置项和数据
>
> 5). 使用指定的配置项和数据显示图表

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ECharts</title>
    <!-- 引入刚刚下载的 ECharts 文件 -->
    <script src="echarts.js"></script>
  </head>
  <body>
    <!-- 为 ECharts 准备一个定义了宽高的 DOM -->
    <div id="main" style="width: 600px;height:400px;"></div>
    <script type="text/javascript">
      // 基于准备好的dom，初始化echarts实例
      var myChart = echarts.init(document.getElementById('main'));

      // 指定图表的配置项和数据
      var option = {
        title: {
          text: 'ECharts 入门示例'
        },
        tooltip: {},
        legend: {
          data: ['销量']
        },
        xAxis: {
          data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
        },
        yAxis: {},
        series: [
          {
            name: '销量',
            type: 'bar',
            data: [5, 20, 36, 10, 10, 20]
          }
        ]
      };
      // 使用刚指定的配置项和数据显示图表。
      myChart.setOption(option);
    </script>
  </body>
</html>
```

使用浏览器方式打开即可。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230711162411824.png" alt="image-20230711162411824" style="zoom:80%;" />

> **总结：**使用Echarts，重点在于研究当前图表所需的数据格式。通常是需要后端提供符合格式要求的动态数据，然后响应给前端来展示图表。



## 营业额统计⭐

### 需求设计

#### 产品原型

> 营业额统计是基于折现图来展现，并且按照天来展示的。实际上，就是某一个时间范围之内的每一天的营业额。同时，不管光标放在哪个点上，那么它就会把具体的数值展示出来。

> 并且还需要注意日期并不是固定写死的，是由上边时间选择器来决定。比如选择是近7天、或者是近30日，或者是本周，就会把相应这个时间段之内的每一天日期通过横坐标展示。

**原型图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101160747433.png" alt="image-20230101160747433" style="zoom:50%;" /> 

**业务规则：**

> - 营业额指订单状态为已完成的订单金额合计
> - 基于可视化报表的折线图展示营业额数据，X轴为日期，Y轴为营业额
> - 根据时间选择区间，展示每天的营业额数据

#### 接口设计

通过上述原型图，设计出对应的接口。


> **注意：**具体返回数据一般由前端来决定，前端展示图表，具体折现图对应数据是什么格式，是有固定的要求的。所以说，后端需要去适应前端，它需要什么格式的数据，我们就给它返回什么格式的数据。

### 代码开发⭐

> 注意：要先生成数据，使用navicat就行，主要字段status=5,order_time,amount

> 返回的结果格式

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TurnoverReportVO implements Serializable {

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //营业额，以逗号分隔，例如：406.0,1520.0,75.0
    private String turnoverList;
}
```

> 请求接口

```java
// 报表
@RestController
@RequestMapping("/admin/report")
@Slf4j
@Api(tags = "统计报表相关接口")
public class ReportController {

    @Resource
    private ReportService reportService;

    // 营业额数据统计
    @GetMapping("/turnoverStatistics")
    @ApiOperation("营业额数据统计")
    public Result turnoverStatistics(
            // 请求日期类型必须和它一致，不然会出错
            @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
            @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end) {
        System.out.println(begin);
        System.out.println(end);
        return Result.success(reportService.getTurnover(begin, end));
    }
}
```

```java
public interface ReportService {

    // 根据时间区间统计营业额
    TurnoverReportVO getTurnover(LocalDate beginTime, LocalDate endTime);
}
```

> 本质上就是进行数据查询，拼接返回结果

```java
@Service
@Slf4j
public class ReportServiceImpl implements ReportService {

    @Resource
    private OrderMapper orderMapper;

    // 根据时间区间统计营业额
    public TurnoverReportVO getTurnover(LocalDate begin, LocalDate end) {
        List<LocalDate> dateList = new ArrayList<>();
        dateList.add(begin);
        while (!begin.equals(end)){
            begin = begin.plusDays(1);//日期计算，获得指定日期后1天的日期
            dateList.add(begin);
        }
        List<Double> turnoverList = new ArrayList<>();
        for (LocalDate date : dateList) {
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
            Map<String,Object> map = new HashMap<>();
            map.put("status", Orders.COMPLETED); // 5：完成订单
            map.put("begin",beginTime); // 0点
            map.put("end", endTime); // 24点
            LambdaQueryWrapper<Orders> wrapper = new LambdaQueryWrapper<>();
            wrapper.eq(map.get("status")!=null,Orders::getStatus,map.get("status"));
            // gt大于，Lt小于
            wrapper.gt(map.get("begin")!=null,Orders::getOrderTime,map.get("begin"));
            wrapper.lt(map.get("end")!=null,Orders::getOrderTime,map.get("end"));
            // 只去查询amount字段
            wrapper.select(Orders::getAmount);
            List<Orders> orders = orderMapper.selectList(wrapper);
            // 计算当天amount之和
            BigDecimal totalAmount = orders.stream()
                      .map(Orders::getAmount) // 提取每个订单的amount字段
                      .reduce(BigDecimal.ZERO, BigDecimal::add); // 执行累加操作
            // 将bigdecimal转换成double类型
            Double turnover = totalAmount.doubleValue();
            turnover = turnover == null ? 0.0 : turnover;
            turnoverList.add(turnover);
        }

        //数据封装，使用字符串拼接的返回结果
        return TurnoverReportVO.builder()
                .dateList(StringUtils.join(dateList,","))
                .turnoverList(StringUtils.join(turnoverList,","))
                .build();
    }
}
```



### 功能测试

可以通过如下方式进行测试：

> - 接口文档测试
> - 前后端联调测试
> - 启动服务器，启动nginx，直接采用前后端联调测试。

> 进入数据统计模块
>

> **查看近7日营业额统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230711195604621.png" alt="image-20230711195604621" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101172807757.png" alt="image-20230101172807757" style="zoom:50%;" /> 

> 进入开发者模式，查看返回数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101173031357.png" alt="image-20230101173031357" style="zoom:80%;" /> 

> **查看近30日营业额统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101173201667.png" alt="image-20230101173201667" style="zoom:50%;" /> 

进入开发者模式，查看返回数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230101173304127.png" alt="image-20230101173304127" style="zoom:80%;" /> 

也可通过断点方式启动，查看每步执行情况。



### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107183427167.png" alt="image-20230107183427167" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。



## 用户统计

### 需求设计

#### 产品原型

> 所谓用户统计，实际上统计的是用户的数量。通过折线图来展示，上面这根蓝色线代表的是用户总量，下边这根绿色线代表的是新增用户数量，是具体到每一天。所以说用户统计主要统计**两个数据**，一个是**总的用户数量**，另外一个是**新增用户数量**。
>

**原型图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230102213727736.png" alt="image-20230102213727736" style="zoom:50%;" /> 

**业务规则：**

> - 基于可视化报表的折线图展示用户数据，X轴为日期，Y轴为用户数
> - 根据时间选择区间，展示每天的用户总量和新增用户量数据

#### 接口设计

根据上述原型图设计接口。


### 代码开发⭐

#### VO层 

> 在sky-pojo模块，UserReportVO.java已定义
>

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserReportVO implements Serializable {

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //用户总量，以逗号分隔，例如：200,210,220
    private String totalUserList;

    //新增用户，以逗号分隔，例如：20,21,10
    private String newUserList;

}
```

#### Controller层

> **根据接口定义，在ReportController中创建userStatistics方法**

```java
// 用户数据统计
@GetMapping("/userStatistics")
@ApiOperation("用户数据统计")
public Result userStatistics(
        @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
        @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end){
    return Result.success(reportService.getUserStatistics(begin,end));
}
```

#### Service层接口

> **在ReportService接口中声明getUserStatistics方法**

```java
public interface ReportService {

    // 根据时间区间统计营业额
    TurnoverReportVO getTurnover(LocalDate beginTime, LocalDate endTime);
    // 根据时间区间统计用户数量
    Object getUserStatistics(LocalDate begin, LocalDate end);
}
```

> **在ReportServiceImpl实现类中实现getUserStatistics方法**

```java
@Resource
private UserService userService;


@Override
public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) {
    List<LocalDate> dateList = new ArrayList<>();
    dateList.add(begin);

    while (!begin.equals(end)){
        begin = begin.plusDays(1);
        dateList.add(begin);
    }
    List<Long> newUserList = new ArrayList<>(); //新增用户数
    List<Long> totalUserList = new ArrayList<>(); //总用户数

    for (LocalDate date : dateList) {
        LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
        //新增用户数量 select count(id) from user where create_time > ? and create_time < ?
        Long newUser = getUserCount(beginTime, endTime);
        //总用户数量 select count(id) from user where  create_time < ?
        Long totalUser = getUserCount(null, endTime);
        newUserList.add(newUser);
        totalUserList.add(totalUser);
    }

    return UserReportVO.builder()
             // 将列表转换成字符串返回
            .dateList(StringUtils.join(dateList,","))
            .newUserList(StringUtils.join(newUserList,","))
            .totalUserList(StringUtils.join(totalUserList,","))
            .build();
}

private Long getUserCount(LocalDateTime beginTime, LocalDateTime endTime) {
    LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
    wrapper.gt(beginTime!=null,User::getCreateTime,beginTime);
    wrapper.lt(endTime!=null,User::getCreateTime,endTime);
    return userService.count(wrapper);
}
```

### 功能测试

可以通过如下方式进行测试：

> - 接口文档测试
> - 前后端联调测试

进入数据统计模块

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712090612145.png" alt="image-20230712090612145" style="zoom:80%;" />

> **查看近7日用户统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107191339668.png" alt="image-20230107191339668" style="zoom:50%;" /> 

> 进入开发者模式，查看返回数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107191532175.png" alt="image-20230107191532175" style="zoom:50%;" /> 

> **查看近30日用户统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107191613369.png" alt="image-20230107191613369" style="zoom:50%;" /> 

> 进入开发者模式，查看返回数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107191707568.png" alt="image-20230107191707568" style="zoom:50%;" /> 

也可通过断点方式启动，查看每步执行情况。

## 订单统计

### 需求设计

#### 产品原型

> 订单统计通过一个折现图来展现，折线图上有两根线，这根蓝色的线代表的是订单总数，而下边这根绿色的线代表的是有效订单数，指的就是状态是已完成的订单就属于有效订单，分别反映的是每一天的数据。上面还有3个数字，分别是订单总数、有效订单、订单完成率，指的是整个时间区间之内总的数据
>

**原型图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107192859270.png" alt="image-20230107192859270" style="zoom:50%;" /> 

**业务规则：**

> - 有效订单指状态为 “已完成” 的订单
> - 基于可视化报表的折线图展示订单数据，X轴为日期，Y轴为订单数量
> - 根据时间选择区间，展示每天的订单总数和有效订单数
> - 所选时间区间内的有效订单数、总订单数、订单完成率，订单完成率 = 有效订单数 / 总订单数 * 100%

#### 接口设计

> 根据上述原型图设计接口。
>


### 代码开发⭐

#### VO层

> **根据订单统计接口的返回结果设计VO**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107195325915.png" alt="image-20230107195325915" style="zoom:50%;" /> 

> 在sky-pojo模块，OrderReportVO.java已定义
>

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderReportVO implements Serializable {

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //每日订单数，以逗号分隔，例如：260,210,215
    private String orderCountList;

    //每日有效订单数，以逗号分隔，例如：20,21,10
    private String validOrderCountList;

    //订单总数
    private Long totalOrderCount;

    //有效订单数
    private Long validOrderCount;

    //订单完成率
    private Double orderCompletionRate;

}
```

#### Controller层

> **在ReportController中根据订单统计接口创建orderStatistics方法**

```java
// 订单数据统计
@GetMapping("/ordersStatistics")
@ApiOperation("用户数据统计")
public Result orderStatistics(
        @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
        @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end){
    return Result.success(reportService.getOrderStatistics(begin,end));
}
```

#### Service层接口

> **在ReportService接口中声明getOrderStatistics方法**

```java
public interface ReportService {

    // 根据时间区间统计营业额
    TurnoverReportVO getTurnover(LocalDate beginTime, LocalDate endTime);
    // 根据时间区间统计用户数量
    Object getUserStatistics(LocalDate begin, LocalDate end);
    // 订单数据统计
    Object getOrderStatistics(LocalDate begin, LocalDate end);
}
```

#### Service层实现类

> **在ReportServiceImpl实现类中实现getOrderStatistics方法**

```java
@Resource
private OrderService orderService;

// 根据时间区间统计订单数量
public OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end){
    List<LocalDate> dateList = new ArrayList<>();
    dateList.add(begin);

    while (!begin.equals(end)){
        begin = begin.plusDays(1);
        dateList.add(begin);
    }
    //每天订单总数集合
    List<Long> orderCountList = new ArrayList<>();
    //每天有效订单数集合
    List<Long> validOrderCountList = new ArrayList<>();
    for (LocalDate date : dateList) {
        LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
        //查询每天的总订单数 select count(id) from orders 
        //where order_time > ? and order_time < ?
        Long orderCount = getOrderCount(beginTime, endTime, null);

        //查询每天的有效订单数 select count(id) from orders 
        //where order_time > ? and order_time < ? and status = ?
        Long validOrderCount = getOrderCount(beginTime, endTime, Orders.COMPLETED);

        orderCountList.add(orderCount);
        validOrderCountList.add(validOrderCount);
    }

    //时间区间内的总订单数
    Long totalOrderCount = orderCountList.stream().reduce(Long::sum).get();
    //时间区间内的总有效订单数
    Long validOrderCount = validOrderCountList.stream().reduce(Long::sum).get();
    //订单完成率
    Double orderCompletionRate = 0.0;
    if(totalOrderCount != 0){
        orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
    }
    return OrderReportVO.builder()
            .dateList(StringUtils.join(dateList, ","))
            .orderCountList(StringUtils.join(orderCountList, ","))
            .validOrderCountList(StringUtils.join(validOrderCountList, ","))
            .totalOrderCount(totalOrderCount)
            .validOrderCount(validOrderCount)
            .orderCompletionRate(orderCompletionRate)
            .build();

}

private Long getOrderCount(LocalDateTime beginTime, LocalDateTime endTime, 
                           Object OrderStatus) {
    LambdaQueryWrapper<Orders> wrapper = new LambdaQueryWrapper<>();
    wrapper.gt(beginTime!=null,Orders::getOrderTime,beginTime);
    wrapper.lt(endTime!=null,Orders::getOrderTime,endTime);
    wrapper.eq(OrderStatus != null, Orders::getStatus,OrderStatus);
    return orderService.count(wrapper);
}
```

### 功能测试

可以通过如下方式进行测试：

> - 接口文档测试
> - 前后端联调

> 重启服务，直接采用前后端联调测试。进入数据统计模块
>

> **查看近7日订单统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107202854533.png" alt="image-20230107202854533" style="zoom:50%;" /> 

进入开发者模式，查看返回数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107202953128.png" alt="image-20230107202953128" style="zoom:50%;" /> 

> **查看近30日订单统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107203025165.png" alt="image-20230107203025165" style="zoom:50%;" /> 

> 进入开发者模式，查看返回数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107203127308.png" alt="image-20230107203127308" style="zoom:50%;" /> 

> 也可通过断点方式启动，查看每步执行情况。
>

### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107203344774.png" alt="image-20230107203344774" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。



## 销量排名⭐

### 需求设计

#### 产品原型

> 所谓销量排名，销量指的是商品销售的数量。项目当中的商品主要包含两类：一个是**套餐**，一个是**菜品**，所以销量排名其实指的就是菜品和套餐销售的数量排名。通过柱形图来展示销量排名，这些销量是按照降序来排列，并且只需要统计销量排名前十的商品。
>

**原型图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107203622747.png" alt="image-20230107203622747" style="zoom:50%;" /> 

**业务规则：**

> - 根据时间选择区间，展示销量前10的商品（包括菜品和套餐）
> - 基于可视化报表的柱状图降序展示商品销量
> - 此处的销量为商品销售的份数

#### 接口设计

根据上述原型图设计接口。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107203720606.png" alt="image-20230107203720606" style="zoom:50%;" />

### 代码开发

#### VO设计

> **根据销量排名接口的返回结果设计VO**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107204028895.png" alt="image-20230107204028895" style="zoom:50%;" /> 

> 在sky-pojo模块，SalesTop10ReportVO.java已定义
>

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SalesTop10ReportVO implements Serializable {

    //商品名称列表，以逗号分隔，例如：鱼香肉丝,宫保鸡丁,水煮鱼
    private String nameList;

    //销量列表，以逗号分隔，例如：260,215,200
    private String numberList;

}
```

#### Controller层

> **在ReportController中根据销量排名接口创建top10方法**

```java
// 销量排名统计
@GetMapping("/top10")
@ApiOperation("销量排名统计")
public Result top10(
    @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate begin,
    @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate end){
	return Result.success(reportService.getSalesTop10(begin,end));
}
```

#### Service层接口

> **在ReportService接口中声明getSalesTop10方法**

```java
public interface ReportService {

    // 根据时间区间统计营业额
    TurnoverReportVO getTurnover(LocalDate beginTime, LocalDate endTime);
    // 根据时间区间统计用户数量
    Object getUserStatistics(LocalDate begin, LocalDate end);
    // 订单数据统计
    Object getOrderStatistics(LocalDate begin, LocalDate end);
    // 查询指定时间区间内的销量排名top10 
    Object getSalesTop10(LocalDate begin, LocalDate end);
}
```

#### Service层实现类

> **在ReportServiceImpl实现类中实现getSalesTop10方法**

```java
// 查询指定时间区间内的销量排名top10
public SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end){
    LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
    LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);
    // 进行查询(写SQL进行查询)
    List<GoodsSalesDTO> goodsSalesDTOList = orderMapper
                                            .getSalesTop10(beginTime, endTime);
    String nameList = StringUtils.join(goodsSalesDTOList.stream()
                                 .map(GoodsSalesDTO::getName)
                                 .collect(Collectors.toList()),",");
    String numberList =  StringUtils.join(goodsSalesDTOList.stream()
                                    .map(GoodsSalesDTO::getNumber)
                                    .collect(Collectors.toList()),",");

    return SalesTop10ReportVO.builder()
            .nameList(nameList)
            .numberList(numberList)
            .build();
}
```

#### Mapper层

> **在OrderMapper接口中声明getSalesTop10方法**

```java
@Mapper
public interface OrderMapper extends BaseMapper<Orders> {

    //查询商品销量排名
    List<GoodsSalesDTO> getSalesTop10(@Param("begin") LocalDateTime beginTime,
                                      @Param("end") LocalDateTime endTime);
}
```

> **在OrderMapper.xml文件中编写动态SQL**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >

<mapper namespace="com.sky.mapper.OrderMapper">
    <select id="getSalesTop10" resultType="com.sky.dto.GoodsSalesDTO">
        select od.name name,sum(od.number) number from order_detail od ,orders o
        where od.order_id = o.id
        and o.status = 5
        <if test="begin != null">
            and order_time &gt;= #{begin}
        </if>
        <if test="end != null">
            and order_time &lt;= #{end}
        </if>
        group by name
        order by number desc
        limit 0, 10
    </select>
</mapper>
```

### 功能测试

可以通过如下方式进行测试：

> - 接口文档测试
> - 前后端联调

重启服务，直接采用前后端联调测试。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712095306425.png" alt="image-20230712095306425" style="zoom:80%;" />

**查看近30日销量排名Top10统计**

> 若查询的某一段时间没有销量数据，则显示不出效果。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107210518821.png" alt="image-20230107210518821" style="zoom:50%;" />

> 使用数据生成一堆数据后

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712095114536.png" alt="image-20230712095114536" style="zoom:80%;" />

> 进入开发者模式，查看返回数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107210711326.png" alt="image-20230107210711326" style="zoom:50%;" /> 

> 也可通过断点方式启动，查看每步执行情况。
>

### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230107210835115.png" alt="image-20230107210835115" style="zoom:50%;" /> 

> 后续步骤和其它功能代码提交一致，不再赘述。
>



# 工作台 & Excel报表

## 课程内容

> - 工作台
> - Apache POI
> - 导出运营数据Excel报表

> 功能实现：**工作台**、**数据导出**
>

> **工作台效果图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130190031553.png" alt="image-20230130190031553" style="zoom: 50%;" />  

> **数据导出效果图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130190124725.png" alt="image-20230130190124725" style="zoom: 50%;" />   

> 在数据统计页面点击**数据导出**：生成Excel报表
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130190243865.png" alt="image-20230130190243865" style="zoom: 50%;" />    

## 工作台

### 需求设计

#### 产品原型

> 工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率。
>

**工作台展示的数据：**

> - 今日数据
> - 订单管理
> - 菜品总览
> - 套餐总览
> - 订单信息

**原型图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130191051003.png" alt="image-20230130191051003" style="zoom:50%;" /> 

**名词解释：**

> - 营业额：已完成订单的总金额
> - 有效订单：已完成订单的数量
> - 订单完成率：有效订单数 / 总订单数 * 100%
> - 平均客单价：营业额 / 有效订单数
> - 新增用户：新增用户的数量

#### 接口设计

> 通过上述原型图分析，共包含6个接口。
>

**接口设计：**

> - 今日数据接口
> - 订单管理接口
> - 菜品总览接口
> - 套餐总览接口
> - 订单搜索（已完成）
> - 各个状态的订单数量统计（已完成）

> **今日数据的接口设计**


> **订单管理的接口设计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130192105373.png" alt="image-20230130192105373" style="zoom:50%;" /> 

> **菜品总览的接口设计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130192225168.png" alt="image-20230130192225168" style="zoom:50%;" /> 

> **套餐总览的接口设计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130195425389.png" alt="image-20230130195425389" style="zoom:50%;" /> 

### 基础代码

#### WorkSpaceController

```java
// 工作台
@RestController
@RequestMapping("/admin/workspace")
@Slf4j
@Api(tags = "工作台相关接口")
public class WorkSpaceController {

    @Resource
    private WorkspaceService workspaceService;

}
```

#### WorkspaceService

```java
public interface WorkspaceService {

    // 根据时间段统计营业数据
    BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end);

    // 查询订单管理数据
    OrderOverViewVO getOrderOverView();

    // 查询菜品总览
    DishOverViewVO getDishOverView();

    // 查询套餐总览
    SetmealOverViewVO getSetmealOverView();

}
```

#### WorkspaceServiceImpl

```java
@Service
@Slf4j
public class WorkspaceServiceImpl implements WorkspaceService {

    @Resource
    private OrderMapper orderMapper;

    @Resource
    private UserMapper userMapper;

    @Resource
    private DishMapper dishMapper;

    @Resource
    private SetmealMapper setmealMapper;
    
}
```

### 今日数据⭐

#### VO层

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BusinessDataVO implements Serializable {

    private Double turnover;//营业额

    private Integer validOrderCount;//有效订单数

    private Double orderCompletionRate;//订单完成率

    private Double unitPrice;//平均客单价

    private Integer newUsers;//新增用户数

}
```

#### Controller层

> 无需传入参数，因为查的是今天的数据

```java
// 工作台今日数据查询
@GetMapping("/businessData")
@ApiOperation("工作台今日数据查询")
public Result<BusinessDataVO> businessData(){
    //获得当天的开始时间
    LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN);
    //获得当天的结束时间
    LocalDateTime end = LocalDateTime.now().with(LocalTime.MAX);
    BusinessDataVO businessDataVO = workspaceService.getBusinessData(begin, end);
    return Result.success(businessDataVO);
}
```

#### Service层

```java
// 根据时间段统计营业数据
BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end);
```

```java
// 根据时间段统计营业数据
public BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end) {
     // 营业额：当日已完成订单的总金额
     // 有效订单：当日已完成订单的数量
     // 订单完成率：有效订单数 / 总订单数
     // 平均客单价：营业额 / 有效订单数
     // 新增用户：当日新增用户的数量
    Map<String,Object> map = new HashMap<>();
    map.put("begin",begin);
    map.put("end",end);
    // 查询总订单数量
    Integer totalOrderCount = orderMapper.countByMap(map);
    map.put("status", Orders.COMPLETED);
    //营业额
    Double turnover = orderMapper.sumByMap(map);
    turnover = turnover == null? 0.0 : turnover;
    //有效订单数
    Integer validOrderCount = orderMapper.countByMap(map);
    Double unitPrice = 0.0;
    Double orderCompletionRate = 0.0;
    if(totalOrderCount != 0 && validOrderCount != 0){
        //订单完成率
        orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
        //平均客单价
        unitPrice = turnover / validOrderCount;
    }
    //新增用户数
    Integer newUsers = userMapper.countByMap(map);
    return BusinessDataVO.builder()
            .turnover(turnover)
            .validOrderCount(validOrderCount)
            .orderCompletionRate(orderCompletionRate)
            .unitPrice(unitPrice)
            .newUsers(newUsers)
            .build();
}
```

#### Mapper层

```java
public interface UserMapper extends BaseMapper<User> {
    // 根据动态条件统计用户数量
    Integer countByMap(Map<String,Object> map);
}
```

```java
@Mapper
public interface OrderMapper extends BaseMapper<Orders> {

    // 根据状态和下单时间查询订单
    ...

    // 根据动态条件统计营业额数据
    Double sumByMap(Map<String,Object> map);

    // 根据动态条件统计订单数量
    Integer countByMap(Map<String,Object> map);
    
}
```

```sql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.UserMapper">

    <select id="countByMap" resultType="java.lang.Integer">
        select count(id) from user
        <where>
            <if test="begin != null">
                and create_time &gt; #{begin}
            </if>
            <if test="end != null">
                and create_time &lt; #{end}
            </if>
        </where>
    </select>

</mapper>
```

```sql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.OrderMapper">

    <select id="sumByMap" resultType="java.lang.Double">
        select sum(amount) from orders
        <where>
            <if test="begin != null">
                and order_time &gt; #{begin}
            </if>
            <if test="end != null">
                and order_time &lt; #{end}
            </if>
            <if test="status != null">
                and status = #{status}
            </if>
        </where>
    </select>

    <select id="countByMap" resultType="java.lang.Integer">
        select count(id) from orders
        <where>
            <if test="begin != null">
                and order_time &gt; #{begin}
            </if>
            <if test="end != null">
                and order_time &lt; #{end}
            </if>
            <if test="status != null">
                and status = #{status}
            </if>
        </where>
    </select>
    
</mapper>
```

#### 功能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712103110796.png" alt="image-20230712103110796" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712103126871.png" alt="image-20230712103126871" style="zoom:80%;" />

### 订单管理

#### VO层

```java
// 订单概览数据
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderOverViewVO implements Serializable {
    //待接单数量
    private Integer waitingOrders;

    //待派送数量
    private Integer deliveredOrders;

    //已完成数量
    private Integer completedOrders;

    //已取消数量
    private Integer cancelledOrders;

    //全部订单
    private Integer allOrders;
}
```

#### Controller层

```java
// 查询订单管理数据
@GetMapping("/overviewOrders")
@ApiOperation("查询订单管理数据")
public Result<OrderOverViewVO> orderOverView(){
    return Result.success(workspaceService.getOrderOverView());
}
```

#### Service层

```java
// 查询订单管理数据
OrderOverViewVO getOrderOverView();
```

```java
// 查询订单管理数据
public OrderOverViewVO getOrderOverView() {
    Map<String,Object> map = new HashMap<>();
    map.put("begin", LocalDateTime.now().with(LocalTime.MIN));
    map.put("status", Orders.TO_BE_CONFIRMED);
    //待接单
    Integer waitingOrders = orderMapper.countByMap(map);
    //待派送
    map.put("status", Orders.CONFIRMED);
    Integer deliveredOrders = orderMapper.countByMap(map);
    //已完成
    map.put("status", Orders.COMPLETED);
    Integer completedOrders = orderMapper.countByMap(map);
    //已取消
    map.put("status", Orders.CANCELLED);
    Integer cancelledOrders = orderMapper.countByMap(map);
    //全部订单
    map.put("status", null);
    Integer allOrders = orderMapper.countByMap(map);

    return OrderOverViewVO.builder()
            .waitingOrders(waitingOrders)
            .deliveredOrders(deliveredOrders)
            .completedOrders(completedOrders)
            .cancelledOrders(cancelledOrders)
            .allOrders(allOrders)
            .build();
}
```

#### Mapper层

> 在今日查询中已经实现了订单数据的统计查询，因此此处不用写

#### 功能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712103708960.png" alt="image-20230712103708960" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712103732469.png" alt="image-20230712103732469" style="zoom:80%;" />

### 菜品总览

#### VO层

```java
// 菜品总览
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DishOverViewVO implements Serializable {
    // 已启售数量
    private Integer sold;

    // 已停售数量
    private Integer discontinued;
}
```

#### Controller层

```java
// 查询菜品总览
@GetMapping("/overviewDishes")
@ApiOperation("查询菜品总览")
public Result<DishOverViewVO> dishOverView(){
    return Result.success(workspaceService.getDishOverView());
}
```

#### Service层

```java
// 查询菜品总览
DishOverViewVO getDishOverView();
```

```java
// 查询菜品总览
public DishOverViewVO getDishOverView() {
    Map<String,Object> map = new HashMap<>();
    map.put("status", StatusConstant.ENABLE);
    Integer sold = dishMapper.countByMap(map);

    map.put("status", StatusConstant.DISABLE);
    Integer discontinued = dishMapper.countByMap(map);

    return DishOverViewVO.builder()
            .sold(sold)
            .discontinued(discontinued)
            .build();
}
```

#### Mapper层

```java
@Mapper
public interface DishMapper extends BaseMapper<Dish> {

    // 根据分类id查询菜品数量
    @Select("select count(id) from dish where category_id = #{categoryId}")
    Integer countByCategoryId(Long categoryId);

    // 根据条件统计菜品数量
    Integer countByMap(Map<String,Object> map);

}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.DishMapper">
    <select id="countByMap" resultType="java.lang.Integer">
        select count(id) from dish
        <where>
            <if test="status != null">
                and status = #{status}
            </if>
            <if test="categoryId != null">
                and category_id = #{categoryId}
            </if>
        </where>
    </select>
</mapper>
```

#### 功能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712105327633.png" alt="image-20230712105327633" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712105307185.png" alt="image-20230712105307185" style="zoom:80%;" />



### 套餐总览

#### VO层

```java
// 套餐总览
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SetmealOverViewVO implements Serializable {
    // 已启售数量
    private Integer sold;

    // 已停售数量
    private Integer discontinued;
}
```

#### Controller层

```java
// 查询套餐总览
@GetMapping("/overviewSetmeals")
@ApiOperation("查询套餐总览")
public Result<SetmealOverViewVO> setmealOverView(){
    return Result.success(workspaceService.getSetmealOverView());
}
```

#### Service层

```java
// 查询套餐总览
SetmealOverViewVO getSetmealOverView();
```

```java
// 查询套餐总览
public SetmealOverViewVO getSetmealOverView() {
    Map<String,Object> map = new HashMap<>();
    map.put("status", StatusConstant.ENABLE);
    Integer sold = setmealMapper.countByMap(map);

    map.put("status", StatusConstant.DISABLE);
    Integer discontinued = setmealMapper.countByMap(map);

    return SetmealOverViewVO.builder()
            .sold(sold)
            .discontinued(discontinued)
            .build();
}
```

#### Mapper层

```java
// 根据条件统计套餐数量
Integer countByMap(Map<String,Object> map);
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.SetmealMapper">
    <select id="countByMap" resultType="java.lang.Integer">
        select count(id) from setmeal
        <where>
            <if test="status != null">
                and status = #{status}
            </if>
            <if test="categoryId != null">
                and category_id = #{categoryId}
            </if>
        </where>
    </select>
</mapper>
```

#### 功能测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712110001719.png" alt="image-20230712110001719" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712105935069.png" alt="image-20230712105935069" style="zoom:80%;" />

### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131105528906.png" alt="image-20230131105528906" style="zoom:50%;" /> 

后续步骤和其它功能代码提交一致，不再赘述。



## Apache POI

### 基本概述

> Apache POI 是一个处理Miscrosoft Office各种文件格式的开源项目。简单来说就是，我们可以使用 POI 在 Java 程序中对Miscrosoft Office各种文件进行读写操作。一般情况下，POI 都是用于操作 Excel 文件。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131110631081.png" alt="image-20230131110631081" style="zoom:50%;" /> 

**Apache POI 的应用场景：**

> 银行网银系统导出交易明细
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131110810568.png" alt="image-20230131110810568" style="zoom:50%;" /> 

> 各种业务系统导出Excel报表
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131110839959.png" alt="image-20230131110839959" style="zoom:50%;" /> 

> 批量导入业务数据
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131110856903.png" alt="image-20230131110856903" style="zoom:50%;" /> 

### 实战演练

> Apache POI既可以将数据写入Excel文件，也可以读取Excel文件中的数据，接下来分别进行实现。

#### Maven坐标

```xml
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>3.16</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>3.16</version>
</dependency>
```

#### 将数据写入Excel文件

```java
public class POITest {

    // 基于POI向Excel文件写入数据
    public static void write() throws Exception{
        //在内存中创建一个Excel文件对象
        XSSFWorkbook excel = new XSSFWorkbook();
        //创建Sheet页(多个sheet页)
        XSSFSheet sheet = excel.createSheet("itcast");

        //在Sheet页中创建行，0表示第1行，编号从0开始
        XSSFRow row1 = sheet.createRow(0);
        //创建单元格并在单元格中设置值，单元格编号也是从0开始，1表示第2个单元格
        row1.createCell(1).setCellValue("姓名");
        row1.createCell(2).setCellValue("城市");

        XSSFRow row2 = sheet.createRow(1);
        row2.createCell(1).setCellValue("张三");
        row2.createCell(2).setCellValue("北京");

        XSSFRow row3 = sheet.createRow(2);
        row3.createCell(1).setCellValue("李四");
        row3.createCell(2).setCellValue("上海");

        FileOutputStream out = new FileOutputStream(new File("D:\\itcast.xlsx"));
        //通过输出流将内存中的Excel文件写入到磁盘上
        excel.write(out);

        //关闭资源
        out.flush();
        out.close();
        excel.close();
    }
    public static void main(String[] args) throws Exception {
        write();
    }
}
```

> **实现效果**

> 在根目录生成itcast.xlsx文件，创建名称为itcast的Sheet页，同时将内容成功写入。
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131112905034.png" alt="image-20230131112905034" style="zoom:50%;" /> 

#### 读取Excel文件中的数据

> **代码开发**

```java
public class POITest {
    // 基于POI读取Excel文件
    public static void read() throws Exception{
        FileInputStream in = new FileInputStream(new File("D:\\itcast.xlsx"));
        //通过输入流读取指定的Excel文件
        XSSFWorkbook excel = new XSSFWorkbook(in);
        //获取Excel文件的第1个Sheet页
        XSSFSheet sheet = excel.getSheetAt(0);

        //获取Sheet页中的最后一行的行号(有文字的)
        int lastRowNum = sheet.getLastRowNum();

        for (int i = 0; i <= lastRowNum; i++) {
            //获取Sheet页中的行
            XSSFRow titleRow = sheet.getRow(i);
            //获取行的第2个单元格
            XSSFCell cell1 = titleRow.getCell(1);
            //获取单元格中的文本内容
            String cellValue1 = cell1.getStringCellValue();
            //获取行的第3个单元格
            XSSFCell cell2 = titleRow.getCell(2);
            //获取单元格中的文本内容
            String cellValue2 = cell2.getStringCellValue();
            System.out.println(cellValue1 + " " +cellValue2);
        }

        //关闭资源
        in.close();
        excel.close();
    }

    public static void main(String[] args) throws Exception {
        read();
    }
}
```

> **实现效果**：将itcast.xlsx文件中的数据进行读取

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131113255962.png" alt="image-20230131113255962" style="zoom:50%;" /> 

## 运营数据Excel报表

### 需求设计

#### 产品原型

> 在数据统计页面，有一个数据导出的按钮，点击该按钮时，其实就会下载一个文件。这个文件实际上是一个Excel形式的文件，文件中主要包含最近30日运营相关的数据。表格的形式已经固定，主要由概览数据和明细数据两部分组成。真正导出这个报表之后，相对应的数字就会填充在表格中，就可以进行存档。
>

**原型图：**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131151132672.png" alt="image-20230131151132672" style="zoom:50%;" /> 

> 导出的Excel报表格式：
>

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130201026785.png" alt="image-20230130201026785" style="zoom: 67%;" />  

**业务规则：**

> - 导出Excel形式的报表文件
> - 导出最近30天的运营数据

#### 接口设计

通过上述原型图设计对应的接口。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230130201109280.png" alt="image-20230130201109280" style="zoom:50%;" /> 

**注意：**

> - 当前接口没有传递参数，因为导出的是最近30天的运营数据，后端计算即可，所以不需要任何参数
>
> - 当前接口没有返回数据，因为报表导出功能本质上是文件下载，服务端会通过输出流将Excel文件下载到客户端浏览器

### 代码开发⭐

#### 实现步骤

> 核心：**模板文件先设计，然后再往模板文件内写入数据**

> 1). 设计Excel模板文件
>
> 2). 查询近30天的运营数据
>
> 3). 将查询到的运营数据写入模板文件
>
> 4). 通过输出流将Excel文件下载到客户端浏览器

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131152610559.png" alt="image-20230131152610559" style="zoom:50%;" /> 

#### Controller层

> **根据接口定义，在ReportController中创建export方法**

```java
// 导出运营数据报表
@GetMapping("/export")
@ApiOperation("导出运营数据报表")
public void export(HttpServletResponse response){
    reportService.exportBusinessData(response);
}
```

#### Service层接口

**在ReportService接口中声明导出运营数据报表的方法：**

```java
// 导出近30天的运营数据报表
void exportBusinessData(HttpServletResponse response);
```

#### Service层实现类

> **在ReportServiceImpl实现类中实现导出运营数据报表的方法:**

> 提前将资料中的**运营数据报表模板.xlsx**拷贝到项目的resources/template目录中

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712142031421.png" alt="image-20230712142031421" style="zoom:80%;" />

```java
// 使用的是上面的工作台查询数据的接口
@Resource
private WorkspaceService workspaceService;

// 导出近30天的运营数据报表
public void exportBusinessData(HttpServletResponse response) {
    LocalDate begin = LocalDate.now().minusDays(30);
    LocalDate end = LocalDate.now().minusDays(1);
    //查询概览运营数据，提供给Excel模板文件
    BusinessDataVO businessData = workspaceService
            .getBusinessData(LocalDateTime.of(begin,LocalTime.MIN),
                             LocalDateTime.of(end, LocalTime.MAX));
    try {
        FileInputStream inputStream = new FileInputStream(new File("G:\\1、黑马程序员Java项目《苍穹外卖》企业级开发实战\\资料\\day01\\后端初始工程\\sky-take-out\\sky-server\\src\\main\\resources\\template\\运营数据报表模板.xlsx"));
        //基于提供好的模板文件创建一个新的Excel表格对象
        XSSFWorkbook excel = new XSSFWorkbook(inputStream);
        //获得Excel文件中的一个Sheet页
        XSSFSheet sheet = excel.getSheet("Sheet1");

        sheet.getRow(1).getCell(1).setCellValue(begin + "至" + end);
        //获得第4行
        XSSFRow row = sheet.getRow(3);
        //获取单元格
        row.getCell(2).setCellValue(businessData.getTurnover());
        row.getCell(4).setCellValue(businessData.getOrderCompletionRate());
        row.getCell(6).setCellValue(businessData.getNewUsers());
        row = sheet.getRow(4);
        row.getCell(2).setCellValue(businessData.getValidOrderCount());
        row.getCell(4).setCellValue(businessData.getUnitPrice());
        for (int i = 0; i < 30; i++) {
            LocalDate date = begin.plusDays(i);
            //准备明细数据
            businessData = workspaceService
                    .getBusinessData(LocalDateTime.of(date,LocalTime.MIN),
                                     LocalDateTime.of(date, LocalTime.MAX));
            row = sheet.getRow(7 + i);
            row.getCell(1).setCellValue(date.toString());
            row.getCell(2).setCellValue(businessData.getTurnover());
            row.getCell(3).setCellValue(businessData.getValidOrderCount());
            row.getCell(4).setCellValue(businessData.getOrderCompletionRate());
            row.getCell(5).setCellValue(businessData.getUnitPrice());
            row.getCell(6).setCellValue(businessData.getNewUsers());
        }
        //通过输出流将文件下载到客户端浏览器中
        ServletOutputStream out = response.getOutputStream();
        excel.write(out);
        //关闭资源
        out.flush();
        out.close();
        excel.close();

    }catch (IOException e){
        e.printStackTrace();
    }
}
```

### 功能测试

> 直接使用前后端联调测试。
>

> **进入数据统计**

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131155111294.png" alt="image-20230131155111294" style="zoom:50%;" /> 

> **点击数据导出**：Excel报表下载成功

​                 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131160647328.png" alt="image-20230131160647328" style="zoom: 67%;" /> 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.8.17/image-20230712143326004.png" alt="image-20230712143326004" style="zoom: 80%;" />

### 代码提交

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.6.17/image-20230131160929202.png" alt="image-20230131160929202" style="zoom:50%;" /> 

> 后续步骤和其它功能代码提交一致，不再赘述。
>



































