

# 鹰眼轨迹服务

## 鹰眼轨迹介绍

- 鹰眼是一套轨迹管理服务，提供各端SDK和API供开发者便捷接入，追踪所管理的车辆/人员等运动物体。
- 基于鹰眼提供的接口和云端服务，开发者可以迅速构建一套完全属于您自己的完整、精准且高性能的轨迹管理系统，可应用于车队管理、人员管理等领域。文档：https://lbsyun.baidu.com/index.php?title=yingyan 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207151648980.png" alt="image-20220715164835886" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303140947690.png" alt="image-20230314094728598" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303140947185.png" alt="image-20230314094744030" style="zoom:80%;" />

## 鹰眼轨迹基本概念

### service 

> 一个service（即鹰眼轨迹服务）对应一个轨迹管理系统，一个service里可管理多个终端设备（即entity），service的唯一标识符是service_id。

### entity

> 一个entity代表现实中一个被追踪轨迹的终端设备，它可以是一个人、一辆车或者任何运动物体。同一个service中，entity以entity_name作为唯一标识。

### track

> entity移动所产生的连续轨迹被称为track，track由一系列轨迹点（point）组成。

### fence

> fence即地理围栏，是指一定范围（如：圆形、多边形、线型、行政区）的虚拟地理区域。当entity进入/离开该区域时，鹰眼将自动推送报警至开发者。开发者接收到报警后，可进行业务处理。

更多说明：https://lbsyun.baidu.com/index.php?title=yingyan/guide/concept 

## 权限与配额

鹰眼开发者的使用权限包括：

### 数据存储

- 开发者可向自己的鹰眼服务中上传轨迹数据。
- 鹰眼将为开发者存储最近1年的轨迹数据。
- 若需保留1年之外的轨迹数据，需要自己查询或导出数据进行自行存储。

### 数据访问

- 开发者创建的鹰眼服务可被该帐号下的ak访问，除非开发者授权，否则不可被其他用户访问。
- 鹰眼轨迹管理台提供授权功能，支持开发者将自有 service 授权给其他开发者访问。

开放平台的每一类 API 都有调用配额限制，配额为帐号下所有ak和service共用。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207151651391.png" alt="image-20220715165113342" style="zoom:67%;" />

详细的配额说明参见：https://lbsyun.baidu.com/index.php?title=yingyan/guide/quota 

## 创建鹰眼服务

### 创建服务

- 使用鹰眼轨迹服务首先需要创建service，用于存储、访问和管理自己的一批终端和轨迹。
- 服务管理系统：https://lbsyun.baidu.com/trace/admin/service 
- 每个service最多可管理100万终端（人、车等），一个开发者最多可创建10个 service。
- 若开发者拥有超过100万的终端，可以创建多个 service 分别管理。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207151653513.png" alt="image-20220715165321461" style="zoom:67%;" />

### 获取服务id

- 创建服务成功后，在"我创建的服务"列表中即可看到新增的 service。
- 列表左侧的“系统 ID（service_id）”，如：128658，即为访问该service的唯一标识，在后续的接口调用中均要使用。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207151654590.png" alt="image-20220715165415534" style="zoom:67%;" />

### 进入服务

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171729036.png" alt="image-20220717172928984" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171729082.png" alt="image-20220717172946928" style="zoom:67%;" />



## 终端管理⭐

- 终端管理类接口主要实现：entity的创建、更新、删除、查询。
- 例如：添加骑行路线、删除骑行路线、更新骑行路线的属性信息（如：骑行路线的名称）等。
- 文档： https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/entity 
- entity 管理类接口实现 entity 的创建、更新、删除、查询。包括四个接口：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207151655214.png" alt="image-20220715165507157" style="zoom:67%;" />

### 添加终端

```apl
http://yingyan.baidu.com/api/v3/entity/add //POST请求
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171757941.png" alt="image-20220717175728857" style="zoom:80%;" />

```java
String ak = "sZWkMbcUn2zbmDsuM7Au1KUT1LSSa7s2";
@Test
public void testEntityAdd() {
    String url = "http://yingyan.baidu.com/api/v3/entity/add";
    String body = HttpRequest.post(url)
            .form("ak", ak)
            .form("service_id", 233603)
            .form("entity_name", "renshuo")
            .form("entity_desc", "renshuo的1001轨迹")
            .execute().body();
    System.out.println(body);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171829131.png" alt="image-20220717182905091" style="zoom:67%;" />

访问：https://lbsyun.baidu.com/trace/admin/manager?service_id=233603

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303141000486.png" alt="image-20230314100049408" style="zoom:80%;" />

### 添加Entity自定义字段

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171758468.png" alt="image-20220717175815374" style="zoom:67%;" />

### 更新Entity自定义字段

```java
@Test
public void testEntityAdd() {
    String url = "http://yingyan.baidu.com/api/v3/entity/update";
    String body = HttpRequest.post(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            .form("entity_name", "renshuo") // entity名称，作为唯一标识
            .form("entity_desc", "renshuo的1001轨迹") // entity的可读性描述
            .form("route_name", "从百草园到三味书屋") // 自定义字段
            .execute().body();
    System.out.println(body);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171759645.png" alt="image-20220717175914568" style="zoom:67%;" />

### 删除Entity

```java
@Test
public void testEntityDelete() {
    String url = "http://yingyan.baidu.com/api/v3/entity/delete";
    String body = HttpRequest.post(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            .form("entity_name", "user1") // entity名称，作为唯一标识
            .execute().body();
    System.out.println(body);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171801677.png" alt="image-20220717180150602" style="zoom:67%;" />

### 查询Entity

```java
@Test
public void testEntityList() {
    String url = "http://yingyan.baidu.com/api/v3/entity/list";
    String body = HttpRequest.get(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            //.form("filter", "renshuo") // 可选，根据entity_name查询
            .execute().body();
    System.out.println(body);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303141028427.png" alt="image-20230314102828343" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171802783.png" alt="image-20220717180232700" style="zoom:67%;" />



## 轨迹上传

为 entity 上传轨迹点，支持为一个 entity上传一个或多个轨迹点，也支持为多个 entity 上传多个轨迹点。

目前中国主要有以下三种坐标系：

- WGS84：为一种大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系
- GCJ02：是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系
- BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标
- 非中国地区地图，统一使用WGS84坐标

文档：https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/trackupload 

### 单点轨迹上传

去百度地图坐标拾取系统拿坐标测试：https://api.map.baidu.com/lbsapi/getpoint/index.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171811606.png" alt="image-20220717181110480" style="zoom:67%;" />

```java
@Test
public void testAddPoint() {
    String url = "https://yingyan.baidu.com/api/v3/track/addpoint";
    String body = HttpRequest.post(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            .form("entity_name", "renshuo") // entity名称，作为唯一标识
            .form("latitude","31.040699") // 纬度
            .form("longitude","121.618075") // 精度
            .form("loc_time",System.currentTimeMillis() / 1000) // 定位时设备的时间
            .form("coord_type_input","bd09ll") // 坐标类型，默认值bd09ll
            .form("speed",10.15) // 速度
            .execute().body();
    System.out.println(body);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303141035704.png" alt="image-20230314103559599" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303141036546.png" alt="image-20230314103627400" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171808870.png" alt="image-20220717180827772" style="zoom: 80%;" />

### 多点轨迹上传

```java
@Test
public void testAddPoints() {
    String url = "https://yingyan.baidu.com/api/v3/track/addpoints";
    List<Object> pointList = new ArrayList<>();
    pointList.add(MapUtil.builder().put("entity_name", "renshuo")
            .put("latitude","31.040699")
            .put("longitude","121.618075")
            .put("loc_time",System.currentTimeMillis() / 1000)
            .put("coord_type_input","bd09ll")
            .put("speed",11.23)
            .put("direction",15).build() // 方向
    );
    // 多个点只需要和上面一样pointList.add即可
    String body = HttpRequest.post(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            .form("point_list", JSONUtil.toJsonStr(pointList)) // entity名称，作为唯一标识
            .execute().body();
    System.out.println(body);
}
```

![image-20220717181654925](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171816002.png)

### 轨迹上传⭐

我们可以将多个轨迹点上传到百度地图，查看他在地图上的轨迹。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171814228.png" alt="image-20220717181431160" style="zoom:67%;" />

- 可以根据entity的名称查询路线中的轨迹点信息。
- 百度地图查询路线轨迹信息是支持轨迹纠偏的。
- 各种定位方式或多或少都存在着一定的误差，GPS信号不好的时候（例如，楼宇密集处、高架桥下、隧道等），可能就会使用WI-FI或基站定位，特别是当周边WI-FI热点比较少的时候会使用基站定位，定位误差会有所加大，产生轨迹漂移的现象。
- 为了纠正轨迹漂移，提升轨迹和里程的准确性，鹰眼在轨迹查询服务中提供了高性能的轨迹纠偏功能。
- 支持查询实时位置、一段时间内的轨迹里程、一段时间内的轨迹点。

文档：https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/trackprocess 

创建新实体

```java
@Test
public void testEntityAdd() {
    String url = "http://yingyan.baidu.com/api/v3/entity/add";
    String body = HttpRequest.post(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            .form("entity_name", "renshuo3") // entity名称，作为唯一标识
            .form("entity_desc", "renshuo的1002轨迹") // entity的可读性描述
            .form("route_name", "从百草园到三味书屋") // 自定义字段
            .execute().body();
    System.out.println(body);
}
```

```java
@Test
public void testAddPoints() {
    String url = "https://yingyan.baidu.com/api/v3/track/addpoint";
    String point = "117.224976,39.10971|117.225479,39.10747"; // 经纬度用坐标拾取器拿就行，用|分隔开
    StrUtil.split(point,'|').forEach(pointStr -> {
        String[] splitStr = StrUtil.splitToArray(pointStr, ','); // 再将经纬度按逗号分隔
        // 创建实体
        String body = HttpRequest.post(url)
                .form("ak", ak)
                .form("service_id", 233603) // service的唯一标识
                .form("entity_name", "renshuo3") // entity名称，作为唯一标识
                .form("latitude", Convert.toDouble(splitStr[1])) // 纬度
                .form("longitude",Convert.toDouble(splitStr[0])) // 经度
                .form("loc_time",System.currentTimeMillis() / 1000) // 定位时设备的时间
                .form("coord_type_input","bd09ll") // 坐标类型，默认值bd09ll
                .form("speed",10.15) // 速度
                .form("direction",15)
                .execute().body();
        System.out.println(body);
    });
}
```

https://lbsyun.baidu.com/trace/admin/manager?service_id=233603

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303141114728.png" alt="image-20230314111416551" style="zoom:80%;" />

### 根据时间查询轨迹

我们重点来看根据时间查询轨迹的接口服务。

```java
@Test
public void testEntityTetTrack() {
    String url = "https://yingyan.baidu.com/api/v3/track/gettrack";
    Long startTime = DateUtil.parse("2023-3-14 00:00:00").getTime() / 1000;
    Long endTime = DateUtil.parse("2023-3-14 20:00:00").getTime() / 1000;
    String body = HttpRequest.get(url)
            .form("ak", ak)
            .form("service_id", 233603) // service的唯一标识
            .form("entity_name", "renshuo3") // entity名称，作为唯一标识
            .form("start_time",startTime) // 定位时设备的时间
            .form("end_time",endTime) // 坐标类型，默认值bd09ll
            .form("is_processed",1) // 是否返回纠偏后的轨迹
            .execute().body();
    System.out.println(body);
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303141455429.png" alt="image-20230314145547342" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207171815108.png" alt="image-20220717181552019" style="zoom:80%;" />

# 运动健康与社交

## 轻骑项目概述

> 轻骑项目是一个基于微信小程序的骑行运动类的应用，类似Keep应用。主要是记录用户的骑行运动轨迹、保存路线、分享路线、附近的人、附近的路线等功能。对于运动轨迹的实现主要基于百度地图的鹰眼轨迹服务实现。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131056876.png" alt="image-20230313105630747" style="zoom:80%;" />

## 申请微信小程序

### 注册小程序开发者账号

开发微信小程序首先需要注册开发者账号。

注册地址：https://mp.weixin.qq.com/wxopen/waregister?action=step1&token=&lang=zh_CN

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131059240.png" alt="image-20230313105922144" style="zoom:80%;" />

### 获取AppID

小程序的AppID在后续的开发中会用到，非常重要的信息。开发管理中 ---> 开发设置中可以获取到AppID。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131100029.png" alt="image-20230313110010939" style="zoom:80%;" />

### 小程序开发者工具

小程序的开发与调试，需要使用微信提供的开发者工具。

下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html

安装包已经在资料中提供，一路下一步安装即可。

## 搭建项目环境

### 导入微信小程序项目

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131102847.png" alt="image-20230313110201722" style="zoom:80%;" />

### 前后端接口定义

前后端的接口定义在yapi系统中，地址： https://mock-java.itheima.net/ 

登录的用户名： [qingqi@itcast.cn](mailto:qingqi@itcast.cn) 密码：123456

共定义了15个接口，在后端服务中需要实现这些接口。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131104991.png" alt="image-20230313110451892" style="zoom:80%;" />

### 部署MongodDB、Redis服务

在后台实现服务中，需要使到MongoDB以及Redis服务。

资料中的《docker安装MongoDB、Redis.md》文档进行部署安装。

### 导入后端服务工程

在代码目录中找到 my-qingqi ，将其拷贝到自己的代码目录中，导入到idea中。

此工程是通过Maven构建，导入后会自动下载所需要的依赖包。

该工程已经包含了一些基础代码，如：微信小程序授权登录、登录token校验、基础的vo对象等。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131105235.png" alt="image-20230313110559155" style="zoom:80%;" />

### 配置说明

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131106257.png" alt="image-20230313110624188" style="zoom:80%;" />

> application.properties 文件中配置当前激活的配置项
>
> application-local.properties 文件中配置了服务端口、MongoDB连接、Redis链接信息。
>
> rsa.properties 文件配置了RSA非对称加密的公钥与私钥
>
> weixin.properties 文件配置了微信小程序的appId、secret等信息。
>
> 在微信小程序的后台中，开发管理 -> 开发设置中可以找到自己的信息。

### 小程序授权登录

小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。

文档地址： https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131118580.png" alt="image-20230313111826494" style="zoom:80%;" />

### 更新用户信息

在小程序登录成功后，需要获取到用户的基本信息，如：昵称、头像、城市等，将其更新到MongoDB中。

在导入的工程中，已经完成了这个接口服务的开发。

接口定义地址：https://mock-java.itheima.net/project/3051/interface/api/37271

请求接受是在WeiXinController中的updateUser()方法中完成的。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131119159.png" alt="image-20230313111911074" style="zoom:80%;" />

### 查询用户信息

导入的工程中，完成了查询用户基本信息的接口服务。

接口定义地址：https://mock-java.itheima.net/project/3051/interface/api/37259

其实现是在UserController中的queryMyInfo()方法中完成的。

MyInfoVo中的count、totalDistance、averageSpeed、totalTime在后续的实现中完成填充。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131119067.png" alt="image-20230313111936986" style="zoom:80%;" />

### Token校验拦截器

在登录完成后，后续所有的请求头中会携带token。通过TokefjnInterceptor拦截器中对token做校验，如果token是伪造或过期，就会拦截请求，并且响应401，token有效则放行。

校验token有效后，会将用户id存放到UserThreadLocal中，在需要时直接取出即可。

标记了@NoAuthorization的 Controller中的方法不会进行拦截处理。

### 通用响应原则

为了简化Controller中的开发，我们将响应进行了统一处理。

如果成功，就响应200状态码。

如果失败，就响应500状态码。

响应的数据直接返回，无需进行包装处理。

具体逻辑在 com.qingqi.interceptor.CommonResponseBodyAdvice 类中实现。

## 骑行路线服务

### 开始骑行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131405243.png" alt="image-20230313140520164" style="zoom:80%;" />

用户点击 【开始骑行】按钮时，调用后端的创建路线的服务。创建路线包括2个方面的处理：

在MongoDB表中存储路线数据，所对应的实体为：Route，对应的表为：tb_route

调用百度地图鹰眼轨迹服务，创建该路线所对应的实体。

### 停止骑行

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131406753.png" alt="image-20230313140633676" style="zoom:67%;" />

> 用户在骑行的过程中，按下暂停按钮，如果是长按是结束运动，如果是短按是暂停。
>
> 如果，用户选择结束运动，并且运动时间小于3分钟，此次运动是无效的，需要将对应的路线数据删除。
>
> 如果运动时间大于3分钟，是有效运动，需要正常结束，具体流程在后面讲解。
>
> 删除路线同样也是2个处理，第一个是删除MongoDB中数据，第二个删除百度地图鹰眼服务中的实体。

### 实现创建路线服务

接口定义文档：https://mock-java.itheima.net/project/3051/interface/api/37283

该接口无需请求参数，创建路线成功后返回routeId即可。

Route路线实体如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131408978.png" alt="image-20230313140826883" style="zoom:67%;" />

第一步，创建RouteController、RouteService 、BaiduService。

第二步，在RouteController创建createRoute()

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131410432.png" alt="image-20230313141011339" style="zoom:80%;" />

第三步，在RouteService 中编写具体的业务逻辑。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131410738.png" alt="image-20230313141032645" style="zoom:80%;" />

第四步，在BaiduService 中实现创建实体逻辑。

创建baidu.properties配置文件，配置ak、serverId、url等内容。

编写通用的BaiduApiService服务，并且开启Spring的失败重试机制，在启动类中添加@Retryable注解。

实现具体的创建实体逻辑。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131411284.png" alt="image-20230313141100196" style="zoom:80%;" />

### 实现创建路线服务–测试

在微信小程序中进行测试，会发现数据库以及百度地图服务中均以创建了路线。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131411329.png" alt="image-20230313141157229" style="zoom:80%;" />

### 实现删除路线服务

删除路线接口服务地址：https://mock-java.itheima.net/project/3051/interface/api/37289

需要注意的是，该接口是DELETE请求，请求参数为路线id，没有返回数据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131414511.png" alt="image-20230313141400410" style="zoom:80%;" />

## 上报地理位置

### 说明

在骑行运动过程中，每隔15秒上报一次用户的地理位置，运动多个点组成运动轨迹。

接口文档地址：https://mock-java.itheima.net/project/3051/interface/api/37277

请求参数如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131414196.png" alt="image-20230313141432107" style="zoom:80%;" />

需要说明的是，运动过程中只是把位置上报给百度地图，MongoDB中不做存储，在运动结束后，将该路线中所有的运动轨迹点查询回来，存储到MongoDB中。在上报运动地理位置时，同时需要更新用户自身的地理位置数据到MongoDB。

### 实现功能

编写RunController实现具体业务逻辑。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131415673.png" alt="image-20230313141524572" style="zoom:67%;" />

上报地理位置数据到百度地图服务。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131415394.png" alt="image-20230313141550293" style="zoom:80%;" />

### 单元测试

通过单元测试的方式，像路线中添加多个位置点。测试效果如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131416406.png" alt="image-20230313141624300" style="zoom:80%;" />

### 更新地理位置

更新用户的地理位置，需要异步更新，这里采用的是Spring的异步方式实现。启动类中需要添加 @EnableAsync 注解

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131416708.png" alt="image-20230313141658612" style="zoom:80%;" />



## 结束骑行运动

### 实现功能

> 结束骑行，也就是运动时间大于3分钟的有效运动，正常的结束操作。
>
> 结束时，需要填写路线名称，在后端需要通过百度地图鹰眼服务查询该路线所有的轨迹点，存储到MongoDB中。
>
> 接口文档地址：https://mock-java.itheima.net/project/3051/interface/api/37301
>
> 请求参数有：路线id，路线标题。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131037980.png" alt="image-20230313103731890" style="zoom:80%;" />

## 查询与投稿路线

### 查询路线

在保存路线成功后，需要根据路线id查询路线数据。

接口定义文档地址： https://mock-java.itheima.net/project/3051/interface/api/37307

该接口的请求路径参数为：路线id，请求参数：当前用户的经纬度，用于计算路线与用户之间的距离。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131040192.png" alt="image-20230313104002106" style="zoom:80%;" />

### 投稿路线

投稿路线实际上就是分享路线，其他人可以看到这个路线后，沿着该路线运动。

接口定义文档地址： https://mock-java.itheima.net/project/3051/interface/api/37295

该接口的请求路径参数为：路线id

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131040969.png" alt="image-20230313104033883" style="zoom:80%;" />

RouteService中的实现：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131040647.png" alt="image-20230313104056564" style="zoom:80%;" />

## 附近的路线与人

### 附近的路线

用户在首页点击【路线】 -> 【附近】 -> 【附近的路线】可以查看自己附近的路线。

为了方便测试，我们构造几条测试数据，参数脚本以及数据已经放到资料目录中，直接导入到MongoDB即可。

注意：userid需要改成自己的用户id。

接口文档地址：https://mock-java.itheima.net/project/3051/interface/api/37313

实现原理：根据中心点坐标+距离（半径），在MongoDB中按照圆形范围查询。

实现时，使用NearQuery进行查询，默认按照由近到远的数据返回，并且会返回之间距离数据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131042774.png" alt="image-20230313104219683" style="zoom:80%;" />

在微信开发者工具设置位置数据为：31.034952，121.612063 （方便测试数据）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131042132.png" alt="image-20230313104242043" style="zoom:80%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131043449.png" alt="image-20230313104319333" style="zoom:80%;" />

### 附近的人

用户在首页点击【路线】 à 【附近】 à 【附近的人】可以查看自己附近的人。

为了方便测试，我们构造几条测试数据，数据脚本已经放到资料目录中，直接导入到MongoDB即可。

接口文档地址：https://mock-java.itheima.net/project/3051/interface/api/37331

实现原理：根据中心点坐标+距离（半径），在MongoDB中按照圆形范围查询。

实现时，使用NearQuery进行查询，默认按照由近到远的数据返回，并且会返回之间距离数据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131044207.png" alt="image-20230313104404123" style="zoom:80%;" />

## 沿着路线骑行

在查询到附近的路线后，可以查看其路线详情，并且可以按照该路线运动。实现思路：

需要记录用户此次运动与目标路线的关系。

在结束运动时，同时需要标记沿着运动的结束。

删除路线时，需要将沿着运动的数据删除。（运动时间小于3分钟）

### 实体类结构

记录运动与目标路线的关系的实体结构如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131044765.png" alt="image-20230313104449669" style="zoom:80%;" />

沿着路线开始骑行接口，主要完成2件事情：创建新的路线。记录该路线与目标路线之间的关系。

接口文档地址：https://mock-java.itheima.net/project/3051/interface/api/37337

该接口中需要传递目标路线的id，返回新创建的路线id。

RouteController中的实现：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131052574.png" alt="image-20230313105228479" style="zoom:80%;" />

RouteService中的实现：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131052776.png" alt="image-20230313105250678" style="zoom:80%;" />

RouteService中的updateRoute()方法中增加结束沿着路线骑行的实现：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131053395.png" alt="image-20230313105314309" style="zoom:80%;" />

RouteService中的deleteRoute()法中增加删除沿着路线骑行的实现：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131053873.png" alt="image-20230313105335781" style="zoom:80%;" />

### 查询正在骑行的人

在查询路线时，需要查询出该路线正在骑行的人。

接口文档地址： https://mock-java.itheima.net/project/3051/interface/api/37325

该接口需要传递目标路线id。

RouteController的实现如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131054407.png" alt="image-20230313105404323" style="zoom:80%;" />

### 最终实现效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131054534.png" alt="image-20230313105427452" style="zoom:80%;" />



## 我的历史路线

关于我的历史路线这个模块与地图关系不大，考虑到项目的功能健全性，这部分代码做拷贝整合。

该功能需要提供2个接口，一个是历史路线列表，另一个是按照日期分组返回历史路线。

对应的接口文档地址分别是：

历史路线：https://mock-java.itheima.net/project/3051/interface/api/37319

按日期分组展现：https://mock-java.itheima.net/project/3051/interface/api/37343

参考实现代码在资料中提供。最后需要将查询我的信息中的默认总里程数、运动时间、平均速度等内容。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131051604.png" alt="image-20230313105121469" style="zoom:80%;" />



# 物流行业地图

## 地图技术在物流行业的应用

### 场景1：智能调度

> 物流调度主要是指在物流过程中,物流公司根据待发货物的重量、去向、规格、加急程度等对所属的车辆和人员进行合理的安排和调度。智能调度系统可以高效、准确的完成这一系列的调度工作。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131008329.png" alt="image-20230313100802226" style="zoom:80%;" />

### 场景2：货车轨迹监控

> 解决车辆运行线路相关的问题，包括车辆的线路规划、车辆运行时的电子围栏（线性电子围栏及区域性电子围栏）、车辆运行线路的轨迹纠偏、车辆运行记录的线路补偿。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131008209.png" alt="image-20230313100847066" style="zoom:80%;" />

### 场景3：快递员多点路线规划

> 结合批量算路服务，实现快递员派送时的多点路线规划，提升派件效率，结合地图展现，方便、直观。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131009755.png" alt="image-20230313100937633" style="zoom:80%;" />

### 场景4：快递分单

通过地址解析的坐标与收派区域结合完成分单。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131010281.png" alt="image-20230313101033185" style="zoom:80%;" />

### 场景5：驿站选址

结合地理编码和地点检索，分析订单分布，辅助驿站选址。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131011869.png" alt="image-20230313101113761" style="zoom:80%;" />

## 金运物流项目简介

### 订单管理

订单是在用户在物流系统中下的订单，比如：寄一件衣服从上海到北京。订单管理的列表如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131015521.png" alt="image-20230313101511429" style="zoom:80%;" />

### 路线规划

在订单详情中，通过百度地图显示出订单的路线规划：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131015182.png" alt="image-20230313101537051" style="zoom:80%;" />

### 运单管理

运单是物流系统为每一个订单生成的运单号，一般是告知用户的，用户根据运单号查询物流状态信息。

运单管理的列表如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131016739.png" alt="image-20230313101610651" style="zoom:67%;" />

运单详情中会显示车辆的运行轨迹，如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131016397.png" alt="image-20230313101645289" style="zoom:80%;" />

### 电子围栏

通过设置多边形的电子围栏对车辆进行监控，如果超出范围就会进行告警：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131017977.png" alt="image-20230313101713859" style="zoom:80%;" />

### 车辆管理

在车辆管理的页面中，如果有车辆超出了电子围栏就会有红色告警显示，如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131017241.png" alt="image-20230313101747155" style="zoom:80%;" />

## 搭建工程

### 前端工程

前端采用Vue编写，我们需要把前端工程跑起来，项目源码在代码目录中。主要步骤如下：

> 将project-jywl-admin-vue-ts.zip解压到自己的目录中
>
> 在Terminal控制台中输入 npm run serve 命令即可运行（代码包中已经包含了所需要的依赖）
>
> 如果依赖有问题，可以将node_modules目录删除，然后执行npm install 即可。
>
> 可在 .env 文件中修改接口的地址，演示功能效果使用mock地址，开发时使用本地开发地址。

### 创建MongoDB用户

为了与前面轻骑项目区分开来，我们在MongoDB中创建jinyun的用户

```sql
db.createUser({ 
     user: 'jinyun', 
     pwd: 'oudqBFGmGY8pU6WS', 
     roles: [ { role: "readWrite", db: "jinyun" } ] 
});
```

### 后端工程

工程的pom.xml、pojo等文件在资料目录中。金运项目中的数据均存储在MongoDB中，地图方面使用百度地图技术

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131020948.png" alt="image-20230313102036859" style="zoom:80%;" />



## 订单管理功能开发

### 构造数据

在提供的测试代码TestOrderService.java文件中，执行测试用例用于生成省、市、区以及订单数据

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131021670.png" alt="image-20230313102116564" style="zoom:80%;" />

### 实现订单列表查询

接口文档： https://mock-java.itheima.net/project/3308/interface/api/41698

对于该接口的实现，我们只做基本的实现，不根据各种参数进行查询。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131022982.png" alt="image-20230313102249897" style="zoom:80%;" />

### 整合到前端的效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131023733.png" alt="image-20230313102313651" style="zoom:80%;" />

### 订单详情

> 接口地址：https://mock-java.itheima.net/project/3308/interface/api/41700

> 根据订单号查询订单数据，在订单详情中，前端根据订单数据中发件人地址与收件人地址，在地图显示路线规划

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131024348.png" alt="image-20230313102402261" style="zoom:80%;" />

### 整合到前端的效果

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131024934.png" alt="image-20230313102443812" style="zoom:67%;" />

## 运单管理功能开发

### 构造数据

在提供的测试代码TestWayBillService.java文件中，执行测试用例生成运单数据。

![image-20230313102525364](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131025439.png)

### 运单列表

接口地址：https://mock-java.itheima.net/project/3308/interface/api/41702

按照分页的方式查询运单数据，简单实现，不进行多条件查询的实现。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131025228.png" alt="image-20230313102559147" style="zoom:80%;" />

### 运单详情

接口地址：https://mock-java.itheima.net/project/3308/interface/api/41704

该接口返回运单的详细信息。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131026124.png" alt="image-20230313102640041" style="zoom:67%;" />

### 运单轨迹

接口地址：https://mock-java.itheima.net/project/3308/interface/api/41706

该接口返回发件人地址与收件人地址之间的车辆路线规划的坐标数据。

实现要点如下：

> 根据百度地图API查询收件人的地址对应的经纬度坐标值。
>
> 根据百度地图API查询发件人的地址对应的经纬度坐标值。
>
> 调用百度地图API查询2点间的路线规划。
>
> 路线规划中可以设置途经点，如：收货地址如果是上海，必须途径南京。

### 运单轨迹效果（有途经点）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131027334.png" alt="image-20230313102745196" style="zoom:80%;" />

### 运单轨迹效果（无途经点）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131028142.png" alt="image-20230313102808012" style="zoom:80%;" />

## 电子围栏功能开发

### 新增电子围栏

> 电子围栏的主要用途是监控车辆是否超出规定的范围，如果超出需要有异常的状态信息。
>
> 电子围栏需要使用到百度地图鹰眼服务中的服务，并在围栏数据也需要在本地存储。
>
> 百度地图文档地址：https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofence

百度地图电子围栏支持圆形、多边形、路线、行政区类型的围栏，在项目中我们只演示多边形围栏的使用，其他类似

> 围栏面积如果超过100平方公里，就需要付费申请开通权限。
>
> 接口地址：https://mock-java.itheima.net/project/3308/interface/api/41710
>
> 接口提交的参数有围栏名称以及多边形坐标数据。

### 实现要点

通过集合接收提交的多边形坐标。先创建百度地图的电子围栏，创建成功后再将围栏数据写入到MongoDB中。

写入MongoDB中数据如下：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131030131.png" alt="image-20230313103011058" style="zoom:67%;" />

### 功能列表

电子围栏列表分2个接口，一个是在列表管理页面中使用，一个是在新增车辆时使用。

电子围栏分页列表接口： https://mock-java.itheima.net/project/3308/interface/api/41712

电子围栏列表： https://mock-java.itheima.net/project/3308/interface/api/41714

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131030233.png" alt="image-20230313103050124" style="zoom:80%;" />

### 详情

根据id查询电子围栏详情，返回多边形坐标数据，在地图上将电子围栏展现出来。

接口地址： https://mock-java.itheima.net/project/3308/interface/api/41718

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131031605.png" alt="image-20230313103120500" style="zoom:80%;" />

### 修改

修改电子围栏需要将坐标重新提交，更新到百度地图与MongoDB数据库。

百度地图API接口：[https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofence#service-page-anchor8](https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofence) 

接口地址：https://mock-java.itheima.net/project/3308/interface/api/41708

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131031162.png" alt="image-20230313103154075" style="zoom:80%;" />

### 删除

删除电子围栏需要将百度地图以及MongoDB中的围栏数据均删除。

百度地图API接口：[https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofence#service-page-anchor11](https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofence) 

接口地址：https://mock-java.itheima.net/project/3308/interface/api/41716

## 车辆管理功能开发

### 车辆列表

查询车辆列表时，需要查询百度鹰眼服务，判断车辆是否有超出电子围栏。

百度鹰眼服务地址：[https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofencealarm#service-page-anchor4](https://lbsyun.baidu.com/index.php?title=yingyan/api/v3/geofencealarm) 

接口地址：https://mock-java.itheima.net/project/3308/interface/api/41726 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131032254.png" alt="image-20230313103252170" style="zoom:80%;" />

### 新增车辆

新增车辆时需要将车辆作为Entity注册到百度鹰眼服务中，并且将其加入到电子围栏中。

百度地图鹰眼Entity新增成功后，需要将车辆数据存储到MongoDB表tb_vehicle中。

接口地址： https://mock-java.itheima.net/project/3308/interface/api/41724

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131033242.png" alt="image-20230313103340155" style="zoom:80%;" />

### 车辆详情

查询车辆的详细信息。

接口文档：https://mock-java.itheima.net/project/3308/interface/api/41728

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131034521.png" alt="image-20230313103415451" style="zoom:80%;" />

### 车辆删除

删除车辆信息，同时要删除百度鹰眼服务中的Entity和MongoDB中的车辆数据。

接口文档：https://mock-java.itheima.net/project/3308/interface/api/41722 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131034611.png" alt="image-20230313103446540" style="zoom:80%;" />

### 车辆更新

更新车辆信息。

接口文档：https://mock-java.itheima.net/project/3308/interface/api/41720 

如果车辆关联的电子围栏变更的话：在原有的电子围栏中将该车辆删除，将该车辆加入新的电子围栏中



# 地图数据收集与存储

## 地图数据收集与存储方案分析

### 问题引出和困难分析

如果不使用百度地图鹰眼服务，我们该如何存储轨迹坐标数据？自己存储轨迹坐标数据面临的困难主要有两个：

> 第一，高并发上报地理位置的请求如何解决?
>
> 第二，海量的坐标数据该如何存储?

针对以上问题我们给出相应的解决方案，这也就是今天课程的主要内容。

### 解决高并发的解决方案

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130923830.png" alt="image-20230313092310722" style="zoom:80%;" />

关于上图的说明如下：

> 客户端可能会有多种，可以是移动端APP、微信小程序、浏览器等。
>
> 客户端一般会发送http请求，为了高效的处理用户请求，我们采用Netty来处理用户的请求。
>
> Netty是一个**高性能的、异步的、基于事件驱动的网络应用框架**。
>
> Netty服务在接收到请求后，自己并不完成数据存储的工作，而是将数据发送给Kafka消息服务器。
>
> 这样做的好处，Netty服务可以更快速给用户响应，自己的变得更加轻量化。
>
> Kafka 是一个开源消息系统，是Apache 软件基金会开发的一个开源消息系统项目。
>
> **该项目的目标是为处理实时数据提供一个统一、高通量、低延迟的平台**。

### 海量数据存储的解决方案

如果不使用百度地图鹰眼服务，我们该如何存储轨迹坐标数据？

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130925815.png" alt="image-20230313092531707" style="zoom:67%;" />



## Netty快速入门

### Netty简介

> Netty是一个高性能的、异步的、基于事件驱动的网络应用框架。官网：https://netty.io/
>
> Netty是基于Java的NIO实现的，Netty将各种传输类型、协议的实现API进行了统一封装，实现阻塞和非阻塞Socket
>
> Netty在网络通信方面更加的高性能、低延迟，尽可能的减少不必要的内存拷贝，提高性能。
>
> Netty只依赖了JDK底层api，没有其他的依赖，如：Netty 3.X依赖JDK5以上，Netty4.x依赖JDK6以上。
>
> Netty的社区比较活跃，版本迭代周期短，发现bug可以快速修复，新版本也会不断的加入。

### 核心架构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130928360.png" alt="image-20230313092815205" style="zoom:80%;" />

### 版本说明

> Netty的版本分为，3.x、4.x和5.x，其中5.x版本已经被官方废弃。目前Netty的最新版本为4.1.66.Final，我们将基于此版本学习。

> 废弃5.x的主要原因是，使用ForkJoinPool后复杂度提升了，但是性能方面并没有明显的优势，反而给项目的维护带来了很大的工作量，因此还有到发布新版本的时机，所以将5.x废弃。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130931670.png" alt="image-20230313093147586" style="zoom:80%;" />

### 应用场景

Netty的应用场景是非常广泛的，比如：互联网行业的、游戏行业、大数据行业、医疗行业、金融等行业。

> 在互联网行业项目中，最具代表性的就是分布式系统架构的远程服务调用，通过RPC的方式进行高性能的服务调用，目前主流的RPC框架底层均采用了Netty作为网络通信组件。

> 比如：阿里巴巴的分布式服务治理框架Dubbo，底层就是使用Netty作为通信组件。

> gRPC，是Google提供的高性能RPC框架，底层也使用了Netty。

> 大数据行业中的许多技术也采用了Netty作为通信组件，如：Flink、Spark、Elasticsearch等。官方列出了使用Netty的一些项目：https://netty.io/wiki/related-projects.html

### Reactor线程模型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130934490.png" alt="image-20230313093435387" style="zoom:80%;" />

### 单Reactor单线程模型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130942044.png" alt="image-20230313094214952" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130942624.png" alt="image-20230313094248545" style="zoom:80%;" />

### 单Reactor多线程模型

> 在Reactor多线程模型相比较单线程模型而言，不同点在于，Handler不会处理业务逻辑，只是负责响应用户请求，真正的业务逻辑，在另外的线程中完成。

> 这样可以降低Reactor的性能开销，充分利用CPU资源，从而更专注的做事件分发工作了，提升整个应用的吞吐。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130943371.png" alt="image-20230313094335297" style="zoom:80%;" />

存在的问题

> 多线程数据共享和访问比较复杂。如果子线程完成业务处理后，把结果传递给主线程Reactor进行发送，就会涉及共享数据的互斥和保护机制。

> Reactor承担所有事件的监听和响应，只在主线程中运行，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。

### 主从Reactor多线程模型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130946231.png" alt="image-20230313094621143" style="zoom:80%;" />

在主从模型中，将Reactor分成2部分：

MainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给SubReactor。

SubReactor主要完成和建立起来的socket的数据交互和事件业务处理操作。

### Netty模型

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130946983.png" alt="image-20230313094658906" style="zoom:80%;" />

在Netty模型中，负责处理新连接事件的是BossGroup，负责处理其他事件的是WorkGroup。Group就是线程池的概念。

NioEventLoop表示一个不断循环的执行处理任务的线程，用于监听绑定在其上的读/写事件。

通过Pipeline（管道）执行业务逻辑的处理，Pipeline中会有多个ChannelHandler，真正的业务逻辑是在ChannelHandler中完成的。

### 实例：使用Netty实现socket服务

> 使用Netty既可以编写服务端，也可以编写客户端，但是我们学习的重点是服务端的实现。

下面我们将使用Netty实现简单的socket服务端，具体实现功能如下：

> 服务端启动后，监听6666端口，服务端接收到请求后，在控制台将接收到的数据打印出来，最后给客户端响应”ok”

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130949397.png" alt="image-20230313094915331" style="zoom:80%;" />

### Netty编解码器（了解）

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130950265.png" alt="image-20230313095041156" style="zoom:80%;" />

## 部署kafka集群

> 参考资料中的《部署kafka集群.md》文档，进行部署。通过kafka manager进行管理、查看集群信息。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130952837.png" alt="image-20230313095220753" style="zoom:80%;" />



## 实现地图数据的收集方案

下面我们将通过Netty、Kafka实现高性能的服务端应用，主要是步骤如下：

> 创建my-geoserver工程，导入所需的依赖包。
>
> 编写配置文件my.setting，通过hutool工具包中的Setting类型读取配置文件信息。
>
> 编写MyGeoHttpServer类，负责启动Netty服务，添加http相关的编解码器。
>
> 编写ServerHandler类，负责接收用户请求，以及发送kafka消息。
>
> 编写KafkaService类，完成发送kafka消息的业务逻辑。

## MongoDB分片式集群

### 集群介绍

> 分片（sharding）是MongoDB用来将大型集合分割到不同服务器（或者说一个集群）上所采用的方法。

> 使用分片减少了每个分片需要处理的请求数，通过水平扩展，集群可以提高自己的存储容量和吞吐量。

> 例如，如果数据库1tb的数据集，并有4个分片，然后每个分片可能仅持有256 GB的数据。如果有40个分片，那么每个切分可能只有25GB的数据。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130954189.png" alt="image-20230313095451085" style="zoom:67%;" />

### 分片集群的优势

> MongoDB自带了一个叫做mongos的专有路由进程。mongos就是掌握统一路口的路由器，其会将客户端发来的请求准确无误的路由到集群中的一个或者一组服务器上，同时会把接收到的响应拼装起来发回到客户端。

> 保证集群总是可读写，将MongoDB的分片和复制功能结合使用，在确保数据分片到多台服务器的同时，也确保了每分数据都有相应的备份，这样就可以确保有服务器坏掉时，其他的从库可以立即接替坏掉的部分继续工作。

> 集群易于扩展，当系统需要更多的空间和资源的时候，MongoDB使我们可以按需方便的扩充系统容量。

### 分片集群的架构

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130956292.png" alt="image-20230313095645186" style="zoom:80%;" />

### 集群中的数据分布

> 在一个shard server内部，MongoDB会把数据分为chunks，每个chunk代表这个shard server内部一部分数据。chunk的产生，会有以下两个用途：

> Splitting：当一个chunk的大小超过配置中的chunk size（默认64M）时，MongoDB的后台进程会把这个chunk切分成更小的chunk，从而避免chunk过大的情况。

> Balancing：balancer是一个后台进程，负责chunk的迁移，从而均衡各个shard server的负载，系统初始1个chunk，mongoDB会自动拆分和迁移chunks。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130958366.png" alt="image-20230313095810273" style="zoom:80%;" />

### 搭建分片式集群

> 下面我们搭建一个分片式的集群，包括：1个Mongos服务，3个Config Server，2个Shard，每个Shard中包含3个MongoDB实例，其为副本集，保障数据的安全。具体方法参考《搭建MongoDB分片式集群.md》文档。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130959724.png" alt="image-20230313095906636" style="zoom:80%;" />

## 接收消息存储到MongoDB

下面我们完成接收消息，并且存储数据到MongoDB的逻辑，主要的步骤如下：

> 导入my-geoserver-consumer工程。
>
> RoutePoint实体类，其中存储了用户的地理位置数据。
>
> GeoServerConsumer类，接收消息并且存储到MongoDB。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303131000912.png" alt="image-20230313100040828" style="zoom:80%;" />



## 压力测试

### 安装JMeter

> 将资料目录中的apache-jmeter-5.4.1.tgz压缩包解压到任意目录，双击在bin目录下的jmeter.bat启动即可。
>
> 按照下图创建测试用例：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130935069.png" alt="image-20230313093554008" style="zoom:80%;" />

### Jmeter – 线程组

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130937534.png" alt="image-20230313093757450" style="zoom:80%;" />

### Jmeter– http请求设置

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130938880.png" alt="image-20230313093853793" style="zoom:80%;" />

### 测试结果

> 由于硬件条件的限制，只是针对单点服务进行测试。
>
> 从测试结论可以看出，通过Netty实现的服务可以应对高并发的场景。

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130940346.png" alt="image-20230313094032258" style="zoom:80%;" />

# 地图专题面试

## 1、百度地图基础API

百度地图基础API的主要功能如下：

![image-20211014161606793](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915654.png)

创建地图

![image-20211014162515800](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915665.png)

添加覆盖物

![image-20211014162537000](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915687.png)

地图事件

![image-20211014162549002](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915699.png)

地图样式

![image-20211014162602264](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915716.png)

地图检索

![image-20211014162624958](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915709.png)

数据可视化

![image-20211014162634345](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915127.png)

地点输入提示

![image-20211014164031057](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915453.png)

路线规划

![image-20211014164428915](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915567.png)

## 2、百度地图鹰眼轨迹服务

鹰眼是一套轨迹管理服务，提供各端SDK和API供开发者便捷接入，追踪所管理的车辆/人员等运动物体。

![image-20211014174128010](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915680.png)

主要功能：

![image-20211014174650886](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915804.png)

## 3、地图找房

业务流程：

![image-20211014171907845](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915916.png)

效果：

![image-20211014173446986](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915028.png)

## 4、轻骑项目

### 1、小程序授权登录

小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。

![image-20211015100312787](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915138.png)

### 2、骑行功能

开始骑行：

 ![image-20211015102015362](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915170.png)

停止骑行：

 ![image-20211015102047848](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915427.png)

### 3、上报地理位置

![image-20211015112651519](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915466.png)

## 5、金运物流项目

### 1、订单管理

在订单管理功能中，主要是为前端提供起始位置，前端通过js调用百度地图api规划路线。

![image-20211015113810549](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915576.png)

![image-20211015113816822](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915676.png)

### 2、运单管理

运单管理中的轨迹是通过后端实现的，并且可以添加途经点。

![image-20211015114058791](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915716.png)

 ![image-20211015114106395](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915891.png)

### 3、电子围栏

通过设置多边形的电子围栏对车辆进行监控，如果超出范围就会进行告警。

> **原理：在百度地图中创建电子围栏，车辆作为Entity添加到围栏中进行监控。**

 ![image-20211015141012206](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915004.png)

![image-20211015141040905](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915042.png)

## 6、高并发解决方案

![image-20211015154514155](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915333.png)

高并发的解决方案，核心是采用Netty作为服务端接收用户请求，然后将数据发送到Kafka集群。

## 7、海量数据存储解决方案

![image-20211015155818478](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130915393.png)

海量数据的存储方案，核心是采用Mongodb分片式集群进行数据存储。



















# 探花交友面试

## 1、项目中使用了哪些技术

我们开发的探花交友项目中使用的技术相对还是比较多的：

> - 前端主要是使用flutter由前端团队完成
>
> - 后端主要使用的技术是Spring Boot + SpringMVC + Mybatis + MybatisPlus + Dubbo，其中服务的注册中心与配置中心使用的是Nacos
> - 底层数据的存储使用的是MySQL+MongoDB，缓存使用的是Redis
> - 第三方的服务有：阿里云的OSS和短信服务、环信即时通讯、百度人脸识别等，在这个项目中，通过Spark + MLlib实现了智能推荐。

## 2、前后端分离开发你们是怎么做的

探花交友项目采用前后端分离的方式开发，就是前端由前端团队负责开发，后端负责接口的开发。

我们要和前端团队事先约定好接口地址以及各种参数、响应数据结构等。

对于接口的定义我们采用YApi进行管理，YApi是一个开源的接口定义、管理、提供mock数据的管理平台。

 ![image-20211101102314329](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904495.png)

接口定义：

 ![image-20211101102323929](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904461.png)

## 3、为什么选择MongoDB

> 之所以选择MongoDB是因为它天生就支持海量数据的存储，可以很好的水平扩容，虽然它不能像传统的关系型数据库那样进行多表联合查询，但对我们的业务而言单表操作足够了。

> 在MongoDB中，我们会存储好友关系、用户发表的动态、推荐的结果等数据。对于MongoDB的集群而且，我们采用了它的分片式集群，这种集群方式有很好的扩展性，使用层面是直接连接到mongos服务即可完成集群的操作

> 说明：如果要继续答分片式集群的话请参考课件中的知识模块。

## 4、你们项目的Maven模块是怎么设计的

> 我们整体项目使用Maven架构搭建，采用聚合工程形式管理模块，为了便于调用，dubbo需要拆分为接口模块和服务模块，模块划分如下：

![image-20211101104543532](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904509.png)

工程结构如下：

| **父工程**   | **工程名称**           | **说明**                                       |
| ------------ | ---------------------- | ---------------------------------------------- |
| tanhua       | tanhua-autoconfig      | 自动装配的工具类                               |
| tanhua       | tanhua-domain          | 实体类模块                                     |
| tanhua       | tanhua-dubbo           | Dubbo子模块（可以理解为文件夹，管理dubbo模块） |
| tanhua       | tanhua-app             | 与手机端交互的入口模块                         |
| tanhua-dubbo | tanhua-dubbo-interface | Dubbo接口模块                                  |
| tanhua-dubbo | tanhua-dubbo-db        | Dubbo服务模块（数据库部分）                    |
| tanhua-dubbo | tanhua-dubbo-mongo     | Dubbo服务模块（MongoDB部分）                   |

模块之间的依赖关系如下：

![image-20211101104803855](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904516.png)

## 5、短信是怎么发送的？发送失败怎么处理

> 项目中的短信是通过阿里云的短信服务发送的，之所以选择阿里云是由于它相对比较稳定，由于我们发送量并不是很大，所以我们只接入了这一个通道，如果后期量大的了话会考虑接入多个通道来确保短信服务的稳定性。

如果短信发送失败的话，我们会这样处理：

> - 首先，我们的发送短信的代码是做了重试功能的，这样基本可以确保网络故障的场景下能恢复发送
> - 如果重试3次后依然出错的话，应该是通道或账号出现了问题，我们会将错误记录到日志中，会有后续的日志监控进行监控，及时的发现问题并解决问题。

## 6、使用过JWT吗，它是如何确保安全的

> 我们项目中，用户在登录成功后系统会生成token，这个token就是采用JWT生成的。

> JWT就是一个字符串，经过加密处理与校验处理的字符串，形式为：A.B.C，其中，A是JWT头部信息header加密得到的，B是JWT用到的身份验证信息json数据加密得到，C是A和B加密得到，是校验部分。

> 所以，只要确保加密方式不会泄漏，就可以确保C部分是不会被人伪造的，通过这种方式确保了token的安全性。

> 至于加密方式，一般来说会有2种方式，分别是：对称加密、非对称加密。一般而言，对称加密相对比较简单，但是其密钥泄露的风险比较高，而非对称加密，分为公钥和私钥，一般只要确保私钥不被泄漏就可以保证其安全性，所以非对称加密的泄漏风险要低一些。建议选择非对称加密进行计算C部分。

## 7、图片是如何存储的

> 对于图片的存储一般会有三种方式，分别是：本地磁盘存储、分布式文件系统、第三方云存储服务。在探花交友项目中，我们选择使用的是阿里云的OSS存储，它的使用基本流程如下：

![image-20211101113833525](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904534.png)

## 8、登录功能的流程是什么样的

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904499.png" alt="image-20211021141222134" style="zoom:80%;" />

## 9、项目中的异常是如何处理的？

> 在项目中的异常，我们采用了统一异常处理的方式，具体采用的是SpringMVC提供了一套解决全局异常的处理方案，它可以在代码无侵入的前提下完成异常处理。

其原理如下：

 <img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904212.png" alt="image-20211101123840242" style="zoom:80%;" />

核心代码实现如下：

~~~java
/**
 * 自定义统一异常处理
 *  1、通过注解，声明异常处理类
 *  2、编写方法，在方法内部处理异常，构造响应数据
 *  3、方法上编写注解，指定此方法可以处理的异常类型
 */
@ControllerAdvice
public class ExceptionAdvice {

    //处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity handlerException(BusinessException be) {
        be.printStackTrace();
        ErrorResult errorResult = be.getErrorResult();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResult);
    }

    //处理不可预知的异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity handlerException1(Exception be) {
        be.printStackTrace();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ErrorResult.error());
    }
}
~~~

## 10、聊聊今日佳人功能是怎么实现的?

> 今日佳人，会推荐缘分值最大的用户，进行展现出来。缘分值的计算是由用户的行为进行打分，如：点击、点赞、评论、学历、婚姻状态等信息组合而成的。业务流程是这样的：

 ![1564105451383](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904271.png)

推荐系统将推荐数据写入到MongoDB中，我们之间从结果中直接查询即可，表recommend_user结构如下：

~~~shell
{
  "userId":1001,  #推荐的用户id
  "toUserId":1002, #用户id
  "score":90,  #推荐得分
  "date":"2019/1/1" #日期
}
~~~

核心代码如下：

~~~java
@DubboService
public class RecommendUserApiImpl  implements RecommendUserApi {

    @Autowired
    private MongoTemplate mongoTemplate;

    //查询今日佳人
    public RecommendUser queryWithMaxScore(Long toUserId) {

        // 根据toUserId查询，根据评分score排序，获取第一条
        // 构建Criteria
        Criteria criteria = Criteria.where("toUserId").is(toUserId);
        // 构建Query对象
        Query query = Query.query(criteria).with(Sort.by(Sort.Order.desc("score")))
                .limit(1);
        
        // 调用mongoTemplate查询
        return mongoTemplate.findOne(query,RecommendUser.class);
    }
}
~~~

## 11、好友推荐是怎么实现的？

> 推荐服务在技术层面来说是通过Spark + Spark MLlib实现的，通过读取到的用户数据，按照一定的规则进行计算用户之间的相似度（得分），比如：性别不同+10分，位置在同一个城市+10等，按照这样的规则就能得出2人之间的得分，再通过ALS算法进行计算并且得到推荐的用户数据，将结果数据写入到MongoDB中。

> 并且推荐计算设置了计算周期，我们设置的是每20分钟计算一次，即可得到新的推荐数据。在业务层面来说，在展现推荐用户时，只需要查询MongoDB即可，比如：在APP首页展现的今日佳人、推荐用户列表等功能。

 ![1567064038029](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904379.png)

## 12、点赞功能如何实现的

 ![image-20211106113815545](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904528.png)

> 点赞功能的实现思路参考上图，用户在对圈子中的动态内容点赞时，首先需要判断一下是否已经点赞过了，如果没有就继续执行，将点赞的数据存储到MongoDB中，为了高效的查询到点赞数，将点赞数存储到Redis中，在存储时使用的是Hash结构进行存储。

## 13、和环信是怎么对接的？

和环信平台的对接主要是在两个方面：

- 前端对接
  - 前端使用环信平台提供的SDK进行与环信进行通信
  - 前提是需要通过账户的用户名与密码进行登录
  - 用户名和密码是有后台系统提供
  - 进行即时通讯时不再经过后台服务，直接与环信进行通信
- 后端对接
  - 后端的对接主要是在用户体系对接上，系统在进行用户注册时，同时在环信平台注册账户
  - 为前端提供接口，返回该账户的用户名密码即可完成环信的对接

整体流程如下：

![image-20201228165200223](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904650.png)

## 14、小视频功能是怎么做的？

> 小视频功能类似于抖音、快手小视频的应用，用户可以上传小视频进行分享，也可以浏览查看别人分享的视频，并且可以对视频评论和点赞操作。

> 对于存储而言，小视频的存储量以及容量都是非常巨大的，所以我们选择自己搭建分布式存储系统 FastDFS进行存储。对于推荐算法，我们将采用多种权重的计算方式进行计算，对于加载速度，除了提升服务器带宽外可以通过CDN的方式进行加速。

> 发布视频的流程是：客户通过点击发布视频，会向后台传递3个数据，一个是视频封面图片，一个是视频，一个是文字。我们在后台会把视频封面图片保存到阿里的OSS图片存储服务器上会给我们返回一个图片的存储链接，把视频上传到本地部署的FastDFS上边会给我们返回一个视频的存储链接，之后我们这边构造一个Video对象，把需要的参数(文字，图片URL，视频URL，用户ID)通过调用VideoAPI进行保存到MongoDB中，之后构造返回值给用户进行显示发布成功。

> 接下来用户会跳转到小视频列表页面。分页查询视频列表是根据后台推荐系统进行智能推荐的，这个根据用户浏览视频的时候点赞，喜欢，评论的情况进行分数积累，把对应的分数值存储到推荐表中，当用户下拉刷新的时候，会从MongoDB中查询出推荐的视频。

发布小视频的流程如下：

![image-20211022180132797](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904808.png)

## 15、测灵魂功能是怎么做的？

> 灵魂测试是通过用户答题的方式来进行分类，寻找同一类型或者内心深处的朋友。我们这块主要采用的技术有：MongoDB +Sprak+Mllib 当用户点击灵魂测试，我们会去后台加载用户的灵魂信息。

如果是新用户我们会停留在初级灵魂题，后边的中级灵魂，高级灵魂则需解锁上一级才能进行答题。

> 如果是老用户我们会加载用户之前测试灵魂的结果进行展示。如果之前他测评通过的是高级灵魂，那么就可以查看初级，中级，高级灵魂的测评。每一级的测评灵魂题都会有10道题，测评结束之后会根据用户的回答生成一个测试报告，通过点击我们可以查看属于自己的唯一一份灵魂报告。

> 生成的报告主要根据用户的属性外向，判断，抽象，理性组成。我们可以把自己的报告进行分享或者选择重做。当进行报告查看时候我们还可以查看系统给我推荐的测试结果相同的好友。通过点击好友头像，我们可以通过回答陌生人问题来进行确认好友，如果对方回复并通过就可以进行正常的交友啦。

## 16、桃花传音功能是怎么做的？

> 语音匹配类似漂流瓶类似，可以发送匿名语音，可以收听匿名语音。收听完匿名语音可以选择喜欢或不喜欢。如果双方互相喜欢那么可以配对成功互相关注，一个人每天只能接收8次，自己接收过语音，其他人不能再使用。

> 如果双方都点击喜欢，就可以添加为好友。这块我们采用的是MongoDB做数据存储，使用Dubbo做分布式服务的调用，使用FastDFS存储语音。

## 17、有实现内容审核机制吗

有的。在用户发布动态时就会进入内容审核环节，主要分为自动审核与手动审核两个流程。其流程如下：

 ![image-20211106172956144](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904946.png)

自动审核使用的是阿里云的内容审核服务，如果自动审核不能确定结果时就需要进入人工审核流程，最终来确定内容是否为合法内容。

## 18、附近的人功能是怎么实现的？

> 附近的人是根据当前用户的位置，查询附近范围内的用户，用户的位置通过APP获取位置数据上报给服务端的，上报频率是当变化大于500米时或每隔5分钟，在底层的存储是，将用户位置数据存储到MongoDB中，其中经纬度数据使用的类型是2dsphere索引类型。

> 在查询附近的人时，使用Spring Data MongoDB中的NearQuery进行查询，通过中心点+距离实现范围搜索，其查询结果会按照距离的由近到远排序。

 ![1571966080530](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904048.png)

## 19、项目中有使用网关吗？网关有什么用

在探花交友项目中有使用网关，是通过SpringCloud Gateway实现的，我们使用网关的目的主要有2个：

> - 入口统一，无论是后台系统还是前端服务系统，都是统一的通过网关进入
> - 统一鉴权，在网关中对用户的请求做统一的鉴权操作，这样可以确保进入服务的请求都是合法有效的请求

使用网关之后的架构如下：

 ![image-20211107111959722](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904202.png)

统一鉴权流程：

![image-20211022153730945](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.3.30/202303130904314.png)















