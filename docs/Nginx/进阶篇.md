



# 快速搭建个人博客网站

## 前言

为什么选择搭建个人博客？一方面是各个平台经常下架原创文章，另一个方面是为了熟悉整个建站流程。

通过搭建个人博客，我们可以自由的发表文章不用担心下架，而且可以锻炼个人的SEO优化能力，不管是运维还是运营这块对个人的技术提升有着很大的帮助。

本篇文章记录了网站从零到一的过程，希望你也能根据本篇文章搭建出属于自己的网站。大家有疑问可以一起讨论。

下面开始正题。

## 环境介绍

| 资源                   | 说明                        |
| ---------------------- | --------------------------- |
| centos                 | v7.2                        |
| docker                 | 快速部署项目环境            |
| nginx                  | 反向代理，同时配置https证书 |
| halo                   | v1.4.2，开源博客项目        |
| Let's Encrypt 免费证书 | 配置https                   |

## 效果演示

> https://yangwq.cn/

## 前置环境安装

### Docker安装

参考：

> https://www.cnblogs.com/winkin/p/14083574.html

### halo安装

#### 准备halo配置文件

```apl
# 下载配置文件到 /home/halo/.halo 目录
curl -o /home/halo/.halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml
```

修改配置文件，将数据库调整为mysql，默认是h2（可选）
<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207311519916.png" alt="image-20220731151944850" style="zoom:67%;" />

将上面h2的数据库注释，并把mysql的配置打开，注意，需要提前在mysql建立数据库 halodb，相关的数据库表halo会自动生成，如果mysql 和 halo都是容器创建的，这里配置的mysqlip应该是mysql容器内部的ip。

```apl
# 查看mysql容器的ip，mysql-prod替换成mysql容器名称或者容器id
docker inspect --format='{{.NetworkSettings.IPAddress}}' mysql
```

修改后：
<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.30/202207311519800.png" alt="image-20220731151958699" style="zoom:67%;" />下载并安装halo

```
# 拉取halo镜像
docker pull ruibaby/halo

# 运行halo
# -p 8090:8090 指定宿主机端口与容器端口映射，这里是将宿主机的8090映射到docker的8090
# -v /home/halo/.halo:/root/.halo 挂载halo配置文件，我们在上一步下载了配置文件在宿主机的/home/halo/.halo
docker run --rm -it -d --name halo -p 8090:8090  -v /home/halo/.halo:/root/.halo ruibaby/halo

## 查看容器状态，确认halo是否启动成功，如果启动失败需要检查下数据库连接
docker ps

# 配置防火墙，注意，阿里云需要同时配置安全组8090端口
# 开放8090端口
firewall-cmd --permanent --add-port=8090/tcp
#重启防火墙(修改配置后要重启防火墙)
firewall-cmd --reload
```

正常情况应该如下：
![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuf7P8uhfWcPKiax4mic0Hf46d5terOWJzLr8F9yFFRdiaBTnTYgEMBqxCDUfguiama6vbAje2Kxq2We2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

经过上面的步骤创建的halo还不能通过外部ip访问，我们现在配置一个nginx进行代理

### nginx安装

```apl
# 下载nginx镜像
docker pull nginx
# 启动nginx
docker run -p 80:80 --name nginx -d nginx

# 我们需要nginx使用我们自定义的配置，最方便的方法将nginx现在有的配置复制一份到宿主机目录 /home/nginx 
docker container cp nginx:/etc/nginx /home/nginx

# 移除我们刚创建的nginx，重新以宿主机配置目录启动
docker stop nginx
docker rm nginx
# 编辑 conf.d 下的default.conf 文件，默认转发到halo端口，ip地址为本机ip
location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
}
改为，10.0.2.5 为本机ip，通过命令 ip addr 查看，端口是halo的端口：
 location / {
     proxy_pass http://10.0.2.5:8090;
 }

# 重新创建nginx
docker run -p 80:80 --name nginx \
-v /home/nginx/logs:/var/log/nginx \
-v /home/nginx/nginx.conf:/etc/nginx/nginx.conf \
-v /home/nginx/conf.d:/etc/nginx/conf.d \
-d nginx

# 配置防火墙，注意，阿里云需要同时配置安全组80端口
# 开放80端口
firewall-cmd --permanent --add-port=80/tcp
#重启防火墙(修改配置后要重启防火墙)
firewall-cmd --reload

# 到这里，我们可以通过ip访问halo了
```

到这一步如果不能使用ip直接访问，首先确定halo启动成功没，然后查看nginx配置是否正确，最后再检查防火墙和安全组。

## 域名及网站备案

目前我们只能通过ip访问halo，我们可以通过配置域名进行访问。

首先我们得申请一个域名：

> https://wanwang.aliyun.com/domain

申请完成后进行备案：

> https://beian.aliyun.com/

备案注意事项：

- 如果处于异地工作的情况，建议备案地点选择老家，而且手上要有老家的手机号，如果选择异地的话，需要你提供临时居住证之类比较麻烦。
- 阿里云备案时间在一周左右，一般提交申请会有人找你确认信息，之后按备案流程走就行了。

## 配置https

一般情况证书是需要购买的，但是也有一些平台提供了免费证书，阿里云也有一年的免费证书，但是阿里云证书只能单个域名使用，如果要通配符证书是需要付费的。而Let’s Encrypt 证书即可以免费申请证书，又支持通配符，是个人开发者的上选。

这里我们通过github项目配置免费证书（也可以手动安装，不过自动安装比较方便，下面两种方式都会提到）：`letencrypt-certbot`

> https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au

使用此项目前我们配置一下前置环境：certbot 和 git

### 安装git

```apl
yum install git
```

### 安装certbot

```apl
# 安装certbot，中间需要输入y确认
yum install epel-release
yum install certbot 
# 查看版本，如果安装正常会显示版本号
certbot --version
```

### 申请证书

特别注意的是，这里需要主机把80端口和443端口开放，上面我们已经开放了80端口，这里开放443端口就行了

```apl
# 配置防火墙，注意，阿里云需要同时配置安全组443端口
# 开放443端口
firewall-cmd --permanent --add-port=443/tcp
#重启防火墙(修改配置后要重启防火墙)
firewall-cmd --reload
```

重要提示：为避免遇到操作次数的限制，加入 dry-run 参数，可以避免操作限制，等执行无误后，再进行真实的 renew 操作

### 手动安装证书+手动续期

```apl
# 申请证书，需要填入你的邮箱和域名, --dry-run 测试使用不会生成证书，我们先用这个命令看是否成功
certbot certonly --email 你的邮箱@qq.com -d *.域名.cn -d 域名.cn --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory --dry-run
# 如果没有错误信息，去掉--dry-run真正生成证书
certbot certonly --email 你的邮箱@qq.com -d *.域名.cn -d 域名.cn --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory

# 手动续期
certbot renew
```

安装过程中，需要确认选项，讲一下手动安装的重点：
![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuf7P8uhfWcPKiax4mic0Hf46dYuCDbOVlAWVA7soZaPeTqcDoibGBicnnYXrzLtEicEoicAIljM22A8GibwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
安装成功后显示：
![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuf7P8uhfWcPKiax4mic0Hf46dNOWtdk8UINOOqJcmK2JM7YvRDYzYwQa5QM46V7HfYVc9aaV2iajfhDA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

注意：证书90天后过期，我们手动续期的话比较麻烦，而且每次需要手动去DNS解析列表创建对应的记录，所以推荐下面的自动续期方式

### 通过apikey 和secret生成证书+自动续期

首先获取api key 和secret：

> https://help.aliyun.com/knowledge_detail/38738.html

这种方式其实是利用你开放的api key调用阿里云提供的接口，所以保险起见我们创建一个权限很小的用户就行了。

流程：

- 为了安全，我们需要先创建RAM用户，配置一个权限小的用户；
- 给新创建的用户配置 AliyunDNSFullAccess（管理云解析（DNS）） 的权限；
- 获取apikey 和 secret。

```apl
# 新建一个目标，拉取项目
mkdir /home/certbot
cd /home/certbot
git clone https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au
cd certbot-letencrypt-wildcardcertificates-alydns-au
chmod 0777 au.sh

# 编辑au.sh，加入我们上面申请的key
vi au.sh

#填写阿里云的AccessKey ID及AccessKey Secret
#如何申请见https://help.aliyun.com/knowledge_detail/38738.html
ALY_KEY=""
ALY_TOKEN=""

# 运行命令，加上--dry-run 测试，如果没问题去掉 --dry-run 执行，脚本目录就是我们上面创建的 /home/certbot/certbot-letencrypt-wildcardcertificates-alydns-au
certbot certonly  -d *.yangwq.cn -d yangwq.cn --manual --preferred-challenges dns-01 --email 1075976874@qq.com  --manual-auth-hook "/脚本目录/au.sh python aly add" --manual-cleanup-hook "/脚本目录/au.sh python aly clean" --dry-run;

# 配置自动续期，使用crontab实现
vi /etc/crontab

# 加入以下命令，这个命令就是每周执行一次脚本，如果需要续期就会自动更新
0 0 * * 0 root certbot renew --manual --preferred-challenges dns --deploy-hook  "docker restart nginx" --manual-auth-hook "/脚本目录/au.sh python aly add" --manual-cleanup-hook "/脚本目录/au.sh python aly clean" --manual-public-ip-logging-ok;
```

到这一步我们证书生成成功了，同样存放在 /etc/letsencrypt/live/yangwq.cn/ 目录，注意这里的文件是软链接，我们实际上的文件在 etc/letsencrypt/archive/yangwq.cn 目录

### nginx安装证书

```apl
# 编辑conf.d 下的default.conf
server {
    listen       80 default;
    server_name yangwq.cn;
 # http自动转https
    rewrite ^(.*)$  https://$host$1 permanent;
  
}

server {
    listen 443 ssl;
    server_name yangwq.cn;
    
    # 配置站点证书文件地址
    ssl_certificate  /etc/letsencrypt/archive/yangwq.cn/fullchain1.pem;
    # 配置证书私钥
    ssl_certificate_key  /etc/letsencrypt/archive/yangwq.cn/privkey1.pem;
 
    
    # 配置服务器可使用的加密算法
    ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';

    # 指定服务器密码算法在优先于客户端密码算法时，使用 SSLv3 和 TLS 协议
    ssl_prefer_server_ciphers  on;
    
    # ssl 版本 可用 SSLv2,SSLv3,TLSv1,TLSv1.1,TLSv1.2 
    # ie6 只支持 SSLv2,SSLv3 但是存在安全问题, 故不支持
    ssl_protocols        TLSv1 TLSv1.1 TLSv1.2;
    
    # 配置 TLS 握手后生成的 session 缓存空间大小 1m 大约能存储 4000 个 session
    ssl_session_cache          shared:SSL:50m;
    # session 超时时间
    ssl_session_timeout        1d;
    
    # 负载均衡时使用 此处暂时关闭 详情见 https://imququ.com/post/optimize-tls-handshake.html 
    # 1.5.9 及以上支持
    ssl_session_tickets off;
    
    # 浏览器可能会在建立 TLS 连接时在线验证证书有效性，从而阻塞 TLS 握手，拖慢整体速度。OCSP stapling 是一种优化措施，服务端通过它可以在证书链中封装证书颁发机构的 OCSP（Online Certificate Status Protocol）响应，从而让浏览器跳过在线查询。服务端获取 OCSP 一方面更快（因为服务端一般有更好的网络环境），另一方面可以更好地缓存 以上内容来自 https://imququ.com/post/my-nginx-conf-for-wpo.html
    # 1.3.7 及以上支持
    ssl_stapling               on;
    ssl_stapling_verify        on;
    # 根证书 + 中间证书
    ssl_trusted_certificate    /etc/letsencrypt/archive/yangwq.cn/fullchain1.pem;
    
    # HSTS 可以告诉浏览器，在指定的 max-age 内，始终通过 HTTPS 访问该域名。即使用户自己输入 HTTP 的地址，或者点击了 HTTP 链接，浏览器也会在本地替换为 HTTPS 再发送请求 相关配置见 https://imququ.com/post/sth-about-switch-to-https.html
    add_header Strict-Transport-Security max-age=60;
    
    # 在此填写原本 http 协议中的配置
    location / {                           # 定义首页索引目录和名称
        proxy_pass http://172.24.35.32:8080;
    }
  error_page   500 502 503 504  /50x.html;
    location = /50x.html {                #重定向错误页面到 /50x.html
        root   /usr/share/nginx/html;
    }

}
```

注意：将上面yangwq.cn相关的路径换成你的域名路径。

```apl
# 为了让nginx能访问到我们刚生成的证书，需要重新挂载证书路径到nginx
docker stop nginx
docker rm nginx
# 运行nginx,此处加入了443端口和证书路径
docker run -p 80:80 -p 443:443 --name nginx \
-v /home/nginx/logs:/var/log//nginx \
-v /home/nginx/nginx.conf:/etc/nginx/nginx.conf \
-v /home/nginx/conf.d:/etc/nginx/conf.d \
-v /etc/letsencrypt/archive/:/etc/letsencrypt/archive/ \
-d nginx
```

此时我们就可以通过https域名访问项目了，而且这个时候也可以新建二级域名访问项目的（二级域名同样是https）。





# Lua

## Lua 概览

### 概念

> Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。
>

### 特性

> 轻量级：Lua用标准C语言编写并以源代码形式开发，编译后仅仅一百余千字节，可以很方便的嵌入到其他程序中
>

> 可扩展：Lua提供非常丰富易于使用的扩展接口和机制，由宿主语言(通常是C或C++)提供功能，Lua可以使用它们，就像内置的功能一样。

> 支持面向过程编程和函数式编程

### 应用场景

> Lua在不同的系统中得到大量应用，游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全
>

## Lua的安装

在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。

Lua的官网地址为:`https://www.lua.org`

点击download可以找到对应版本的下载地址，我们本次课程采用的是lua-5.3.5,其对应的资源链接地址为https://www.lua.org/ftp/lua-5.4.1.tar.gz,也可以使用wget命令直接下载:

```
wget https://www.lua.org/ftp/lua-5.4.1.tar.gz
```

编译安装

```
cd lua-5.4.1
make linux test
make install
```

如果在执行make linux test失败，说明当前系统缺少libreadline-dev依赖包，需要通过命令来进行安装

```
yum install -y readline-devel
```

验证是否安装成功

```
lua -v
```

## 第一个Lua程序

> Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难

大家需要知道的是，Lua有两种交互方式，分别是:交互式和脚本式，这两者的区别，下面我们分别来讲解下：

### Lua命令行

交互式是指可以在命令行输入程序，然后回车就可以看到运行的效果。

Lua交互式编程模式可以通过命令lua -i 或lua来启用:

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301190956788.png" alt="image-20230119095616724" style="zoom:67%;" />

在命令行中key输入如下命令，并按回车,会有输出在控制台：

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301190956647.png" alt="image-20230119095645567" style="zoom:67%;" />

### Lua 脚本

脚本式是将代码保存到一个以lua为扩展名的文件中并执行的方式。

方式一:

我们需要一个文件名为 hello.lua,然后通过命令 `lua hello.lua`来执行，会在控制台输出对应的结果。

hello.lua

```
print("Hello World!!")
```

将hello.lua做如下修改

```
#!/usr/local/bin/lua
print("Hello World!!!")
```

第一行用来指定Lua解释器所在位置为 /usr/local/bin/lua，加上#号标记解释器会忽略它。一般情况下#!就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为:

```
chmod 755 hello.lua
```

然后执行该文件 

```
./hello.lua
```

### 注意事项

补充一点，如果想在交互式中运行脚本式的hello.lua中的内容，我们可以使用一个dofile函数，如：

```
dofile("lua_demo/hello.lua")
```

注意:在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错，

在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的

```lua
-- 写法一
a=1
b=a+2
-- 写法二
a=1;
b=a+2;
-- 写法三
a=1; b=a+2;
-- 写法四
a=1 b=a+2
```

不建议使用第四种方式，可读性太差。

## Lua的注释

关于Lua的注释要分两种，第一种是单行注释，第二种是多行注释。

单行注释的语法为：

```
--注释内容
```

多行注释的语法为:

```
--[[
	注释内容
	注释内容
--]]
```

如果想取消多行注释，只需要在第一个--之前在加一个-即可，如：

```
---[[
	注释内容
	注释内容
--]]
```

## 标识符

换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。这块建议大家最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样定义的，容易发生冲突。注意Lua是区分大小写字母的。

## 关键字

下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字：

| and      | break | do    | else   |
| -------- | ----- | ----- | ------ |
| elseif   | end   | false | for    |
| function | if    | in    | local  |
| nil      | not   | or    | repeat |
| return   | then  | true  | until  |
| while    | goto  |       |        |

一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。

## 运算符

Lua中支持的运算符有算术运算符、关系运算符、逻辑运算符、其他运算符。

算术运算符:

```
+   加法
-	减法
*	乘法
/	除法
%	取余
^	乘幂
-	负号
```

例如:

```
10+20	-->30
20-10	-->10
10*20	-->200
20/10	-->2
3%2		-->1
10^2	-->100
-10		-->-10
```

关系运算符

```
==	等于
~=	不等于
>	大于
<	小于
>=	大于等于
<=	小于等于
```

例如:

```
10==10		-->true
10~=10		-->false
20>10		-->true
20<10		-->false
20>=10		-->true
20<=10		-->false
```

逻辑运算符

```
and	逻辑与	 A and B     &&   
or	逻辑或	 A or B     ||
not	逻辑非  取反，如果为true,则返回false  !
```

逻辑运算符可以作为if的判断条件，返回的结果如下:

```
A = true
B = true

A and B	-->true
A or  B -->true
not A 	-->false

A = true
B = false

A and B	-->false
A or  B -->true
not A 	-->false

A = false
B = true

A and B	-->false
A or  B -->true
not A 	-->true
```

其他运算符

```
..	连接两个字符串
#	一元预算法，返回字符串或表的长度
```

例如:

```
> "HELLO ".."WORLD"		-->HELLO WORLD
> #"HELLO"			-->5
```

## 全局变量&局部变量

在Lua语言中，全局变量无须声明即可使用。在默认情况下，变量总是认为是全局的，如果未提前赋值，默认为nil:

![1604650220670](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301181923006.png)

要想声明一个局部变量，需要使用local来声明

![1604650235860](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301181923034.png)

## Lua数据类型

Lua有8个数据类型

```
nil(空，无效值)
boolean(布尔，true/false)
number(数值)
string(字符串)
function(函数)
table（表）
thread(线程)
userdata（用户数据）
```

可以使用type函数测试给定变量或者的类型：

```
print(type(nil))				-->nil
print(type(true))               --> boolean
print(type(1.1*1.1))             --> number
print(type("Hello world"))      --> string
print(type(io.stdin))			-->userdata
print(type(print))              --> function
print(type(type))               -->function
print(type{})					-->table
print(type(type(X)))            --> string
```

### nil

nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存。

### boolean

boolean类型具有两个值，true和false。boolean类型一般被用来做条件判断的真与假。在Lua语言中，只会将false和nil视为假，其他的都视为真，特别是在条件检测中0和空字符串都会认为是真，这个和我们熟悉的大多数语言不太一样。

### number

在Lua5.3版本开始，Lua语言为数值格式提供了两种选择:integer(整型)和float(双精度浮点型)[和其他语言不太一样，float不代表单精度类型]。

数值常量的表示方式:

```
>4			-->4
>0.4		-->0.4
>4.75e-3	-->0.00475
>4.75e3		-->4750
```

不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number

```
>type(3)	-->number
>type(3.3)	-->number
```

所以它们之间是可以相互转换的，同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的

### string

Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。

可以使用单引号或双引号来声明字符串

```
>a = "hello"
>b = 'world'
>print(a)	-->hello
>print(b) 	-->world
```

如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明

```
html = [[
<html>
<head>
<title>Lua-string</title>
</head>
<body>
<a href="http://www.lua.org">Lua</a>
</body>
</html>
]]
```

### table ⭐

> table是Lua语言中最主要和强大的数据结构。使用表， Lua 语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 Lua语言中的表本质上是一种辅助数组。这种数组比Java中的数组更加灵活，可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。
>

创建表的最简单方式:

```
> a = {}
```

创建数组:我们都知道数组就是相同数据类型的元素按照一定顺序排列的集合，那么使用table如何创建一个数组呢?

```
>arr = {"TOM","JERRY","ROSE"}
```

要想获取数组中的值，我们可以通过如下内容来获取:

```lua
-- 下标默认从1开始
print(arr[0])		nil
print(arr[1])		TOM
print(arr[2])		JERRY
print(arr[3])		ROSE
```

​	从上面的结果可以看出来，数组的下标默认是从1开始的。所以上述创建数组，也可以通过如下方式来创建

```lua
>arr = {}
>arr[1] = "TOM"
>arr[2] = "JERRY"
>arr[3] = "ROSE"
```

上面我们说过了，表的索引即可以是数字，也可以是字符串等其他的内容，所以我们也可以将索引更改为字符串来创建

```lua
>arr = {}
>arr["X"] = 10
>arr["Y"] = 20
>arr["Z"] = 30
```

当然，如果想要获取这些数组中的值，可以使用下面的方式

```lua
-- 方式一
>print(arr["X"])
>print(arr["Y"])
>print(arr["Z"])
-- 方式二
>print(arr.X)
>print(arr.Y)
>print(arr.Z)
```

当前table的灵活不进于此，还有更灵活的声明方式

```lua
>arr = {"TOM",X=10,"JERRY",Y=20,"ROSE",Z=30}
```

如何获取上面的值?

```lua
TOM :  arr[1]
10  :  arr["X"] | arr.X
JERRY: arr[2]
20  :  arr["Y"] | arr.Y
ROESE?
```

### thread

> thread翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。
>

### userdata

> userdata是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。
>

## function 函数 ⭐

在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。

### 定义函数语法

```lua
function functionName(params)

end
```

### 传参

> 函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过 抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数。

```lua
function  f(a,b)
print(a,b)
end

f()		--> nil  nil
f(2)	--> 2 nil
f(2,6)	--> 2 6
f(2.6.8)	--> 2 6 (8被丢弃)
```

### 可变参数

```lua
function add(...)
a,b,c=...
print(a)
print(b)
print(c)
end

add(1,2,3)  --> 1 2 3
```

### 多个返回值

函数返回值可以有多个，这点和Java不太一样

```lua
function f(a,b)
return a,b
end

x,y=f(11,22)	--> x=11,y=22	
```



## Lua控制结构

Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 while、 repeat 和 for。 所有的控制结构语法上都有一个显式的终结符： end 用于终结 if、 for 及 while 结构， until 用于终结 repeat 结构。

### if then elseif else

if语句先测试其条件，并根据条件是否满足执行相应的 then 部分或 else 部分。 else 部分 是可选的。

```lua
function testif(a)
 if a>0 then
 	print("a是正数")
 end
end
```

```lua
function testif(a)
 if a>0 then
 	print("a是正数")
 else
 	print("a是负数")
 end
end
```

如果要编写嵌套的 if 语句，可以使用 elseif。 它类似于在 else 后面紧跟一个if。根据传入的年龄返回不同的结果，如

> age<=18 青少年，age>18 , age <=45 青年，age>45 , age<=60 中年人，age>60 老年人

```lua
function show(age)
    if age<=18 then
       return "青少年"
    elseif age>18 and age<=45 then
       return "青年"
    elseif age>45 and age<=60 then
       return "中年人"
    elseif age>60 then
       return "老年人"
    end
end
```

### while循环

顾名思义，当条件为真时 while 循环会重复执行其循环体。 Lua 语言先测试 while 语句 的条件，若条件为假则循环结束；否则， Lua 会执行循环体并不断地重复这个过程。

语法：

```lua
while 条件 do
  循环体
end
```

例子:实现数组的循环

```lua
function testWhile()
   local i = 1
   while i<=10 do
      print(i)
      i=i+1
   end
end
```

### repeat循环

顾名思义， repeat-until语句会重复执行其循环体直到条件为真时结束。 由于条件测试在循环体之后执行，所以循环体至少会执行一次。

语法

```lua
repeat
 循环体
 until 条件
```

```lua
function testRepeat()
   local i = 10
   repeat
      print(i)
      i=i-1
   until i < 1
end
```

### for循环 ⭐

数值型for循环

```lua
for param=exp1,exp2,exp3 do
 循环体
end
```

param的值从exp1变化到exp2之前的每次循环会执行 循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1

```lua
for i = 1,100,10 do
  print(i)
end
```

泛型for循环

泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。

语法

```lua
for i,v in ipairs(x) do
	循环体
end
```

i是数组索引值，v是对应索引的数组元素值，ipairs是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。

例如:

```lua
arr = {"TOME","JERRY","ROWS","LUCY"}
for i,v in ipairs(arr) do
  print(i,v)
end
```

上述实例输出的结果为

```lua
1	TOM
2	JERRY
3	ROWS
4	LUCY
```

但是如果将arr的值进行修改为

```lua
arr = {"TOME","JERRY","ROWS",x="JACK","LUCY"}
```

同样的代码在执行的时候，就只能看到和之前一样的结果，而其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢?

我们可以将迭代器函数变成pairs,如

```lua
for i,v in pairs(arr) do
 print(i,v)
end
```

上述实例就输出的结果为

```lua
1	TOM
2	JERRY
3	ROWS
4	LUCY
x	JACK
```



# OpenRestry

## 概念

> 淘宝开发的ngx_lua模块通过将lua解释器集成进Nginx，可以采用lua脚本实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。
>

> 前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站(<http://openresty.org/>)我们读起来是非常的方便。OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以本身OpenResty内部就已经集成了Nginx和Lua，所以我们使用起来会更加方便。

## 环境准备

### 安装编译

```sh
# 使用wget下载
wget https://openresty.org/download/openresty-1.15.8.2.tar.gz
# 解压缩
tar -zxvf openresty-1.15.8.2.tar.gz
# 进入OpenResty目录:
cd openresty-1.15.8.2
# 编译安装
./configure
make && make install
```

### 访问测试

进入OpenResty的目录，找到nginx：cd /usr/local/openresty/nginx/，在conf目录下的nginx.conf添加如下内容

```apl
location /lua{
    default_type 'text/html';
    content_by_lua 'ngx.say("<h1>HELLO,OpenRestry</h1>")';
}
```

在sbin目录下启动nginx

```sh
cd sbin
./nginx
```

通过浏览器访问测试

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301191044533.png" alt="image-20230119104449454" style="zoom:67%;" />



<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301191045831.png" alt="image-20230119104518775" style="zoom:80%;" />

## ngx_lua 详解

使用Lua编写Nginx脚本的基本构建块是指令。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。

![1604717983815](https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022/202204301712574.png)

先来解释下*的作用

```scala
*：无 ， 即 xxx_by_lua ,指令后面跟的是 lua指令
*:_file，即 xxx_by_lua_file 指令后面跟的是 lua文件
*:_block,即 xxx_by_lua_block 在0.9.17版后替换init_by_lua_file
```

### init_by_lua*

> 该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。

### init_worker_by_lua*

> 该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。

### set_by_lua*

> 该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。

### rewrite_by_lua*

> 该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。

### access_by_lua*

> 该指令用于访问控制。例如，如果只允许内网IP访问。

### content_by_lua*

> 该指令是应用最多的指令，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。

### header_filter_by_lua*

> 该指令用于设置应答消息的头部信息。

### body_filter_by_lua*

> 该指令是对响应数据进行过滤，如截断、替换。

### log_by_lua*

> 该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。

### balancer_by_lua*

> 该指令主要的作用是用来实现上游服务器的负载均衡器算法

### ssl_certificate_by_*

> 该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。

## ngx_lua 案例⭐

### 需求描述

> http://192.168.22.130?name=张三&gender=1

> Nginx接收到请求后，根据gender传入的值，
>
> 如果gender传入的是1，则在页面上展示张三先生
>
> 如果gender传入的是0，则在页面上展示张三女士
>
> 如果未传或者传入的不是1和2则在页面上展示张三

### 实现代码

> 注意：要把注释去掉才能执行成功

```lua
location /getByGender {
	default_type 'text/html';
	set_by_lua $name "
		local uri_args = ngx.req.get_uri_args() # 获取传入参数
		gender = uri_args['gender'] # 将传入参数进行赋值
		name = uri_args['name']
		if gender=='1' then
			return name..'先生' # ..表示拼接字符串，因为外部使用双引号，此处必须单引号
		elseif gender=='0' then
			return name..'女士'
		else
			return name
		end
	";
	charset utf-8; # 避免乱码
	header_filter_by_lua "
		ngx.header.aaa='bbb'
	";
	return 200 $name;
}
```

访问测试

```apl
 ./nginx -s reload
```

http://192.168.22.130/getByGender?name=张三&gender=1

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202211457.png" alt="image-20220620221157375" style="zoom:67%;" />



## 操作Redis

> Redis在系统中经常作为数据缓存、内存数据库使用，在大型系统中扮演着非常重要的作用。在Nginx核心系统中，Redis是常备组件。Nginx支持3种方法访问Redis,分别是HttpRedis模块、HttpRedis2Module、lua-resty-redis库。

> HttpRedis模块提供的指令少，功能单一，适合做简单缓存
>
> HttpRedis2Module模块比HttpRedis模块操作更灵活，功能更强大。
>
> Lua-resty-redis库是OpenResty提供的一个操作Redis的接口库，可根据自己的业务情况做一些逻辑处理，适合做复杂的业务逻辑。所以本次课程将主要以Lua-resty-redis来进行讲解

### resty-redis API

> - lua-resty-redis提供了访问Redis的详细API，包括创建对接、连接、操作、数据处理等。基本与Redis的操作对应
> - redis = require "resty.redis"
> - new语法: redis,err = redis:new(),创建一个Redis对象。
> - connect语法: ok,err=redis:connect(host,port[,options_table]),设置连接Redis的连接信息。ok:连接成功返回 1，连接失败返回nil，err:返回对应的错误信息
> - set_timeout语法: redis:set_timeout(time) ，设置请求操作Redis的超时时间。
> - close语法: ok,err = redis:close(),关闭当前连接，成功返回1，失败返回nil和错误信息
> - redis命令对应的方法：在lua-resty-redis中，所有的Redis命令都有自己的方法，方法名字和命令名字相同，只是全部为小写

### 环境准备

步骤一:准备一个Redis环境

```sh
# 连接地址
host= 192.168.0.130
port=6379
redis-server /etc/redis.conf
redis-cli
```

### 实现代码

```lua
location /testRedis {
    default_type "text/html";
    content_by_lua_block{
        local redis = require "resty.redis" -- 引入Redis
        local redisObj = redis:new()  --创建Redis对象
        redisObj:set_timeout(1000) --设置超时数据为1s
        local ok,err = redisObj:connect("192.168.22.130",6379) --设置redis连接信息
        if not ok then --判断是否连接成功
           ngx.say("failed to connection redis",err)
           return
        end
        ok,err = redisObj:set("username","TOM")--存入数据
        if not ok then --判断是否存入成功
           ngx.say("failed to set username",err)
           return
        end
        local res,err = redisObj:get("username") --从redis中获取数据
        ngx.say(res)	--将数据写会消息体中，返回给前端页面
        redisObj:close()
    }
}
```

步骤四:运行测试效果

http://192.168.22.130/testRedis

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202218930.png" alt="image-20220620221800877" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202218074.png" alt="image-20220620221843012" style="zoom:67%;" />



## 操作MySQL

MySQL是一个使用广泛的关系型数据库。在ngx_lua中，MySQL有两种访问模式,分别是使

> 用ngx_lua模块和lua-resty-mysql模块：这两个模块是安装OpenResty时默认安装的。
>
> 使用drizzle_nginx_module(HttpDrizzleModule)模块：需要单独安装，这个库现不在OpenResty中。

> lua-resty-mysql是OpenResty开发的模块，使用灵活、功能强大，适合复杂的业务场景，同时支持存储过程的访问
>

### MySQL 连接和数据

创建一个数据库表及表中的数据。

```apl
mysql -uroot -p123456
mysql -uroot -p123456 -h 192.168.0.199 -P 3307
```

```apl
create database nginx_db;

use nginx_db;

create table users(
   id int primary key auto_increment,
   username varchar(30),
   birthday date,
   salary double
);

insert into users(id,username,birthday,salary) values(null,"TOM","1988-11-11",10000.0);
insert into users(id,username,birthday,salary) values(null,"JERRY","1989-11-11",20000.0);
insert into users(id,username,birthday,salary) values(null,"ROWS","1990-11-11",30000.0);
insert into users(id,username,birthday,salary) values(null,"LUCY","1991-11-11",40000.0);
insert into users(id,username,birthday,salary) values(null,"JACK","1992-11-11",50000.0);
```

### resty-mysql API

```lua
-- 引入"resty.mysql"模块
local mysql = require "resty.mysql"
-- new，创建一个MySQL连接对象，遇到错误时，db为nil，err为错误描述信息
db,err = mysql:new()
-- connect：尝试连接到一个MySQL服务器
ok,err=db:connect(options)
-- options是一个参数的Lua表结构，里面包含数据库连接的相关信息
    host:服务器主机名或IP地址
    port:服务器监听端口，默认为3306
    user:登录的用户名
    password:登录密码
    database:使用的数据库名
-- set_timeout 设置子请求的超时时间(ms)，包括connect方法
db:set_timeout(time)
-- close 关闭当前MySQL连接并返回状态。如果成功，则返回1；如果出现任何错误，则将返回nil和错误描述。
db:close()
-- send_query：异步向远程MySQL发送一个查询。如果成功则返回成功发送的字节数；如果错误，则返回nil和错误描述
bytes,err=db:send_query(sql)
-- read_result：从MySQL服务器返回结果中读取一行数据。res返回一个描述OK包或结果集包的Lua表
res, err, errcode, sqlstate = db:read_result() 
res, err, errcode, sqlstate = db:read_result(rows) --:rows指定返回结果集的最大值，默认为4
```


结果集分析

```lua
-- 如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key-value对，如
{
  {id=1,username="TOM",birthday="1988-11-11",salary=10000.0},
  {id=2,username="JERRY",birthday="1989-11-11",salary=20000.0}
}
-- 如果是增删改，则返回类上如下数据
{
	insert_id = 0,
	server_status=2,
	warning_count=1,
	affected_rows=2,
	message=nil
}
-- 返回值:
	res:操作的结果集
	err:错误信息
	errcode:MySQL的错误码，比如1064
	sqlstate:返回由5个字符组成的标准SQL错误码，比如42000
```

### 查询实现

> 当连接的是MySQL8时，可能会出现连接不上问题，因此可以进入MySQL8的命令行，执行如下命令即可

```mysql
use mysql;
update user set plugin='mysql_native_password' where user='root';
alter user 'root'@'%' identified with mysql_native_password by '123456';
flush privileges;
```

```lua
location /testMySQL {
    default_type "text/html";
    charset utf-8;
    content_by_lua_block{
        local mysql = require "resty.mysql"
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.0.199",
            port=3307,
            user="root",
            password="123456",
            database="nginx_db"
        }
	   if err then 
           ngx.say(err)
           return
        end
        db:set_timeout(1000) 
        db:send_query("select * from users where id = 2")
        local res,err,errcode,sqlstate = db:read_result()
        if err then 
           ngx.say(err)
           return
        end
        -- 进行结果拼接
        ngx.say('结果查询成功')
        ngx.say(res[1].id..","..res[1].username..","..res[1].birthday..","..res[1].salary)
        db:close()
    }
}
```

进行访问：http://192.168.22.130/testMySQL

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.1.30/202301191208846.png" alt="image-20230119120825771" style="zoom:80%;" />

### cjson 结果拼接简化⭐

通过上述的案例学习，read_result()得到的结果res都是table类型，要想在页面上展示，就必须知道table的具体数据结构才能进行遍历获取。处理起来比较麻烦，接下来我们介绍一种简单方式cjson，使用它就可以将table类型的数据转换成json字符串，把json字符串展示在页面上即可。具体如何使用?

> 1.如何获取返回数据的内容
>
> 2.如何实现查询多条数据
>
> 3.如何实现数据库的增删改操作

#### cjson用法

步骤一：引入cjson

方式一：局部变量

```apl
local cjson = require "cjson"
```

方式二：全局变量，需要设置在server块外部，http块内部

```apl
init_by_lua_block {
    cjson = require "cjson"
}
```

步骤二：调用cjson的encode方法进行类型转换

```apl
cjson.encode(res) 
```

#### 完整使用

```apl
location /testMySQL {
    default_type "text/html";
    content_by_lua_block{
        local mysql = require "resty.mysql"
        -- 定义局部变量
        local cjson = require "cjson"
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.22.130",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db"
        }
        db:set_timeout(1000)
        -- 批量结果
        db:send_query("select * from users")
        local res,err,errcode,sqlstate = db:read_result()
        -- cjson的结果
        ngx.say(cjson.encode(res))
        -- 正常遍历结果
        for i,v in ipairs(res) do
            ngx.say(v.id..","..v.username..","..v.birthday..","..v.salary)
         end
    	db:close()
    }
}
```

http://192.168.22.130/testMySQL

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202238804.png" alt="image-20220620223843739" style="zoom:80%;" />

### 增删改实现

优化send_query和read_result

本方法是send_query和read_result组合的快捷方法。很简单，只要替换SQL就行了

```apl
res, err, errcode, sqlstate = db:query(sql[,rows])
```

有了该API，上面的代码我们就可以进行对应的优化，如下:

#### 查

```apl
location /testMySQL {
    default_type "text/html";
    content_by_lua_block{
        local mysql = require "resty.mysql"
        local cjson = require "cjson"
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.22.130",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db",
            max_packet_size=1024,
            compact_arrays=false
        }
        db:set_timeout(1000)
        local res,err,errcode,sqlstate = db:query("select * from users")
        ngx.say(cjson.encode(res))
        db:close()
    }
}
```

http://192.168.22.130/testMySQL

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202246460.png" alt="image-20220620224644360" style="zoom:67%;" />

#### 增加

```apl
location /testMySQL {
    default_type "text/html";
    content_by_lua_block{
        local mysql = require "resty.mysql"
        local cjson = require "cjson"
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.22.130",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db",
            max_packet_size=1024,
            compact_arrays=false
        }
        db:set_timeout(1000)
        local sql = "insert into users(id,username,birthday,salary)   
                     values(null,'zhangsan','2020-11-11',32222.0)"
        local res,err,errcode,sqlstate = db:query(sql)
        ngx.say(cjson.encode(res))
        db:close()
    }
}
```

http://192.168.22.130/testMySQL

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202250229.png" alt="image-20220620225029163" style="zoom:67%;" />

#### 修改

```apl
location /testMySQL {
    default_type "text/html";
    content_by_lua_block{
        local mysql = require "resty.mysql"
        local cjson = require "cjson"
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.22.130",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db",
            max_packet_size=1024,
            compact_arrays=false
        }
        db:set_timeout(1000)
        local sql = "update users set username='lisi' where id = 6"
        local res,err,errcode,sqlstate = db:query(sql)
        ngx.say(cjson.encode(res))
        db:close()
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202251049.png" alt="image-20220620225119976" style="zoom: 67%;" />

#### 删除

```apl
location /testMySQL {
    default_type "text/html";
    content_by_lua_block{
        local mysql = require "resty.mysql"
        local cjson = require "cjson"
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.22.130",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db",
            max_packet_size=1024,
            compact_arrays=false
        }
        db:set_timeout(1000)
        local sql = "delete from users where id = 6"
        local res,err,errcode,sqlstate = db:query(sql)
        ngx.say(cjson.encode(res))
        db:close()
    }
}
```

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202253868.png" alt="image-20220620225315803" style="zoom:67%;" />



## 综合案例-缓存预热

> 使用ngx_lua模块完成Redis缓存预热
>

### 问题分析

（1）先得有一张表(users)，就是上面的users表

（2）浏览器输入如下地址

```lua
-- 存入所有信息
http://192.168.22.130/test
-- 存入TOM个人信息
http://192.168.22.130/test?username=TOM
```

（3）从表中查询出符合条件的记录，此时获取的结果为table类型

（4）使用cjson将table数据转换成json字符串

（5）将查询的结果数据存入Redis中

### 引入资源-全局变量

http块中引入，按照使用顺序依次引入

```apl
init_by_lua_block {
    mysql = require "resty.mysql"
    redis = require "resty.redis"
    cjson = require "cjson"
}
```

实现

```apl
location /test {
    default_type "text/html";
    content_by_lua_block{
        --获取请求的参数username
        local param = ngx.req.get_uri_args()["username"]
        --建立mysql数据库的连接
        local db = mysql:new()
        local ok,err = db:connect{
                host="192.168.0.199",
                port=3307,
                user="root",
                password="123456",
                database="nginx_db"
            }
        if not ok then
            ngx.say("failed connect to mysql:",err)
            return
        end
        --设置连接超时时间
        db:set_timeout(1000)
        --查询数据
        local sql = "";
        -- 没有传入参数，最上面req.get_uri_args获取传入的username
        if not param then
            sql="select * from users"
        else
            sql="select * from users where username=".."'"..param.."'"
        end
        --传递SQL
        local res,err,errcode,sqlstate=db:query(sql)
        if not res then
        ngx.say("failed to query from mysql:",err)
            return
        end
        --连接redis
        local rd = redis:new()
        ok,err = rd:connect("192.168.22.130",6379)
        if not ok then
            ngx.say("failed to connect to redis:",err)
             return
        end
        rd:set_timeout(1000)
        --循环遍历数据(存入redis)
        for i,v in ipairs(res) do
            rd:set("user_"..v.username, cjson.encode(v))
        end
        ngx.say("success")
        rd:close()
        db:close()
    }
}
```

### 测试

http://192.168.22.130/test?username=TOM

http://192.168.22.130/test

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2022.6.11/202206202318145.png" alt="image-20220620231821073" style="zoom:50%;" />

# 性能优化 ⭐

到这里文章的篇幅较长了，最后再来聊一下关于`Nginx`的性能优化，主要就简单说说收益最高的几个优化项，在这块就不再展开叙述了，毕竟影响性能都有多方面原因导致的，比如网络、服务器硬件、操作系统、后端服务、程序自身、数据库服务等。

## 打开长连接配置

通常Nginx作为代理服务，负责分发客户端的请求，那么建议开启`HTTP`长连接，用户减少握手的次数，降低服务器损耗，具体如下：

```apl
upstream xxx {
    # 长连接数
    keepalive 32;
    # 每个长连接提供的最大请求数
    keepalived_requests 100;
    # 每个长连接没有新的请求时，保持的最长时间
    keepalive_timeout 60s;
}
```

## 开启零拷贝技术

零拷贝这个概念，在大多数性能较为不错的中间件中都有出现，例如`Kafka、Netty`等，而`Nginx`中也可以配置数据零拷贝技术，如下：

```apl
sendfile on; # 开启零拷贝机制
```

零拷贝读取机制与传统资源读取机制的区别：

- 传统方式：**「硬件-->内核-->用户空间-->程序空间-->程序内核空间-->网络套接字」**
- 零拷贝方式：**「硬件-->内核-->程序内核空间-->网络套接字」**

从上述这个过程对比，很轻易就能看出两者之间的性能区别。

## 开启无延迟或多包共发机制

在`Nginx`中有两个较为关键的性能参数，即`tcp_nodelay、tcp_nopush`，开启方式如下：

```
tcp_nodelay on;
tcp_nopush on;
```

`TCP/IP`协议中默认是采用了Nagle算法的，即在网络数据传输过程中，每个数据报文并不会立马发送出去，而是会等待一段时间，将后面的几个数据包一起组合成一个数据报文发送，但这个算法虽然提高了网络吞吐量，但是实时性却降低

> 因此你的项目属于交互性很强的应用，那么可以手动开启`tcp_nodelay`配置，让应用程序向内核递交的每个数据包都会立即发送出去。但这样会产生大量的`TCP`报文头，增加很大的网络开销。

相反，有些项目的业务对数据的实时性要求并不高，追求的则是更高的吞吐，那么则可以开启`tcp_nopush`配置项，这个配置就类似于“塞子”的意思，首先将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽量把小数据包拼接成一个大的数据包（一个`MTU`）再发送出去.

> 当然若一定时间后（一般为`200ms`），内核仍然没有积累到一个`MTU`的量时，也必须发送现有的数据，否则会一直阻塞。

`tcp_nodelay、tcp_nopush`两个参数是“互斥”的，如果追求响应速度的应用推荐开启`tcp_nodelay`参数，如`IM`、金融等类型的项目。如果追求吞吐量的应用则建议开启`tcp_nopush`参数，如调度系统、报表系统等。

> 注意：①`tcp_nodelay`一般要建立在开启了长连接模式的情况下使用。②`tcp_nopush`参数是必须要开启`sendfile`参数才可使用的。

## 调整Worker工作进程

`Nginx`启动后默认只会开启一个`Worker`工作进程处理客户端请求，而我们可以根据机器的CPU核数开启对应数量的工作进程，以此来提升整体的并发量支持，如下：

```apl
# 自动根据CPU核心数调整Worker进程数量
worker_processes auto;
```

> 工作进程的数量最高开到`8`个就OK了，`8`个之后就不会有再大的性能提升。

同时也可以稍微调整一下每个工作进程能够打开的文件句柄数：

```apl
# 每个Worker能打开的文件描述符，最少调整至1W以上，负荷较高建议2-3W
worker_rlimit_nofile 20000;
```

> 操作系统内核（`kernel`）都是利用文件描述符来访问文件，无论是打开、新建、读取、写入文件时，都需要使用文件描述符来指定待操作的文件，因此该值越大，代表一个进程能够操作的文件越多（但不能超出内核限制，最多建议`3.8W`左右为上限）。

## 开启CPU亲和机制

对于并发编程较为熟悉的伙伴都知道，因为进程/线程数往往都会远超出系统CPU的核心数，因为操作系统执行的原理本质上是采用时间片切换机制，也就是一个CPU核心会在多个进程之间不断频繁切换，造成很大的性能损耗。

而CPU亲和机制则是指将每个`Nginx`的工作进程，绑定在固定的CPU核心上，从而减小CPU切换带来的时间开销和资源损耗，开启方式如下：

```apl
worker_cpu_affinity auto;
```

## 开启epoll模型及调整并发连接数

在最开始就提到过：`Nginx、Redis`都是基于多路复用模型去实现的程序，但最初版的多路复用模型`select/poll`最大只能监听`1024`个连接，而`epoll`则属于`select/poll`接口的增强版，因此采用该模型能够大程度上提升单个`Worker`的性能，如下：

```apl
events {
    # 使用epoll网络模型
    use epoll;
    # 调整每个Worker能够处理的连接数上限
    worker_connections  10240;
}
```

> 这里对于`select/poll/epoll`模型就不展开细说了，后面的IO模型文章中会详细剖析。

## 禁用日志 & 日志缓冲

访问日志记录，它记录每个nginx请求，因此消耗了大量CPU资源，从而降低了nginx性能

完全禁用访问日志记录

```apl
access_log off;  
```

如果必须具有访问日志记录，则启用访问日志缓冲

```sh
log_format compression '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $bytes_sent '
                       '"$http_referer" "$http_user_agent" "$gzip_ratio"';
# 设置日志缓冲区，只有达到缓冲区才会记录日志
access_log /usr/local/nginx/logs/nginx-access.log compression buffer=1k;
```

或者直接使用默认日志格式

```sh
access_log /usr/local/nginx/logs/nginx-access.log buffer = 16k  
```

## 为静态文件启用缓存

为静态文件启用缓存，以减少带宽并提高性能，可以添加下面的命令，限定计算机缓存网页的静态文件：

```apl
location ~* .(jpg|jpeg|png|gif|ico|css|js)$ {
     expires 365d;
}
```

# HTTPS 调优

## 为什么要优化 Ngin HTTPS 延迟

> Nginx 常作为最常见的服务器，常被用作负载均衡 (Load Balancer)、反向代理 (Reverse Proxy)，以及网关 (Gateway) 等等。一个配置得当的 Nginx 服务器单机应该可以期望承受住 50K 到 80K 左右每秒的请求，同时将 CPU 负载在可控范围内。

> 但在很多时候，负载并不是需要首要优化的重点。比如对于卡拉搜索来说，我们希望用户在每次击键的时候，可以体验即时搜索的感觉，也就是说，每个搜索请求必须在 100ms - 200ms 的时间内端对端地返回给用户，才能让用户搜索时没有“卡顿”和“加载”。因此，对于我们来说，优化请求延迟才是最重要的优化方向。

> 这篇文章中，我们先介绍 Nginx 中的 TLS 设置有哪些与请求延迟可能相关，如何调整才能最大化加速。然后我们用优化卡拉搜索 Nginx 服务器的实例来分享如何调整 Nginx TLS/SSL 设置，为首次搜索的用户提速 30% 左右。我们会详细讨论每一步我们做了一些什么优化，优化的动机和效果。希望可以对其它遇到类似问题的同学提供帮助。

## TLS 握手和延迟

> 很多时候开发者会认为：如果不是绝对在意性能，那么了解底层和更细节的优化没有必要。这句话在很多时候是恰当的，因为很多时候复杂的底层逻辑必须包起来，才能让更高层的应用开发复杂度可控。比如说，如果你就只需要开发一个 APP 或者网站，可能并没有必要关注汇编细节，关注编译器如何优化你的代码——毕竟在苹果或者安卓上很多优化在底层就做好了。

那么，了解底层的 TLS 和应用层的 Nginx 延迟优化有什么关系呢？

> 答案是多数情况下，优化网络延迟其实是在尝试减少用户和服务器之间的数据传输次数，也就是所谓的 roundtrip。由于物理限制，北京到云南的光速传播差不多就是要跑 20 来毫秒，如果你不小心让数据必须多次往返于北京和云南之间，那么必然延迟就上去了。

> 因此如果你需要优化请求延迟，那么了解一点底层网络的上下文则会大有裨益，很多时候甚至是你是否可以轻松理解一个优化的关键。本文中我们不深入讨论太多 TCP 或者 TLS 机制的细节，如果有兴趣的话请参考 High Performance Browser Networking 一书，可以免费阅读。

举个例子，下图中展示了如果你的服务启用了 HTTPS，在开始传输任何数据之前的数据传输情况。 

![图片](https://mmbiz.qpic.cn/mmbiz_png/2rMyvdWluHuicvGcar1iaFjwZ9fO7yzcImPpb9iboDNjNEDDm8TIJsEWGv9acp9BNqybcNG49VZT6tRSkQuzhjYew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

> 在传输数据前数据已经跑了好几个来回 roundtrip 在传输数据前数据已经跑了好几个来回 roundtrip 可以看到，在你的用户拿到他需要的数据前，底层的数据包就已经在用户和你的服务器之间跑了 3 个来回。

假设每次来回需要 28 毫秒的话，用户已经等了 224 毫秒之后才开始接收数据。

> 同时这个 28 毫秒其实是非常乐观的假设，在国内电信、联通和移动以及各种复杂的网络状况下，用户与服务器之间的延迟更不可控。另一方面，通常一个网页需要数十个请求，这些请求不一定可以全部并行，因此几十乘以 224 毫秒，页面打开可能就是数秒之后了。

> 所以，原则上如果可能的话，我们需要尽量减少用户和服务器之间的往返程 (roundtrip)，在下文的设置中，对于每个设置我们会讨论为什么这个设置有可能帮助减少往返程。

## Nginx 中的 TLS 设置

那么在 Nginx 设置中，怎样调整参数会减少延迟呢？

### 开启 HTTP/2

> HTTP/2 标准是从 Google 的 SPDY 上进行的改进，比起 HTTP 1.1 提升了不少性能，尤其是需要并行多个请求的时候可以显著减少延迟。在现在的网络上，一个网页平均需要请求几十次，而**在 HTTP 1.1 时代浏览器能做的就是多开几个连接（通常是 6 个）进行并行请求**，而 **HTTP 2 中可以在一个连接中进行并行请求**。HTTP 2 原生支持多个并行请求，因此大大减少了顺序执行的请求的往返程，可以首要考虑开启。

如果你想自己看一下 HTTP 1.1 和 HTTP 2.0 的速度差异，可以试一下：https://www.httpvshttps.com/。我的网络测试下来 HTTP/2 比 HTTP 1.1 快了 90%。 

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302031513784.png" alt="image-20230203151315656" style="zoom:67%;" />

<img src="https://edu-8673.oss-cn-beijing.aliyuncs.com/img2023.2.30/202302031513116.png" alt="image-20230203151347007" style="zoom:67%;" />

在 Nginx 中开启 HTTP 2.0 非常简单，只需要增加一个 http2 标志即可

```sh
listen 443 ssl;
# 改为
listen 443 ssl http2;
```

> 如果你担心你的用户用的是旧的客户端，比如 Python 的 requests，暂时还不支持 HTTP 2 的话，l     那么其实不用担心。如果用户的客户端不支持 HTTP 2，那么连接会自动降级为 HTTP 1.1，保持了后向兼容。因此，所有使用旧 Client 的用户，仍然不受影响，而新的客户端则可以享受 HTTP/2 的新特性。

### 如何确认你的网站或者 API 开启了 HTTP 2

在 Chrome 中打开开发者工具，点开 Protocol 之后在所有的请求中都可以看到请求用的协议了。如果 protocol 这列的值是 h2 的话，那么用的就是 HTTP 2 了 

![图片](https://mmbiz.qpic.cn/mmbiz_png/2rMyvdWluHuicvGcar1iaFjwZ9fO7yzcImxQWHlMke9FibxvFNon1XnRPTqfjJdicXtibZLBDdLxJPXowp5D2fQKGIA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

当然另一个办法是直接用 curl 如果返回的 status 前有 HTTP/2 的话自然也就是 HTTP/2 开启了。

```
➜  ~ curl --http2 -I https://kalasearch.cn
HTTP/2 403
server: Tengine
content-type: application/xml
content-length: 264
date: Tue, 22 Dec 2020 18:38:46 GMT
x-oss-request-id: 5FE23D363ADDB93430197043
x-oss-cdn-auth: success
x-oss-server-time: 0
x-alicdn-da-ups-status: endOs,0,403
via: cache13.l2et2[148,0], cache10.l2ot7[291,0], cache4.us13[360,0]
timing-allow-origin: *
eagleid: 2ff6169816086623266688093e
```

### 调整 Cipher 优先级

尽量挑选更新更快的 Cipher，有助于减少延迟:

```
# 手动启用 cipher 列表
ssl_prefer_server_ciphers on;  # prefer a list of ciphers to prevent old and slow ciphers
ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';
```

### 启用 OCSP Stapling

在国内这可能是对使用 Let's Encrypt 证书的服务或网站影响最大的延迟优化了。如果不启用 OCSP Stapling 的话，在用户连接你的服务器的时候，有时候需要去验证证书。而因为一些不可知的原因（这个就不说穿了）Let's Encrypt 的验证服务器并不是非常通畅，因此可以造成有时候数秒甚至十几秒延迟的问题，这个问题在 iOS 设备上特别严重

解决这个问题的方法有两个：

1. 不使用 Let's Encrypt，可以尝试替换为阿里云提供的免费 DV 证书
2. 开启 OCSP Stapling

开启了 OCSP Stapling 的话开启了 OCSP Stapling 的话，跑到证书验证这一步可以省略掉。省掉一个 roundtrip，特别是网络状况不可控的 roundtrip，可能可以将你的延迟大大减少。

在 Nginx 中启用 OCSP Stapling 也非常简单，只需要设置：

```
ssl_stapling on;
ssl_stapling_verify on;
ssl_trusted_certificate /path/to/full_chain.pem;
```

### 如何检测 OCSP Stapling 是否已经开启？

可以通过以下命令

```
openssl s_client -connect test.kalasearch.cn:443 -servername kalasearch.cn -status -tlsextdebug < /dev/null 2>&1 | grep -i "OCSP response"
```

来测试。如果结果为

```
OCSP response:
OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
```

则表明已经开启。

### 调整 ssl_buffer_size

sslbuffersize 控制在发送数据时的 buffer 大小，默认设置是 16k。这个值越小，则延迟越小，而添加的报头之类会使 overhead 会变大，反之则延迟越大，overhead 越小。

因此如果你的服务是 REST API 或者网站的话，将这个值调小可以减小延迟和 TTFB，但如果你的服务器是用来传输大文件的，那么可以维持 16k。

如果是网站或者 REST API，建议值为 4k，但是这个值的最佳取值显然会因为数据的不同而不一样，因此请尝试 2 - 16k 间不同的值。在 Nginx 中调整这个值也非常容易

```
sl_buffer_size 4k;
```

### 启用 SSL Session 缓存

启用 SSL Session 缓存可以大大减少 TLS 的反复验证，减少 TLS 握手的 roundtrip。虽然 session 缓存会占用一定内存，但是用 1M 的内存就可以缓存 4000 个连接，可以说是非常非常划算的。同时，对于绝大多数网站和服务，要达到 4000 个同时连接本身就需要非常非常大的用户基数，因此可以放心开启。

这里 ssl_session_cache 设置为使用 50M 内存，以及 4 小时的连接超时关闭时间 ssl_session_timeout

```
# Enable SSL cache to speed up for return visitors
ssl_session_cache   shared:SSL:50m; # speed up first time. 1m ~= 4000 connections
ssl_session_timeout 4h;
```

### 卡拉搜索如何减少 30% 的请求延迟

卡拉搜索是国内的 Algolia，致力于帮助开发者快速搭建即时搜索功能(instant search)，做国内最快最易用的搜索即服务。

开发者接入后，所有搜索请求通过卡拉 API 即可直接返回给终端用户。为了让用户有即时搜索的体验，我们需要在用户每次击键后极短的时间内（通常是 100ms 到 200ms）将结果返回给用户。因此每次搜索需要可以达到 50 毫秒以内的引擎处理时间和 200 毫秒以内的端对端时间。

> 我们用豆瓣电影的数据做了一个电影搜索的 Demo，如果感兴趣的话欢迎体验一下即时搜索，尝试一下搜索“无间道”或者“大话西游”体验一下速度和相关度：https://movies-demo.kalasearch.cn/

对于每个请求只有 100 到 200 毫秒的延迟预算，我们必须把每一步的延迟都考虑在内。

简化一下，每个搜索请求需要经历的延迟有 

![图片](https://mmbiz.qpic.cn/mmbiz_png/2rMyvdWluHuicvGcar1iaFjwZ9fO7yzcImD0XKcBLC2yEe8gmu6QescFdH6N1mInHwutaic9OJgBdlRk2LdhfibEXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

总延迟 = 用户请求到达服务器(T1) + 反代处理(Nginx T2) + 数据中心延迟(T3) + 服务器处理 (卡拉引擎 T4) + 用户请求返回(T3+T1)

在上述延迟中，T1 只与用户与服务器的物理距离相关，而 T3 非常小，可以忽略不计。

所以我们能控制的大致只有 T2 和 T4，即 Nginx 服务器的处理时间和卡拉的引擎处理时间。

Nginx 在这里作为反向代理，处理一些安全、流量控制和 TLS 的逻辑，而卡拉的引擎则是一个在 Lucene 基础上的倒排引擎。

我们首先考虑的第一个可能性是：延迟是不是来自卡拉引擎呢？

在下图展示的 Grafana 仪表盘中，我们看到除了几个时不时的慢查询，搜索的 95% 服务器处理延迟小于 20 毫秒。对比同样的数据集上 benchmark 的 Elastic Search 引擎的 P95 搜索延迟则在 200 毫秒左右，所以排除了引擎速度慢的可能。

![图片](https://mmbiz.qpic.cn/mmbiz_png/2rMyvdWluHuicvGcar1iaFjwZ9fO7yzcImS3wKJLicLgVetMl4akQjoxlw8QMZys1zvWKtrkdxSwIcF6ufQjffPFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

而在阿里云监控中，我们设置了从全国各地向卡拉服务器发送搜索请求。我们终于发现 SSL 处理时间时常会超过 300 毫秒，也就是说在 T2 这一步，光处理 TLS 握手之类的事情，Nginx 已经用掉了我们所有的请求时间预算。

同时检查之后我们发现，在苹果设备上搜索速度格外慢，特别是第一次访问的设备。因此我们大致判断应该是因为我们使用的 Let's Encrypt 证书的问题。

我们按照上文中的步骤对 Nginx 设置进行了调整，并将步骤总结出来写了这篇文章。在调整了 Nginx TLS 的设置后，SSL 时间从平均的 140ms 降低到了 110ms 左右（全国所有省份联通和移动测试点），同时苹果设备上首次访问慢的问题也消失了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/2rMyvdWluHuicvGcar1iaFjwZ9fO7yzcImQSKARmHkZdx6Kbf0ucHiaSRxXBTtCHcHdyfhQDEHrC6gOOAvAQkVN0Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在调整过后，全国范围内测试的搜索延迟降低到了 150 毫秒左右。























































































